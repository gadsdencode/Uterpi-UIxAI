This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-09-27T18:18:55.375Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.replit
client/index.html
client/src/App.tsx
client/src/components/AICoachPanel.tsx
client/src/components/AICreditsDisplay.tsx
client/src/components/AICreditsQuickPurchase.tsx
client/src/components/AIProviderQuickSelector.tsx
client/src/components/AIProviderSelector.tsx
client/src/components/AIProviderSettings.tsx
client/src/components/AnalyzeModal.tsx
client/src/components/auth/ForgotPasswordForm.tsx
client/src/components/auth/LoginForm.tsx
client/src/components/auth/RegisterForm.tsx
client/src/components/auth/ResetPasswordForm.tsx
client/src/components/auth/UserMenu.tsx
client/src/components/ChatView.tsx
client/src/components/CheckoutPages.tsx
client/src/components/CloneUIModal.tsx
client/src/components/CreatePageModal.tsx
client/src/components/CreditLimitMessage.tsx
client/src/components/EmailPreferences.tsx
client/src/components/FileManager.tsx
client/src/components/FileManager/AnalysisModal.tsx
client/src/components/FileManager/AnalysisStatusCard.tsx
client/src/components/FileManager/EditFileModal.tsx
client/src/components/FileManager/EnhancedFileCard.tsx
client/src/components/FileManager/EnhancedFileManager.tsx
client/src/components/FileManager/index.ts
client/src/components/FileManager/InlineUploadArea.tsx
client/src/components/FileManager/README.md
client/src/components/FileManager/ShareFileModal.tsx
client/src/components/FileManager/SkeletonLoader.tsx
client/src/components/FileManager/TestModal.tsx
client/src/components/GeminiSettingsModal.tsx
client/src/components/HuggingFaceSettingsModal.tsx
client/src/components/ImproveModal.tsx
client/src/components/InputBar.tsx
client/src/components/LLMModelSelector.tsx
client/src/components/Message.tsx
client/src/components/MessageList.tsx
client/src/components/OpenAISettingsModal.tsx
client/src/components/PricingPage.tsx
client/src/components/ProfileModal.tsx
client/src/components/ProviderSettingsPage.tsx
client/src/components/Router.tsx
client/src/components/Sidebar.tsx
client/src/components/SimpleModelSelector.tsx
client/src/components/SpeechSettings.tsx
client/src/components/SubscriptionGuard.tsx
client/src/components/SubscriptionPage.tsx
client/src/components/SystemMessageDemo.tsx
client/src/components/SystemMessageSelector.tsx
client/src/components/ui/accordion.tsx
client/src/components/ui/alert-dialog.tsx
client/src/components/ui/alert.tsx
client/src/components/ui/aspect-ratio.tsx
client/src/components/ui/avatar.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/breadcrumb.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/components/ui/carousel.tsx
client/src/components/ui/chart.tsx
client/src/components/ui/checkbox.tsx
client/src/components/ui/collapsible.tsx
client/src/components/ui/command.tsx
client/src/components/ui/context-menu.tsx
client/src/components/ui/dialog.tsx
client/src/components/ui/drawer.tsx
client/src/components/ui/dropdown-menu.tsx
client/src/components/ui/form.tsx
client/src/components/ui/hover-card.tsx
client/src/components/ui/input-otp.tsx
client/src/components/ui/input.tsx
client/src/components/ui/label.tsx
client/src/components/ui/menubar.tsx
client/src/components/ui/navigation-menu.tsx
client/src/components/ui/pagination.tsx
client/src/components/ui/popover.tsx
client/src/components/ui/progress.tsx
client/src/components/ui/radio-group.tsx
client/src/components/ui/resizable.tsx
client/src/components/ui/scroll-area.tsx
client/src/components/ui/select.tsx
client/src/components/ui/separator.tsx
client/src/components/ui/sheet.tsx
client/src/components/ui/sidebar.tsx
client/src/components/ui/skeleton.tsx
client/src/components/ui/slider.tsx
client/src/components/ui/sonner.tsx
client/src/components/ui/switch.tsx
client/src/components/ui/table.tsx
client/src/components/ui/tabs.tsx
client/src/components/ui/textarea.tsx
client/src/components/ui/toggle-group.tsx
client/src/components/ui/toggle.tsx
client/src/components/ui/tooltip.tsx
client/src/components/UnsubscribePage.tsx
client/src/components/UserProfile.tsx
client/src/hooks/use-mobile.tsx
client/src/hooks/use-toast.tsx
client/src/hooks/useAI.ts
client/src/hooks/useAICoach.ts
client/src/hooks/useAIProvider.ts
client/src/hooks/useAuth.ts
client/src/hooks/useAzureAI.ts
client/src/hooks/useCreditUpdates.ts
client/src/hooks/useFileManager.ts
client/src/hooks/useGemini.ts
client/src/hooks/useHuggingFace.ts
client/src/hooks/useIntelligentToast.ts
client/src/hooks/useLMStudio.ts
client/src/hooks/useOpenAI.ts
client/src/hooks/useSpeech.ts
client/src/hooks/useSubscription.ts
client/src/hooks/useSubscriptionErrors.ts
client/src/index.css
client/src/lib/azureAI.ts
client/src/lib/gemini.ts
client/src/lib/huggingface.ts
client/src/lib/intelligentToastService.ts
client/src/lib/lmstudio.ts
client/src/lib/modelConfigurations.ts
client/src/lib/modelMigration.ts
client/src/lib/openAI.ts
client/src/lib/speech/azureSpeechService.ts
client/src/lib/speech/baseSpeechService.ts
client/src/lib/speech/googleSpeechService.ts
client/src/lib/speech/index.ts
client/src/lib/speech/openaiSpeechService.ts
client/src/lib/speech/README.md
client/src/lib/speech/SpeechOrchestrator.ts
client/src/lib/speech/speechServiceFactory.ts
client/src/lib/speech/speechUtils.ts
client/src/lib/speech/webSpeechService.ts
client/src/lib/transcriptUtils.ts
client/src/lib/utils.ts
client/src/main.tsx
client/src/types/index.ts
client/src/types/speech.ts
client/src/vite-env.d.ts
components.json
cookies.txt
drizzle.config.ts
GEMINI_STREAMING_FIX.md
llms.txt
package.json
postcss.config.js
replit.md
server/ai-coach.ts
server/auth.ts
server/context-enhancer.ts
server/conversation-service.ts
server/cron-monthly-reset.ts
server/db.ts
server/email.ts
server/engagement.ts
server/file-storage.ts
server/friends-family-migration.ts
server/grandfather-users-migration.ts
server/index.ts
server/routes.ts
server/run-migration.ts
server/sample-plans.sql
server/storage.ts
server/stripe-checkout.ts
server/stripe-enhanced.ts
server/stripe.ts
server/subscription-middleware.ts
server/subscription-routes.ts
server/test-vectorization.ts
server/vector-flags.ts
server/vector-processor.ts
server/vector-service.ts
server/vite.ts
server/webhooks.ts
shared/schema.ts
src/components/LLMModelSelector.tsx
tailwind.config.ts
tsconfig.json
vite.config.ts

================================================================
Files
================================================================

================
File: .gitignore
================
node_modules
dist
.DS_Store
server/public
vite.config.ts.*
*.tar.gz
*.env
/android
/www
/ios
/migrations
/attached_assets

================
File: .replit
================
modules = ["nodejs-20", "web", "postgresql-16"]
run = "npm run dev"
hidden = [".config", ".git", "generated-icon.png", "node_modules", "dist"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "autoscale"
build = ["npm", "run", "build"]
run = ["npm", "run", "start"]

[[ports]]
localPort = 5000
externalPort = 80

[[ports]]
localPort = 44443
externalPort = 3000

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Start application"

[[workflows.workflow]]
name = "Start application"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000

[objectStorage]
defaultBucketID = "replit-objstore-407ad3b9-74ca-460d-bcc6-5249ade5d6b0"

[agent]
integrations = ["javascript_stripe:1.0.0"]

================
File: client/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>

================
File: client/src/App.tsx
================
import React, { useState, useEffect, useRef } from 'react'
import { motion, AnimatePresence } from "framer-motion";
import FuturisticAIChat from './components/ChatView'
import { Toaster } from './components/ui/sonner'
import { AuthProvider, useAuth } from './hooks/useAuth'
import { LoginForm } from './components/auth/LoginForm'
import { RegisterForm } from './components/auth/RegisterForm'
import { ForgotPasswordForm } from './components/auth/ForgotPasswordForm'
import { UserMenu } from './components/auth/UserMenu'
import { SubscriptionGuard } from './components/SubscriptionGuard'
import { Button } from './components/ui/button'
import { Card, CardContent } from './components/ui/card'
import { Loader2, Zap } from 'lucide-react'
// Import model migration utilities for debugging
import './lib/modelMigration'

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 100,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "#8B5CF6",
  vx = 0,
  vy = 0,
}) => {
  const [particleColor, setParticleColor] = useState<string>(color);

  interface MousePosition {
    x: number;
    y: number;
  }

  const MousePosition = (): MousePosition => {
    const [mousePosition, setMousePosition] = useState<MousePosition>({
      x: 0,
      y: 0,
    });

    useEffect(() => {
      const handleMouseMove = (event: MouseEvent) => {
        setMousePosition({ x: event.clientX, y: event.clientY });
      };

      window.addEventListener("mousemove", handleMouseMove);

      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
      };
    }, []);

    return mousePosition;
  };

  const hexToRgb = (hex: string): number[] => {
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mousePosition = MousePosition();
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.1;
    const dy = (Math.random() - 0.5) * 0.1;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const rgb = hexToRgb(particleColor);

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${rgb.join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(
        0,
        0,
        canvasSize.current.w,
        canvasSize.current.h,
      );
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const remapValue = (
    value: number,
    start1: number,
    end1: number,
    start2: number,
    end2: number,
  ): number => {
    const remapped =
      ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;
    return remapped > 0 ? remapped : 0;
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      const edge = [
        circle.x + circle.translateX - circle.size,
        canvasSize.current.w - circle.x - circle.translateX - circle.size,
        circle.y + circle.translateY - circle.size,
        canvasSize.current.h - circle.y - circle.translateY - circle.size,
      ];
      const closestEdge = edge.reduce((a, b) => Math.min(a, b));
      const remapClosestEdge = parseFloat(
        remapValue(closestEdge, 0, 20, 0, 1).toFixed(2),
      );
      if (remapClosestEdge > 1) {
        circle.alpha += 0.02;
        if (circle.alpha > circle.targetAlpha) {
          circle.alpha = circle.targetAlpha;
        }
      } else {
        circle.alpha = circle.targetAlpha * remapClosestEdge;
      }
      circle.x += circle.dx + vx;
      circle.y += circle.dy + vy;
      circle.translateX +=
        (mouse.current.x / (staticity / circle.magnetism) - circle.translateX) /
        ease;
      circle.translateY +=
        (mouse.current.y / (staticity / circle.magnetism) - circle.translateY) /
        ease;

      drawCircle(circle, true);

      if (
        circle.x < -circle.size ||
        circle.x > canvasSize.current.w + circle.size ||
        circle.y < -circle.size ||
        circle.y > canvasSize.current.h + circle.size
      ) {
        circles.current.splice(i, 1);
        const newCircle = circleParams();
        drawCircle(newCircle);
      }
    });
    window.requestAnimationFrame(animate);
  };

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const onMouseMove = () => {
    if (canvasRef.current) {
      const rect = canvasRef.current.getBoundingClientRect();
      const { w, h } = canvasSize.current;
      const x = mousePosition.x - rect.left - w / 2;
      const y = mousePosition.y - rect.top - h / 2;
      const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;
      if (inside) {
        mouse.current.x = x;
        mouse.current.y = y;
      }
    }
  };

  useEffect(() => {
    if (canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
    }
    initCanvas();
    animate();
    window.addEventListener("resize", initCanvas);

    return () => {
      window.removeEventListener("resize", initCanvas);
    };
  }, [particleColor]);

  useEffect(() => {
    onMouseMove();
  }, [mousePosition.x, mousePosition.y]);

  useEffect(() => {
    initCanvas();
  }, [refresh]);

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  );
};

const CircuitPattern: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    className={className}
    viewBox="0 0 100 100"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M10 10h20v20h20v-20h20v40h-20v20h-40z"
      stroke="currentColor"
      strokeWidth="0.5"
      fill="none"
      opacity="0.1"
    />
    <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
    <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
  </svg>
);

const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-8 rounded-2xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/10 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 3,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

const RippleButton: React.FC<{
  children: React.ReactNode;
  onClick?: () => void;
  className?: string;
  disabled?: boolean;
  type?: "button" | "submit";
}> = ({ children, onClick, className, disabled = false, type = "button" }) => {
  const [ripples, setRipples] = useState<Array<{ id: number; x: number; y: number }>>([]);

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    if (disabled) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const newRipple = { id: Date.now(), x, y };
    setRipples(prev => [...prev, newRipple]);
    
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);
    
    if (onClick && typeof onClick === 'function') {
      try {
        onClick();
      } catch (error) {
        console.error('Error in onClick handler:', error);
      }
    }
  };

  return (
    <button
      type={type}
      onClick={handleClick}
      disabled={disabled}
      className={`
        relative overflow-hidden transition-all duration-200
        ${disabled ? "opacity-50 cursor-not-allowed" : "hover:scale-105 active:scale-95"}
        ${className}
      `}
    >
      {children}
      {ripples.map(ripple => (
        <motion.span
          key={ripple.id}
          className="absolute bg-white/30 rounded-full pointer-events-none"
          style={{
            left: ripple.x - 10,
            top: ripple.y - 10,
            width: 20,
            height: 20,
          }}
          initial={{ scale: 0, opacity: 1 }}
          animate={{ scale: 4, opacity: 0 }}
          transition={{ duration: 0.6, ease: "easeOut" }}
        />
      ))}
    </button>
  );
};

const AuthenticatedApp: React.FC = () => {
  const { user, loading } = useAuth();
  const [showAuth, setShowAuth] = useState(false);
  const [authMode, setAuthMode] = useState<'login' | 'register' | 'forgot-password'>('login');

  if (loading) {
    return (
      <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden flex items-center justify-center p-4">
        {/* Background Effects */}
        <div className="absolute inset-0">
          <Particles
            className="absolute inset-0"
            quantity={150}
            color="#8B5CF6"
            size={1}
            staticity={30}
          />
          
          {/* Holographic Gradients */}
          <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
          <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
          
          {/* Circuit Patterns */}
          <div className="absolute inset-0 opacity-5">
            <CircuitPattern className="absolute top-10 left-10 w-20 h-20 text-violet-400" />
            <CircuitPattern className="absolute top-1/3 right-20 w-16 h-16 text-blue-400" />
            <CircuitPattern className="absolute bottom-20 left-1/3 w-24 h-24 text-purple-400" />
          </div>
        </div>

        {/* Main Content */}
        <div className="relative z-10 w-full max-w-md mx-auto">
          <HolographicBubble>
            <div className="flex flex-col items-center justify-center">
              <Loader2 className="h-8 w-8 animate-spin mb-4 text-violet-400" />
              <p className="text-lg font-medium text-white">Loading...</p>
              <p className="text-sm text-slate-300">Checking authentication status</p>
            </div>
          </HolographicBubble>
        </div>
      </div>
    );
  }

  if (!user) {
    if (!showAuth) {
      return (
        <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden flex items-center justify-center p-4">
          {/* Background Effects */}
          <div className="absolute inset-0">
            <Particles
              className="absolute inset-0"
              quantity={150}
              color="#8B5CF6"
              size={1}
              staticity={30}
            />
            
            {/* Holographic Gradients */}
            <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
            <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
            
            {/* Circuit Patterns */}
            <div className="absolute inset-0 opacity-5">
              <CircuitPattern className="absolute top-10 left-10 w-20 h-20 text-violet-400" />
              <CircuitPattern className="absolute top-1/3 right-20 w-16 h-16 text-blue-400" />
              <CircuitPattern className="absolute bottom-20 left-1/3 w-24 h-24 text-purple-400" />
            </div>
          </div>

          {/* Main Content */}
          <div className="relative z-10 w-full max-w-md mx-auto">
            <HolographicBubble>
              <div className="text-center mb-8">
                <div className="flex items-center justify-center mb-4">
                  <div className="relative">
                    <img 
                      src="/images/uterpi_logo.png" 
                      alt="Uterpi Logo" 
                      className="w-72 h-72 rounded-full"
                    />
                    <motion.div
                      className="absolute inset-0 bg-violet-400/20 rounded-full blur-lg"
                      animate={{ scale: [1, 1.2, 1] }}
                      transition={{ duration: 2, repeat: Infinity }}
                    />
                  </div>
                </div>
                <p className="text-sm bg-gradient-to-r from-violet-400 to-purple-400 bg-clip-text text-transparent font-bold pt-2">
                Please sign in or create an account
                </p>
                <div className="mt-4 p-3 bg-violet-500/10 rounded-lg border border-violet-400/20">
                  <p className="text-sm text-white mb-2">
                    üöÄ <span className="font-bold">Your Interface for AI</span>
                  </p>
                  <div className="flex flex-col gap-3 mb-3">
                    <div className="p-2 bg-gradient-to-r from-green-500/10 to-emerald-500/10 rounded-lg border border-green-400/20">
                      <p className="text-green-400 font-bold text-sm">Start Today</p>
                      <p className="text-xs text-slate-300">10 free messages per month to start your journey with Uterpi</p>
                    </div>
                    <div className="flex flex-col sm:flex-row gap-2">
                      <div className="flex-1 text-center">
                        <p className="text-violet-400 font-bold text-base">$19<span className="text-xs font-normal">/mo</span></p>
                        <p className="text-xs text-slate-400">Pro ‚Ä¢ Higher Message Limit ‚Ä¢ More AI Credits</p>
                      </div>
                      <div className="flex-1 text-center border-l-0 sm:border-l border-violet-400/20">
                        <p className="text-violet-400 font-bold text-base">$49<span className="text-xs font-normal">/user</span></p>
                        <p className="text-xs text-slate-400">Team ‚Ä¢ Shared AI Credits</p>
                      </div>
                      <div className="flex-1 text-center border-l-0 sm:border-l border-violet-400/20">
                        <p className="text-blue-400 font-bold text-sm">Pay as you go</p>
                        <p className="text-xs text-slate-400">AI Credits: 2¬¢ each</p>
                      </div>
                    </div>
                  </div>
                  <div className="text-xs text-slate-300 space-y-1">
                    <p>‚Ä¢ Use any AI model + Uterpi's proprietary LLM</p>
                    <p>‚Ä¢ Custom templates & personas to make Uterpi your own</p>
                    <p>‚Ä¢ AI analyzes and suggests optimizations to your workflow</p>
                    <p>‚Ä¢ Purchase AI Credits as needed - they never expire</p>
                  </div>
                </div>
              </div>
              
              <div className="flex flex-col gap-4 w-full">
                <RippleButton
                  onClick={() => {
                    setAuthMode('login');
                    setShowAuth(true);
                  }}
                  className="w-full py-3 bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 rounded-xl text-white font-medium transition-all duration-200"
                >
                  Sign In
                </RippleButton>
                <RippleButton
                  onClick={() => {
                    setAuthMode('register');
                    setShowAuth(true);
                  }}
                  className="w-full py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-xl text-white font-medium transition-all duration-200"
                >
                  <p className="text-md font-bold bg-gradient-to-r from-violet-500 to-purple-600 bg-clip-text text-transparent">Start your journey with Uterpi for free!</p>
                  <br />
                  <p className="text-xs text-slate-400">10 Messages Included Monthly + Bring Your Own AI API Keys</p>
                </RippleButton>
                <p className="text-xs text-slate-400 text-center">
                  ‚ö†Ô∏è Some LLMs may have parameters that are not currently supported by Uterpi.
                </p>
              </div>
            </HolographicBubble>
          </div>
        </div>
      );
    }

    return (
      <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden">
        {/* Background Effects */}
        <div className="absolute inset-0">
          <Particles
            className="absolute inset-0"
            quantity={150}
            color="#8B5CF6"
            size={1}
            staticity={30}
          />
          
          {/* Holographic Gradients */}
          <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
          <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
          
          {/* Circuit Patterns */}
          <div className="absolute inset-0 opacity-5">
            <CircuitPattern className="absolute top-10 left-10 w-20 h-20 text-violet-400" />
            <CircuitPattern className="absolute top-1/3 right-20 w-16 h-16 text-blue-400" />
            <CircuitPattern className="absolute bottom-20 left-1/3 w-24 h-24 text-purple-400" />
          </div>
        </div>

        {/* Auth Forms - positioned to cover the entire screen */}
        <div className="relative z-10 min-h-screen flex items-center justify-center p-4">
          <div className="w-full max-w-md mx-auto">
            {authMode === 'login' && (
              <LoginForm
                onSwitchToRegister={() => setAuthMode('register')}
                onForgotPassword={() => setAuthMode('forgot-password')}
                onSuccess={() => setShowAuth(false)}
              />
            )}
            {authMode === 'register' && (
              <RegisterForm
                onSwitchToLogin={() => setAuthMode('login')}
                onSuccess={() => setShowAuth(false)}
              />
            )}
            {authMode === 'forgot-password' && (
              <ForgotPasswordForm
                onBackToLogin={() => setAuthMode('login')}
              />
            )}
          </div>
        
          <div className="absolute top-6 left-6">
            <RippleButton
            onClick={() => setShowAuth(false)}
              className="px-4 py-2 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-lg text-white font-medium transition-all duration-200"
          >
            ‚Üê Back
            </RippleButton>
          </div>
        </div>
      </div>
    );
  }

  return (
    <main className="h-screen w-full">
      <div className="absolute top-4 right-4 z-50">
        <UserMenu />
      </div>
      <SubscriptionGuard 
        feature="NomadAI" 
        requiredTier="freemium"
      >
        <FuturisticAIChat />
      </SubscriptionGuard>
    </main>
  );
};

function App() {
  return <AuthenticatedApp />;
}

export default App

================
File: client/src/components/AICoachPanel.tsx
================
import React, { useState, useEffect } from 'react';
import { ChevronDown, ChevronUp, Brain, TrendingUp, Lightbulb, Target, X, ThumbsUp, ThumbsDown, Sparkles } from 'lucide-react';
import { useAICoach } from '../hooks/useAICoach';
import { cn } from '../lib/utils';

interface AICoachPanelProps {
  className?: string;
  position?: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';
  autoExpand?: boolean;
}

export const AICoachPanel: React.FC<AICoachPanelProps> = ({
  className,
  position = 'bottom-right',
  autoExpand = false,
}) => {
  const [isExpanded, setIsExpanded] = useState(autoExpand);
  const [selectedInsight, setSelectedInsight] = useState<number | null>(null);
  
  const {
    insights,
    workflowStats,
    isLoading,
    recordFeedback,
    applyRecommendation,
    fetchInsights,
  } = useAICoach({ enabled: true, autoFetch: true });

  // Auto-expand when new high-priority insights arrive
  useEffect(() => {
    const hasHighPriorityInsights = insights.some(
      i => !i.wasShown && i.expectedImpact === 'high'
    );
    if (hasHighPriorityInsights && !isExpanded) {
      setIsExpanded(true);
    }
  }, [insights]);

  const positionClasses = {
    'bottom-right': 'bottom-4 right-4',
    'bottom-left': 'bottom-4 left-4',
    'top-right': 'top-20 right-4',
    'top-left': 'top-20 left-4',
  };

  const getInsightIcon = (type: string) => {
    switch (type) {
      case 'workflow_optimization':
        return <TrendingUp className="w-4 h-4" />;
      case 'model_recommendation':
        return <Brain className="w-4 h-4" />;
      case 'efficiency_tip':
        return <Lightbulb className="w-4 h-4" />;
      case 'strategic_advice':
        return <Target className="w-4 h-4" />;
      default:
        return <Sparkles className="w-4 h-4" />;
    }
  };

  const getCategoryColor = (category: string) => {
    switch (category) {
      case 'strategic':
        return 'text-purple-400 bg-purple-900/20';
      case 'tactical':
        return 'text-blue-400 bg-blue-900/20';
      case 'operational':
        return 'text-green-400 bg-green-900/20';
      default:
        return 'text-gray-400 bg-gray-900/20';
    }
  };

  const handleFeedback = async (insightId: number, feedback: 'positive' | 'negative') => {
    await recordFeedback(insightId, feedback);
    setSelectedInsight(null);
  };

  const handleApplyRecommendation = async (insight: any, index: number) => {
    await applyRecommendation(insight, index);
    setSelectedInsight(null);
  };

  const unreadCount = insights.filter(i => !i.wasShown).length;

  return (
    <div
      className={cn(
        'fixed z-50 transition-all duration-300',
        positionClasses[position],
        className
      )}
    >
      {/* Collapsed View */}
      {!isExpanded && (
        <button
          onClick={() => setIsExpanded(true)}
          className="bg-slate-900/95 backdrop-blur-xl border border-slate-700/50 rounded-full px-4 py-3 shadow-2xl hover:bg-slate-800/95 transition-all group flex items-center gap-2"
        >
          <Brain className="w-5 h-5 text-violet-400 group-hover:text-violet-300" />
          <span className="text-sm font-medium text-white">AI Coach</span>
          {unreadCount > 0 && (
            <span className="bg-violet-600 text-white text-xs rounded-full px-2 py-0.5 animate-pulse">
              {unreadCount}
            </span>
          )}
          <ChevronUp className="w-4 h-4 text-slate-400 group-hover:text-slate-300" />
        </button>
      )}

      {/* Expanded View */}
      {isExpanded && (
        <div className="bg-slate-900/95 backdrop-blur-xl border border-slate-700/50 rounded-2xl shadow-2xl w-96 max-h-[600px] flex flex-col">
          {/* Header */}
          <div className="p-4 border-b border-slate-700/50 flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Brain className="w-5 h-5 text-violet-400" />
              <h3 className="text-white font-semibold">AI Coach</h3>
              {unreadCount > 0 && (
                <span className="bg-violet-600 text-white text-xs rounded-full px-2 py-0.5">
                  {unreadCount} new
                </span>
              )}
            </div>
            <button
              onClick={() => setIsExpanded(false)}
              className="text-slate-400 hover:text-slate-300 transition-colors"
              aria-label="Minimize AI Coach panel"
            >
              <ChevronDown className="w-5 h-5" />
            </button>
          </div>

          {/* Workflow Stats */}
          {workflowStats && (
            <div className="p-3 border-b border-slate-700/50 bg-slate-800/30">
              <div className="grid grid-cols-3 gap-2 text-xs">
                <div className="text-center">
                  <div className="text-slate-400">Efficiency</div>
                  <div className="text-white font-semibold">{workflowStats.averageEfficiency}%</div>
                </div>
                <div className="text-center">
                  <div className="text-slate-400">Workflows</div>
                  <div className="text-white font-semibold">{workflowStats.completedWorkflows}/{workflowStats.totalWorkflows}</div>
                </div>
                <div className="text-center">
                  <div className="text-slate-400">Trend</div>
                  <div className={cn(
                    "font-semibold",
                    workflowStats.improvementTrend === 'improving' ? 'text-green-400' :
                    workflowStats.improvementTrend === 'declining' ? 'text-red-400' :
                    'text-yellow-400'
                  )}>
                    {workflowStats.improvementTrend === 'improving' ? '‚Üë' :
                     workflowStats.improvementTrend === 'declining' ? '‚Üì' : '‚Üí'}
                    {' '}{workflowStats.improvementTrend}
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Insights List */}
          <div className="flex-1 overflow-y-auto p-4 space-y-3">
            {isLoading && (
              <div className="text-center py-8 text-slate-400">
                <Brain className="w-8 h-8 mx-auto mb-2 animate-pulse" />
                <p className="text-sm">Analyzing your workflow...</p>
              </div>
            )}

            {!isLoading && insights.length === 0 && (
              <div className="text-center py-8 text-slate-400">
                <Sparkles className="w-8 h-8 mx-auto mb-2" />
                <p className="text-sm">No new insights yet.</p>
                <p className="text-xs mt-1">Keep working and I'll provide strategic advice!</p>
              </div>
            )}

            {insights.map((insight) => (
              <div
                key={insight.id}
                className={cn(
                  "rounded-lg p-3 border transition-all cursor-pointer",
                  insight.wasShown 
                    ? "border-slate-700/30 bg-slate-800/20" 
                    : "border-violet-600/30 bg-violet-900/10",
                  selectedInsight === insight.id && "ring-2 ring-violet-500/50"
                )}
                onClick={() => setSelectedInsight(selectedInsight === insight.id ? null : insight.id)}
              >
                {/* Insight Header */}
                <div className="flex items-start gap-2 mb-2">
                  <div className={cn(
                    "p-1.5 rounded-md",
                    getCategoryColor(insight.insightCategory)
                  )}>
                    {getInsightIcon(insight.insightType)}
                  </div>
                  <div className="flex-1">
                    <h4 className="text-sm font-medium text-white flex items-center gap-2">
                      {insight.title}
                      {!insight.wasShown && (
                        <span className="text-xs bg-violet-600/20 text-violet-400 px-1.5 py-0.5 rounded">
                          NEW
                        </span>
                      )}
                    </h4>
                    <span className={cn(
                      "text-xs",
                      insight.expectedImpact === 'high' ? 'text-red-400' :
                      insight.expectedImpact === 'medium' ? 'text-yellow-400' :
                      'text-slate-400'
                    )}>
                      {insight.expectedImpact} impact
                    </span>
                  </div>
                </div>

                {/* Insight Content */}
                <p className="text-xs text-slate-300 leading-relaxed">
                  {insight.description}
                </p>

                {/* Expanded Content */}
                {selectedInsight === insight.id && insight.recommendations && (
                  <div className="mt-3 space-y-2">
                    <div className="text-xs font-medium text-slate-400 mb-1">
                      Recommendations:
                    </div>
                    {insight.recommendations.map((rec, index) => (
                      <div
                        key={index}
                        className="bg-slate-800/50 rounded-md p-2 text-xs"
                      >
                        <div className="flex items-start justify-between mb-1">
                          <span className="text-white font-medium">{rec.action}</span>
                          <span className={cn(
                            "text-xs px-1.5 py-0.5 rounded",
                            rec.difficulty === 'easy' ? 'bg-green-900/30 text-green-400' :
                            rec.difficulty === 'medium' ? 'bg-yellow-900/30 text-yellow-400' :
                            'bg-red-900/30 text-red-400'
                          )}>
                            {rec.difficulty}
                          </span>
                        </div>
                        <p className="text-slate-400 mb-2">
                          Expected: {rec.expectedImprovement}
                        </p>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleApplyRecommendation(insight, index);
                          }}
                          className="w-full bg-violet-600 hover:bg-violet-700 text-white py-1.5 rounded-md transition-colors text-xs font-medium"
                        >
                          Apply This
                        </button>
                      </div>
                    ))}

                    {/* Feedback Buttons */}
                    <div className="flex gap-2 mt-3 pt-3 border-t border-slate-700/30">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleFeedback(insight.id, 'positive');
                        }}
                        className="flex-1 flex items-center justify-center gap-1 bg-green-900/20 hover:bg-green-900/30 text-green-400 py-1.5 rounded-md transition-colors text-xs"
                      >
                        <ThumbsUp className="w-3 h-3" />
                        Helpful
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleFeedback(insight.id, 'negative');
                        }}
                        className="flex-1 flex items-center justify-center gap-1 bg-red-900/20 hover:bg-red-900/30 text-red-400 py-1.5 rounded-md transition-colors text-xs"
                      >
                        <ThumbsDown className="w-3 h-3" />
                        Not Helpful
                      </button>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>

          {/* Footer */}
          <div className="p-3 border-t border-slate-700/50 flex items-center justify-between">
            <button
              onClick={fetchInsights}
              className="text-xs text-violet-400 hover:text-violet-300 transition-colors"
            >
              Refresh Insights
            </button>
            <div className="text-xs text-slate-500">
              Powered by Azure AI
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

================
File: client/src/components/AICreditsDisplay.tsx
================
/**
 * AI Credits Display Component
 * Shows current balance, usage, and allows purchasing more credits
 */

import React, { useState, useEffect } from 'react';
import { 
  Coins, 
  TrendingUp, 
  TrendingDown, 
  ShoppingCart,
  Activity,
  AlertCircle,
  Sparkles
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { useToast } from '@/hooks/use-toast';
import { navigateTo } from './Router';
import { useAuth } from '@/hooks/useAuth';

interface CreditTransaction {
  id: number;
  transactionType: 'usage' | 'purchase' | 'monthly_reset' | 'bonus';
  amount: number;
  operationType?: string;
  description: string;
  createdAt: string;
}

interface CreditPackage {
  credits: number;
  price: number;
  priceId: string;
}

interface AICreditsDisplayProps {
  compact?: boolean;
  showPurchaseOption?: boolean;
  onCreditsUpdate?: (balance: number) => void;
}

export const AICreditsDisplay: React.FC<AICreditsDisplayProps> = ({
  compact = false,
  showPurchaseOption = true,
  onCreditsUpdate,
}) => {
  const { user } = useAuth();
  const { toast } = useToast();
  const [loading, setLoading] = useState(true);
  const [balance, setBalance] = useState(0);
  const [monthlyLimit, setMonthlyLimit] = useState(1000);
  const [isTeamPooled, setIsTeamPooled] = useState(false);
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [creditPackages, setCreditPackages] = useState<CreditPackage[]>([]);
  const [purchasingPackage, setPurchasingPackage] = useState<string | null>(null);

  useEffect(() => {
    if (user) {
      fetchCreditBalance();
      fetchCreditPackages();
      fetchSubscriptionDetails();
    }
  }, [user]);

  const fetchCreditBalance = async () => {
    try {
      const response = await fetch('/api/credits/balance', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setBalance(data.balance || 0);
        setIsTeamPooled(data.isTeamPooled || false);
        setTransactions(data.recentTransactions || []);
        onCreditsUpdate?.(data.balance || 0);
      } else {
        // If credits/balance fails, try subscription details
        const subResponse = await fetch('/api/subscription/details', {
          credentials: 'include',
        });
        
        if (subResponse.ok) {
          const subData = await subResponse.json();
          const credits = subData.features?.currentCreditsBalance || 0;
          setBalance(credits);
          onCreditsUpdate?.(credits);
        }
      }
    } catch (error) {
      console.error('Error fetching credit balance:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchSubscriptionDetails = async () => {
    if (!user) {
      return; // Don't fetch if user is not authenticated
    }

    try {
      const response = await fetch('/api/subscription/details', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setMonthlyLimit(data.features.monthlyAiCredits);
      } else if (response.status === 401) {
        // User not authenticated, just return without error
        console.log('User not authenticated for subscription details');
        return;
      }
    } catch (error) {
      console.error('Error fetching subscription details:', error);
    }
  };

  const fetchCreditPackages = async () => {
    try {
      const response = await fetch('/api/credits/packages', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setCreditPackages(data.packages);
      }
    } catch (error) {
      console.error('Error fetching credit packages:', error);
    }
  };

  const handlePurchaseCredits = async (packageId: string) => {
    setPurchasingPackage(packageId);
    try {
      // In a real implementation, this would open Stripe checkout
      navigateTo(`/checkout/credits?package=${packageId}`);
    } catch (error) {
      console.error('Error purchasing credits:', error);
      toast({
        title: 'Purchase Failed',
        description: 'Unable to process credit purchase. Please try again.',
      });
    } finally {
      setPurchasingPackage(null);
    }
  };

  const getUsagePercentage = () => {
    if (monthlyLimit === 0) return 0;
    return Math.min(100, ((monthlyLimit - balance) / monthlyLimit) * 100);
  };

  const getTransactionIcon = (type: string) => {
    switch (type) {
      case 'usage':
        return <TrendingDown className="w-4 h-4 text-red-500" />;
      case 'purchase':
        return <ShoppingCart className="w-4 h-4 text-green-500" />;
      case 'monthly_reset':
        return <TrendingUp className="w-4 h-4 text-blue-500" />;
      case 'bonus':
        return <Sparkles className="w-4 h-4 text-purple-500" />;
      default:
        return <Activity className="w-4 h-4" />;
    }
  };

  const formatOperationType = (type?: string) => {
    if (!type) return '';
    return type.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  };

  if (loading) {
    return (
      <Card className={compact ? 'w-full' : ''}>
        <CardContent className="p-6">
          <div className="animate-pulse space-y-2">
            <div className="h-4 bg-muted rounded w-1/3"></div>
            <div className="h-8 bg-muted rounded w-1/2"></div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Compact view for header/sidebar
  if (compact) {
    return (
      <div className="flex items-center space-x-2">
        <Coins className="w-5 h-5 text-muted-foreground" />
        <div className="flex flex-col">
          <span className="text-sm font-medium">
            {balance.toLocaleString()} Credits
          </span>
          {isTeamPooled && (
            <span className="text-xs text-muted-foreground">Team Pool</span>
          )}
        </div>
        {balance < 100 && (
          <Badge variant="destructive" className="ml-2">Low</Badge>
        )}
      </div>
    );
  }

  // Full view for settings/dashboard
  return (
    <div className="space-y-6">
      {/* Main Balance Card */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span className="flex items-center">
              <Coins className="w-5 h-5 mr-2" />
              AI Credits Balance
            </span>
            {isTeamPooled && (
              <Badge variant="secondary">Team Pool</Badge>
            )}
          </CardTitle>
          <CardDescription>
            Manage your AI credits and track usage
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Balance Display */}
          <div className="flex items-end justify-between">
            <div>
              <p className="text-3xl font-bold">
                {balance.toLocaleString()}
              </p>
              <p className="text-sm text-muted-foreground">
                of {monthlyLimit.toLocaleString()} monthly credits
              </p>
            </div>
            
            {showPurchaseOption && (
              <Dialog>
                <DialogTrigger asChild>
                  <Button variant="outline">
                    <ShoppingCart className="w-4 h-4 mr-2" />
                    Buy Credits
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Purchase AI Credits</DialogTitle>
                    <DialogDescription>
                      Select a credit package. Credits never expire.
                    </DialogDescription>
                  </DialogHeader>
                  <div className="grid grid-cols-2 gap-4 mt-4">
                    {creditPackages.map((pkg) => (
                      <Card 
                        key={pkg.priceId}
                        className="cursor-pointer hover:border-primary transition-colors"
                        onClick={() => handlePurchaseCredits(pkg.priceId)}
                      >
                        <CardContent className="p-4 text-center">
                          <p className="text-2xl font-bold">
                            {pkg.credits.toLocaleString()}
                          </p>
                          <p className="text-sm text-muted-foreground">credits</p>
                          <p className="text-lg font-semibold mt-2">
                            ${pkg.price}
                          </p>
                          <Button 
                            size="sm" 
                            className="mt-2 w-full"
                            disabled={purchasingPackage === pkg.priceId}
                          >
                            {purchasingPackage === pkg.priceId ? 'Processing...' : 'Purchase'}
                          </Button>
                        </CardContent>
                      </Card>
                    ))}
                  </div>
                </DialogContent>
              </Dialog>
            )}
          </div>

          {/* Usage Progress */}
          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span>Monthly Usage</span>
              <span>{getUsagePercentage().toFixed(0)}%</span>
            </div>
            <Progress value={getUsagePercentage()} className="h-2" />
          </div>

          {/* Low Balance Warning */}
          {balance < 100 && (
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                Your credit balance is running low. Consider purchasing more credits to avoid interruptions.
              </AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>

      {/* Recent Transactions */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Transactions</CardTitle>
          <CardDescription>
            Your recent credit activity
          </CardDescription>
        </CardHeader>
        <CardContent>
          {transactions.length === 0 ? (
            <p className="text-sm text-muted-foreground text-center py-4">
              No recent transactions
            </p>
          ) : (
            <div className="space-y-2">
              {transactions.map((transaction) => (
                <div 
                  key={transaction.id}
                  className="flex items-center justify-between p-2 rounded-lg hover:bg-muted/50 transition-colors"
                >
                  <div className="flex items-center space-x-3">
                    {getTransactionIcon(transaction.transactionType)}
                    <div>
                      <p className="text-sm font-medium">
                        {transaction.description}
                      </p>
                      {transaction.operationType && (
                        <p className="text-xs text-muted-foreground">
                          {formatOperationType(transaction.operationType)}
                        </p>
                      )}
                    </div>
                  </div>
                  <div className="text-right">
                    <p className={`text-sm font-medium ${
                      transaction.amount > 0 ? 'text-green-600' : 'text-red-600'
                    }`}>
                      {transaction.amount > 0 ? '+' : ''}{transaction.amount}
                    </p>
                    <p className="text-xs text-muted-foreground">
                      {new Date(transaction.createdAt).toLocaleDateString()}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Usage Tips */}
      <Card>
        <CardHeader>
          <CardTitle>Credit Usage Tips</CardTitle>
        </CardHeader>
        <CardContent>
          <ul className="space-y-2 text-sm">
            <li className="flex items-start">
              <span className="text-muted-foreground mr-2">‚Ä¢</span>
              <span>Basic chat messages use 1 credit each</span>
            </li>
            <li className="flex items-start">
              <span className="text-muted-foreground mr-2">‚Ä¢</span>
              <span>Codebase analysis uses 10 credits per operation</span>
            </li>
            <li className="flex items-start">
              <span className="text-muted-foreground mr-2">‚Ä¢</span>
              <span>App generation uses 50 credits</span>
            </li>
            <li className="flex items-start">
              <span className="text-muted-foreground mr-2">‚Ä¢</span>
              <span>Premium models (GPT-4, Claude-3) use 3x credits</span>
            </li>
            <li className="flex items-start">
              <span className="text-muted-foreground mr-2">‚Ä¢</span>
              <span>Credits reset on the 1st of each month</span>
            </li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
};

export default AICreditsDisplay;

================
File: client/src/components/AICreditsQuickPurchase.tsx
================
/**
 * Minimalist AI Credits Quick Purchase Component
 * Elegant dropdown for ad-hoc credit purchases during sessions
 */

import React, { useState, useEffect } from 'react';
import { Coins, ShoppingCart, Sparkles, CreditCard, Check, Loader2 } from 'lucide-react';
import { Button } from './ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from './ui/dropdown-menu';
import { Badge } from './ui/badge';
import { toast } from 'sonner';
import { cn } from '../lib/utils';
import { navigateTo } from './Router';
import { useAuth } from '@/hooks/useAuth';

interface CreditPackage {
  credits: number;
  price: number;
  priceId: string;
  popular?: boolean;
}

const CREDIT_PACKAGES: CreditPackage[] = [
  { credits: 100, price: 1.99, priceId: 'price_credits_100' },
  { credits: 500, price: 8.99, priceId: 'price_credits_500', popular: true },
  { credits: 1000, price: 15.99, priceId: 'price_credits_1000' },
  { credits: 5000, price: 69.99, priceId: 'price_credits_5000' },
];

interface AICreditsQuickPurchaseProps {
  currentBalance?: number;
  isCompact?: boolean;
  onPurchaseComplete?: (newBalance: number) => void;
}

export const AICreditsQuickPurchase: React.FC<AICreditsQuickPurchaseProps> = ({
  currentBalance = 0,
  isCompact = false,
  onPurchaseComplete,
}) => {
  const { user } = useAuth();
  const [isOpen, setIsOpen] = useState(false);
  const [balance, setBalance] = useState(currentBalance);
  const [isLoading, setIsLoading] = useState(false);
  const [purchasingPackage, setPurchasingPackage] = useState<string | null>(null);
  const [messagesRemaining, setMessagesRemaining] = useState<number | null>(null);
  const [isFreemium, setIsFreemium] = useState(false);

  useEffect(() => {
    if (user) {
      fetchBalance();
    }
  }, [user]);

  const fetchBalance = async () => {
    if (!user) {
      return; // Don't fetch if user is not authenticated
    }

    try {
      // Get subscription details which includes credit balance
      const response = await fetch('/api/subscription/details', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setBalance(data.features?.currentCreditsBalance || 0);
        setIsFreemium(data.tier === 'freemium');
        if (data.tier === 'freemium') {
          setMessagesRemaining(data.features?.messagesRemaining || 0);
        }
      } else if (response.status === 401) {
        // User not authenticated, just return without error
        console.log('User not authenticated for subscription details');
        return;
      }
    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  };

  const handlePurchase = async (pkg: CreditPackage) => {
    setPurchasingPackage(pkg.priceId);
    setIsLoading(true);
    
    try {
      // Map priceId to packageId for the API
      const packageMap: { [key: string]: string } = {
        'price_credits_100': 'credits_100',
        'price_credits_500': 'credits_500',
        'price_credits_1000': 'credits_1000',
        'price_credits_5000': 'credits_5000',
      };
      
      const packageId = packageMap[pkg.priceId] || 'credits_500';
      
      // Create Stripe Checkout Session
      const response = await fetch('/api/checkout/credits', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          packageId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error initiating purchase:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to start purchase. Please try again.');
    } finally {
      setIsLoading(false);
      setPurchasingPackage(null);
      setIsOpen(false);
    }
  };

  const handleUpgradeToPro = async () => {
    if (!user) {
      setIsOpen(false);
      navigateTo('/login');
      return;
    }

    try {
      setIsLoading(true);
      
      // Create Stripe Checkout Session for Pro subscription
      const response = await fetch('/api/checkout/subscription', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          tier: 'pro',
          interval: 'monthly', // Default to monthly
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error upgrading to Pro:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to start upgrade. Please try again.');
      // Fallback to pricing page
      setIsOpen(false);
      navigateTo('/pricing');
    } finally {
      setIsLoading(false);
    }
  };

  const getBalanceColor = () => {
    if (balance === 0) return 'text-red-500';
    if (balance < 50) return 'text-yellow-500';
    return 'text-green-500';
  };

  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
    }).format(price);
  };

  // Compact trigger for header/sidebar
  if (isCompact) {
    return (
      <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "h-8 px-2 gap-1.5",
              "hover:bg-slate-800/50 transition-all duration-200"
            )}
          >
            <Coins className={cn("w-4 h-4", getBalanceColor())} />
            <span className={cn("text-sm font-medium", getBalanceColor())}>
              {balance}
            </span>
          </Button>
        </DropdownMenuTrigger>
        
        <DropdownMenuContent 
          align="end" 
          className="w-72 bg-slate-900 border-slate-700 text-white p-0"
        >
          {renderDropdownContent()}
        </DropdownMenuContent>
      </DropdownMenu>
    );
  }

  // Full button trigger
  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className={cn(
            "h-9 px-3 gap-2 border-slate-600",
            "bg-slate-800/50 hover:bg-slate-700/50",
            "text-white transition-all duration-200"
          )}
        >
          <Coins className={cn("w-4 h-4", getBalanceColor())} />
          <div className="flex flex-col items-start">
            <span className="text-xs font-medium">AI Credits</span>
            <span className={cn("text-[10px] leading-tight", getBalanceColor())}>
              {balance} remaining
            </span>
          </div>
          {balance < 100 && (
            <ShoppingCart className="w-3 h-3 ml-1 text-slate-400" />
          )}
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent 
        align="end" 
        className="w-80 bg-slate-900 border-slate-700 text-white p-0"
      >
        {renderDropdownContent()}
      </DropdownMenuContent>
    </DropdownMenu>
  );

  function renderDropdownContent() {
    return (
      <>
        {/* Header */}
        <div className="p-4 border-b border-slate-700">
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
              <div className="p-1.5 rounded-lg bg-violet-500/10 border border-violet-400/20">
                <Coins className="w-4 h-4 text-violet-400" />
              </div>
              <div>
                <p className="text-sm font-medium">AI Credits</p>
                <p className="text-xs text-slate-400">Pay as you go</p>
              </div>
            </div>
            <div className="text-right">
              <p className={cn("text-lg font-bold", getBalanceColor())}>
                {balance}
              </p>
              <p className="text-xs text-slate-400">current</p>
            </div>
          </div>

          {/* Freemium message allowance */}
          {isFreemium && messagesRemaining !== null && (
            <div className="mt-3 p-2 bg-blue-500/10 rounded-lg border border-blue-400/20">
              <div className="flex items-center justify-between">
                <span className="text-xs text-blue-300">Free Messages</span>
                <span className="text-xs font-medium text-blue-400">
                  {messagesRemaining}/10 remaining
                </span>
              </div>
              {messagesRemaining === 0 && (
                <p className="text-xs text-slate-400 mt-1">
                  Resets monthly or upgrade to Pro
                </p>
              )}
            </div>
          )}

          {balance === 0 && (
            <div className="mt-3 p-2 bg-red-500/10 rounded-lg border border-red-400/20">
              <p className="text-xs text-red-300">
                You're out of credits! Purchase more to continue.
              </p>
            </div>
          )}
        </div>

        {/* Credit Packages */}
        <div className="p-2">
          <p className="text-xs text-slate-400 px-2 py-1">Quick Purchase</p>
          
          {CREDIT_PACKAGES.map((pkg) => (
            <DropdownMenuItem
              key={pkg.priceId}
              className={cn(
                "cursor-pointer rounded-lg my-1 p-3",
                "hover:bg-slate-800/50 transition-all duration-200",
                pkg.popular && "border border-violet-400/20 bg-violet-500/5"
              )}
              onSelect={(e) => {
                e.preventDefault();
                handlePurchase(pkg);
              }}
              disabled={isLoading}
            >
              <div className="flex items-center justify-between w-full">
                <div className="flex items-center gap-3">
                  <div className={cn(
                    "p-2 rounded-lg",
                    pkg.popular 
                      ? "bg-violet-500/10 border border-violet-400/20" 
                      : "bg-slate-800/50 border border-slate-600/50"
                  )}>
                    <Sparkles className={cn(
                      "w-4 h-4",
                      pkg.popular ? "text-violet-400" : "text-slate-400"
                    )} />
                  </div>
                  <div>
                    <div className="flex items-center gap-2">
                      <p className="text-sm font-medium">
                        {pkg.credits.toLocaleString()} Credits
                      </p>
                      {pkg.popular && (
                        <Badge variant="secondary" className="h-4 px-1 text-[10px]">
                          Popular
                        </Badge>
                      )}
                    </div>
                    <p className="text-xs text-slate-400">
                      {(pkg.price / pkg.credits * 100).toFixed(1)}¬¢ per credit
                    </p>
                  </div>
                </div>
                
                <div className="flex items-center gap-2">
                  {purchasingPackage === pkg.priceId ? (
                    <Loader2 className="w-4 h-4 animate-spin text-violet-400" />
                  ) : (
                    <span className="text-sm font-bold text-violet-400">
                      {formatPrice(pkg.price)}
                    </span>
                  )}
                </div>
              </div>
            </DropdownMenuItem>
          ))}
        </div>

        {/* Footer Actions */}
        <div className="p-3 border-t border-slate-700 space-y-2">
          <Button
            variant="outline"
            size="sm"
            className="w-full h-8 text-xs bg-slate-700/50 hover:bg-slate-600/50 border-slate-600 text-white hover:text-white"
            onClick={() => {
              setIsOpen(false);
              navigateTo('/pricing');
            }}
          >
            View Subscription Plans
          </Button>
          
          {isFreemium && (
            <Button
              size="sm"
              className="w-full h-8 text-xs bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700"
              onClick={handleUpgradeToPro}
              disabled={isLoading}
            >
              {isLoading ? (
                <>
                  <Loader2 className="w-3 h-3 animate-spin mr-1" />
                  Processing...
                </>
              ) : (
                'Upgrade to Pro - $19/month'
              )}
            </Button>
          )}

          <p className="text-[10px] text-slate-500 text-center">
            Credits never expire ‚Ä¢ Secure checkout with Stripe
          </p>
        </div>
      </>
    );
  }
};

export default AICreditsQuickPurchase;

================
File: client/src/components/AIProviderQuickSelector.tsx
================
import React, { useState, useEffect } from 'react';
import { ChevronDown, Settings, Check, AlertCircle, Sparkles, Trash2, TestTube, ChevronRight } from 'lucide-react';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { toast } from 'sonner';
import { 
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem
} from './ui/dropdown-menu';
import { Badge } from './ui/badge';
import { useAIProvider, AIProvider } from '../hooks/useAIProvider';
import { LLMModel } from '../types';
import { cn } from '../lib/utils';

interface ProviderConfig {
  id: AIProvider;
  name: string;
  icon: string;
  color: string;
  requiresKey?: boolean;
  keyPlaceholder?: string;
  keyPattern?: string;
  secondaryField?: {
    name: string;
    placeholder: string;
  };
}

const providers: ProviderConfig[] = [
  {
    id: 'lmstudio',
    name: 'Uterpi AI',
    icon: 'üöÄ',
    color: 'purple',
    requiresKey: false
  },
  {
    id: 'azure',
    name: 'Azure AI',
    icon: '‚òÅÔ∏è',
    color: 'blue',
    requiresKey: false
  },
  {
    id: 'openai',
    name: 'OpenAI',
    icon: 'ü§ñ',
    color: 'green',
    requiresKey: true,
    keyPlaceholder: 'sk-...',
    keyPattern: 'sk-'
  },
  {
    id: 'gemini',
    name: 'Google Gemini',
    icon: '‚ú®',
    color: 'purple',
    requiresKey: true,
    keyPlaceholder: 'AI...',
    keyPattern: 'AI'
  },
  {
    id: 'huggingface',
    name: 'Hugging Face',
    icon: 'ü§ó',
    color: 'orange',
    requiresKey: true,
    keyPlaceholder: 'hf_...',
    keyPattern: 'hf_',
    secondaryField: {
      name: 'Endpoint URL',
      placeholder: 'https://...'
    }
  }
];

export const AIProviderQuickSelector: React.FC = () => {
  const {
    currentProvider,
    setProvider,
    selectedLLMModel,
    updateModel,
    getAvailableModels,
    isProviderConfigured
  } = useAIProvider();

  const [isOpen, setIsOpen] = useState(false);
  const [apiKeys, setApiKeys] = useState<Record<string, string>>({});
  const [endpointUrl, setEndpointUrl] = useState('');
  const [showConfig, setShowConfig] = useState<AIProvider | null>(null);
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [testingConnection, setTestingConnection] = useState<AIProvider | null>(null);

  // Load stored API keys
  useEffect(() => {
    const keys: Record<string, string> = {};
    const openaiKey = localStorage.getItem('openai-api-key');
    const geminiKey = localStorage.getItem('gemini-api-key');
    const hfToken = localStorage.getItem('hf-api-token');
    const hfUrl = localStorage.getItem('hf-endpoint-url');

    if (openaiKey) keys.openai = openaiKey;
    if (geminiKey) keys.gemini = geminiKey;
    if (hfToken) keys.huggingface = hfToken;
    if (hfUrl) setEndpointUrl(hfUrl);

    setApiKeys(keys);
  }, []);

  const saveApiKey = (provider: AIProvider, key: string) => {
    setApiKeys(prev => ({ ...prev, [provider]: key }));
    
    // Save to localStorage based on provider
    if (provider === 'openai') {
      if (key) localStorage.setItem('openai-api-key', key);
      else localStorage.removeItem('openai-api-key');
    } else if (provider === 'gemini') {
      if (key) localStorage.setItem('gemini-api-key', key);
      else localStorage.removeItem('gemini-api-key');
    } else if (provider === 'huggingface') {
      if (key) localStorage.setItem('hf-api-token', key);
      else localStorage.removeItem('hf-api-token');
    }
  };

  const saveEndpointUrl = (url: string) => {
    setEndpointUrl(url);
    if (url) localStorage.setItem('hf-endpoint-url', url);
    else localStorage.removeItem('hf-endpoint-url');
  };

  const handleProviderSelect = (provider: AIProvider, event?: React.MouseEvent) => {
    const config = providers.find(p => p.id === provider);
    
    // Check if provider needs configuration
    if (config?.requiresKey && !isProviderConfigured(provider)) {
      // Prevent dropdown from closing when configuration is needed
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      setShowConfig(provider);
      return false; // Indicate that we should not close the dropdown
    } else {
      setProvider(provider);
      // Auto-select first available model for new provider
      const models = getAvailableModels();
      if (models.length > 0 && (!selectedLLMModel || selectedLLMModel.provider !== config?.name)) {
        updateModel(models[0]);
      }
      return true; // Indicate that we can close the dropdown
    }
  };

  const handleModelSelect = (model: LLMModel) => {
    updateModel(model);
  };

  const testConnection = async (provider: AIProvider) => {
    setTestingConnection(provider);
    try {
      // Import the service dynamically based on provider
      let service: any;
      
      if (provider === 'openai' && apiKeys.openai) {
        const { OpenAIService } = await import('../lib/openAI');
        service = new OpenAIService({ apiKey: apiKeys.openai, modelName: 'gpt-4o-mini' });
      } else if (provider === 'gemini' && apiKeys.gemini) {
        const { GeminiService } = await import('../lib/gemini');
        service = new GeminiService({ apiKey: apiKeys.gemini, modelName: 'gemini-2.5-flash' });
      } else if (provider === 'huggingface' && apiKeys.huggingface && endpointUrl) {
        const { HuggingFaceService } = await import('../lib/huggingface');
        service = new HuggingFaceService({ 
          apiToken: apiKeys.huggingface, 
          endpointUrl: endpointUrl, 
          modelName: 'hf-endpoint' 
        });
      } else if (provider === 'azure') {
        toast.success('Azure AI is pre-configured and ready to use');
        setTestingConnection(null);
        return;
      } else if (provider === 'lmstudio') {
        toast.success('LM Studio is ready to use');
        setTestingConnection(null);
        return;
      } else {
        toast.error('Missing credentials for this provider');
        setTestingConnection(null);
        return;
      }

      // Test the connection
      await service.sendChatCompletion([
        { role: 'system', content: 'Connection test' },
        { role: 'user', content: 'ping' }
      ], { maxTokens: 100 }); // Increased for Gemini compatibility
      
      toast.success(`Connection successful!`);
    } catch (error) {
      toast.error(`Connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setTestingConnection(null);
    }
  };

  const clearCredentials = (provider: AIProvider) => {
    // Clear from state
    setApiKeys(prev => {
      const newKeys = { ...prev };
      delete newKeys[provider];
      return newKeys;
    });

    // Clear from localStorage
    if (provider === 'openai') {
      localStorage.removeItem('openai-api-key');
    } else if (provider === 'gemini') {
      localStorage.removeItem('gemini-api-key');
    } else if (provider === 'huggingface') {
      localStorage.removeItem('hf-api-token');
      localStorage.removeItem('hf-endpoint-url');
      setEndpointUrl('');
    }

    toast.success(`Cleared ${providers.find(p => p.id === provider)?.name} credentials`);
    
    // If this was the current provider and it now needs setup, switch to a configured provider
    if (currentProvider === provider) {
      const fallbackProvider = providers.find(p => isProviderConfigured(p.id));
      if (fallbackProvider) {
        setProvider(fallbackProvider.id);
      }
    }
  };

  const currentProviderConfig = providers.find(p => p.id === currentProvider);
  const availableModels = getAvailableModels();

  return (
    <div className="flex items-center gap-2">
      <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
        <DropdownMenuTrigger asChild>
          <Button
            variant="outline"
            size="sm"
            className={cn(
              "h-9 px-3 gap-2 border-slate-600 bg-slate-800/50 hover:bg-slate-700/50",
              "text-white transition-all duration-200"
            )}
          >
            <span className="text-base">{currentProviderConfig?.icon}</span>
            <div className="flex flex-col items-start">
              <span className="text-xs font-medium">{currentProviderConfig?.name}</span>
              {selectedLLMModel && (
                <span className="text-[10px] text-slate-400 leading-tight">{currentProviderConfig?.id === 'lmstudio' ? 'Uterpi AI' : selectedLLMModel.name}</span>
              )}
            </div>
            <ChevronDown className="w-3 h-3 ml-1 text-slate-400" />
          </Button>
        </DropdownMenuTrigger>
        
        <DropdownMenuContent 
          align="end" 
          className="w-80 bg-slate-900 border-slate-700 text-white"
        >
          <DropdownMenuLabel className="text-xs text-slate-400">AI Provider</DropdownMenuLabel>
          
          {/* Provider Selection */}
          {providers.map(provider => {
            const isConfigured = isProviderConfigured(provider.id);
            const isSelected = currentProvider === provider.id;
            const needsSetup = provider.requiresKey && !isConfigured;
            
            return (
              <DropdownMenuItem
                key={provider.id}
                className={cn(
                  "cursor-pointer",
                  isSelected && "bg-slate-800"
                )}
                onSelect={(event) => {
                  // For providers that need setup, prevent default closing behavior
                  if (needsSetup) {
                    event.preventDefault();
                  }
                  handleProviderSelect(provider.id, event as any);
                }}
              >
                <div className="flex items-center justify-between w-full">
                  <div className="flex items-center gap-2">
                    {isSelected && (
                      <div className="w-2 h-2 rounded-full bg-violet-500" />
                    )}
                    {!isSelected && (
                      <div className="w-2 h-2 rounded-full border border-slate-600" />
                    )}
                    <span>{provider.icon}</span>
                    <span className="text-sm">{provider.name}</span>
                  </div>
                  <div className="flex items-center gap-1">
                    {provider.requiresKey && (
                      <Badge
                        variant={isConfigured ? "default" : "outline"}
                        className={cn(
                          "text-[10px] h-4 px-1",
                          isConfigured 
                            ? "bg-green-600/20 text-green-400 border-green-600/30" 
                            : "text-slate-400 border-slate-600"
                        )}
                      >
                        {isConfigured ? "Ready" : "Setup"}
                      </Badge>
                    )}
                    {provider.id === 'lmstudio' && (
                      <Badge className="text-[10px] h-4 px-1 bg-amber-500/20 text-amber-400 border-amber-500/30">
                        Recommended
                      </Badge>
                    )}
                  </div>
                </div>
              </DropdownMenuItem>
            );
          })}

          <DropdownMenuSeparator className="bg-slate-700" />

          {/* Model Selection */}
          {availableModels.length > 1 && (
            <>
              <DropdownMenuLabel className="text-xs text-slate-400">Model</DropdownMenuLabel>
              <DropdownMenuRadioGroup 
                value={selectedLLMModel?.id} 
                onValueChange={(value) => {
                  const model = availableModels.find(m => m.id === value);
                  if (model) handleModelSelect(model);
                }}
              >
                {availableModels.map(model => (
                  <DropdownMenuRadioItem
                    key={model.id}
                    value={model.id}
                    className="cursor-pointer"
                  >
                    <div className="flex items-center justify-between w-full">
                      <div className="flex flex-col">
                        <span className="text-sm">{model.name}</span>
                        <span className="text-[10px] text-slate-400">
                          {model.contextLength.toLocaleString()} tokens
                        </span>
                      </div>
                      {model.tier && (
                        <Badge 
                          variant="secondary" 
                          className={cn(
                            "text-[10px] h-4 px-1.5 font-medium",
                            model.tier === 'standard' && "bg-slate-700/50 text-slate-300 border-slate-600",
                            model.tier === 'freemium' && "bg-emerald-900/30 text-emerald-400 border-emerald-600",
                            model.tier === 'pro' && "bg-violet-900/30 text-violet-400 border-violet-600",
                            model.tier === 'enterprise' && "bg-amber-900/30 text-amber-400 border-amber-600"
                          )}
                        >
                          {model.tier}
                        </Badge>
                      )}
                    </div>
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
              <DropdownMenuSeparator className="bg-slate-700" />
            </>
          )}

          {/* Configuration Section for Selected Provider */}
          {showConfig && (
            <>
              <div className="p-3 space-y-3">
                <div className="text-xs font-medium text-slate-300">Configure {providers.find(p => p.id === showConfig)?.name}</div>
                
                {/* API Key Input */}
                {providers.find(p => p.id === showConfig)?.requiresKey && (
                  <div className="space-y-2">
                    <Label className="text-xs text-slate-400">API Key</Label>
                    <Input
                      type="password"
                      placeholder={providers.find(p => p.id === showConfig)?.keyPlaceholder}
                      value={apiKeys[showConfig] || ''}
                      onChange={(e) => saveApiKey(showConfig, e.target.value)}
                      className="h-8 text-xs bg-slate-800 border-slate-600 text-white"
                    />
                  </div>
                )}

                {/* Secondary Field (for HuggingFace) */}
                {showConfig === 'huggingface' && (
                  <div className="space-y-2">
                    <Label className="text-xs text-slate-400">Endpoint URL</Label>
                    <Input
                      type="url"
                      placeholder="https://..."
                      value={endpointUrl}
                      onChange={(e) => saveEndpointUrl(e.target.value)}
                      className="h-8 text-xs bg-slate-800 border-slate-600 text-white"
                    />
                  </div>
                )}

                <div className="flex gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      setShowConfig(null);
                    }}
                    className="flex-1 h-8 text-xs border-slate-500/70 bg-slate-800/60 text-slate-200 hover:text-white hover:bg-slate-700/80 hover:border-slate-400/80 transition-all duration-200 font-medium"
                  >
                    Cancel
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => {
                      // Now the provider is configured, we can select it
                      handleProviderSelect(showConfig);
                      setShowConfig(null);
                      // Allow dropdown to close after successful configuration
                      setIsOpen(false);
                    }}
                    disabled={
                      (providers.find(p => p.id === showConfig)?.requiresKey && !apiKeys[showConfig]) ||
                      (showConfig === 'huggingface' && !endpointUrl)
                    }
                    className="flex-1 h-8 text-xs bg-violet-600/90 hover:bg-violet-700 text-white border border-violet-500/50 hover:border-violet-400/70 transition-all duration-200 font-medium shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Save & Use
                  </Button>
                </div>
              </div>
              <DropdownMenuSeparator className="bg-slate-700" />
            </>
          )}

          {/* Advanced Settings Toggle */}
          <DropdownMenuItem
            onSelect={(e) => {
              e.preventDefault(); // Keep dropdown open
              setShowAdvanced(!showAdvanced);
            }}
            className="text-xs text-slate-400 hover:text-white cursor-pointer"
          >
            <div className="flex items-center justify-between w-full">
              <div className="flex items-center">
                <Settings className="w-3 h-3 mr-2" />
                Advanced Settings
              </div>
              <ChevronRight className={cn(
                "w-3 h-3 transition-transform",
                showAdvanced && "rotate-90"
              )} />
            </div>
          </DropdownMenuItem>

          {/* Advanced Settings Content */}
          {showAdvanced && (
            <>
              <DropdownMenuSeparator className="bg-slate-700" />
              <div className="px-2 py-3 space-y-3">
                <Label className="text-xs text-slate-400">Manage Providers</Label>
                
                {providers.filter(p => p.requiresKey || p.id === currentProvider).map(provider => {
                  const isConfigured = isProviderConfigured(provider.id);
                  const isCurrent = currentProvider === provider.id;
                  const isTesting = testingConnection === provider.id;
                  
                  return (
                    <div 
                      key={provider.id} 
                      className={cn(
                        "p-2 rounded border",
                        isCurrent 
                          ? "bg-slate-800 border-violet-500/50" 
                          : "bg-slate-900/50 border-slate-700"
                      )}
                    >
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <span>{provider.icon}</span>
                          <span className="text-xs font-medium">{provider.name}</span>
                        </div>
                        <Badge 
                          variant={isConfigured ? "default" : "outline"}
                          className={cn(
                            "text-[10px] h-4 px-2 font-medium",
                            isConfigured 
                              ? "bg-green-600/80 text-green-100 border-green-500/50" 
                              : "border-amber-500/60 text-amber-300 bg-amber-950/30"
                          )}
                        >
                          {isConfigured ? "Configured" : "Setup Required"}
                        </Badge>
                      </div>
                      
                      {isConfigured && (
                        <div className="flex gap-2">
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={(e) => {
                              e.preventDefault();
                              e.stopPropagation();
                              testConnection(provider.id);
                            }}
                            disabled={isTesting}
                            className="flex-1 h-7 text-xs px-3 border-slate-500/70 bg-slate-800/60 text-slate-100 hover:text-white hover:bg-slate-700/80 hover:border-slate-400/80 transition-all duration-200 font-medium"
                          >
                            {isTesting ? (
                              <>
                                <TestTube className="w-3 h-3 mr-1 animate-pulse" />
                                Testing...
                              </>
                            ) : (
                              <>
                                <TestTube className="w-3 h-3 mr-1" />
                                Test
                              </>
                            )}
                          </Button>
                          {provider.requiresKey && (
                            <Button
                              size="sm"
                              variant="outline"
                              onClick={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                clearCredentials(provider.id);
                              }}
                              className="flex-1 h-7 text-xs px-3 border-red-500/70 bg-red-950/40 text-red-200 hover:text-red-100 hover:bg-red-900/50 hover:border-red-400/80 transition-all duration-200 font-medium"
                            >
                              <Trash2 className="w-3 h-3 mr-1" />
                              Clear
                            </Button>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </>
          )}
        </DropdownMenuContent>
      </DropdownMenu>

      {/* Status Indicator */}
      {currentProviderConfig && (
        <div className="flex items-center">
          {isProviderConfigured(currentProvider) ? (
            <Check className="w-3 h-3 text-green-400" />
          ) : (
            <AlertCircle className="w-3 h-3 text-amber-400" />
          )}
        </div>
      )}
    </div>
  );
};

================
File: client/src/components/AIProviderSelector.tsx
================
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Badge } from './ui/badge';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Settings, Cloud, Key, CheckCircle, AlertCircle } from 'lucide-react';
import { OpenAIService } from '../lib/openAI';
import { GeminiService } from '../lib/gemini';
import { HuggingFaceService } from '../lib/huggingface';
import { LMStudioService } from '../lib/lmstudio';

export type AIProvider = 'azure' | 'openai' | 'gemini' | 'huggingface' | 'uterpi' | 'lmstudio';

interface AIProviderSelectorProps {
  currentProvider: AIProvider;
  onProviderChange: (provider: AIProvider) => void;
}

interface ProviderStatus {
  configured: boolean;
  hasApiKey?: boolean;
  hasEndpoint?: boolean; // for Hugging Face
  error?: string;
  connection?: 'unknown' | 'ok' | 'fail';
  connectionMessage?: string;
}

const AIProviderSelector: React.FC<AIProviderSelectorProps> = ({
  currentProvider,
  onProviderChange
}) => {
  
  // Provider status tracking
  const [providerStatus, setProviderStatus] = useState<Record<AIProvider, ProviderStatus>>({
    azure: { configured: true }, // Azure is always configured via env vars
    openai: { configured: false },
    gemini: { configured: false },
    huggingface: { configured: false },
    uterpi: { configured: false },
    lmstudio: { configured: true }
  });

  // Inline config inputs
  const [openaiKey, setOpenaiKey] = useState('');
  const [geminiKey, setGeminiKey] = useState('');
  const [hfToken, setHfToken] = useState('');
  const [hfUrl, setHfUrl] = useState('');
  const [lmstudioUrl, setLmstudioUrl] = useState('');
  const [lmstudioApiKey, setLmstudioApiKey] = useState('');

  // Load stored values and compute status on mount
  useEffect(() => {
    const savedOpenaiKey = localStorage.getItem('openai-api-key') || '';
    const savedGeminiKey = localStorage.getItem('gemini-api-key') || '';
    const savedHfToken = localStorage.getItem('hf-api-token') || '';
    const savedHfUrl = localStorage.getItem('hf-endpoint-url') || '';
    const savedLmstudioUrl = localStorage.getItem('lmstudio-base-url') || '';
    const savedLmstudioApiKey = localStorage.getItem('lmstudio-api-key') || '';

    setOpenaiKey(savedOpenaiKey);
    setGeminiKey(savedGeminiKey);
    setHfToken(savedHfToken);
    setHfUrl(savedHfUrl);
    setLmstudioUrl(savedLmstudioUrl);
    setLmstudioApiKey(savedLmstudioApiKey);

    const updateStatus = () => {
      const uterpiConfigured = !!(import.meta as any).env?.VITE_UTERPI_API_TOKEN && !!(import.meta as any).env?.VITE_UTERPI_ENDPOINT_URL;
      setProviderStatus({
        azure: { configured: true, connection: 'unknown' },
        openai: { configured: !!savedOpenaiKey, hasApiKey: !!savedOpenaiKey, connection: 'unknown' },
        gemini: { configured: !!savedGeminiKey, hasApiKey: !!savedGeminiKey, connection: 'unknown' },
        huggingface: { configured: !!savedHfToken && !!savedHfUrl, hasApiKey: !!savedHfToken, hasEndpoint: !!savedHfUrl, connection: 'unknown' },
        uterpi: { configured: uterpiConfigured, connection: 'unknown' },
        lmstudio: { configured: true, hasEndpoint: !!savedLmstudioUrl, connection: 'unknown' }
      });
    };
    updateStatus();

    const handleStorageChange = () => updateStatus();
    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);

  const handleProviderSelect = (provider: AIProvider) => {
    onProviderChange(provider);
  };

  // Persist helper
  const persist = (key: string, value: string) => {
    if (value) localStorage.setItem(key, value);
    else localStorage.removeItem(key);
  };

  // Debounced connection test
  const [pendingTestProvider, setPendingTestProvider] = useState<AIProvider | null>(null);
  useEffect(() => {
    const timer = setTimeout(async () => {
      if (!pendingTestProvider) return;
      const p = pendingTestProvider;
      setPendingTestProvider(null);
      try {
        if (p === 'openai' && openaiKey) {
          setProviderStatus(prev => ({ ...prev, openai: { ...prev.openai, connection: 'unknown', connectionMessage: 'Testing‚Ä¶' } }));
          const svc = new OpenAIService({ apiKey: openaiKey.trim(), modelName: 'gpt-4o-mini' });
          await svc.sendChatCompletion([
            { role: 'system', content: 'Connectivity test' },
            { role: 'user', content: 'ping' }
          ], { maxTokens: 100 }); // Increased for Gemini compatibility
          setProviderStatus(prev => ({ ...prev, openai: { ...prev.openai, connection: 'ok', connectionMessage: 'Connected' } }));
        }
        if (p === 'gemini' && geminiKey) {
          setProviderStatus(prev => ({ ...prev, gemini: { ...prev.gemini, connection: 'unknown', connectionMessage: 'Testing‚Ä¶' } }));
          const svc = new GeminiService({ apiKey: geminiKey.trim(), modelName: 'gemini-2.5-flash' });
          await svc.sendChatCompletion([
            { role: 'system', content: 'Connectivity test' },
            { role: 'user', content: 'ping' }
          ], { maxTokens: 100 }); // Increased for Gemini compatibility
          setProviderStatus(prev => ({ ...prev, gemini: { ...prev.gemini, connection: 'ok', connectionMessage: 'Connected' } }));
        }
        if (p === 'huggingface' && hfToken && hfUrl) {
          setProviderStatus(prev => ({ ...prev, huggingface: { ...prev.huggingface, connection: 'unknown', connectionMessage: 'Testing‚Ä¶' } }));
          const svc = new HuggingFaceService({ endpointUrl: hfUrl.trim(), apiToken: hfToken.trim(), modelName: 'hf-endpoint' });
          await svc.sendChatCompletion([
            { role: 'system', content: 'Connectivity test' },
            { role: 'user', content: 'ping' }
          ], { maxTokens: 100 }); // Increased for Gemini compatibility
          setProviderStatus(prev => ({ ...prev, huggingface: { ...prev.huggingface, connection: 'ok', connectionMessage: 'Connected' } }));
        }
        if (p === 'lmstudio') {
          setProviderStatus(prev => ({ ...prev, lmstudio: { ...prev.lmstudio, connection: 'unknown', connectionMessage: 'Testing‚Ä¶' } }));
          const cfg = LMStudioService.createWithModel(LMStudioService.getAvailableModels()[0].id);
          const baseUrl = (lmstudioUrl || cfg.baseUrl) as string | undefined;
          const apiKey = (lmstudioApiKey || cfg.apiKey) as string;
          const svc = new LMStudioService({ ...cfg, baseUrl, apiKey });
          await svc.sendChatCompletion([
            { role: 'system', content: 'Connectivity test' },
            { role: 'user', content: 'ping' }
          ], { maxTokens: 100 }); // Increased for Gemini compatibility
          setProviderStatus(prev => ({ ...prev, lmstudio: { ...prev.lmstudio, connection: 'ok', connectionMessage: 'Connected' } }));
        }
      } catch (err: any) {
        const msg = err?.message || 'Connection failed';
        if (p === 'openai') setProviderStatus(prev => ({ ...prev, openai: { ...prev.openai, connection: 'fail', connectionMessage: msg } }));
        if (p === 'gemini') setProviderStatus(prev => ({ ...prev, gemini: { ...prev.gemini, connection: 'fail', connectionMessage: msg } }));
        if (p === 'huggingface') setProviderStatus(prev => ({ ...prev, huggingface: { ...prev.huggingface, connection: 'fail', connectionMessage: msg } }));
        if (p === 'lmstudio') setProviderStatus(prev => ({ ...prev, lmstudio: { ...prev.lmstudio, connection: 'fail', connectionMessage: msg } }));
      }
    }, 600);
    return () => clearTimeout(timer);
  }, [pendingTestProvider, openaiKey, geminiKey, hfToken, hfUrl, lmstudioUrl, lmstudioApiKey]);

  const StatusBadge: React.FC<{ status: ProviderStatus; isActive: boolean }> = ({ status, isActive }) => {
    if (isActive) {
      return <Badge className="bg-green-600 text-white"><CheckCircle className="w-3 h-3 mr-1" />Active</Badge>;
    }
    if (status.configured) {
      return <Badge variant="secondary"><CheckCircle className="w-3 h-3 mr-1" />Ready</Badge>;
    }
    return <Badge variant="outline"><AlertCircle className="w-3 h-3 mr-1" />Setup Required</Badge>;
  };

  const ConnectionNote: React.FC<{ status?: ProviderStatus }> = ({ status }) => {
    if (!status) return null;
    if (status.connection === 'ok') return <p role="status" aria-live="polite" className="text-xs text-emerald-500">{status.connectionMessage || 'Connected'}</p>;
    if (status.connection === 'fail') return <p role="status" aria-live="polite" className="text-xs text-red-500">{status.connectionMessage || 'Connection failed'}</p>;
    if (status.connectionMessage) return <p role="status" aria-live="polite" className="text-xs text-slate-400">{status.connectionMessage}</p>;
    return null;
  };

  const providers = [
    {
      id: 'azure' as AIProvider,
      name: 'Azure AI',
      description: 'Microsoft Azure AI with enterprise-grade models',
      icon: <Cloud className="w-6 h-6" />,
      features: ['Enterprise Security', 'Pre-configured', 'Multiple Models'],
      color: 'blue'
    },
    {
      id: 'lmstudio' as AIProvider,
      name: 'Uterpi AI',
      description: 'Uterpi AI via LM Studio (Recommended)',
      icon: <Cloud className="w-6 h-6" />,
      features: ['Runs Locally', 'OpenAI-Compatible', 'No API Key Needed'],
      color: 'purple'
    },
    {
      id: 'uterpi' as AIProvider,
      name: 'Uterpi',
      description: 'Proprietary LLM. Ready out-of-the-box.',
      icon: <Cloud className="w-6 h-6" />,
      features: ['No Setup Required', 'Managed Endpoint', 'Great Defaults'],
      color: 'amber'
    },
    {
      id: 'openai' as AIProvider,
      name: 'OpenAI',
      description: 'Direct access to GPT-4, GPT-4o, and other OpenAI models',
      icon: <Key className="w-6 h-6" />,
      features: ['Latest Models', 'API Key Required', 'Vision Support'],
      color: 'green'
    },
    {
      id: 'gemini' as AIProvider,
      name: 'Google Gemini',
      description: 'Google\'s advanced multimodal AI models',
      icon: <Key className="w-6 h-6" />,
      features: ['Multimodal', 'Long Context', 'API Key Required'],
      color: 'purple'
    },
    {
      id: 'huggingface' as AIProvider,
      name: 'Hugging Face',
      description: 'Use your own HuggingFace Inference Endpoint',
      icon: <Key className="w-6 h-6" />,
      features: ['Custom Endpoint', 'API Token Required', 'Provider-Agnostic'],
      color: 'orange'
    }
  ];

  return (
    <>
      <Card className="w-full max-w-4xl mx-auto">
        <CardHeader>
          <div className="flex items-center gap-2">
            <Settings className="w-5 h-5" />
            <CardTitle>AI Provider Selection</CardTitle>
          </div>
          <CardDescription>
            Choose your preferred AI provider. Uterpi via LM Studio is recommended and works out-of-the-box. OpenAI and Gemini require API keys; Hugging Face requires both an API token and endpoint URL.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div role="radiogroup" aria-label="AI providers" className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 gap-4">
            {providers.map((provider) => {
              const status = providerStatus[provider.id];
              const isActive = currentProvider === provider.id;
              
              const colorMap: Record<string, string> = {
                blue: 'bg-blue-100 dark:bg-blue-900/20',
                amber: 'bg-amber-100 dark:bg-amber-900/20',
                green: 'bg-green-100 dark:bg-green-900/20',
                purple: 'bg-purple-100 dark:bg-purple-900/20',
                orange: 'bg-orange-100 dark:bg-orange-900/20'
              };

              return (
                <Card 
                  key={provider.id}
                  className={`cursor-pointer transition-all hover:shadow-lg ${
                    isActive 
                      ? 'ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-950/20' 
                      : 'hover:bg-gray-50 dark:hover:bg-gray-800/50'
                  }`}
                  role="radio"
                  aria-checked={isActive}
                  tabIndex={0}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      handleProviderSelect(provider.id);
                    }
                  }}
                  onClick={() => handleProviderSelect(provider.id)}
                >
                  <CardContent className="p-6">
                    <div className="flex items-start justify-between mb-4">
                      <div className={`p-2 rounded-lg ${colorMap[provider.color]}`}>
                        {provider.icon}
                      </div>
                      <div className="flex items-center gap-2">
                        {provider.id === 'lmstudio' && (
                          <Badge className="bg-amber-500 text-white">Recommended</Badge>
                        )}
                        <StatusBadge status={status} isActive={isActive} />
                      </div>
                    </div>
                    
                    <h3 className="font-semibold text-lg mb-2">{provider.name}</h3>
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
                      {provider.description}
                    </p>
                    <p className="text-xs text-gray-500 dark:text-gray-400 mb-3">
                      {provider.id === 'azure' && 'Ready to use.'}
                      {provider.id === 'lmstudio' && 'Ready to use. Recommended.'}
                      {provider.id === 'uterpi' && 'Ready to use. Managed.'}
                      {provider.id === 'openai' && 'Enter API key to start.'}
                      {provider.id === 'gemini' && 'Enter API key to start.'}
                      {provider.id === 'huggingface' && 'Enter endpoint URL and API token.'}
                    </p>
                    
                    <div className="space-y-2">
                      {provider.features.map((feature, index) => (
                        <div key={index} className="flex items-center text-sm text-gray-500">
                          <CheckCircle className="w-3 h-3 mr-2 text-green-500" />
                          {feature}
                        </div>
                      ))}
                      {provider.id === 'openai' && (
                        <div className="mt-2 text-xs text-gray-600 dark:text-gray-400">
                          <div className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${providerStatus.openai.hasApiKey ? 'bg-green-500' : 'bg-red-500'}`} />
                            API Key {providerStatus.openai.hasApiKey ? 'Present' : 'Required'}
                          </div>
                        </div>
                      )}
                      {provider.id === 'gemini' && (
                        <div className="mt-2 text-xs text-gray-600 dark:text-gray-400">
                          <div className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${providerStatus.gemini.hasApiKey ? 'bg-green-500' : 'bg-red-500'}`} />
                            API Key {providerStatus.gemini.hasApiKey ? 'Present' : 'Required'}
                          </div>
                        </div>
                      )}
                      {provider.id === 'huggingface' && (
                        <div className="mt-2 text-xs text-gray-600 dark:text-gray-400 space-y-1">
                          <div className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${providerStatus.huggingface.hasApiKey ? 'bg-green-500' : 'bg-red-500'}`} />
                            API Token {providerStatus.huggingface.hasApiKey ? 'Present' : 'Required'}
                          </div>
                          <div className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${providerStatus.huggingface.hasEndpoint ? 'bg-green-500' : 'bg-red-500'}`} />
                            Endpoint URL {providerStatus.huggingface.hasEndpoint ? 'Present' : 'Required'}
                          </div>
                        </div>
                      )}
                    </div>
                    
                    <div className="mt-4" aria-label={`${provider.name} configuration`}>
                      {isActive && (
                        <div className="space-y-3 p-3 rounded-md bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-slate-700/60">
                          {provider.id === 'azure' && (
                            <p className="text-sm text-slate-500">Azure AI is pre-configured. No setup needed.</p>
                          )}
                          {provider.id === 'openai' && (
                            <div className="space-y-2">
                              <Label htmlFor="openai-key" className="text-sm">OpenAI API Key</Label>
                              <Input id="openai-key" type="password" placeholder="sk-..." value={openaiKey} onChange={(e) => setOpenaiKey(e.target.value)} onBlur={() => {
                                const v = openaiKey.trim();
                                persist('openai-api-key', v);
                                setProviderStatus(prev => ({ ...prev, openai: { ...prev.openai, configured: !!v, hasApiKey: !!v } }));
                                setPendingTestProvider('openai');
                              }} />
                              <ConnectionNote status={providerStatus.openai} />
                            </div>
                          )}
                          {provider.id === 'gemini' && (
                            <div className="space-y-2">
                              <Label htmlFor="gemini-key" className="text-sm">Gemini API Key</Label>
                              <Input id="gemini-key" type="password" placeholder="AI..." value={geminiKey} onChange={(e) => setGeminiKey(e.target.value)} onBlur={() => {
                                const v = geminiKey.trim();
                                persist('gemini-api-key', v);
                                setProviderStatus(prev => ({ ...prev, gemini: { ...prev.gemini, configured: !!v, hasApiKey: !!v } }));
                                setPendingTestProvider('gemini');
                              }} />
                              <ConnectionNote status={providerStatus.gemini} />
                            </div>
                          )}
                          {provider.id === 'huggingface' && (
                            <div className="space-y-2">
                              <div className="space-y-2">
                                <Label htmlFor="hf-url" className="text-sm">Endpoint URL</Label>
                                <Input id="hf-url" type="text" placeholder="https://..." value={hfUrl} onChange={(e) => setHfUrl(e.target.value)} onBlur={() => {
                                  const v = hfUrl.trim();
                                  persist('hf-endpoint-url', v);
                                  setProviderStatus(prev => ({ ...prev, huggingface: { ...prev.huggingface, hasEndpoint: !!v, configured: !!v && !!hfToken.trim() } }));
                                  setPendingTestProvider('huggingface');
                                }} />
                              </div>
                              <div className="space-y-2">
                                <Label htmlFor="hf-token" className="text-sm">API Token</Label>
                                <Input id="hf-token" type="password" placeholder="hf_..." value={hfToken} onChange={(e) => setHfToken(e.target.value)} onBlur={() => {
                                  const v = hfToken.trim();
                                  persist('hf-api-token', v);
                                  setProviderStatus(prev => ({ ...prev, huggingface: { ...prev.huggingface, hasApiKey: !!v, configured: !!v && !!hfUrl.trim() } }));
                                  setPendingTestProvider('huggingface');
                                }} />
                              </div>
                              <ConnectionNote status={providerStatus.huggingface} />
                            </div>
                          )}
                          {provider.id === 'lmstudio' && (
                            <div className="space-y-2">
                              <div className="space-y-2">
                                <Label htmlFor="lmstudio-url" className="text-sm">Base URL (optional)</Label>
                                <Input id="lmstudio-url" type="text" placeholder="/lmstudio or https://lmstudio.uterpi.com" value={lmstudioUrl} onChange={(e) => setLmstudioUrl(e.target.value)} onBlur={() => {
                                  const v = lmstudioUrl.trim();
                                  persist('lmstudio-base-url', v);
                                  setProviderStatus(prev => ({ ...prev, lmstudio: { ...prev.lmstudio, hasEndpoint: !!v } }));
                                  setPendingTestProvider('lmstudio');
                                }} />
                              </div>
                              <div className="space-y-2">
                                <Label htmlFor="lmstudio-key" className="text-sm">API Key (optional)</Label>
                                <Input id="lmstudio-key" type="password" placeholder="lm-studio" value={lmstudioApiKey} onChange={(e) => setLmstudioApiKey(e.target.value)} onBlur={() => {
                                  const v = lmstudioApiKey.trim();
                                  persist('lmstudio-api-key', v);
                                  setPendingTestProvider('lmstudio');
                                }} />
                              </div>
                              <ConnectionNote status={providerStatus.lmstudio} />
                              <p className="text-xs text-slate-500">Uterpi AI runs locally via LM Studio. This is the default and recommended setup.</p>
                            </div>
                          )}
                          {provider.id === 'uterpi' && (
                            <p className="text-sm text-slate-500">Managed Uterpi endpoint. Credentials are provided by the app environment.</p>
                          )}
                        </div>
                      )}
                    </div>
                  </CardContent>
                </Card>
              );
            })}
          </div>
          
          <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-900 rounded-lg">
            <h4 className="font-medium mb-2">Current Selection</h4>
            <p className="text-sm text-gray-600 dark:text-gray-400">
              You are currently using <strong>{providers.find(p => p.id === currentProvider)?.name}</strong>. 
              {currentProvider === 'lmstudio' 
                ? ' Uterpi via LM Studio is recommended and ready to use.' 
                : currentProvider === 'azure' ? ' Azure AI is pre-configured and ready to use.' : ' If required, configure credentials above.'}
            </p>
          </div>
        </CardContent>
      </Card>
    </>
  );
};

export default AIProviderSelector;

================
File: client/src/components/AIProviderSettings.tsx
================
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';
import { Alert, AlertDescription } from './ui/alert';
import { Badge } from './ui/badge';
import { Eye, EyeOff, CheckCircle, XCircle, Key, Settings } from 'lucide-react';
import { OpenAIService } from '../lib/openAI';
import { GeminiService } from '../lib/gemini';

interface APIKeyStatus {
  configured: boolean;
  valid?: boolean;
  error?: string;
}

const AIProviderSettings: React.FC = () => {
  // OpenAI state
  const [openaiKey, setOpenaiKey] = useState('');
  const [showOpenaiKey, setShowOpenaiKey] = useState(false);
  const [openaiStatus, setOpenaiStatus] = useState<APIKeyStatus>({ configured: false });
  const [testingOpenai, setTestingOpenai] = useState(false);

  // Gemini state
  const [geminiKey, setGeminiKey] = useState('');
  const [showGeminiKey, setShowGeminiKey] = useState(false);
  const [geminiStatus, setGeminiStatus] = useState<APIKeyStatus>({ configured: false });
  const [testingGemini, setTestingGemini] = useState(false);

  // Load saved API keys on mount
  useEffect(() => {
    const savedOpenaiKey = localStorage.getItem('openai-api-key');
    const savedGeminiKey = localStorage.getItem('gemini-api-key');

    if (savedOpenaiKey) {
      setOpenaiKey(savedOpenaiKey);
      setOpenaiStatus({ configured: true });
    }

    if (savedGeminiKey) {
      setGeminiKey(savedGeminiKey);
      setGeminiStatus({ configured: true });
    }
  }, []);

  // Save OpenAI API key
  const saveOpenaiKey = () => {
    if (openaiKey.trim()) {
      localStorage.setItem('openai-api-key', openaiKey.trim());
      setOpenaiStatus({ configured: true });
    } else {
      localStorage.removeItem('openai-api-key');
      setOpenaiStatus({ configured: false });
    }
  };

  // Save Gemini API key
  const saveGeminiKey = () => {
    if (geminiKey.trim()) {
      localStorage.setItem('gemini-api-key', geminiKey.trim());
      setGeminiStatus({ configured: true });
    } else {
      localStorage.removeItem('gemini-api-key');
      setGeminiStatus({ configured: false });
    }
  };

  // Test OpenAI connection
  const testOpenaiConnection = async () => {
    if (!openaiKey.trim()) {
      setOpenaiStatus({ configured: false, error: 'API key is required' });
      return;
    }

    setTestingOpenai(true);
    try {
      const service = new OpenAIService({ apiKey: openaiKey.trim(), modelName: 'gpt-4o-mini' });
      
      // Test with a simple message
      await service.sendChatCompletion([
        { role: 'system', content: 'You are a helpful assistant.' },
        { role: 'user', content: 'Say "hello" if you can read this.' }
      ], { maxTokens: 100 }); // Increased for Gemini compatibility

      setOpenaiStatus({ configured: true, valid: true });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      setOpenaiStatus({ configured: true, valid: false, error: errorMessage });
    } finally {
      setTestingOpenai(false);
    }
  };

  // Test Gemini connection
  const testGeminiConnection = async () => {
    if (!geminiKey.trim()) {
      setGeminiStatus({ configured: false, error: 'API key is required' });
      return;
    }

    setTestingGemini(true);
    try {
      const service = new GeminiService({ apiKey: geminiKey.trim(), modelName: 'gemini-2.5-flash' });
      
      // Test with a simple message
      await service.sendChatCompletion([
        { role: 'system', content: 'You are a helpful assistant.' },
        { role: 'user', content: 'Say "hello" if you can read this.' }
      ], { maxTokens: 100 }); // Increased for Gemini compatibility

      setGeminiStatus({ configured: true, valid: true });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      setGeminiStatus({ configured: true, valid: false, error: errorMessage });
    } finally {
      setTestingGemini(false);
    }
  };

  // Clear OpenAI settings
  const clearOpenaiSettings = () => {
    setOpenaiKey('');
    localStorage.removeItem('openai-api-key');
    setOpenaiStatus({ configured: false });
  };

  // Clear Gemini settings
  const clearGeminiSettings = () => {
    setGeminiKey('');
    localStorage.removeItem('gemini-api-key');
    setGeminiStatus({ configured: false });
  };

  const StatusBadge: React.FC<{ status: APIKeyStatus }> = ({ status }) => {
    if (!status.configured) {
      return <Badge variant="outline">Not Configured</Badge>;
    }
    if (status.valid === true) {
      return <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 mr-1" />Valid</Badge>;
    }
    if (status.valid === false) {
      return <Badge variant="destructive"><XCircle className="w-3 h-3 mr-1" />Invalid</Badge>;
    }
    return <Badge variant="secondary">Configured</Badge>;
  };

  return (
    <Card className="w-full max-w-4xl mx-auto">
      <CardHeader>
        <div className="flex items-center gap-2">
          <Settings className="w-5 h-5" />
          <CardTitle>AI Provider Settings</CardTitle>
        </div>
        <CardDescription>
          Configure your API keys for OpenAI and Gemini providers. These keys are stored securely in your browser's local storage.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="openai" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="openai" className="flex items-center gap-2">
              <Key className="w-4 h-4" />
              OpenAI
              <StatusBadge status={openaiStatus} />
            </TabsTrigger>
            <TabsTrigger value="gemini" className="flex items-center gap-2">
              <Key className="w-4 h-4" />
              Gemini
              <StatusBadge status={geminiStatus} />
            </TabsTrigger>
          </TabsList>

          <TabsContent value="openai" className="space-y-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="openai-key">OpenAI API Key</Label>
                <div className="flex gap-2">
                  <div className="relative flex-1">
                    <Input
                      id="openai-key"
                      type={showOpenaiKey ? 'text' : 'password'}
                      placeholder="sk-..."
                      value={openaiKey}
                      onChange={(e) => setOpenaiKey(e.target.value)}
                      className="pr-10"
                    />
                    <Button
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3"
                      onClick={() => setShowOpenaiKey(!showOpenaiKey)}
                    >
                      {showOpenaiKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                    </Button>
                  </div>
                  <Button onClick={saveOpenaiKey} disabled={!openaiKey.trim()}>
                    Save
                  </Button>
                </div>
                <p className="text-sm text-muted-foreground">
                  Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">OpenAI Platform</a>
                </p>
              </div>

              {openaiStatus.configured && (
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <Button 
                      variant="outline" 
                      onClick={testOpenaiConnection}
                      disabled={testingOpenai || !openaiKey.trim()}
                    >
                      {testingOpenai ? 'Testing...' : 'Test Connection'}
                    </Button>
                    <Button 
                      variant="destructive" 
                      onClick={clearOpenaiSettings}
                    >
                      Clear Settings
                    </Button>
                  </div>

                  {openaiStatus.error && (
                    <Alert variant="destructive">
                      <XCircle className="h-4 w-4" />
                      <AlertDescription>{openaiStatus.error}</AlertDescription>
                    </Alert>
                  )}

                  {openaiStatus.valid === true && (
                    <Alert className="border-green-200 bg-green-50">
                      <CheckCircle className="h-4 w-4 text-green-600" />
                      <AlertDescription className="text-green-800">
                        OpenAI connection successful! You can now use OpenAI models.
                      </AlertDescription>
                    </Alert>
                  )}
                </div>
              )}
            </div>
          </TabsContent>

          <TabsContent value="gemini" className="space-y-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="gemini-key">Gemini API Key</Label>
                <div className="flex gap-2">
                  <div className="relative flex-1">
                    <Input
                      id="gemini-key"
                      type={showGeminiKey ? 'text' : 'password'}
                      placeholder="AI..."
                      value={geminiKey}
                      onChange={(e) => setGeminiKey(e.target.value)}
                      className="pr-10"
                    />
                    <Button
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3"
                      onClick={() => setShowGeminiKey(!showGeminiKey)}
                    >
                      {showGeminiKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                    </Button>
                  </div>
                  <Button onClick={saveGeminiKey} disabled={!geminiKey.trim()}>
                    Save
                  </Button>
                </div>
                <p className="text-sm text-muted-foreground">
                  Get your API key from <a href="https://ai.google.dev/" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">Google AI Studio</a>
                </p>
              </div>

              {geminiStatus.configured && (
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <Button 
                      variant="outline" 
                      onClick={testGeminiConnection}
                      disabled={testingGemini || !geminiKey.trim()}
                    >
                      {testingGemini ? 'Testing...' : 'Test Connection'}
                    </Button>
                    <Button 
                      variant="destructive" 
                      onClick={clearGeminiSettings}
                    >
                      Clear Settings
                    </Button>
                  </div>

                  {geminiStatus.error && (
                    <Alert variant="destructive">
                      <XCircle className="h-4 w-4" />
                      <AlertDescription>{geminiStatus.error}</AlertDescription>
                    </Alert>
                  )}

                  {geminiStatus.valid === true && (
                    <Alert className="border-green-200 bg-green-50">
                      <CheckCircle className="h-4 w-4 text-green-600" />
                      <AlertDescription className="text-green-800">
                        Gemini connection successful! You can now use Gemini models.
                      </AlertDescription>
                    </Alert>
                  )}
                </div>
              )}
            </div>
          </TabsContent>
        </Tabs>

        <div className="mt-6 p-4 bg-gray-50 rounded-lg">
          <h4 className="font-medium mb-2">Security Note</h4>
          <p className="text-sm text-gray-600">
            Your API keys are stored locally in your browser and never sent to our servers. 
            They are only used to make direct requests to OpenAI and Google's APIs from your browser.
          </p>
        </div>
      </CardContent>
    </Card>
  );
};

export default AIProviderSettings;

================
File: client/src/components/AnalyzeModal.tsx
================
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Brain, 
  X, 
  BarChart3, 
  Target, 
  Shield, 
  Clock, 
  Gauge,
  TrendingUp,
  AlertTriangle,
  CheckCircle,
  Package,
  Zap
} from 'lucide-react';

interface AnalyzeModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface PerformanceAnalysis {
  loadTime: number;
  bundleSize: number;
  renderTime: number;
}

interface Pattern {
  name: string;
  usage: string;
  recommendation: string;
}

interface AntiPattern {
  name: string;
  instances: number;
  severity: 'low' | 'medium' | 'high';
}

interface AnalysisResult {
  performance: PerformanceAnalysis;
  suggestions: string[];
  codeSmells: number;
  securityIssues: number;
}

interface DesignPatternsResult {
  detected: Pattern[];
  antiPatterns: AntiPattern[];
}

const AnalyzeModal: React.FC<AnalyzeModalProps> = ({ isOpen, onClose }) => {
  const [analysisType, setAnalysisType] = useState<'performance' | 'patterns'>('performance');
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [performanceResult, setPerformanceResult] = useState<AnalysisResult | null>(null);
  const [patternsResult, setPatternsResult] = useState<DesignPatternsResult | null>(null);

  const analyzePerformance = async () => {
    setIsAnalyzing(true);

    try {
      const response = await fetch('/api/analyze/performance', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          projectPath: '.',
          metrics: ['loadTime', 'bundleSize', 'renderTime']
        }),
      });

      if (response.ok) {
        const result = await response.json();
        setPerformanceResult(result.analysis);
      } else {
        throw new Error('Performance analysis failed');
      }
    } catch (error) {
      console.error('Performance analysis error:', error);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const analyzePatterns = async () => {
    setIsAnalyzing(true);

    try {
      const response = await fetch('/api/analyze/design-patterns', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          codebase: '.'
        }),
      });

      if (response.ok) {
        const result = await response.json();
        setPatternsResult(result.patterns);
      } else {
        throw new Error('Pattern analysis failed');
      }
    } catch (error) {
      console.error('Pattern analysis error:', error);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const resetModal = () => {
    setAnalysisType('performance');
    setIsAnalyzing(false);
    setPerformanceResult(null);
    setPatternsResult(null);
  };

  const handleClose = () => {
    resetModal();
    onClose();
  };

  const getPerformanceScore = (value: number, type: 'time' | 'size') => {
    if (type === 'time') {
      if (value < 1) return { score: 'excellent', color: 'text-green-400', bg: 'bg-green-500/20' };
      if (value < 2) return { score: 'good', color: 'text-yellow-400', bg: 'bg-yellow-500/20' };
      return { score: 'needs improvement', color: 'text-red-400', bg: 'bg-red-500/20' };
    } else {
      if (value < 200) return { score: 'excellent', color: 'text-green-400', bg: 'bg-green-500/20' };
      if (value < 400) return { score: 'good', color: 'text-yellow-400', bg: 'bg-yellow-500/20' };
      return { score: 'needs improvement', color: 'text-red-400', bg: 'bg-red-500/20' };
    }
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'high': return 'text-red-400 bg-red-500/20';
      case 'medium': return 'text-yellow-400 bg-yellow-500/20';
      case 'low': return 'text-green-400 bg-green-500/20';
      default: return 'text-slate-400 bg-slate-500/20';
    }
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        {/* Backdrop */}
        <motion.div
          className="absolute inset-0 bg-black/60 backdrop-blur-sm"
          onClick={handleClose}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        />

        {/* Modal */}
        <motion.div
          className="relative w-full max-w-5xl max-h-[90vh] mx-4 bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-slate-700/50 overflow-hidden"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          transition={{ type: "spring", duration: 0.5 }}
        >
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-slate-700/50">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-purple-500/20 rounded-lg">
                <Brain className="w-6 h-6 text-purple-400" />
              </div>
              <div>
                <h2 className="text-xl font-semibold text-white">Uterpi System Performance & Status</h2>
                <p className="text-sm text-slate-400">Analysis of performance, system architecture, & current status</p>
              </div>
            </div>
            <button
              onClick={handleClose}
              className="p-2 hover:bg-slate-700/50 rounded-lg transition-colors"
              title="Close modal"
              aria-label="Close Analyze modal"
            >
              <X className="w-5 h-5 text-slate-400" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6 overflow-y-auto max-h-[calc(90vh-80px)]">
            {/* Analysis Type Selection */}
            <div className="flex justify-center gap-2 mb-8">
              <button
                onClick={() => setAnalysisType('performance')}
                className={`px-6 py-3 rounded-lg transition-all flex items-center gap-2 ${
                  analysisType === 'performance'
                    ? 'bg-purple-500/20 text-purple-400 border border-purple-400/50'
                    : 'text-slate-400 hover:text-white border border-slate-600'
                }`}
              >
                <BarChart3 className="w-4 h-4" />
                Performance Analysis
              </button>
              <button
                onClick={() => setAnalysisType('patterns')}
                className={`px-6 py-3 rounded-lg transition-all flex items-center gap-2 ${
                  analysisType === 'patterns'
                    ? 'bg-purple-500/20 text-purple-400 border border-purple-400/50'
                    : 'text-slate-400 hover:text-white border border-slate-600'
                }`}
              >
                <Target className="w-4 h-4" />
                System Status & Architecture
              </button>
            </div>

            {analysisType === 'performance' && (
              <div className="space-y-6">
                {!performanceResult && !isAnalyzing && (
                  <div className="text-center space-y-6">
                    <div className="p-8 bg-slate-800/50 rounded-xl border border-slate-700/50">
                      <BarChart3 className="w-16 h-16 text-purple-400 mx-auto mb-4" />
                      <h3 className="text-lg font-semibold text-white mb-2">Performance Analysis</h3>
                      <p className="text-slate-400 mb-6">
                        Analyze Uterpi performance metrics including load time, bundle size, and render performance.
                      </p>
                      <motion.button
                        onClick={analyzePerformance}
                        className="px-8 py-3 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 rounded-lg text-white font-medium flex items-center gap-2 mx-auto transition-all"
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                      >
                        <Gauge className="w-4 h-4" />
                        Start Performance Analysis
                      </motion.button>
                    </div>
                  </div>
                )}

                {isAnalyzing && (
                  <div className="flex flex-col items-center justify-center py-12 space-y-6">
                    <div className="relative">
                      <motion.div
                        className="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full"
                        animate={{ rotate: 360 }}
                        transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                      />
                      <motion.div
                        className="absolute inset-2 bg-purple-500/20 rounded-full flex items-center justify-center"
                        animate={{ scale: [1, 1.1, 1] }}
                        transition={{ duration: 2, repeat: Infinity }}
                      >
                        <BarChart3 className="w-6 h-6 text-purple-400" />
                      </motion.div>
                    </div>
                    <div className="text-center">
                      <h3 className="text-xl font-semibold text-white mb-2">Analyzing Performance</h3>
                      <p className="text-slate-400">Measuring load times, bundle sizes, and rendering performance...</p>
                    </div>
                  </div>
                )}

                {performanceResult && (
                  <div className="space-y-6">
                    <div className="text-center">
                      <h3 className="text-lg font-semibold text-white mb-2">Performance Analysis Results</h3>
                      <p className="text-slate-400">Key metrics and optimization suggestions</p>
                    </div>

                    <div className="grid md:grid-cols-3 gap-4">
                      {/* Load Time */}
                      <div className="p-6 bg-slate-800/50 rounded-xl border border-slate-700/50">
                        <div className="flex items-center gap-3 mb-4">
                          <Clock className="w-6 h-6 text-blue-400" />
                          <h4 className="font-semibold text-white">Load Time</h4>
                        </div>
                        <div className="text-3xl font-bold text-white mb-2">
                          {performanceResult.performance.loadTime.toFixed(2)}s
                        </div>
                        <div className={`px-2 py-1 rounded-full text-xs font-medium ${
                          getPerformanceScore(performanceResult.performance.loadTime, 'time').bg
                        } ${getPerformanceScore(performanceResult.performance.loadTime, 'time').color}`}>
                          {getPerformanceScore(performanceResult.performance.loadTime, 'time').score}
                        </div>
                      </div>

                      {/* Bundle Size */}
                      <div className="p-6 bg-slate-800/50 rounded-xl border border-slate-700/50">
                        <div className="flex items-center gap-3 mb-4">
                          <Package className="w-6 h-6 text-green-400" />
                          <h4 className="font-semibold text-white">Bundle Size</h4>
                        </div>
                        <div className="text-3xl font-bold text-white mb-2">
                          {Math.round(performanceResult.performance.bundleSize)}KB
                        </div>
                        <div className={`px-2 py-1 rounded-full text-xs font-medium ${
                          getPerformanceScore(performanceResult.performance.bundleSize, 'size').bg
                        } ${getPerformanceScore(performanceResult.performance.bundleSize, 'size').color}`}>
                          {getPerformanceScore(performanceResult.performance.bundleSize, 'size').score}
                        </div>
                      </div>

                      {/* Render Time */}
                      <div className="p-6 bg-slate-800/50 rounded-xl border border-slate-700/50">
                        <div className="flex items-center gap-3 mb-4">
                          <Zap className="w-6 h-6 text-yellow-400" />
                          <h4 className="font-semibold text-white">Render Time</h4>
                        </div>
                        <div className="text-3xl font-bold text-white mb-2">
                          {Math.round(performanceResult.performance.renderTime)}ms
                        </div>
                        <div className={`px-2 py-1 rounded-full text-xs font-medium ${
                          getPerformanceScore(performanceResult.performance.renderTime / 100, 'time').bg
                        } ${getPerformanceScore(performanceResult.performance.renderTime / 100, 'time').color}`}>
                          {getPerformanceScore(performanceResult.performance.renderTime / 100, 'time').score}
                        </div>
                      </div>
                    </div>

                    <div className="grid md:grid-cols-2 gap-6">
                      {/* Suggestions */}
                      <div className="space-y-4">
                        <h4 className="text-white font-medium flex items-center gap-2">
                          <TrendingUp className="w-5 h-5 text-purple-400" />
                          Optimization Suggestions
                        </h4>
                        <div className="space-y-2">
                          {performanceResult.suggestions.map((suggestion, index) => (
                            <div key={index} className="p-3 bg-slate-800/50 rounded-lg border border-slate-700/50">
                              <div className="flex items-start gap-2">
                                <CheckCircle className="w-4 h-4 text-green-400 mt-0.5 flex-shrink-0" />
                                <span className="text-sm text-slate-300">{suggestion}</span>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* Issues Summary */}
                      <div className="space-y-4">
                        <h4 className="text-white font-medium flex items-center gap-2">
                          <AlertTriangle className="w-5 h-5 text-purple-400" />
                          Issues Summary
                        </h4>
                        <div className="space-y-3">
                          <div className="flex items-center justify-between p-3 bg-slate-800/50 rounded-lg">
                            <div className="flex items-center gap-2">
                              <div className="w-3 h-3 bg-yellow-400 rounded-full"></div>
                              <span className="text-white">Code Smells</span>
                            </div>
                            <span className="text-yellow-400 font-medium">{performanceResult.codeSmells}</span>
                          </div>
                          <div className="flex items-center justify-between p-3 bg-slate-800/50 rounded-lg">
                            <div className="flex items-center gap-2">
                              <Shield className="w-4 h-4 text-red-400" />
                              <span className="text-white">Security Issues</span>
                            </div>
                            <span className="text-red-400 font-medium">{performanceResult.securityIssues}</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {analysisType === 'patterns' && (
              <div className="space-y-6">
                {!patternsResult && !isAnalyzing && (
                  <div className="text-center space-y-6">
                    <div className="p-8 bg-slate-800/50 rounded-xl border border-slate-700/50">
                      <Target className="w-16 h-16 text-purple-400 mx-auto mb-4" />
                      <h3 className="text-lg font-semibold text-white mb-2">Uterpi System Status</h3>
                      <p className="text-slate-400 mb-6">
                        Run for a full system status report.
                      </p>
                      <motion.button
                        onClick={analyzePatterns}
                        className="px-8 py-3 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 rounded-lg text-white font-medium flex items-center gap-2 mx-auto transition-all"
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                      >
                        <Target className="w-4 h-4" />
                        Start System Status Analysis
                      </motion.button>
                    </div>
                  </div>
                )}

                {isAnalyzing && (
                  <div className="flex flex-col items-center justify-center py-12 space-y-6">
                    <div className="relative">
                      <motion.div
                        className="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full"
                        animate={{ rotate: 360 }}
                        transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                      />
                      <motion.div
                        className="absolute inset-2 bg-purple-500/20 rounded-full flex items-center justify-center"
                        animate={{ scale: [1, 1.1, 1] }}
                        transition={{ duration: 2, repeat: Infinity }}
                      >
                        <Target className="w-6 h-6 text-purple-400" />
                      </motion.div>
                    </div>
                    <div className="text-center">
                      <h3 className="text-xl font-semibold text-white mb-2">Analyzing System Architecture</h3>
                      <p className="text-slate-400">Scanning code for patterns, anti-patterns, and architecture...</p>
                    </div>
                  </div>
                )}

                {patternsResult && (
                  <div className="space-y-6">
                    <div className="text-center">
                      <h3 className="text-lg font-semibold text-white mb-2">Analyzing System Architecture</h3>
                      <p className="text-slate-400">Scanning code for patterns, anti-patterns, and architecture...</p>
                    </div>

                    <div className="grid md:grid-cols-2 gap-6">
                      {/* Detected Patterns */}
                      <div className="space-y-4">
                        <h4 className="text-white font-medium flex items-center gap-2">
                          <CheckCircle className="w-5 h-5 text-green-400" />
                          System Architecture
                        </h4>
                        <div className="space-y-3">
                          {patternsResult.detected.map((pattern, index) => (
                            <div key={index} className="p-4 bg-slate-800/50 rounded-lg border border-slate-700/50">
                              <div className="flex items-center justify-between mb-2">
                                <h5 className="font-medium text-white">{pattern.name}</h5>
                                <span className="text-green-400 font-medium">{pattern.usage}</span>
                              </div>
                              <p className="text-sm text-slate-400">{pattern.recommendation}</p>
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* Anti-Patterns */}
                      <div className="space-y-4">
                        <h4 className="text-white font-medium flex items-center gap-2">
                          <AlertTriangle className="w-5 h-5 text-red-400" />
                          Anti-Patterns Found
                        </h4>
                        <div className="space-y-3">
                          {patternsResult.antiPatterns.map((antiPattern, index) => (
                            <div key={index} className="p-4 bg-slate-800/50 rounded-lg border border-slate-700/50">
                              <div className="flex items-center justify-between mb-2">
                                <h5 className="font-medium text-white">{antiPattern.name}</h5>
                                <div className="flex items-center gap-2">
                                  <span className="text-slate-400">{antiPattern.instances} instances</span>
                                  <span className={`px-2 py-1 rounded-full text-xs font-medium ${getSeverityColor(antiPattern.severity)}`}>
                                    {antiPattern.severity}
                                  </span>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Action Buttons */}
            {(performanceResult || patternsResult) && (
              <div className="flex justify-center gap-3 pt-6">
                <button
                  onClick={resetModal}
                  className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                >
                  Run Another Analysis
                </button>
                <motion.button
                  onClick={handleClose}
                  className="px-8 py-3 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 rounded-lg text-white font-medium transition-all"
                  whileHover={{ scale: 1.02 }}
                  whileTap={{ scale: 0.98 }}
                >
                  Done
                </motion.button>
              </div>
            )}
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default AnalyzeModal;

================
File: client/src/components/auth/ForgotPasswordForm.tsx
================
import React, { useState } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card';
import { Alert, AlertDescription } from '../ui/alert';
import { Mail, ArrowLeft, Loader2 } from 'lucide-react';

interface ForgotPasswordFormProps {
  onBackToLogin: () => void;
}

export function ForgotPasswordForm({ onBackToLogin }: ForgotPasswordFormProps) {
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/forgot-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to send reset email');
      }

      setIsSubmitted(true);
    } catch (error: any) {
      console.error('Forgot password error:', error);
      setError(error.message || 'Failed to send reset email. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  if (isSubmitted) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-green-100">
            <Mail className="h-8 w-8 text-green-600" />
          </div>
          <CardTitle>Check Your Email</CardTitle>
          <CardDescription>
            We've sent a password reset link to your email address.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <Alert>
            <Mail className="h-4 w-4" />
            <AlertDescription>
              If an account with <strong>{email}</strong> exists, you'll receive a password reset link within a few minutes.
            </AlertDescription>
          </Alert>
          
          <div className="text-center text-sm text-muted-foreground">
            <p>Don't see the email? Check your spam folder.</p>
            <p>The reset link will expire in 1 hour.</p>
          </div>

          <div className="space-y-2">
            <Button
              variant="outline"
              className="w-full"
              onClick={() => {
                setIsSubmitted(false);
                setEmail('');
              }}
            >
              Send Another Email
            </Button>
            <Button
              variant="ghost"
              className="w-full"
              onClick={onBackToLogin}
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Back to Login
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="text-center">
        <CardTitle>Forgot Password?</CardTitle>
        <CardDescription>
          Enter your email address and we'll send you a link to reset your password.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div className="space-y-2">
            <Label htmlFor="email">Email Address</Label>
            <Input
              id="email"
              name="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email address"
              required
              disabled={isLoading}
              className="w-full"
            />
          </div>

          <Button 
            type="submit" 
            className="w-full" 
            disabled={isLoading || !email.trim()}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Sending Reset Link...
              </>
            ) : (
              <>
                <Mail className="mr-2 h-4 w-4" />
                Send Reset Link
              </>
            )}
          </Button>

          <Button
            type="button"
            variant="ghost"
            className="w-full"
            onClick={onBackToLogin}
            disabled={isLoading}
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to Login
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

================
File: client/src/components/auth/LoginForm.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from "framer-motion";
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Alert, AlertDescription } from '../ui/alert';
import { Loader2, Lock, Mail, Eye, EyeOff, CheckCircle } from 'lucide-react';
import { useAuth } from '../../hooks/useAuth';
import { toast } from 'sonner';

interface LoginFormProps {
  onSwitchToRegister?: () => void;
  onForgotPassword?: () => void;
  onSuccess?: () => void;
}

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 100,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "#8B5CF6",
  vx = 0,
  vy = 0,
}) => {
  const [particleColor, setParticleColor] = useState<string>(color);

  interface MousePosition {
    x: number;
    y: number;
  }

  const MousePosition = (): MousePosition => {
    const [mousePosition, setMousePosition] = useState<MousePosition>({
      x: 0,
      y: 0,
    });

    useEffect(() => {
      const handleMouseMove = (event: MouseEvent) => {
        setMousePosition({ x: event.clientX, y: event.clientY });
      };

      window.addEventListener("mousemove", handleMouseMove);

      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
      };
    }, []);

    return mousePosition;
  };

  const hexToRgb = (hex: string): number[] => {
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mousePosition = MousePosition();
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.1;
    const dy = (Math.random() - 0.5) * 0.1;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const rgb = hexToRgb(particleColor);

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${rgb.join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(
        0,
        0,
        canvasSize.current.w,
        canvasSize.current.h,
      );
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const remapValue = (
    value: number,
    start1: number,
    end1: number,
    start2: number,
    end2: number,
  ): number => {
    const remapped =
      ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;
    return remapped > 0 ? remapped : 0;
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      const edge = [
        circle.x + circle.translateX - circle.size,
        canvasSize.current.w - circle.x - circle.translateX - circle.size,
        circle.y + circle.translateY - circle.size,
        canvasSize.current.h - circle.y - circle.translateY - circle.size,
      ];
      const closestEdge = edge.reduce((a, b) => Math.min(a, b));
      const remapClosestEdge = parseFloat(
        remapValue(closestEdge, 0, 20, 0, 1).toFixed(2),
      );
      if (remapClosestEdge > 1) {
        circle.alpha += 0.02;
        if (circle.alpha > circle.targetAlpha) {
          circle.alpha = circle.targetAlpha;
        }
      } else {
        circle.alpha = circle.targetAlpha * remapClosestEdge;
      }
      circle.x += circle.dx + vx;
      circle.y += circle.dy + vy;
      circle.translateX +=
        (mouse.current.x / (staticity / circle.magnetism) - circle.translateX) /
        ease;
      circle.translateY +=
        (mouse.current.y / (staticity / circle.magnetism) - circle.translateY) /
        ease;

      drawCircle(circle, true);

      if (
        circle.x < -circle.size ||
        circle.x > canvasSize.current.w + circle.size ||
        circle.y < -circle.size ||
        circle.y > canvasSize.current.h + circle.size
      ) {
        circles.current.splice(i, 1);
        const newCircle = circleParams();
        drawCircle(newCircle);
      }
    });
    window.requestAnimationFrame(animate);
  };

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const onMouseMove = () => {
    if (canvasRef.current) {
      const rect = canvasRef.current.getBoundingClientRect();
      const { w, h } = canvasSize.current;
      const x = mousePosition.x - rect.left - w / 2;
      const y = mousePosition.y - rect.top - h / 2;
      const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;
      if (inside) {
        mouse.current.x = x;
        mouse.current.y = y;
      }
    }
  };

  useEffect(() => {
    if (canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
    }
    initCanvas();
    animate();
    window.addEventListener("resize", initCanvas);

    return () => {
      window.removeEventListener("resize", initCanvas);
    };
  }, [particleColor]);

  useEffect(() => {
    onMouseMove();
  }, [mousePosition.x, mousePosition.y]);

  useEffect(() => {
    initCanvas();
  }, [refresh]);

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  );
};

const CircuitPattern: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    className={className}
    viewBox="0 0 100 100"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M10 10h20v20h20v-20h20v40h-20v20h-40z"
      stroke="currentColor"
      strokeWidth="0.5"
      fill="none"
      opacity="0.1"
    />
    <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
    <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
  </svg>
);

const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-8 rounded-2xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/10 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 3,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

const RippleButton: React.FC<{
  children: React.ReactNode;
  onClick?: () => void;
  className?: string;
  disabled?: boolean;
  type?: "button" | "submit";
}> = ({ children, onClick, className, disabled = false, type = "button" }) => {
  const [ripples, setRipples] = useState<Array<{ id: number; x: number; y: number }>>([]);

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    if (disabled) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const newRipple = { id: Date.now(), x, y };
    setRipples(prev => [...prev, newRipple]);
    
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);
    
    if (onClick && typeof onClick === 'function') {
      try {
        onClick();
      } catch (error) {
        console.error('Error in onClick handler:', error);
      }
    }
  };

  return (
    <button
      type={type}
      onClick={handleClick}
      disabled={disabled}
      className={`
        relative overflow-hidden transition-all duration-200
        ${disabled ? "opacity-50 cursor-not-allowed" : "hover:scale-105 active:scale-95"}
        ${className}
      `}
    >
      {children}
      {ripples.map(ripple => (
        <motion.span
          key={ripple.id}
          className="absolute bg-white/30 rounded-full pointer-events-none"
          style={{
            left: ripple.x - 10,
            top: ripple.y - 10,
            width: 20,
            height: 20,
          }}
          initial={{ scale: 0, opacity: 1 }}
          animate={{ scale: 4, opacity: 0 }}
          transition={{ duration: 0.6, ease: "easeOut" }}
        />
      ))}
    </button>
  );
};

export const LoginForm: React.FC<LoginFormProps> = ({ onSwitchToRegister, onForgotPassword, onSuccess }) => {
  const { login, loginWithGoogle, loading } = useAuth();
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    // Clear error when user starts typing
    if (error) setError('');
  };

  // Test toast functionality (for debugging)
  const testToast = () => {
    toast.success('Test notification', {
      description: 'This is a test to verify toast functionality.',
      duration: 3000,
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isSubmitting || loading) return;

    setError('');
    setIsSubmitting(true);

    try {
      await login(formData.email, formData.password);
      
      // Set success state for visual feedback
      setIsSuccess(true);
      
      // Show success toast
      toast.success('Welcome back!', {
        description: 'You have successfully signed in.',
        duration: 2000,
      });
      
      // Brief delay to show success message before redirect
      setTimeout(() => {
        onSuccess?.();
      }, 1500);
    } catch (err: any) {
      const errorMessage = err.message || 'Login failed';
      setError(errorMessage);
      
      // Show error toast for better visibility
      toast.error('Sign In Failed', {
        description: errorMessage,
        duration: 4000,
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleGoogleLogin = () => {
    if (isSubmitting || loading) return;
    loginWithGoogle();
  };

  return (
    <HolographicBubble>
          {/* Header */}
          <div className="text-center mb-8">
            <div className="flex items-center justify-center mb-4">
              <div className="relative">
                <img 
                  src="/images/uterpi_logo.png" 
                  alt="Uterpi Logo" 
                  className="w-72 h-72 rounded-full"
                />
                <motion.div
                  className="absolute inset-0 bg-violet-400/20 rounded-full blur-lg"
                  animate={{ scale: [1, 1.2, 1] }}
                  transition={{ duration: 2, repeat: Infinity }}
                />
              </div>
            </div>
            <h1 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-purple-400 bg-clip-text text-transparent mb-2">
              Welcome Back
            </h1>
            <p className="text-slate-300">
              Sign in to continue
            </p>
            {/* Temporary test button for debugging */}
            <button 
              type="button" 
              onClick={testToast}
              className="text-xs text-violet-400 hover:text-violet-300 underline mt-2"
            >
              Test Notification
            </button>
          </div>
          
          <form onSubmit={handleSubmit} className="space-y-6">
            {error && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: "auto" }}
                className="p-4 bg-red-900/20 backdrop-blur-xl rounded-xl border border-red-500/30"
              >
                <AlertDescription className="text-red-200">{error}</AlertDescription>
              </motion.div>
            )}
            
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email" className="text-slate-300 text-sm font-medium">
                  Email Address
                </Label>
                <div className="relative">
                  <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="email"
                    name="email"
                    type="email"
                    placeholder="Enter your email"
                    value={formData.email}
                    onChange={handleChange}
                    required
                    disabled={isSubmitting || loading}
                    className="pl-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="password" className="text-slate-300 text-sm font-medium">
                  Password
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="password"
                    name="password"
                    type={showPassword ? "text" : "password"}
                    placeholder="Enter your password"
                    value={formData.password}
                    onChange={handleChange}
                    required
                    disabled={isSubmitting || loading}
                    className="pl-10 pr-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-300"
                  >
                    {showPassword ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                  </button>
                </div>
                {onForgotPassword && (
                  <div className="text-right">
                    <button
                      type="button"
                      onClick={onForgotPassword}
                      className="text-sm text-violet-400 hover:text-violet-300 underline underline-offset-4 transition-colors"
                      disabled={isSubmitting || loading}
                    >
                      Forgot password?
                    </button>
                  </div>
                )}
              </div>
            </div>
            
            <div className="space-y-4">
              <RippleButton
                type="submit"
                disabled={isSubmitting || loading}
                className="w-full py-3 bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 rounded-xl text-white font-medium transition-all duration-200"
              >
                {isSubmitting ? (
                  <div className="flex items-center justify-center gap-2">
                    {isSuccess ? (
                      <>
                        <CheckCircle className="w-4 h-4 text-green-400" />
                        Success! Redirecting...
                      </>
                    ) : (
                      <>
                        <Loader2 className="w-4 h-4 animate-spin" />
                        Signing In...
                      </>
                    )}
                  </div>
                ) : (
                  'Sign In'
                )}
              </RippleButton>
              
              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <span className="w-full border-t border-slate-700" />
                </div>
                <div className="relative flex justify-center text-xs uppercase">
                  <span className="bg-slate-900/50 px-2 text-slate-400">
                    Or continue with
                  </span>
                </div>
              </div>
              
              <RippleButton
                type="button"
                onClick={handleGoogleLogin}
                disabled={isSubmitting || loading}
                className="w-full py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-xl text-white font-medium transition-all duration-200"
              >
                <div className="flex items-center justify-center gap-2">
                  <svg className="w-4 h-4" viewBox="0 0 24 24">
                    <path
                      fill="currentColor"
                      d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                    />
                    <path
                      fill="currentColor"
                      d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                    />
                    <path
                      fill="currentColor"
                      d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                    />
                    <path
                      fill="currentColor"
                      d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                    />
                  </svg>
                  Continue with Google
                </div>
              </RippleButton>
              
              {onSwitchToRegister && (
                <div className="text-center text-sm">
                  <span className="text-slate-400">Don't have an account? </span>
                  <button
                    type="button"
                    onClick={onSwitchToRegister}
                    className="text-violet-400 hover:text-violet-300 underline underline-offset-4 transition-colors"
                    disabled={isSubmitting || loading}
                  >
                    Create account
                  </button>
                </div>
              )}
            </div>
          </form>
        </HolographicBubble>
  );
};

================
File: client/src/components/auth/RegisterForm.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from "framer-motion";
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Alert, AlertDescription } from '../ui/alert';
import { Loader2, Lock, Mail, Eye, EyeOff, User, CheckCircle } from 'lucide-react';
import { useAuth, RegisterData } from '../../hooks/useAuth';
import { toast } from 'sonner';

interface RegisterFormProps {
  onSwitchToLogin?: () => void;
  onSuccess?: () => void;
}

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 100,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "#8B5CF6",
  vx = 0,
  vy = 0,
}) => {
  const [particleColor, setParticleColor] = useState<string>(color);

  interface MousePosition {
    x: number;
    y: number;
  }

  const MousePosition = (): MousePosition => {
    const [mousePosition, setMousePosition] = useState<MousePosition>({
      x: 0,
      y: 0,
    });

    useEffect(() => {
      const handleMouseMove = (event: MouseEvent) => {
        setMousePosition({ x: event.clientX, y: event.clientY });
      };

      window.addEventListener("mousemove", handleMouseMove);

      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
      };
    }, []);

    return mousePosition;
  };

  const hexToRgb = (hex: string): number[] => {
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mousePosition = MousePosition();
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.1;
    const dy = (Math.random() - 0.5) * 0.1;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const rgb = hexToRgb(particleColor);

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${rgb.join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(
        0,
        0,
        canvasSize.current.w,
        canvasSize.current.h,
      );
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const remapValue = (
    value: number,
    start1: number,
    end1: number,
    start2: number,
    end2: number,
  ): number => {
    const remapped =
      ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;
    return remapped > 0 ? remapped : 0;
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      const edge = [
        circle.x + circle.translateX - circle.size,
        canvasSize.current.w - circle.x - circle.translateX - circle.size,
        circle.y + circle.translateY - circle.size,
        canvasSize.current.h - circle.y - circle.translateY - circle.size,
      ];
      const closestEdge = edge.reduce((a, b) => Math.min(a, b));
      const remapClosestEdge = parseFloat(
        remapValue(closestEdge, 0, 20, 0, 1).toFixed(2),
      );
      if (remapClosestEdge > 1) {
        circle.alpha += 0.02;
        if (circle.alpha > circle.targetAlpha) {
          circle.alpha = circle.targetAlpha;
        }
      } else {
        circle.alpha = circle.targetAlpha * remapClosestEdge;
      }
      circle.x += circle.dx + vx;
      circle.y += circle.dy + vy;
      circle.translateX +=
        (mouse.current.x / (staticity / circle.magnetism) - circle.translateX) /
        ease;
      circle.translateY +=
        (mouse.current.y / (staticity / circle.magnetism) - circle.translateY) /
        ease;

      drawCircle(circle, true);

      if (
        circle.x < -circle.size ||
        circle.x > canvasSize.current.w + circle.size ||
        circle.y < -circle.size ||
        circle.y > canvasSize.current.h + circle.size
      ) {
        circles.current.splice(i, 1);
        const newCircle = circleParams();
        drawCircle(newCircle);
      }
    });
    window.requestAnimationFrame(animate);
  };

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const onMouseMove = () => {
    if (canvasRef.current) {
      const rect = canvasRef.current.getBoundingClientRect();
      const { w, h } = canvasSize.current;
      const x = mousePosition.x - rect.left - w / 2;
      const y = mousePosition.y - rect.top - h / 2;
      const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;
      if (inside) {
        mouse.current.x = x;
        mouse.current.y = y;
      }
    }
  };

  useEffect(() => {
    if (canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
    }
    initCanvas();
    animate();
    window.addEventListener("resize", initCanvas);

    return () => {
      window.removeEventListener("resize", initCanvas);
    };
  }, [particleColor]);

  useEffect(() => {
    onMouseMove();
  }, [mousePosition.x, mousePosition.y]);

  useEffect(() => {
    initCanvas();
  }, [refresh]);

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  );
};

const CircuitPattern: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    className={className}
    viewBox="0 0 100 100"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M10 10h20v20h20v-20h20v40h-20v20h-40z"
      stroke="currentColor"
      strokeWidth="0.5"
      fill="none"
      opacity="0.1"
    />
    <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
    <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
  </svg>
);

const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-8 rounded-2xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/10 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 3,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

const RippleButton: React.FC<{
  children: React.ReactNode;
  onClick?: () => void;
  className?: string;
  disabled?: boolean;
  type?: "button" | "submit";
}> = ({ children, onClick, className, disabled = false, type = "button" }) => {
  const [ripples, setRipples] = useState<Array<{ id: number; x: number; y: number }>>([]);

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    if (disabled) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const newRipple = { id: Date.now(), x, y };
    setRipples(prev => [...prev, newRipple]);
    
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);
    
    if (onClick && typeof onClick === 'function') {
      try {
        onClick();
      } catch (error) {
        console.error('Error in onClick handler:', error);
      }
    }
  };

  return (
    <button
      type={type}
      onClick={handleClick}
      disabled={disabled}
      className={`
        relative overflow-hidden transition-all duration-200
        ${disabled ? "opacity-50 cursor-not-allowed" : "hover:scale-105 active:scale-95"}
        ${className}
      `}
    >
      {children}
      {ripples.map(ripple => (
        <motion.span
          key={ripple.id}
          className="absolute bg-white/30 rounded-full pointer-events-none"
          style={{
            left: ripple.x - 10,
            top: ripple.y - 10,
            width: 20,
            height: 20,
          }}
          initial={{ scale: 0, opacity: 1 }}
          animate={{ scale: 4, opacity: 0 }}
          transition={{ duration: 0.6, ease: "easeOut" }}
        />
      ))}
    </button>
  );
};

export const RegisterForm: React.FC<RegisterFormProps> = ({ onSwitchToLogin, onSuccess }) => {
  const { register, loginWithGoogle, loading } = useAuth();
  const [formData, setFormData] = useState<RegisterData>({
    email: '',
    password: '',
    username: '',
    firstName: '',
    lastName: '',
  });
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    if (name === 'confirmPassword') {
      setConfirmPassword(value);
    } else {
      setFormData(prev => ({
        ...prev,
        [name]: value
      }));
    }
    // Clear error when user starts typing
    if (error) setError('');
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isSubmitting || loading) return;

    setError('');

    // Validation
    if (formData.password !== confirmPassword) {
      const errorMessage = 'Passwords do not match';
      setError(errorMessage);
      toast.error('Validation Error', {
        description: errorMessage,
        duration: 3000,
      });
      return;
    }

    if (formData.password.length < 8) {
      const errorMessage = 'Password must be at least 8 characters long';
      setError(errorMessage);
      toast.error('Validation Error', {
        description: errorMessage,
        duration: 3000,
      });
      return;
    }

    setIsSubmitting(true);

    try {
      // Filter out empty optional fields
      const submitData: RegisterData = {
        email: formData.email,
        password: formData.password,
      };

      if (formData.username?.trim()) {
        submitData.username = formData.username.trim();
      }
      if (formData.firstName?.trim()) {
        submitData.firstName = formData.firstName.trim();
      }
      if (formData.lastName?.trim()) {
        submitData.lastName = formData.lastName.trim();
      }

      await register(submitData);
      
      // Set success state for visual feedback
      setIsSuccess(true);
      
      // Show success toast
      toast.success('Welcome to Uterpi!', {
        description: 'Your account has been created successfully.',
        duration: 2000,
      });
      
      // Brief delay to show success message before redirect
      setTimeout(() => {
        onSuccess?.();
      }, 1500);
    } catch (err: any) {
      const errorMessage = err.message || 'Registration failed';
      setError(errorMessage);
      
      // Show error toast for better visibility
      toast.error('Registration Failed', {
        description: errorMessage,
        duration: 4000,
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleGoogleLogin = () => {
    if (isSubmitting || loading) return;
    loginWithGoogle();
  };

  return (
    <HolographicBubble>
          {/* Header */}
          <div className="text-center mb-8">
            <div className="flex items-center justify-center mb-4">
              <div className="relative">
                <img 
                  src="/images/uterpi_logo.png" 
                  alt="Uterpi Logo" 
                  className="w-72 h-72 rounded-full"
                />
                <motion.div
                  className="absolute inset-0 bg-violet-400/20 rounded-full blur-lg"
                  animate={{ scale: [1, 1.2, 1] }}
                  transition={{ duration: 2, repeat: Infinity }}
                />
              </div>
            </div>
            <h1 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-purple-400 bg-clip-text text-transparent mb-2">
              Join the Journey
            </h1>
            <p className="text-slate-300">
              Create your account to start exploring Uterpi!
            </p>
          </div>
          
          <form onSubmit={handleSubmit} className="space-y-6">
            {error && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: "auto" }}
                className="p-4 bg-red-900/20 backdrop-blur-xl rounded-xl border border-red-500/30"
              >
                <AlertDescription className="text-red-200">{error}</AlertDescription>
              </motion.div>
            )}
            
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="firstName" className="text-slate-300 text-sm font-medium">
                    First Name
                  </Label>
                  <div className="relative">
                    <User className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                    <Input
                      id="firstName"
                      name="firstName"
                      type="text"
                      placeholder="John"
                      value={formData.firstName}
                      onChange={handleChange}
                      disabled={isSubmitting || loading}
                      className="pl-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                    />
                  </div>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="lastName" className="text-slate-300 text-sm font-medium">
                    Last Name
                  </Label>
                  <div className="relative">
                    <User className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                    <Input
                      id="lastName"
                      name="lastName"
                      type="text"
                      placeholder="Doe"
                      value={formData.lastName}
                      onChange={handleChange}
                      disabled={isSubmitting || loading}
                      className="pl-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                    />
                  </div>
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="email" className="text-slate-300 text-sm font-medium">
                  Email Address *
                </Label>
                <div className="relative">
                  <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="email"
                    name="email"
                    type="email"
                    placeholder="john@example.com"
                    value={formData.email}
                    onChange={handleChange}
                    required
                    disabled={isSubmitting || loading}
                    className="pl-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="username" className="text-slate-300 text-sm font-medium">
                  Username
                </Label>
                <div className="relative">
                  <User className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="username"
                    name="username"
                    type="text"
                    placeholder="johndoe (optional)"
                    value={formData.username}
                    onChange={handleChange}
                    disabled={isSubmitting || loading}
                    className="pl-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="password" className="text-slate-300 text-sm font-medium">
                  Password *
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="password"
                    name="password"
                    type={showPassword ? "text" : "password"}
                    placeholder="At least 8 characters"
                    value={formData.password}
                    onChange={handleChange}
                    required
                    disabled={isSubmitting || loading}
                    className="pl-10 pr-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-300"
                  >
                    {showPassword ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                  </button>
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="confirmPassword" className="text-slate-300 text-sm font-medium">
                  Confirm Password *
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400" />
                  <Input
                    id="confirmPassword"
                    name="confirmPassword"
                    type={showConfirmPassword ? "text" : "password"}
                    placeholder="Confirm your password"
                    value={confirmPassword}
                    onChange={handleChange}
                    required
                    disabled={isSubmitting || loading}
                    className="pl-10 pr-10 bg-slate-900/50 border-slate-700 text-white placeholder-slate-400 focus:border-violet-500 focus:ring-violet-500/20 rounded-lg"
                  />
                  <button
                    type="button"
                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-300"
                  >
                    {showConfirmPassword ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                  </button>
                </div>
              </div>
            </div>
            
            <div className="space-y-4">
              <RippleButton
                type="submit"
                disabled={isSubmitting || loading}
                className="w-full py-3 bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 rounded-xl text-white font-medium transition-all duration-200"
              >
                {isSubmitting ? (
                  <div className="flex items-center justify-center gap-2">
                    {isSuccess ? (
                      <>
                        <CheckCircle className="w-4 h-4 text-green-400" />
                        Account Created! Redirecting...
                      </>
                    ) : (
                      <>
                        <Loader2 className="w-4 h-4 animate-spin" />
                        Creating Account...
                      </>
                    )}
                  </div>
                ) : (
                  'Create Account'
                )}
              </RippleButton>
              
              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <span className="w-full border-t border-slate-700" />
                </div>
                <div className="relative flex justify-center text-xs uppercase">
                  <span className="bg-slate-900/50 px-2 text-slate-400">
                    Or continue with
                  </span>
                </div>
              </div>
              
              <RippleButton
                type="button"
                onClick={handleGoogleLogin}
                disabled={isSubmitting || loading}
                className="w-full py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-xl text-white font-medium transition-all duration-200"
              >
                <div className="flex items-center justify-center gap-2">
                  <svg className="w-4 h-4" viewBox="0 0 24 24">
                    <path
                      fill="currentColor"
                      d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                    />
                    <path
                      fill="currentColor"
                      d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                    />
                    <path
                      fill="currentColor"
                      d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                    />
                    <path
                      fill="currentColor"
                      d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                    />
                  </svg>
                  Continue with Google
                </div>
              </RippleButton>
              
              {onSwitchToLogin && (
                <div className="text-center text-sm">
                  <span className="text-slate-400">Already have an account? </span>
                  <button
                    type="button"
                    onClick={onSwitchToLogin}
                    className="text-violet-400 hover:text-violet-300 underline underline-offset-4 transition-colors"
                    disabled={isSubmitting || loading}
                  >
                    Sign in
                  </button>
                </div>
              )}
            </div>
          </form>
        </HolographicBubble>
  );
};

================
File: client/src/components/auth/ResetPasswordForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card';
import { Alert, AlertDescription } from '../ui/alert';
import { Lock, Eye, EyeOff, CheckCircle, Loader2 } from 'lucide-react';

interface ResetPasswordFormProps {
  token: string;
  onSuccess: () => void;
  onBackToLogin: () => void;
}

export function ResetPasswordForm({ token, onSuccess, onBackToLogin }: ResetPasswordFormProps) {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [error, setError] = useState('');
  const [passwordStrength, setPasswordStrength] = useState({
    length: false,
    number: false,
    lowercase: false,
    uppercase: false,
  });

  // Check password strength
  useEffect(() => {
    setPasswordStrength({
      length: password.length >= 8,
      number: /\d/.test(password),
      lowercase: /[a-z]/.test(password),
      uppercase: /[A-Z]/.test(password),
    });
  }, [password]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    // Validate passwords match
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      setIsLoading(false);
      return;
    }

    // Validate password strength
    if (password.length < 8) {
      setError('Password must be at least 8 characters long');
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch('/api/auth/reset-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ token, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to reset password');
      }

      setIsSuccess(true);
      // Wait a moment before calling onSuccess to show the success message
      setTimeout(() => {
        onSuccess();
      }, 2000);
    } catch (error: any) {
      console.error('Reset password error:', error);
      if (error.message.includes('Invalid or expired')) {
        setError('This reset link has expired or is invalid. Please request a new password reset.');
      } else {
        setError(error.message || 'Failed to reset password. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  if (isSuccess) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-green-100">
            <CheckCircle className="h-8 w-8 text-green-600" />
          </div>
          <CardTitle>Password Reset Successful!</CardTitle>
          <CardDescription>
            Your password has been successfully reset. You can now log in with your new password.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={onBackToLogin} className="w-full">
            Continue to Login
          </Button>
        </CardContent>
      </Card>
    );
  }

  const isFormValid = password.length >= 8 && password === confirmPassword;

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="text-center">
        <CardTitle>Reset Your Password</CardTitle>
        <CardDescription>
          Enter your new password below. Make sure it's strong and secure.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div className="space-y-2">
            <Label htmlFor="password">New Password</Label>
            <div className="relative">
              <Input
                id="password"
                name="password"
                type={showPassword ? 'text' : 'password'}
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter your new password"
                required
                disabled={isLoading}
                className="pr-10"
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 flex items-center pr-3"
                onClick={() => setShowPassword(!showPassword)}
                disabled={isLoading}
              >
                {showPassword ? (
                  <EyeOff className="h-4 w-4 text-gray-400" />
                ) : (
                  <Eye className="h-4 w-4 text-gray-400" />
                )}
              </button>
            </div>
            
            {/* Password strength indicators */}
            {password && (
              <div className="space-y-2 text-sm">
                <div className="flex items-center space-x-2">
                  <div className={`h-2 w-2 rounded-full ${passwordStrength.length ? 'bg-green-500' : 'bg-gray-300'}`} />
                  <span className={passwordStrength.length ? 'text-green-600' : 'text-gray-500'}>
                    At least 8 characters
                  </span>
                </div>
                <div className="flex items-center space-x-2">
                  <div className={`h-2 w-2 rounded-full ${passwordStrength.lowercase && passwordStrength.uppercase ? 'bg-green-500' : 'bg-gray-300'}`} />
                  <span className={passwordStrength.lowercase && passwordStrength.uppercase ? 'text-green-600' : 'text-gray-500'}>
                    Upper and lowercase letters
                  </span>
                </div>
                <div className="flex items-center space-x-2">
                  <div className={`h-2 w-2 rounded-full ${passwordStrength.number ? 'bg-green-500' : 'bg-gray-300'}`} />
                  <span className={passwordStrength.number ? 'text-green-600' : 'text-gray-500'}>
                    At least one number
                  </span>
                </div>
              </div>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Confirm New Password</Label>
            <div className="relative">
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type={showConfirmPassword ? 'text' : 'password'}
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                placeholder="Confirm your new password"
                required
                disabled={isLoading}
                className="pr-10"
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 flex items-center pr-3"
                onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                disabled={isLoading}
              >
                {showConfirmPassword ? (
                  <EyeOff className="h-4 w-4 text-gray-400" />
                ) : (
                  <Eye className="h-4 w-4 text-gray-400" />
                )}
              </button>
            </div>
            {confirmPassword && password !== confirmPassword && (
              <p className="text-sm text-red-600">Passwords do not match</p>
            )}
          </div>

          <Button 
            type="submit" 
            className="w-full" 
            disabled={isLoading || !isFormValid}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Resetting Password...
              </>
            ) : (
              <>
                <Lock className="mr-2 h-4 w-4" />
                Reset Password
              </>
            )}
          </Button>

          <Button
            type="button"
            variant="ghost"
            className="w-full"
            onClick={onBackToLogin}
            disabled={isLoading}
          >
            Back to Login
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

================
File: client/src/components/auth/UserMenu.tsx
================
import React from 'react';
import { motion, AnimatePresence } from "framer-motion";
import { Button } from '../ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu';
import { Avatar, AvatarFallback, AvatarImage } from '../ui/avatar';
import { LogOut, User } from 'lucide-react';
import { useAuth } from '../../hooks/useAuth';
import { ProfileModal } from '../ProfileModal';

export const UserMenu: React.FC = () => {
  const { user, logout } = useAuth();
  
  // Use React.useState directly to avoid import issues
  const [isProfileModalOpen, setIsProfileModalOpen] = React.useState(false);

  if (!user) {
    return null;
  }

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      console.error('Logout error:', error);
    }
  };

  const handleProfileClick = () => {
    setIsProfileModalOpen(true);
  };

  const displayName = user.firstName && user.lastName 
    ? `${user.firstName} ${user.lastName}`
    : user.username || user.email;

  const initials = user.firstName && user.lastName
    ? `${user.firstName[0]}${user.lastName[0]}`
    : user.username
    ? user.username[0].toUpperCase()
    : user.email[0].toUpperCase();

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button 
            variant="ghost" 
            className="relative h-8 w-8 rounded-full bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 backdrop-blur-xl transition-all duration-200 hover:scale-105 active:scale-95"
          >
            <Avatar className="h-8 w-8">
              <AvatarImage src={user.avatar || undefined} alt={displayName} />
              <AvatarFallback className="bg-gradient-to-br from-violet-500/20 to-purple-600/20 text-white border border-violet-400/30">
                {initials}
              </AvatarFallback>
            </Avatar>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent 
          className="w-56 bg-slate-900/90 backdrop-blur-xl border border-slate-700/50 rounded-xl" 
          align="end" 
          forceMount
        >
          <DropdownMenuLabel className="font-normal">
            <div className="flex flex-col space-y-1">
              <p className="text-sm font-medium leading-none text-white">{displayName}</p>
              <p className="text-xs leading-none text-slate-400">
                {user.email}
              </p>
            </div>
          </DropdownMenuLabel>
          <DropdownMenuSeparator className="border-slate-700" />
          <DropdownMenuItem 
            onClick={handleProfileClick}
            className="text-slate-300 hover:text-white hover:bg-slate-800/50 focus:bg-slate-800/50 focus:text-white cursor-pointer"
          >
            <User className="mr-2 h-4 w-4" />
            <span>Profile</span>
          </DropdownMenuItem>
          <DropdownMenuSeparator className="border-slate-700" />
          <DropdownMenuItem 
            onClick={handleLogout}
            className="text-slate-300 hover:text-white hover:bg-slate-800/50 focus:bg-slate-800/50 focus:text-white cursor-pointer"
          >
            <LogOut className="mr-2 h-4 w-4" />
            <span>Log out</span>
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <ProfileModal 
        open={isProfileModalOpen} 
        onOpenChange={setIsProfileModalOpen} 
      />
    </>
  );
};

================
File: client/src/components/ChatView.tsx
================
"use client";

import React, { useEffect, useRef, useState, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Send,
  Command,
  Sparkles,
  ImageIcon,
  FileUp,
  MonitorIcon,
  X,
  Loader2,
  Edit3,
  Share2,
  Plus,
  Brain,
  Cpu,
  CircuitBoard,
  AlertCircle,
  Download,
  Copy,
  ExternalLink,
  Settings,
  Files,
  Volume2,
  VolumeX,
  Mic,
  MicOff,
  CreditCard
} from "lucide-react";
import { Message, CommandSuggestion, LLMModel, ModelCapabilities } from "../types";
import { useAIProvider } from "../hooks/useAIProvider";
import { SYSTEM_MESSAGE_PRESETS } from "../hooks/useAzureAI";
import { useIntelligentToast } from "../hooks/useIntelligentToast";
import { useSpeech } from "../hooks/useSpeech";
import { AzureAIService } from "../lib/azureAI";
import { SystemMessageSelector } from './SystemMessageSelector';
import CloneUIModal from './CloneUIModal';
import CreatePageModal from './CreatePageModal';
import ImproveModal from './ImproveModal';
import AnalyzeModal from './AnalyzeModal';
import { FileManager } from './FileManager';
import { AIProviderQuickSelector } from './AIProviderQuickSelector';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "./ui/tooltip";
import { toast } from "sonner";
import { useAuth } from '../hooks/useAuth';
import { 
  downloadTranscript, 
  copyTranscriptToClipboard, 
  shareTranscript, 
  isWebShareSupported 
} from '../lib/transcriptUtils';
import { CreditLimitMessage } from './CreditLimitMessage';
import { AICreditsQuickPurchase } from './AICreditsQuickPurchase';
import { navigateTo } from './Router';
import { useCreditUpdates } from '../hooks/useCreditUpdates';

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 100,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "#8B5CF6",
  vx = 0,
  vy = 0,
}) => {
  const [particleColor, setParticleColor] = useState<string>(color);

  interface MousePosition {
    x: number;
    y: number;
  }

  const MousePosition = (): MousePosition => {
    const [mousePosition, setMousePosition] = useState<MousePosition>({
      x: 0,
      y: 0,
    });

    useEffect(() => {
      const handleMouseMove = (event: MouseEvent) => {
        setMousePosition({ x: event.clientX, y: event.clientY });
      };

      window.addEventListener("mousemove", handleMouseMove);

      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
      };
    }, []);

    return mousePosition;
  };

  const hexToRgb = (hex: string): number[] => {
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mousePosition = MousePosition();
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  useEffect(() => {
    if (canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
    }
    initCanvas();
    animate();
    window.addEventListener("resize", initCanvas);

    return () => {
      window.removeEventListener("resize", initCanvas);
    };
  }, [particleColor]);

  useEffect(() => {
    onMouseMove();
  }, [mousePosition.x, mousePosition.y]);

  useEffect(() => {
    initCanvas();
  }, [refresh]);

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const onMouseMove = () => {
    if (canvasRef.current) {
      const rect = canvasRef.current.getBoundingClientRect();
      const { w, h } = canvasSize.current;
      const x = mousePosition.x - rect.left - w / 2;
      const y = mousePosition.y - rect.top - h / 2;
      const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2;
      if (inside) {
        mouse.current.x = x;
        mouse.current.y = y;
      }
    }
  };

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.1;
    const dy = (Math.random() - 0.5) * 0.1;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const rgb = hexToRgb(particleColor);

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${rgb.join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(
        0,
        0,
        canvasSize.current.w,
        canvasSize.current.h,
      );
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const remapValue = (
    value: number,
    start1: number,
    end1: number,
    start2: number,
    end2: number,
  ): number => {
    const remapped =
      ((value - start1) * (end2 - start2)) / (end1 - start1) + start2;
    return remapped > 0 ? remapped : 0;
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      const edge = [
        circle.x + circle.translateX - circle.size,
        canvasSize.current.w - circle.x - circle.translateX - circle.size,
        circle.y + circle.translateY - circle.size,
        canvasSize.current.h - circle.y - circle.translateY - circle.size,
      ];
      const closestEdge = edge.reduce((a, b) => Math.min(a, b));
      const remapClosestEdge = parseFloat(
        remapValue(closestEdge, 0, 20, 0, 1).toFixed(2),
      );
      if (remapClosestEdge > 1) {
        circle.alpha += 0.02;
        if (circle.alpha > circle.targetAlpha) {
          circle.alpha = circle.targetAlpha;
        }
      } else {
        circle.alpha = circle.targetAlpha * remapClosestEdge;
      }
      circle.x += circle.dx + vx;
      circle.y += circle.dy + vy;
      circle.translateX +=
        (mouse.current.x / (staticity / circle.magnetism) - circle.translateX) /
        ease;
      circle.translateY +=
        (mouse.current.y / (staticity / circle.magnetism) - circle.translateY) /
        ease;

      drawCircle(circle, true);

      if (
        circle.x < -circle.size ||
        circle.x > canvasSize.current.w + circle.size ||
        circle.y < -circle.size ||
        circle.y > canvasSize.current.h + circle.size
      ) {
        circles.current.splice(i, 1);
        const newCircle = circleParams();
        drawCircle(newCircle);
      }
    });
    window.requestAnimationFrame(animate);
  };

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  );
};

// Helper function to check if a command is available based on dynamic capabilities
const isCommandAvailable = (command: string, capabilities: ModelCapabilities | null): boolean => {
  if (!capabilities) {
    // Default to unavailable if no capability info (loading or error state)
    return false;
  }

  switch (command) {
    case "/clone":
      return capabilities.supportsVision === true;
    case "/page":
      return capabilities.supportsCodeGeneration === true;
    case "/improve":
      return capabilities.supportsCodeGeneration === true;
    case "/analyze":
      return capabilities.supportsAnalysis === true;
    default:
      return true;
  }
};

const commandSuggestions: CommandSuggestion[] = [
  {
    icon: <ImageIcon className="w-4 h-4" />,
    label: "Clone UI",
    description: "Generate a UI from a screenshot",
    prefix: "/clone"
  },
  {
    icon: <MonitorIcon className="w-4 h-4" />,
    label: "Create Page",
    description: "Generate a new web page",
    prefix: "/page"
  },
  {
    icon: <Sparkles className="w-4 h-4" />,
    label: "Improve",
    description: "Improve existing UI design",
    prefix: "/improve"
  },
  {
    icon: <Brain className="w-4 h-4" />,
    label: "Uterpi System Status",
    description: "Uterpi system reports and analysis",
    prefix: "/analyze"
  }
];

const CircuitPattern: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    className={className}
    viewBox="0 0 100 100"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M10 10h20v20h20v-20h20v40h-20v20h-40z"
      stroke="currentColor"
      strokeWidth="0.5"
      fill="none"
      opacity="0.1"
    />
    <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
    <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
  </svg>
);

const HolographicBubble: React.FC<{
  children: React.ReactNode;
  isUser?: boolean;
  className?: string;
}> = ({ children, isUser = false, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-2xl backdrop-blur-xl border overflow-hidden
      ${isUser 
        ? "bg-gradient-to-br from-violet-500/20 to-purple-600/20 border-violet-400/30 ml-4 sm:ml-12" 
        : "bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30 mr-4 sm:mr-12"
      }
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/10 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 3,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

const TypingIndicator: React.FC = () => (
  <HolographicBubble>
    <div className="flex items-center gap-2">
      <div className="flex items-center gap-1">
        {[0, 1, 2].map((i) => (
          <motion.div
            key={i}
            className="w-2 h-2 bg-violet-400 rounded-full"
            animate={{
              scale: [1, 1.2, 1],
              opacity: [0.5, 1, 0.5],
            }}
            transition={{
              duration: 1.5,
              repeat: Infinity,
              delay: i * 0.2,
            }}
          />
        ))}
      </div>
      <span className="text-sm text-slate-300">AI is thinking...</span>
    </div>
  </HolographicBubble>
);

const NeuralNetworkPulse: React.FC<{ isActive?: boolean }> = ({ isActive = false }) => (
  <motion.div
    className="absolute inset-0 pointer-events-none"
    animate={isActive ? {
      opacity: [0, 0.3, 0],
      scale: [0.8, 1.2, 0.8],
    } : {}}
    transition={{
      duration: 2,
      repeat: isActive ? Infinity : 0,
      ease: "easeInOut",
    }}
  >
    <div className="absolute inset-0 rounded-2xl border border-violet-400/20">
      <div className="absolute top-2 left-2 w-1 h-1 bg-violet-400 rounded-full animate-pulse" />
      <div className="absolute top-4 right-3 w-1 h-1 bg-blue-400 rounded-full animate-pulse delay-300" />
      <div className="absolute bottom-3 left-4 w-1 h-1 bg-purple-400 rounded-full animate-pulse delay-700" />
    </div>
  </motion.div>
);

const RippleButton = React.forwardRef<
  HTMLButtonElement,
  {
    children: React.ReactNode;
    onClick?: (e?: React.MouseEvent<HTMLButtonElement>) => void;
    className?: string;
    disabled?: boolean;
    'aria-label'?: string;
  }
>(({ children, onClick, className, disabled = false, 'aria-label': ariaLabel }, ref) => {
  const [ripples, setRipples] = useState<Array<{ id: number; x: number; y: number }>>([]);

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    if (disabled) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const newRipple = { id: Date.now(), x, y };
    setRipples(prev => [...prev, newRipple]);
    
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);
    
    if (onClick && typeof onClick === 'function') {
      try {
        // Forward the original event so upstream handlers can access defaultPrevented, etc.
        onClick(e);
      } catch (error) {
        console.error('Error in onClick handler:', error);
        console.error('onClick handler failed:', error);
      }
    }
  };

  return (
    <button
      ref={ref}
      onClick={handleClick}
      disabled={disabled}
      aria-label={ariaLabel}
      className={`
        relative overflow-hidden transition-all duration-200
        ${disabled ? "opacity-50 cursor-not-allowed" : "hover:scale-105 active:scale-95"}
        ${className}
      `}
    >
      {children}
      {ripples.map(ripple => (
        <motion.span
          key={ripple.id}
          className="absolute bg-white/30 rounded-full pointer-events-none"
          style={{
            left: ripple.x - 10,
            top: ripple.y - 10,
            width: 20,
            height: 20,
          }}
          initial={{ scale: 0, opacity: 1 }}
          animate={{ scale: 4, opacity: 0 }}
          transition={{ duration: 0.6, ease: "easeOut" }}
        />
      ))}
    </button>
  );
});

RippleButton.displayName = 'RippleButton';

const OrigamiModal: React.FC<{
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}> = ({ isOpen, onClose, title, children }) => (
  <AnimatePresence>
    {isOpen && (
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center p-4"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        <motion.div
          className="absolute inset-0 bg-black/60 backdrop-blur-sm"
          onClick={onClose}
        />
        <motion.div
          className="relative bg-slate-900/90 backdrop-blur-xl border border-slate-700/50 rounded-2xl p-6 max-w-md w-full"
          initial={{ scale: 0, rotateX: -90 }}
          animate={{ scale: 1, rotateX: 0 }}
          exit={{ scale: 0, rotateX: 90 }}
          transition={{ type: "spring", damping: 20, stiffness: 300 }}
          style={{ transformStyle: "preserve-3d" }}
        >
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold text-white">{title}</h3>
            <RippleButton
              onClick={onClose}
              className="p-2 text-slate-400 hover:text-white rounded-lg"
            >
              <X className="w-4 h-4" />
            </RippleButton>
          </div>
          {children}
        </motion.div>
      </motion.div>
    )}
  </AnimatePresence>
);

const FuturisticAIChat: React.FC = () => {
  const { user } = useAuth(); // Get user context for AI personalization
  
  // Credit status state
  const [creditBalance, setCreditBalance] = useState<number | null>(null);
  const [isFreemium, setIsFreemium] = useState(false);
  const [messagesRemaining, setMessagesRemaining] = useState<number | null>(null);

  // Listen for real-time credit updates from AI responses
  const creditUpdate = useCreditUpdates();

  // Update credit balance when we receive real-time updates
  useEffect(() => {
    if (creditUpdate) {
      console.log('üí≥ Real-time credit update received:', creditUpdate);
      setCreditBalance(creditUpdate.remainingBalance);
    }
  }, [creditUpdate]);

  // Fetch credit status on component mount
  useEffect(() => {
    if (user) {
      fetchCreditStatus();
    }
  }, [user]);

  const fetchCreditStatus = async () => {
    try {
      const response = await fetch('/api/subscription/details', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setCreditBalance(data.features.currentCreditsBalance);
        setIsFreemium(data.tier === 'freemium');
        if (data.tier === 'freemium') {
          setMessagesRemaining(data.features.messagesRemaining);
        }
      }
    } catch (error) {
      console.error('Error fetching credit status:', error);
    }
  };
  
  // Create personalized welcome message
  const getPersonalizedWelcome = useCallback(() => {
    if (!user) {
      return "Hello! I'm Uterpi's AI. What would you like to accomplish today?";
    }

    const name = user.firstName || user.username || "there";
    const greeting = `Hello ${name}! I'm Uterpi's AI.`;
    
    const personalizations = [];
    
    if (user.bio) {
      personalizations.push(`I see you're interested in ${user.bio.toLowerCase()}.`);
    }
    
    if (user.age) {
      if (user.age < 25) {
        personalizations.push("I'm here to help with any questions or projects you're working on.");
      } else if (user.age < 40) {
        personalizations.push("Whether it's work, personal projects, or learning something new, I'm here to assist.");
      } else {
        personalizations.push("I'm here to help with any professional or personal endeavors.");
      }
    }

    // Check for birthday
    if (user.dateOfBirth) {
      const birthDate = new Date(user.dateOfBirth);
      const today = new Date();
      const isToday = birthDate.getMonth() === today.getMonth() && birthDate.getDate() === today.getDate();
      
      if (isToday) {
        return `üéâ ${greeting} Happy Birthday! I hope you're having a wonderful day. What would you like to explore together today?`;
      }
    }
    
    if (personalizations.length > 0) {
      return `${greeting} ${personalizations.join(' ')} What would you like to work on today?`;
    }
    
    return `${greeting} What would you like to accomplish today?`;
  }, [user]);

  const [messages, setMessages] = useState<Message[]>([
    {
      id: "1",
      content: getPersonalizedWelcome(),
      role: "assistant",
      timestamp: new Date(),
    }
  ]);
  const [input, setInput] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [showCommands, setShowCommands] = useState(false);
  const [attachments, setAttachments] = useState<string[]>([]);
  const [attachedFileIds, setAttachedFileIds] = useState<number[]>([]);
  const [activeMessage, setActiveMessage] = useState<string | null>(null);
  const [showShareModal, setShowShareModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [enableStreaming, setEnableStreaming] = useState(true);
  const [streamingResponse, setStreamingResponse] = useState("");
  const [showSystemMessageModal, setShowSystemMessageModal] = useState(false);
  const [selectedSystemPreset, setSelectedSystemPreset] = useState<keyof typeof SYSTEM_MESSAGE_PRESETS | "custom">("DEFAULT");
  const [customSystemMessage, setCustomSystemMessage] = useState<string>("");
  
  // Enhanced modal states
  const [showCloneUIModal, setShowCloneUIModal] = useState(false);
  const [showCreatePageModal, setShowCreatePageModal] = useState(false);
  const [showImproveModal, setShowImproveModal] = useState(false);
  const [showAnalyzeModal, setShowAnalyzeModal] = useState(false);
  const [showFileManager, setShowFileManager] = useState(false);
  const [speakingMessageId, setSpeakingMessageId] = useState<string | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [isChatActive, setIsChatActive] = useState(false); // Track if chat is actively processing
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const [latestSources, setLatestSources] = useState<Array<{ fileId: number; name: string; mimeType: string; similarity: number; snippet: string }>>([]);


  // Keyboard shortcuts: New Chat (Ctrl/Cmd+N) and Open Model Selector (Ctrl/Cmd+M)
  useEffect(() => {
    const handleSources = (e: Event) => {
      const ce = e as CustomEvent;
      if (Array.isArray(ce.detail)) {
        setLatestSources(ce.detail as any);
      }
    };
    window.addEventListener('ai-sources', handleSources as EventListener);
    return () => window.removeEventListener('ai-sources', handleSources as EventListener);
  }, []);

  const SourcesList: React.FC<{ sources: typeof latestSources }> = ({ sources }) => {
    if (!sources || sources.length === 0) return null;
    return (
      <div className="mt-3 border border-slate-700/50 rounded-lg bg-slate-900/40 p-3">
        <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">Sources</div>
        <div className="flex flex-col gap-2">
          {sources.slice(0, 8).map((s, idx) => (
            <div key={idx} className="text-xs text-slate-300">
              <div className="flex items-center justify-between">
                <span className="font-medium">{s.name}</span>
                <span className="text-slate-500">{(s.similarity * 100).toFixed(0)}%</span>
              </div>
              <div className="text-slate-400 truncate">{s.snippet}</div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  useEffect(() => {
    const handleGlobalKeydown = (e: KeyboardEvent) => {
      const isMeta = e.metaKey || e.ctrlKey;
      if (!isMeta) return;

      if (e.key.toLowerCase() === 'n') {
        e.preventDefault();
        setMessages([
          {
            id: "1",
            content: getPersonalizedWelcome(),
            role: "assistant",
            timestamp: new Date(),
          }
        ]);
        toast.success("Started new conversation!");
      }

      // Model selector moved to quick dropdown
      // if (e.key.toLowerCase() === 'm') {
      //   e.preventDefault();
      //   // Now handled by AIProviderQuickSelector
      // }
    };

    window.addEventListener('keydown', handleGlobalKeydown);
    return () => window.removeEventListener('keydown', handleGlobalKeydown);
  }, [getPersonalizedWelcome]);

  // Get the current system message based on selection
  const getCurrentSystemMessage = () => {
    if (selectedSystemPreset === "custom") {
      return customSystemMessage || SYSTEM_MESSAGE_PRESETS.DEFAULT;
    }
    return SYSTEM_MESSAGE_PRESETS[selectedSystemPreset];
  };

  // Handle system message preset changes
  const handleSystemPresetChange = (preset: keyof typeof SYSTEM_MESSAGE_PRESETS | "custom", message?: string) => {
    setSelectedSystemPreset(preset);
    if (preset === "custom" && message !== undefined) {
      setCustomSystemMessage(message);
    }
    
    // Track system message changes
    trackAction('system_message_change');
  };

  // AI Provider hook (supports Azure AI, OpenAI, Gemini)
  const { 
    sendMessage, 
    sendStreamingMessage, 
    isLoading, 
    error, 
    clearError,
    currentModel,
    updateModel,
    selectedLLMModel,
    modelCapabilities,
    isLoadingCapabilities,
    refreshCapabilities,
    getAvailableModels,
    currentProvider
  } = useAIProvider({
    enableStreaming,
    systemMessage: getCurrentSystemMessage(),
    chatOptions: {
      maxTokens: 2048,
      temperature: 0.8,
      topP: 0.1
    },
    userContext: { user } // Pass user context correctly
  });

  // Display label for current model in header
  const displayModelName = (() => {
    if (currentProvider === 'lmstudio') {
      // Show the actual model name from LM Studio
      return selectedLLMModel?.name || 'Uterpi AI';
    }
    return selectedLLMModel?.name || currentModel || 'Choose Model';
  })();

  // Get AI service instance for intelligent toasts (create a SEPARATE instance to avoid interference)
  const aiServiceRef = useRef<any>(null);
  useEffect(() => {
    const getAIService = async () => {
      try {
        // Create a DEDICATED service instance for intelligent toasts
        // This prevents interference with chat operations
        switch (currentProvider) {
          case 'gemini': {
            const apiKey = localStorage.getItem('gemini-api-key');
            if (apiKey) {
              const { GeminiService } = await import('../lib/gemini');
              // Create a separate instance specifically for analysis
              // Use a lightweight model for faster analysis
              aiServiceRef.current = new GeminiService({ 
                apiKey, 
                modelName: 'gemini-1.5-flash' // Use flash model for analysis to reduce load
              });
              console.log('‚úÖ Separate Gemini Service initialized for intelligent toasts');
              return;
            }
            break;
          }
          
          case 'openai': {
            const apiKey = localStorage.getItem('openai-api-key');
            if (apiKey) {
              const { OpenAIService } = await import('../lib/openAI');
              // Create a separate instance for analysis with a lightweight model
              aiServiceRef.current = new OpenAIService({ 
                apiKey, 
                modelName: 'gpt-4o-mini' // Use mini model for analysis to reduce load
              });
              console.log('‚úÖ Separate OpenAI Service initialized for intelligent toasts');
              return;
            }
            break;
          }
          
          case 'huggingface': {
            const token = localStorage.getItem('hf-api-token');
            const url = localStorage.getItem('hf-endpoint-url');
            if (token && url) {
              const { HuggingFaceService } = await import('../lib/huggingface');
              aiServiceRef.current = new HuggingFaceService({ 
                apiToken: token, 
                endpointUrl: url, 
                modelName: 'hf-endpoint' 
              });
              console.log('‚úÖ HuggingFace Service initialized for intelligent toasts');
              return;
            }
            break;
          }
          
          case 'azure': {
            const azureKey = localStorage.getItem('azure-api-key');
            const azureEndpoint = localStorage.getItem('azure-endpoint');
            if (azureKey && azureEndpoint) {
              const { AzureAIService } = await import('../lib/azureAI');
              aiServiceRef.current = new AzureAIService({ 
                apiKey: azureKey, 
                endpoint: azureEndpoint,
                modelName: selectedLLMModel?.id || 'gpt-4o' 
              });
              console.log('‚úÖ Azure AI Service initialized for intelligent toasts');
              return;
            }
            break;
          }
          
          case 'uterpi': {
            const uterpiToken = (import.meta as any).env?.VITE_UTERPI_API_TOKEN;
            const uterpiUrl = (import.meta as any).env?.VITE_UTERPI_ENDPOINT_URL;
            if (uterpiToken && uterpiUrl) {
              const { HuggingFaceService } = await import('../lib/huggingface');
              aiServiceRef.current = new HuggingFaceService({ 
                apiToken: uterpiToken, 
                endpointUrl: uterpiUrl, 
                modelName: 'hf-endpoint' 
              });
              console.log('‚úÖ Uterpi AI Service initialized for intelligent toasts');
              return;
            }
            break;
          }
          
          case 'lmstudio': {
            const baseUrl = localStorage.getItem('lmstudio-base-url') || 'http://localhost:1234/v1';
            const { LMStudioService } = await import('../lib/lmstudio');
            aiServiceRef.current = new LMStudioService({ 
              apiKey: 'not-needed', // LM Studio doesn't require an API key
              baseUrl, 
              modelName: selectedLLMModel?.id || 'nomadic-icdu-v8' 
            });
            console.log('‚úÖ LM Studio Service initialized for intelligent toasts');
            return;
          }
        }

        // No service available for current provider
        aiServiceRef.current = null;
        console.log(`‚ö†Ô∏è No AI service available for intelligent toasts with provider: ${currentProvider}`);
      } catch (err) {
        console.warn('Failed to initialize AI service for toasts:', err);
        aiServiceRef.current = null;
      }
    };
    getAIService();
  }, [currentProvider, selectedLLMModel]);

  // Intelligent toast system - pass toast function explicitly
  const {
    analyzeConversation,
    trackAction,
    showOptimizationTip,
    showPerformanceAlert,
    clearRecommendationCache,
    forceClearRecommendation,
    forceClearInsightCaches,
    testShowRecommendation,
    getRecommendationCacheStatus
  } = useIntelligentToast({
    enabled: !!aiServiceRef.current, // Only enable if we have a compatible AI service
    aiService: aiServiceRef.current,
    toastFunction: (title: string, options?: any) => {
      toast(title, options);
    },
    onModelSwitch: (modelId: string) => {
      const availableModels = getAvailableModels();
      const targetModel = availableModels.find((m: any) => m.id === modelId);
      if (targetModel) {
        updateModel(targetModel);
        toast.success(`Switched to ${targetModel.name}!`);
      }
    },
    onNewChat: () => {
      // Reset conversation
      setMessages([
        {
          id: "1",
          content: getPersonalizedWelcome(),
          role: "assistant",
          timestamp: new Date(),
        }
      ]);
      toast.success("Started new conversation!");
    }
  });
  
  // Initialize speech functionality
  const {
    speak,
    stopSpeaking,
    isSpeaking,
    startListening,
    stopListening,
    isListening,
    transcript,
    interimTranscript,
    isAvailable: speechAvailable,
    isHTTPS,
    microphonePermission,
    error: speechError,
    initialize
  } = useSpeech({
    autoInitialize: false, // Don't auto-initialize - only when user explicitly enables speech
    onRecognitionResult: (result) => {
      if (result.transcript) {
        // For both interim and final results, show the full transcript
        // The transcript already contains the accumulated text
        setInput(result.transcript);
      }
    },
    onRecognitionError: (error) => {
      toast.error(`Speech recognition error: ${error.message}`);
      setIsRecording(false);
    }
  });
  
  // Handle text-to-speech for messages
  const handleSpeak = useCallback(async (messageId: string, text: string) => {
    try {
      // Initialize speech service if not already initialized
      if (!speechAvailable && initialize) {
        toast.info('Initializing text-to-speech...');
        await initialize();
        // Wait a bit for initialization to complete
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      if (speakingMessageId === messageId) {
        // Stop speaking if clicking same message
        stopSpeaking();
        setSpeakingMessageId(null);
      } else {
        // Start speaking new message
        stopSpeaking();
        setSpeakingMessageId(messageId);
        await speak(text);
        setSpeakingMessageId(null);
      }
    } catch (error) {
      console.error('Failed to speak:', error);
      toast.error('Failed to speak message');
      setSpeakingMessageId(null);
    }
  }, [speakingMessageId, speak, stopSpeaking, speechAvailable, initialize]);
  
  // Handle speech-to-text for input
  const handleVoiceInput = useCallback(async () => {
    try {
      // Initialize speech service if not already initialized
      if (!speechAvailable && initialize) {
        toast.info('Initializing speech service...');
        await initialize();
        // Wait a bit for initialization to complete
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // Check HTTPS requirement
      if (!isHTTPS && microphonePermission !== 'granted') {
        toast.error('üîí Microphone access requires HTTPS. Please use a secure connection.');
        return;
      }
      
      if (isRecording) {
        // Stop recording and get transcript
        setIsRecording(false);
        const finalTranscript = await stopListening();
        if (finalTranscript) {
          setInput(finalTranscript);
        }
      } else {
        // Start recording
        setIsRecording(true);
        setInput(''); // Clear input to show fresh transcript
        await startListening({
          language: 'en-US',
          continuous: true,
          interimResults: true
        });
      }
    } catch (error) {
      console.error('Voice input error:', error);
      const errorMessage = (error as Error).message || 'Voice input failed';
      
      // Provide helpful error messages
      if (errorMessage.includes('permission')) {
        toast.error('üé§ Microphone permission denied. Please allow microphone access and try again.');
      } else if (errorMessage.includes('not-allowed')) {
        toast.error('üîí Microphone access blocked. Check your browser settings.');
      } else if (errorMessage.includes('network')) {
        toast.error('üåê Network error. Please check your internet connection.');
      } else {
        toast.error(`üé§ ${errorMessage}`);
      }
      
      setIsRecording(false);
    }
  }, [isRecording, startListening, stopListening, isHTTPS, microphonePermission, speechAvailable, initialize]);

  // Mic permission badge helper
  const MicPermissionBadge = () => (
    <div className="flex items-center gap-2 text-xs text-slate-400">
      <span className={`w-2 h-2 rounded-full ${microphonePermission === 'granted' ? 'bg-green-500' : microphonePermission === 'denied' ? 'bg-red-500' : 'bg-yellow-500'}`} />
      <span>
        Mic: {microphonePermission === 'granted' ? 'Granted' : microphonePermission === 'denied' ? 'Denied' : 'Prompt'}
        {!isHTTPS && microphonePermission !== 'granted' && (
          <span className="ml-2 text-yellow-400">(HTTPS recommended)</span>
        )}
      </span>
    </div>
  );
  
  // Stop recording when component unmounts
  useEffect(() => {
    return () => {
      if (isListening) {
        stopListening();
      }
      if (isSpeaking) {
        stopSpeaking();
      }
    };
  }, [isListening, isSpeaking, stopListening, stopSpeaking]);

  // Add debugging commands to window object for console testing
  useEffect(() => {
    (window as any).intelligentToastDebug = {
      clearCache: clearRecommendationCache,
      forceClear: forceClearRecommendation,
      clearInsights: forceClearInsightCaches,
      testShow: testShowRecommendation,
      getStatus: getRecommendationCacheStatus,
      testInsight: () => testShowRecommendation("üß† Test Insight", "This is a test insight that should show up!", "insight"),
      testSuggestion: () => testShowRecommendation("üí° Test Suggestion", "This is a test suggestion!", "suggestion"),
      help: () => {
        console.log(`
üîß Intelligent Toast Debug Commands:
- intelligentToastDebug.clearCache() - Clear all caches
- intelligentToastDebug.clearInsights() - Clear only insight caches (for immediate testing)
- intelligentToastDebug.forceClear('recommendation-id') - Clear specific recommendation
- intelligentToastDebug.testInsight() - Show test insight
- intelligentToastDebug.testSuggestion() - Show test suggestion  
- intelligentToastDebug.getStatus() - Get cache status
- intelligentToastDebug.help() - Show this help
        `);
      }
    };
    
    // Auto-show help on first load
    console.log('üîß Intelligent Toast Debug Commands loaded! Type intelligentToastDebug.help() for available commands.');
    
    return () => {
      delete (window as any).intelligentToastDebug;
    };
  }, [clearRecommendationCache, forceClearRecommendation, forceClearInsightCaches, testShowRecommendation, getRecommendationCacheStatus]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

    // Performance monitoring and contextual tips
  useEffect(() => {
    if (messages.length > 3) { // Reduced from 4 to 3 for earlier feedback
      const lastMessage = messages[messages.length - 1];
      const userMessages = messages.filter(m => m.role === 'user');
      
      // Contextual coding tips - reduced threshold
      const codeMessages = userMessages.filter(m => m.content.includes('```'));
      if (codeMessages.length >= 1 && lastMessage.role === 'user' && lastMessage.content.includes('```')) {
        setTimeout(() => {
          if (selectedLLMModel?.id !== 'gpt-4o' && selectedLLMModel?.id !== 'gpt-4-turbo') {
            showOptimizationTip(
              "For extensive code analysis, GPT-4 models provide more accurate responses",
              () => {
                toast.success("Consider switching to GPT-4 for better code assistance!");
              }
            );
          }
        }, 3000); // Reduced delay from 5000 to 3000
      }

      // Lower conversation length warning threshold 
      if (messages.length > 20) { // Reduced from 35 to 20
        setTimeout(() => {
          showPerformanceAlert(
            "Long conversation detected. Performance may start to degrade. Consider starting a new chat.",
            'low'
          );
        }, 5000); // Reduced delay from 8000 to 5000
      }

      // Expert-level complexity detection - reduced requirements
      const complexTerms = ['algorithm', 'optimization', 'architecture', 'scalability', 'distributed', 'microservices'];
      const recentUserMessages = userMessages.slice(-3);
      const techMessageCount = recentUserMessages.filter(m => 
        complexTerms.some(term => m.content.toLowerCase().includes(term))
      ).length;
      
      if (techMessageCount >= 1 && selectedSystemPreset === 'DEFAULT' && messages.length > 4) { // Reduced requirements
        setTimeout(() => {
          showOptimizationTip(
            "For sustained technical discussions, the Technical system preset provides more detailed responses",
            () => {
              handleSystemPresetChange('TECHNICAL');
              toast.success("Switched to Technical system preset!");
            }
          );
        }, 4000); // Reduced delay from 6000 to 4000
      }
    }
  }, [messages, selectedLLMModel, selectedSystemPreset, showOptimizationTip, showPerformanceAlert]);

   // Periodic performance monitoring - reduced thresholds
   useEffect(() => {
     if (!selectedLLMModel || messages.length < 5) return; // Reduced from 10 to 5

     const checkPerformance = () => {
       // Alert for conversation getting very long - reduced threshold
       if (messages.length > 30) { // Reduced from 50 to 30
         showPerformanceAlert(
           "Very long conversation detected. Performance may degrade. Consider starting a new chat.",
           'medium'
         );
       }

       // Model efficiency tips based on usage patterns
       const recentUserMessages = messages.filter(m => m.role === 'user').slice(-5); // Reduced from 8 to 5
       const codeQuestions = recentUserMessages.filter(m => 
         m.content.toLowerCase().includes('code') || 
         m.content.toLowerCase().includes('programming') ||
         m.content.includes('```')
       );

       // Suggest if half or more of recent messages are code-related
       if (codeQuestions.length >= 2 && selectedLLMModel.category !== 'code' && selectedLLMModel.id !== 'gpt-4o') { // Reduced from 4 to 2
         setTimeout(() => {
           showOptimizationTip(
             "You're doing a lot of coding work. GPT-4o would provide more accurate code assistance",
             () => {
               toast.success("Consider a code-optimized model for programming tasks!");
             }
           );
         }, 3000); // Reduced delay from 5000 to 3000
       }
     };

     const interval = setInterval(checkPerformance, 180000); // Reduced from 5 minutes to 3 minutes
     return () => clearInterval(interval);
   }, [messages, selectedLLMModel, showOptimizationTip, showPerformanceAlert]);

  useEffect(() => {
    if (input.startsWith('/')) {
      setShowCommands(true);
    } else {
      setShowCommands(false);
    }
  }, [input]);

  const handleSend = async () => {
    console.log('üöÄ handleSend called with input:', input.trim());
    console.log('üöÄ handleSend - isLoading:', isLoading);
    console.log('üöÄ handleSend - attachments.length:', attachments.length);
    
    if (!input.trim() && attachments.length === 0) {
      console.log('‚ùå handleSend - No input, returning');
      return;
    }
    if (isLoading) {
      console.log('‚ùå handleSend - Already loading, returning');
      return; // Prevent multiple requests
    }

    console.log('‚úÖ handleSend - Proceeding with message send');
    // Set chat as active to prevent interference from intelligent toasts
    setIsChatActive(true);
    const startTime = Date.now();
    const userMessage: Message = {
      id: Date.now().toString(),
      content: input,
      role: "user",
      timestamp: new Date(),
      attachments: attachments.length > 0 ? [...attachments] : undefined,
      metadata: attachedFileIds.length ? { attachedFileIds } : undefined
    };

    const updatedMessages = [...messages, userMessage];
    
    // DEBUG: Log current conversation state
    console.log('üó®Ô∏è Current conversation state before sending to AI:');
    updatedMessages.forEach((msg, index) => {
      console.log(`  [${index}] ${msg.role} (${msg.id}): ${msg.content.substring(0, 60)}...`);
    });
    
    console.log('üìù Adding user message to chat:', userMessage);
    setMessages(updatedMessages);
    setInput("");
    setAttachments([]);
    setAttachedFileIds([]);
    setIsTyping(true);
    setActiveMessage(userMessage.id);
    clearError(); // Clear any previous errors
    console.log('üìù User message added, proceeding to AI call');

    try {
      if (enableStreaming) {
        // Handle streaming response
        console.log('üì§ Using STREAMING mode with provider:', currentProvider);
        const aiMessageId = (Date.now() + 1).toString();
        const aiMessage: Message = {
          id: aiMessageId,
          content: "",
          role: "assistant",
          timestamp: new Date(),
        };
        
        setMessages(prev => [...prev, aiMessage]);
        setStreamingResponse("");

        await sendStreamingMessage(updatedMessages, (chunk: string) => {
          setStreamingResponse(prev => {
            const newContent = prev + chunk;
            setMessages(prevMessages => 
              prevMessages.map(msg => 
                msg.id === aiMessageId 
                  ? { ...msg, content: newContent }
                  : msg
              )
            );
            return newContent;
          });
        });

        // After streaming completes, attempt to fetch sources from last backend response if available via a side channel in future

        setStreamingResponse("");
        
        // Auto-speak AI response if TTS is available and enabled (for streaming)
        if (speechAvailable && !isSpeaking) {
          const autoSpeak = localStorage.getItem('auto-speak-responses');
          if (autoSpeak === 'true') {
            // Get the final message content
            const finalMessage = messages.find(m => m.id === aiMessageId);
            if (finalMessage && finalMessage.content) {
              handleSpeak(aiMessageId, finalMessage.content);
            }
          }
        }
      } else {
        // Handle non-streaming response
        console.log('üì§ Sending message to AI provider:', currentProvider);
        const response = await sendMessage(updatedMessages);
        console.log('üì• Received response:', response ? `${response.substring(0, 100)}...` : 'EMPTY/UNDEFINED');
        // If backend attaches sources, it must come with structured data. Current hooks return string only.
        
        if (!response) {
          console.error('‚ùå Empty response received from AI provider');
          throw new Error('No response received from AI provider');
        }
        
        const aiMessage: Message = {
          id: (Date.now() + 1).toString(),
          content: response,
          role: "assistant",
          timestamp: new Date(),
        };
        console.log('üí¨ Adding AI message to chat:', aiMessage);
        console.log('üîç ChatView: Current messages before adding:', messages.length);
        setMessages(prev => {
          const newMessages = [...prev, aiMessage];
          console.log('üîç ChatView: New messages after adding:', newMessages.length);
          return newMessages;
        });
        
        // Auto-speak AI response if TTS is available and enabled
        if (speechAvailable && !isSpeaking && response) {
          const autoSpeak = localStorage.getItem('auto-speak-responses');
          if (autoSpeak === 'true') {
            handleSpeak(aiMessage.id, response);
          }
        }
      }

      // Trigger intelligent analysis and track performance - earlier triggering
      const responseTime = Date.now() - startTime;
      const estimatedTokens = userMessage.content.length * 1.3; // Rough estimate
      
      console.log(`üìä Message sent. Total messages: ${updatedMessages.length}, Response time: ${responseTime}ms, Estimated tokens: ${estimatedTokens}`);
      
      // Credit balance will be updated automatically via real-time updates from AI response
      
      // Track message sending and analyze conversation - reduced threshold for earlier analysis
      if (updatedMessages.length >= 2) { // Temporarily reduced to 2 for immediate testing
        console.log(`üöÄ Triggering conversation analysis for ${updatedMessages.length} messages...`);
        console.log(`üîß AI Service available: ${!!aiServiceRef.current}`);
        console.log(`üîß Selected LLM Model: ${selectedLLMModel?.name || 'none'}`);
        
        setTimeout(() => {
          if (selectedLLMModel) {
            console.log('üìû Calling analyzeConversation...');
            // Wrap in try-catch to prevent analysis errors from breaking chat
            try {
              analyzeConversation(updatedMessages, selectedLLMModel, responseTime, estimatedTokens, isChatActive)
                .then(() => {
                  console.log('‚úÖ analyzeConversation completed successfully');
                })
                .catch((error) => {
                  // Log error but don't let it break the chat
                  console.error('‚ö†Ô∏è analyzeConversation failed (non-critical):', error);
                });
            } catch (error) {
              // Catch any synchronous errors
              console.error('‚ö†Ô∏è analyzeConversation error (non-critical):', error);
            }
          } else {
            console.warn('‚ö†Ô∏è No selectedLLMModel available for analysis');
          }
        }, 2000); // Reduced delay from 5000 to 2000 for quicker feedback
      } else {
        console.log(`‚è≥ Not enough messages for analysis yet (${updatedMessages.length}/2)`);
      }

    } catch (err) {
      // Track error occurrence
      trackAction('error_occurred');
      
      // Check if this is a credit limit error (402 status)
      if (err instanceof Error && err.message.includes('Subscription error:')) {
        try {
          // Try to parse the error response for credit limit data
          const errorData = JSON.parse(err.message.replace('Subscription error: ', ''));
          
          if (errorData.code === 'MESSAGE_LIMIT_EXCEEDED' || 
              errorData.code === 'INSUFFICIENT_CREDITS' || 
              errorData.code === 'NO_CREDITS_AVAILABLE') {
            
            // Show credit limit message instead of generic error
            const creditLimitMessage: Message = {
              id: (Date.now() + 1).toString(),
              content: '',
              role: "assistant",
              timestamp: new Date(),
              isCreditLimit: true,
              metadata: errorData,
            };
            
            setMessages(prev => [...prev, creditLimitMessage]);
            return; // Don't show generic error
          }
        } catch (parseError) {
          // If parsing fails, fall through to generic error
          console.error('Failed to parse credit limit error:', parseError);
        }
      }
      
      // Generic error handling
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: `Sorry, I encountered an error: ${err instanceof Error ? err.message : 'Unknown error'}. Please check your configuration and try again.`,
        role: "assistant",
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
      setActiveMessage(null);
      // Clear chat active flag after a short delay to ensure response is complete
      setTimeout(() => setIsChatActive(false), 1000);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  // Handle upgrade to Pro subscription
  const handleUpgradeToPro = async () => {
    if (!user) {
      navigateTo('/login');
      return;
    }

    try {
      // Create Stripe Checkout Session for Pro subscription
      const response = await fetch('/api/checkout/subscription', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          tier: 'pro',
          interval: 'monthly', // Default to monthly
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error upgrading to Pro:', error);
      // Fallback to pricing page
      navigateTo('/pricing');
    }
  };

  // Handle purchase credits with dynamic package selection
  const handlePurchaseCredits = async (packageId: string) => {
    if (!user) {
      navigateTo('/login');
      return;
    }

    try {
      // Create Stripe Checkout Session for selected credit package
      const response = await fetch('/api/checkout/credits', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          packageId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error purchasing credits:', error);
      // Fallback to pricing page
      navigateTo('/pricing');
    }
  };

  const selectCommand = (command: CommandSuggestion) => {
    // Enhanced functionality - open appropriate modal instead of just inserting text
    setShowCommands(false);
    
    // Track command usage
    trackAction('use_command', { command: command.prefix });
    
    switch (command.prefix) {
      case "/clone":
        setShowCloneUIModal(true);
        break;
      case "/page":
        setShowCreatePageModal(true);
        break;
      case "/improve":
        setShowImproveModal(true);
        break;
      case "/analyze":
        setShowAnalyzeModal(true);
        break;
      default:
        // Fallback to original behavior for unknown commands
        setInput(command.prefix + " ");
        inputRef.current?.focus();
    }

    // Show feature enhancement tips for advanced commands - only for first-time usage
    setTimeout(() => {
      if (command.prefix === "/analyze" && messages.length < 8) {
        const hasUsedAnalyzeBefore = messages.some(m => 
          m.content.includes('/analyze') || m.content.toLowerCase().includes('analyze')
        );
        
        if (!hasUsedAnalyzeBefore) {
          showOptimizationTip(
            "Pro tip: Analysis works best with detailed conversations and specific questions",
            () => {
              toast.success("Try asking detailed questions for better analysis!");
            }
          );
        }
      }
    }, 4000);
  };



  const removeAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
    setAttachedFileIds(prev => prev.filter((_, i) => i !== index));
  };

  // Transcript handling functions
  const handleDownloadTranscript = async () => {
    try {
      downloadTranscript(messages, true);
      toast.success('Transcript downloaded successfully!');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to download transcript');
    }
  };

  const handleCopyTranscript = async () => {
    try {
      await copyTranscriptToClipboard(messages, true);
      toast.success('Transcript copied to clipboard!');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to copy transcript');
    }
  };

  const handleShareTranscript = async () => {
    try {
      const result = await shareTranscript(messages, true);
      if (result.method === 'share') {
        toast.success('Transcript shared successfully!');
      } else {
        toast.success('Transcript copied to clipboard for sharing!');
      }
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to share transcript');
    }
  };




  // Update welcome message when user profile changes
  useEffect(() => {
    setMessages(prev => {
      const newMessages = [...prev];
      if (newMessages.length > 0 && newMessages[0].id === "1") {
        newMessages[0] = {
          ...newMessages[0],
          content: getPersonalizedWelcome(),
        };
      }
      return newMessages;
    });
  }, [getPersonalizedWelcome]);

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden">
      {/* Background Effects */}
      <div className="absolute inset-0">
        <Particles
          className="absolute inset-0"
          quantity={150}
          color="#8B5CF6"
          size={1}
          staticity={30}
        />
        
        {/* Holographic Gradients */}
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
        
        {/* Circuit Patterns */}
        <div className="absolute inset-0 opacity-5">
          <CircuitPattern className="absolute top-10 left-10 w-20 h-20 text-violet-400" />
          <CircuitPattern className="absolute top-1/3 right-20 w-16 h-16 text-blue-400" />
          <CircuitPattern className="absolute bottom-20 left-1/3 w-24 h-24 text-purple-400" />
        </div>
      </div>

      {/* Main Content */}
      <div className="relative z-10 flex flex-col h-screen">
        {/* Header */}
        <motion.header
          className="p-4 sm:p-6 border-b border-slate-800/50 backdrop-blur-xl"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="flex items-center justify-between max-w-4xl mx-auto">
            <div className="flex items-center gap-3">
              <div className="relative">
                <img 
                  src="/images/uterpi_logo.png" 
                  alt="Uterpi Logo" 
                  className="w-16 h-16 sm:w-24 sm:h-24 rounded-full"
                />
                <motion.div
                  className="absolute inset-0 bg-violet-400/20 rounded-full blur-lg"
                  animate={{ scale: [1, 1.2, 1] }}
                  transition={{ duration: 2, repeat: Infinity }}
                />
              </div>
            </div>
            
            <div className="flex items-center gap-1 sm:gap-2 overflow-x-auto">
              {/* Credit Status Indicator */}
              {user && (
                <div className="flex items-center gap-1 sm:gap-2 px-2 sm:px-3 py-2 bg-slate-800/50 rounded-lg border border-slate-700/50 flex-shrink-0">
                  {isFreemium ? (
                    <div className="flex items-center gap-2 sm:gap-3 text-xs sm:text-sm">
                      <div className="flex items-center gap-1">
                        <span className="text-slate-300 hidden sm:inline">Free:</span>
                        <span className="text-slate-300 sm:hidden">F:</span>
                        <span className={`font-medium ${
                          (messagesRemaining || 0) === 0 
                            ? 'text-red-400' 
                            : (messagesRemaining || 0) <= 2 
                              ? 'text-amber-400' 
                              : 'text-green-400'
                        }`}>
                          {messagesRemaining || 0}
                        </span>
                      </div>
                      <div className="h-3 sm:h-4 w-px bg-slate-600"></div>
                      <div className="flex items-center gap-1">
                        <span className="text-slate-300 hidden sm:inline">Credits:</span>
                        <span className="text-slate-300 sm:hidden">C:</span>
                        <span className={`font-medium ${(creditBalance || 0) === 0 ? 'text-red-400' : (creditBalance || 0) < 50 ? 'text-yellow-400' : 'text-green-400'}`}>
                          {creditBalance || 0}
                        </span>
                      </div>
                    </div>
                  ) : (
                    <div className="flex items-center gap-1 sm:gap-2 text-xs sm:text-sm">
                      <span className="text-slate-300 hidden sm:inline">Credits:</span>
                      <span className="text-slate-300 sm:hidden">C:</span>
                      <span className={`font-medium ${(creditBalance || 0) === 0 ? 'text-red-400' : (creditBalance || 0) < 50 ? 'text-yellow-400' : 'text-green-400'}`}>
                        {creditBalance || 0}
                      </span>
                    </div>
                  )}
                  <AICreditsQuickPurchase 
                    currentBalance={creditBalance || 0}
                    isCompact={true}
                    onPurchaseComplete={() => {
                      fetchCreditStatus(); // Refresh credit status after purchase
                    }}
                  />
                </div>
              )}
              
              {/* New Chat */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <RippleButton
                    onClick={() => {
                      setMessages([
                        {
                          id: "1",
                          content: getPersonalizedWelcome(),
                          role: "assistant",
                          timestamp: new Date(),
                        }
                      ]);
                      toast.success("Started new conversation!");
                    }}
                    className="px-2 sm:px-3 py-2 bg-slate-800/50 hover:bg-slate-700/50 rounded-lg border border-slate-700/50 text-xs sm:text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                    aria-label="New Chat (Ctrl+N)"
                  >
                    <span className="hidden sm:inline">New Chat</span>
                    <Plus className="w-4 h-4 sm:hidden" />
                  </RippleButton>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Start a new chat (Ctrl/Cmd + N)</p>
                </TooltipContent>
              </Tooltip>

              {/* Current Model */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <RippleButton
                    onClick={() => setShowShareModal(true)}
                    className="p-2 bg-slate-800/50 hover:bg-slate-700/50 rounded-lg border border-slate-700/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                    aria-label="Share or export conversation"
                  >
                    <Share2 className="w-3 h-3 sm:w-4 sm:h-4" />
                  </RippleButton>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Share or export conversation</p>
                </TooltipContent>
              </Tooltip>
              {/* Mic status indicator and Speech Settings */}
              {speechAvailable && (
                <div className="hidden sm:flex items-center gap-2">
                  <MicPermissionBadge />
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={() => setShowEditModal(true)}
                        className="p-2 bg-slate-800/50 hover:bg-slate-700/50 rounded-lg border border-slate-700/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                        aria-label="Speech settings"
                      >
                        <Volume2 className="w-3 h-3 sm:w-4 sm:h-4" />
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Speech settings</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
              )}
              <Tooltip>
                <TooltipTrigger asChild>
                  <RippleButton
                    onClick={() => setShowEditModal(true)}
                    className="p-2 bg-slate-800/50 hover:bg-slate-700/50 rounded-lg border border-slate-700/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                    aria-label="Open AI provider settings"
                  >
                    <Settings className="w-3 h-3 sm:w-4 sm:h-4" />
                  </RippleButton>
                </TooltipTrigger>
                <TooltipContent>
                  <p>AI provider settings</p>
                </TooltipContent>
              </Tooltip>
              
              {/* DEV: Test Credit Purchase Button */}
              {/*<Tooltip>
                <TooltipTrigger asChild>
                  <RippleButton
                    onClick={() => {
                      // Create a test credit limit message to trigger the popup
                      const testCreditMessage: Message = {
                        id: (Date.now() + 1).toString(),
                        content: "You've reached your credit limit. Purchase more credits to continue chatting.",
                        role: "assistant",
                        timestamp: new Date(),
                        isCreditLimit: true,
                        metadata: {
                          code: 'INSUFFICIENT_CREDITS',
                          currentBalance: 0,
                          messagesUsed: 10,
                          monthlyAllowance: 10,
                          isFreemium: true,
                          creditsRequired: 1,
                          isTeamPooled: false,
                          purchaseUrl: '/settings/billing/credits',
                          upgradeUrl: '/pricing',
                          message: 'You have used all your free messages for this month.'
                        }
                      };
                      setMessages(prev => [...prev, testCreditMessage]);
                      toast.info("Test credit limit message added to chat");
                    }}
                    className="p-2 bg-amber-600/20 hover:bg-amber-600/30 rounded-lg border border-amber-500/30 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-amber-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950"
                    aria-label="Test credit purchase popup"
                  >
                    <CreditCard className="w-4 h-4 text-amber-400" />
                  </RippleButton>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Test credit purchase popup (DEV)</p>
                </TooltipContent>
              </Tooltip>*/}
            </div>
          </div>
        </motion.header>

        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-4 sm:p-6">
          <div className="max-w-4xl mx-auto space-y-4 sm:space-y-6">
            <AnimatePresence>
              {messages.map((message) => (
                <motion.div
                  key={message.id}
                  layout
                  className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
                >
                  <div className="relative max-w-[80%]">
                    {message.isCreditLimit ? (
                      <CreditLimitMessage 
                        message={message}
                        onUpgrade={handleUpgradeToPro}
                        onPurchaseCredits={handlePurchaseCredits}
                      />
                    ) : (
                      <HolographicBubble isUser={message.role === 'user'}>
                        <div className="space-y-2">
                          <p className="text-sm leading-relaxed">{message.content}</p>
                          {message.attachments && (
                            <div className="flex flex-wrap gap-2">
                              {message.attachments.map((file, index) => (
                                <div
                                  key={index}
                                  className="flex items-center gap-2 px-2 py-1 bg-slate-700/50 rounded text-xs"
                                >
                                  <FileUp className="w-3 h-3" />
                                  {file}
                                </div>
                              ))}
                            </div>
                          )}
                          {/* Render sources for the latest assistant message */}
                          {message.role === 'assistant' && message.id === messages[messages.length - 1]?.id && latestSources.length > 0 && (
                            <SourcesList sources={latestSources} />
                          )}

                          <div className="flex items-center justify-between text-xs text-slate-400">
                            <span>{message.timestamp.toLocaleTimeString()}</span>
                            {message.role === 'assistant' && (
                              <div className="flex items-center gap-2">
                                {speechAvailable && message.content && (
                                  <button
                                    onClick={() => handleSpeak(message.id, message.content)}
                                    className="p-1 hover:bg-slate-600/50 rounded transition-colors"
                                    title={speakingMessageId === message.id ? "Stop speaking" : "Read aloud"}
                                  >
                                    {speakingMessageId === message.id ? (
                                      <VolumeX className="w-3 h-3 text-blue-400" />
                                    ) : (
                                      <Volume2 className="w-3 h-3" />
                                    )}
                                  </button>
                                )}
                                <div className="flex items-center gap-1">
                                  <Cpu className="w-3 h-3" />
                                  <span>AI</span>
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      </HolographicBubble>
                    )}
                    
                    {activeMessage === message.id && (
                      <NeuralNetworkPulse isActive />
                    )}
                  </div>
                </motion.div>
              ))}
            </AnimatePresence>
            
            {isTyping && <TypingIndicator />}
            <div ref={messagesEndRef} />
          </div>
        </div>

        {/* Input Area */}
        <motion.div
          className="p-4 sm:p-6 border-t border-slate-800/50 backdrop-blur-xl"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="max-w-4xl mx-auto">
            {/* Command Suggestions */}
            <AnimatePresence>
              {showCommands && (
                <motion.div
                  className="mb-4 p-4 bg-slate-900/50 backdrop-blur-xl rounded-xl border border-slate-700/50"
                  initial={{ opacity: 0, height: 0 }}
                  animate={{ opacity: 1, height: "auto" }}
                  exit={{ opacity: 0, height: 0 }}
                >
                  <div className="grid grid-cols-2 gap-2">
                    {commandSuggestions.map((command) => {
                      const isAvailable = isCommandAvailable(command.prefix, modelCapabilities);
                      const isLoading = isLoadingCapabilities;
                      const buttonContent = (
                        <RippleButton
                          key={command.prefix}
                          onClick={() => isAvailable && !isLoading && selectCommand(command)}
                          disabled={!isAvailable || isLoading}
                          className={`flex items-center gap-3 p-3 rounded-lg border text-left transition-all duration-200 ${
                            isAvailable && !isLoading
                              ? "bg-slate-800/50 hover:bg-slate-700/50 border-slate-700/30 cursor-pointer"
                              : "bg-slate-900/30 border-slate-800/30 cursor-not-allowed opacity-50"
                          }`}
                        >
                          <div className={`${isAvailable && !isLoading ? "text-violet-400" : "text-slate-500"}`}>
                            {isLoading ? <Loader2 className="w-4 h-4 animate-spin" /> : command.icon}
                          </div>
                          <div>
                            <div className={`text-sm font-medium ${isAvailable && !isLoading ? "text-white" : "text-slate-500"}`}>
                              {command.label}
                            </div>
                            <div className={`text-xs ${isAvailable && !isLoading ? "text-slate-400" : "text-slate-600"}`}>
                              {isLoading 
                                ? "Checking capabilities..." 
                                : isAvailable 
                                  ? command.description 
                                  : "Not available with current model"
                              }
                            </div>
                          </div>
                        </RippleButton>
                      );

                      if (!isAvailable && !isLoading) {
                        const getRequiredCapability = (prefix: string) => {
                          switch (prefix) {
                            case "/clone": return "vision";
                            case "/page": return "code generation";
                            case "/improve": return "code generation";
                            case "/analyze": return "analysis";
                            default: return "unknown";
                          }
                        };

                        return (
                          <TooltipProvider key={command.prefix}>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                {buttonContent}
                              </TooltipTrigger>
                              <TooltipContent side="top" className="bg-slate-800 border-slate-700">
                                <p className="text-sm">
                                  This feature requires {getRequiredCapability(command.prefix)} capabilities.
                                  <br />
                                  Current model: <span className="font-medium">{selectedLLMModel?.name || currentModel}</span>
                                  <br />
                                  Try switching to a model with {getRequiredCapability(command.prefix)} support.
                                </p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        );
                      }

                      // Add tooltips for available commands
                      return (
                        <TooltipProvider key={command.prefix}>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              {buttonContent}
                            </TooltipTrigger>
                            <TooltipContent side="top" className="bg-slate-800 border-slate-700">
                              <p className="text-sm">
                                {command.description}
                                <br />
                                <span className="text-violet-400 font-medium">Click to use {command.prefix}</span>
                              </p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      );
                    })}
                  </div>
                </motion.div>
              )}
            </AnimatePresence>

            {/* Attachments */}
            <AnimatePresence>
              {attachments.length > 0 && (
                <motion.div
                  className="mb-4 flex flex-wrap gap-2"
                  initial={{ opacity: 0, height: 0 }}
                  animate={{ opacity: 1, height: "auto" }}
                  exit={{ opacity: 0, height: 0 }}
                >
                  {attachments.map((file, index) => (
                    <motion.div
                      key={index}
                      className="flex items-center gap-2 px-3 py-2 bg-slate-800/50 rounded-lg border border-slate-700/50"
                      initial={{ opacity: 0, scale: 0.8 }}
                      animate={{ opacity: 1, scale: 1 }}
                      exit={{ opacity: 0, scale: 0.8 }}
                    >
                      <FileUp className="w-4 h-4 text-violet-400" />
                      <span className="text-sm">{file}</span>
                      <RippleButton
                        onClick={() => removeAttachment(index)}
                        className="p-1 text-slate-400 hover:text-white"
                      >
                        <X className="w-3 h-3" />
                      </RippleButton>
                    </motion.div>
                  ))}
                </motion.div>
              )}
            </AnimatePresence>

            {/* Error Display */}
            {error && !error.includes('Subscription error:') && (
              <motion.div
                className="mb-4 p-4 bg-red-900/20 backdrop-blur-xl rounded-xl border border-red-500/30"
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: "auto" }}
                exit={{ opacity: 0, height: 0 }}
              >
                <div className="flex items-center gap-3">
                  <AlertCircle className="w-5 h-5 text-red-400" />
                  <div className="flex-1">
                    <p className="text-sm text-red-200">{error}</p>
                  </div>
                  <RippleButton
                    onClick={clearError}
                    className="p-1 text-red-400 hover:text-red-200"
                  >
                    <X className="w-4 h-4" />
                  </RippleButton>
                </div>
              </motion.div>
            )}

            {/* Input */}
            <div className="relative">
              <div className="flex flex-col sm:flex-row sm:items-end gap-3 sm:gap-4 p-4 bg-slate-900/50 backdrop-blur-xl rounded-2xl border border-slate-700/50">
                {/* Action Buttons Row - Mobile: Top row, Desktop: Left side */}
                <div className="flex gap-2 items-center justify-start pb-2 sm:pb-0">
                  {/* Quick Provider & Model Selector */}
                  <div className="flex-shrink-0">
                    <AIProviderQuickSelector />
                  </div>
                  <div className="w-px h-6 sm:h-8 bg-slate-700 flex-shrink-0" /> {/* Divider */}
                  
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={() => setShowCommands(!showCommands)}
                        className="p-2 text-slate-400 hover:text-violet-400 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                        aria-label="Toggle quick commands"
                      >
                        <Command className="w-4 h-4 sm:w-5 sm:h-5" />
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Quick commands & shortcuts</p>
                    </TooltipContent>
                  </Tooltip>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={() => setShowSystemMessageModal(true)}
                        className="p-2 text-slate-400 hover:text-violet-400 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                        aria-label="Change AI personality"
                      >
                        <Brain className="w-4 h-4 sm:w-5 sm:h-5" />
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Change AI personality & style</p>
                    </TooltipContent>
                  </Tooltip>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={() => setShowFileManager(true)}
                        className="p-2 text-slate-400 hover:text-violet-400 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0"
                        aria-label="Open file manager"
                      >
                        <Files className="w-4 h-4 sm:w-5 sm:h-5" />
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Manage files & uploads</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                
                {/* Input Row - Mobile: Bottom row, Desktop: Center + Right */}
                <div className="flex items-end gap-3 flex-1">
                  <div className="flex-1">
                    <textarea
                      ref={inputRef}
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Type your message or use / for commands..."
                      className="w-full bg-transparent text-white placeholder-slate-400 resize-none focus:outline-none min-h-[40px] max-h-32"
                      rows={1}
                      disabled={isLoading}
                    />
                  </div>
                  
                  {/* Voice Input Button */}
                  {speechAvailable && (
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <RippleButton
                          onClick={handleVoiceInput}
                          className={`p-2 ${isRecording ? 'text-red-400 animate-pulse' : 'text-slate-400 hover:text-violet-400'} transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 flex-shrink-0`}
                          aria-label={isRecording ? "Stop recording" : "Start voice input"}
                        >
                          {isRecording ? (
                            <MicOff className="w-4 h-4 sm:w-5 sm:h-5" />
                          ) : (
                            <Mic className="w-4 h-4 sm:w-5 sm:h-5" />
                          )}
                        </RippleButton>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>
                          {isRecording ? "Stop recording" : "Start voice input"}
                          {!isHTTPS && microphonePermission !== 'granted' && (
                            <span className="block text-xs text-yellow-400 mt-1">
                              ‚ö†Ô∏è HTTPS required for continuous access
                            </span>
                          )}
                        </p>
                      </TooltipContent>
                    </Tooltip>
                  )}
                  
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={handleSend}
                        disabled={(!input.trim() && attachments.length === 0) || isLoading}
                        className="p-3 bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 rounded-xl transition-all duration-200 flex-shrink-0"
                      >
                        {isLoading ? (
                          <Loader2 className="w-4 h-4 sm:w-5 sm:h-5 animate-spin" />
                        ) : (
                          <Send className="w-4 h-4 sm:w-5 sm:h-5" />
                        )}
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>{isLoading ? "AI is thinking..." : "Send message (Enter)"}</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
              </div>
            </div>
          </div>
        </motion.div>
      </div>

      {/* Modals */}
      <OrigamiModal
        isOpen={showShareModal}
        onClose={() => setShowShareModal(false)}
        title="Share Conversation"
      >
        <div className="space-y-6">
          <div>
            <p className="text-slate-300 mb-4">Export and share your chat transcript</p>
            
            {/* Download Transcript */}
            <div className="space-y-3">
              <h4 className="text-sm font-medium text-slate-200">Download Transcript</h4>
              <RippleButton
                onClick={handleDownloadTranscript}
                className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-lg text-white transition-colors"
                aria-label="Download chat transcript as text file"
              >
                <Download className="w-4 h-4" />
                Download as .txt file
              </RippleButton>
              <p className="text-xs text-slate-400">
                Downloads a formatted text file with your complete conversation
              </p>
            </div>

            {/* Share Options */}
            <div className="space-y-3">
              <h4 className="text-sm font-medium text-slate-200">Share Options</h4>
              <div className="grid grid-cols-1 gap-2">
                {isWebShareSupported() && (
                  <RippleButton
                    onClick={handleShareTranscript}
                    className="flex items-center justify-center gap-2 px-4 py-3 bg-violet-600/80 hover:bg-violet-600 border border-violet-500/50 rounded-lg text-white transition-colors"
                    aria-label="Share transcript using system share dialog"
                  >
                    <ExternalLink className="w-4 h-4" />
                    Share Transcript
                  </RippleButton>
                )}
                <RippleButton
                  onClick={handleCopyTranscript}
                  className="flex items-center justify-center gap-2 px-4 py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-lg text-white transition-colors"
                  aria-label="Copy transcript to clipboard"
                >
                  <Copy className="w-4 h-4" />
                  Copy to Clipboard
                </RippleButton>
              </div>
              <p className="text-xs text-slate-400">
                {isWebShareSupported() 
                  ? "Use your device's native sharing options or copy to clipboard"
                  : "Copy the transcript text to share via your preferred method"
                }
              </p>
            </div>
          </div>
        </div>
      </OrigamiModal>

      <OrigamiModal
        isOpen={showEditModal}
        onClose={() => setShowEditModal(false)}
        title="Uterpi Settings & Status"
      >
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              Streaming Mode
            </label>
            <div className="flex items-center gap-3">
              <Tooltip>
                <TooltipTrigger asChild>
                  <RippleButton
                    onClick={() => setEnableStreaming(!enableStreaming)}
                    className={`p-2 rounded-lg transition-colors ${
                      enableStreaming 
                        ? "bg-violet-600 text-white" 
                        : "bg-slate-800 text-slate-400"
                    }`}
                  >
                    {enableStreaming ? "Enabled" : "Disabled"}
                  </RippleButton>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{enableStreaming ? "Disable real-time streaming" : "Enable real-time streaming"}</p>
                </TooltipContent>
              </Tooltip>
              <span className="text-sm text-slate-400">
                {enableStreaming ? "Real-time responses" : "Wait for complete response"}
              </span>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              Azure AI Status
            </label>
            <div className="flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${error ? "bg-red-500" : "bg-green-500"}`} />
              <span className="text-sm text-slate-300">
                {error ? "Configuration Error" : "Connected"}
              </span>
            </div>
            {error && (
              <p className="text-xs text-red-400 mt-1">
                Check your .env file for proper Azure AI configuration
              </p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              Model Selection
            </label>
            <div className="p-3 bg-slate-800 rounded-lg">
              {/* Streamlined Provider & Model Selector */}
              <AIProviderQuickSelector />
            </div>
            <div className="mt-2">
              <p className="text-xs text-slate-400">
                AzureAI API: {import.meta.env.VITE_AZURE_AI_ENDPOINT ? "Configured" : "Not configured"}
              </p>
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
            Uterpi Terms & Conditions
            </label>
            <div className="text-xs text-slate-400 space-y-1 max-h-32 overflow-y-auto">
              <p className="text-sm font-thin text-slate-300 mb-2 text-center">By using Uterpi, you agree to the following terms & conditions:</p>
              <p>1. Uterpi is an ongoing project; always check AI responses for accuracy.</p>
              <p>2. Uterpi is not responsible for any damage caused by the use of Uterpi.</p>
              <p>3. Uterpi is not responsible for any data loss or corruption caused by the use of Uterpi.</p>
              <p>4. Uterpi is not responsible for any legal issues caused by the use of Uterpi.</p>
              <p>5. Uterpi is not responsible for any ethical issues caused by the use of Uterpi.</p>
              <p>6. Uterpi is not responsible for any issues caused by the use of Uterpi.</p>
            </div>
          </div>
        </div>
      </OrigamiModal>

      {/* System Message Modal */}
      <AnimatePresence>
        {showSystemMessageModal && (
          <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center p-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <motion.div
              className="absolute inset-0 bg-black/60 backdrop-blur-sm"
              onClick={() => setShowSystemMessageModal(false)}
            />
            <motion.div
              className="relative bg-slate-900/90 backdrop-blur-xl border border-slate-700/50 rounded-2xl p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto"
              initial={{ scale: 0, rotateX: -90 }}
              animate={{ scale: 1, rotateX: 0 }}
              exit={{ scale: 0, rotateX: 90 }}
              transition={{ type: "spring", damping: 20, stiffness: 300 }}
              style={{ transformStyle: "preserve-3d" }}
            >
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-xl font-semibold text-white">AI Personality & Style</h3>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <RippleButton
                      onClick={() => setShowSystemMessageModal(false)}
                      className="p-2 text-slate-400 hover:text-white rounded-lg"
                    >
                      <X className="w-5 h-5" />
                    </RippleButton>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Close personality settings</p>
                  </TooltipContent>
                </Tooltip>
              </div>
              
              <div className="space-y-6">
                <SystemMessageSelector
                  selectedPreset={selectedSystemPreset}
                  customMessage={customSystemMessage}
                  onPresetChange={handleSystemPresetChange}
                />
                
                {selectedSystemPreset === "custom" && (
                  <div className="space-y-3 p-4 bg-slate-800/30 backdrop-blur-sm rounded-lg border border-slate-600/50">
                    <label className="block text-sm font-medium text-white">
                      Custom System Message
                    </label>
                    <textarea
                      value={customSystemMessage}
                      onChange={(e) => setCustomSystemMessage(e.target.value)}
                      placeholder="Enter your custom system message..."
                      className="w-full h-32 px-3 py-2 bg-slate-900/50 border border-slate-700 rounded-lg text-white placeholder-slate-400 resize-none focus:outline-none focus:ring-2 focus:ring-violet-500"
                    />
                  </div>
                )}
                
                <div className="flex justify-end gap-3 pt-4 border-t border-slate-600">
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <RippleButton
                        onClick={() => setShowSystemMessageModal(false)}
                        className="px-6 py-2 bg-violet-600 hover:bg-violet-700 rounded-lg text-white font-medium"
                      >
                        Apply Settings
                      </RippleButton>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Apply personality changes and close</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>


      {/* Enhanced Feature Modals */}
      <CloneUIModal 
        isOpen={showCloneUIModal} 
        onClose={() => setShowCloneUIModal(false)} 
      />
      
      <CreatePageModal 
        isOpen={showCreatePageModal} 
        onClose={() => setShowCreatePageModal(false)} 
      />
      
      <ImproveModal 
        isOpen={showImproveModal} 
        onClose={() => setShowImproveModal(false)} 
      />
      
      <AnalyzeModal 
        isOpen={showAnalyzeModal} 
        onClose={() => setShowAnalyzeModal(false)} 
      />

      {/* File Manager Modal */}
      <AnimatePresence>
        {showFileManager && (
          <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center p-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            {/* Backdrop */}
            <motion.div
              className="absolute inset-0 bg-black/60 backdrop-blur-sm"
              onClick={() => setShowFileManager(false)}
            />
            
            {/* Modal */}
            <motion.div
              className="relative bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-slate-700/50 shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden"
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.9, opacity: 0 }}
            >
              <div className="flex items-center justify-between p-6 border-b border-slate-700/50">
                <h2 className="text-2xl font-bold text-white">File Manager</h2>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <button
                      onClick={() => setShowFileManager(false)}
                      className="p-2 text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition-colors"
                      aria-label="Close File Manager"
                    >
                      <X className="w-5 h-5" />
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Close file manager</p>
                  </TooltipContent>
                </Tooltip>
              </div>
              <div className="p-6 max-h-[calc(90vh-120px)] overflow-auto">
                <FileManager 
                  onFileSelect={(file) => {
                    setAttachments(prev => [...prev, file.name]);
                    setAttachedFileIds(prev => [...prev, file.id]);
                    setShowFileManager(false);
                    toast.success(`Attached "${file.name}"`);
                  }}
                />
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

    </div>
    </TooltipProvider>
  );
};

export default FuturisticAIChat;

================
File: client/src/components/CheckoutPages.tsx
================
/**
 * Checkout Success and Cancel Pages
 * Handle Stripe Checkout Session redirects
 */

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CheckCircle2, XCircle, Loader2, Home, CreditCard } from 'lucide-react';
import { navigateTo } from './Router';
import { useAuth } from '@/hooks/useAuth';

interface CheckoutSession {
  id: string;
  status: string;
  mode: 'subscription' | 'payment';
  amountTotal: number;
  currency: string;
  customerEmail: string;
  paymentStatus: string;
  metadata: {
    userId: string;
    tier?: string;
    interval?: string;
    type?: string;
    credits?: string;
  };
}

export const CheckoutSuccessPage: React.FC = () => {
  const { user } = useAuth();
  const [session, setSession] = useState<CheckoutSession | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const sessionId = urlParams.get('session_id');

    if (!sessionId) {
      setError('No checkout session found');
      setLoading(false);
      return;
    }

    fetchSessionDetails(sessionId);
  }, []);

  const fetchSessionDetails = async (sessionId: string) => {
    try {
      const response = await fetch(`/api/checkout/session/${sessionId}`, {
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error('Failed to fetch checkout session details');
      }

      const data = await response.json();
      setSession(data.session);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load checkout details');
    } finally {
      setLoading(false);
    }
  };

  const formatAmount = (amount: number, currency: string) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency.toUpperCase(),
    }).format(amount / 100);
  };

  const getSuccessMessage = () => {
    if (!session) return '';

    if (session.mode === 'subscription') {
      const tier = session.metadata.tier;
      const interval = session.metadata.interval;
      return `Your ${tier} ${interval}ly subscription has been activated!`;
    } else {
      const credits = session.metadata.credits;
      return `${credits} AI credits have been added to your account!`;
    }
  };

  const getSuccessDetails = () => {
    if (!session) return '';

    if (session.mode === 'subscription') {
      return 'You now have access to all premium features. Welcome aboard!';
    } else {
      return 'Your credits are ready to use and never expire.';
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
        <Card className="w-full max-w-md mx-auto bg-slate-900 border-slate-700">
          <CardContent className="flex flex-col items-center justify-center p-8">
            <Loader2 className="h-8 w-8 animate-spin mb-4 text-violet-400" />
            <p className="text-lg font-medium text-white">Processing your payment...</p>
            <p className="text-sm text-slate-400 text-center mt-2">
              Please wait while we confirm your purchase details.
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (error || !session) {
    return (
      <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
        <Card className="w-full max-w-md mx-auto bg-slate-900 border-slate-700">
          <CardHeader className="text-center">
            <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-red-100">
              <XCircle className="h-8 w-8 text-red-600" />
            </div>
            <CardTitle className="text-white">Payment Error</CardTitle>
            <CardDescription className="text-slate-400">
              {error || 'Unable to verify your payment. Please contact support if you were charged.'}
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button 
              onClick={() => navigateTo('/pricing')} 
              className="w-full"
              variant="outline"
            >
              <CreditCard className="mr-2 h-4 w-4" />
              Back to Pricing
            </Button>
            <Button 
              onClick={() => navigateTo('/')} 
              className="w-full"
              variant="secondary"
            >
              <Home className="mr-2 h-4 w-4" />
              Return Home
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
      <Card className="w-full max-w-md mx-auto bg-slate-900 border-slate-700">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-green-100">
            <CheckCircle2 className="h-8 w-8 text-green-600" />
          </div>
          <CardTitle className="text-white">Payment Successful!</CardTitle>
          <CardDescription className="text-slate-400">
            {getSuccessMessage()}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Payment Details */}
          <div className="bg-slate-800 rounded-lg p-4 space-y-3">
            <div className="flex justify-between items-center">
              <span className="text-sm text-slate-400">Amount Paid:</span>
              <span className="font-semibold text-white">
                {formatAmount(session.amountTotal, session.currency)}
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-sm text-slate-400">Payment Status:</span>
              <span className="text-green-400 capitalize">{session.paymentStatus}</span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-sm text-slate-400">Email:</span>
              <span className="text-white text-sm">{session.customerEmail || user?.email}</span>
            </div>
          </div>

          {/* Success Message */}
          <div className="text-center">
            <p className="text-slate-300 mb-4">
              {getSuccessDetails()}
            </p>
          </div>

          {/* Action Buttons */}
          <div className="space-y-3">
            <Button 
              onClick={() => navigateTo('/')} 
              className="w-full bg-violet-600 hover:bg-violet-700"
            >
              <Home className="mr-2 h-4 w-4" />
              Go to Dashboard
            </Button>
            {session.mode === 'subscription' && (
              <Button 
                onClick={() => navigateTo('/settings/billing')} 
                className="w-full"
                variant="outline"
              >
                <CreditCard className="mr-2 h-4 w-4" />
                Manage Subscription
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export const CheckoutCancelPage: React.FC = () => {
  return (
    <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
      <Card className="w-full max-w-md mx-auto bg-slate-900 border-slate-700">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-orange-100">
            <XCircle className="h-8 w-8 text-orange-600" />
          </div>
          <CardTitle className="text-white">Payment Cancelled</CardTitle>
          <CardDescription className="text-slate-400">
            Your payment was cancelled. No charges have been made to your account.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="text-center text-slate-300 mb-6">
            <p>You can try again anytime or explore our free features.</p>
          </div>
          
          <div className="space-y-3">
            <Button 
              onClick={() => navigateTo('/pricing')} 
              className="w-full bg-violet-600 hover:bg-violet-700"
            >
              <CreditCard className="mr-2 h-4 w-4" />
              Back to Pricing
            </Button>
            <Button 
              onClick={() => navigateTo('/')} 
              className="w-full"
              variant="outline"
            >
              <Home className="mr-2 h-4 w-4" />
              Continue with Free Plan
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

================
File: client/src/components/CloneUIModal.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Upload, 
  ImageIcon, 
  X, 
  Check, 
  Loader2, 
  Download, 
  Copy, 
  Eye,
  Sparkles,
  Zap,
  Code,
  FolderOpen,
  AlertCircle,
  Settings
} from 'lucide-react';
import { useFileManager, type FileItem } from '../hooks/useFileManager';
import { useAIProvider } from '../hooks/useAIProvider';
import { toast } from 'sonner';
import { AICreditsDisplay } from './AICreditsDisplay';
import { Badge } from './ui/badge';
import { Button } from './ui/button';

interface CloneUIModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface AnalysisResult {
  components: Array<{ type: string; description: string; complexity?: string }>;
  colorPalette: string[] | {
    primary?: string;
    secondary?: string;
    accent?: string;
    background?: string;
    text?: string;
    additional?: string[];
    [key: string]: string | string[] | undefined;
  };
  layout: string | {
    system?: string;
    structure?: string;
    responsive?: string;
  };
  estimatedComplexity: string;
  typography?: {
    primary?: string;
    secondary?: string;
    sizes?: string[];
  };
  implementationNotes?: string[];
}

interface GenerationResult {
  success: boolean;
  analysis: AnalysisResult;
  generatedCode: string;
  metadata?: {
    model?: string;
    provider?: string;
    responseTime?: string;
    creditsUsed?: number;
    tokensUsed?: number;
    cached?: boolean;
    analysisTime?: number;
  };
}

interface ImageFileManagerModalProps {
  onFileSelect: (file: FileItem) => void;
  selectedFile: FileItem | null;
  preview: string | null;
}

// Provider status header component
interface ProviderStatusHeaderProps {
  currentProvider: any;
  selectedLLMModel: any;
  isProviderConfigured: (provider: any) => boolean;
}

const ProviderStatusHeader: React.FC<ProviderStatusHeaderProps> = ({ 
  currentProvider, 
  selectedLLMModel, 
  isProviderConfigured 
}) => {
  const providerNames: { [key: string]: string } = {
    lmstudio: 'Uterpi AI',
    uterpi: 'Uterpi',
    openai: 'OpenAI',
    gemini: 'Google Gemini', 
    huggingface: 'Hugging Face'
  };

  const isConfigured = isProviderConfigured(currentProvider);
  
  return (
    <div className="flex items-center justify-between mb-4 p-3 bg-slate-800/30 rounded-lg">
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-2">
          <span className="text-sm text-slate-400">AI Provider:</span>
          <Badge 
            variant="outline" 
            className={`${isConfigured ? 'text-violet-400 border-violet-400/50' : 'text-orange-400 border-orange-400/50'}`}
          >
            {providerNames[currentProvider] || currentProvider}
          </Badge>
          {!isConfigured && (
            <div className="flex items-center gap-1 text-orange-400">
              <AlertCircle className="w-4 h-4" />
              <span className="text-xs">Not configured</span>
            </div>
          )}
        </div>
        {selectedLLMModel && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-slate-400">Model:</span>
            <span className="text-sm text-white">{selectedLLMModel.name}</span>
          </div>
        )}
      </div>
      <div className="flex items-center gap-3">
        <AICreditsDisplay compact={true} />
        <Button
          variant="ghost"
          size="sm"
          onClick={() => {
            // Navigate to provider settings - you may need to implement this navigation
            toast.info('Provider settings - implement navigation');
          }}
          className="p-1 h-auto text-slate-400 hover:text-white"
        >
          <Settings className="w-4 h-4" />
        </Button>
      </div>
    </div>
  );
};

const ImageFileManagerModal: React.FC<ImageFileManagerModalProps> = ({ onFileSelect, selectedFile, preview }) => {
  const fileManager = useFileManager();
  const [searchQuery, setSearchQuery] = useState('');
  
  // Enhanced file filtering with better image support
  const { data: fileList, isLoading } = fileManager.useFileList({
    search: searchQuery || undefined,
    mimeType: 'image/',
    limit: 50 // Show more images
  });

  const imageFiles = fileList?.files.filter(file => 
    file.mimeType.startsWith('image/') && 
    ['image/jpeg', 'image/png', 'image/webp', 'image/gif'].includes(file.mimeType)
  ) || [];

  return (
    <div className="space-y-4">
      {/* Enhanced search with filters */}
      <div className="space-y-3">
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search your images..."
          className="w-full p-3 bg-slate-800/50 border border-slate-600 rounded-lg text-white placeholder-slate-400 focus:border-violet-400 focus:outline-none"
        />
        
        {/* File type filters */}
        <div className="flex gap-2 text-xs">
          <Badge variant="outline" className="text-slate-400">
            {imageFiles.length} images found
          </Badge>
          <Badge variant="outline" className="text-slate-400">
            Supported: JPG, PNG, WebP, GIF
          </Badge>
        </div>
      </div>

      {/* Enhanced preview section */}
      {preview && selectedFile && (
        <div className="p-4 bg-slate-800/50 border border-violet-400 rounded-lg">
          <div className="flex items-start space-x-4">
            <img
              src={preview}
              alt="Selected"
              className="w-24 h-24 object-cover rounded border border-slate-600"
            />
            <div className="flex-1">
              <h3 className="font-medium text-violet-400">{selectedFile.name}</h3>
              <div className="space-y-1 text-sm text-slate-400">
                <p>{(selectedFile.size / 1024).toFixed(1)} KB ‚Ä¢ {selectedFile.mimeType}</p>
                <p>Selected for analysis</p>
              </div>
              <Badge variant="outline" className="mt-2 text-green-400 border-green-400/50">
                Ready for Analysis
              </Badge>
            </div>
          </div>
        </div>
      )}

      <div className="max-h-64 overflow-y-auto border border-slate-600 rounded-lg">
        {isLoading ? (
          <div className="p-8 text-center">
            <div className="animate-spin w-6 h-6 border-2 border-violet-400 border-t-transparent rounded-full mx-auto mb-2"></div>
            <p className="text-slate-400">Loading images...</p>
          </div>
        ) : imageFiles.length === 0 ? (
          <div className="p-8 text-center text-slate-400">
            <ImageIcon className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No images found</p>
            <p className="text-sm">Upload some UI screenshots first</p>
          </div>
        ) : (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-3 p-4">
            {imageFiles.map((file) => (
              <button
                key={file.id}
                onClick={() => onFileSelect(file)}
                className={`relative group rounded-lg overflow-hidden border-2 transition-all ${
                  selectedFile?.id === file.id 
                    ? 'border-violet-400 ring-2 ring-violet-400/20' 
                    : 'border-slate-600 hover:border-slate-500'
                }`}
              >
                <div className="aspect-square bg-slate-800 relative">
                  {/* Enhanced image preview */}
                  <img 
                    src={`/api/files/${file.id}/download`}
                    alt={file.name}
                    className="w-full h-full object-cover"
                    loading="lazy"
                    onError={(e) => {
                      // Fallback to icon if image fails to load
                      e.currentTarget.classList.add('hidden');
                      const fallback = e.currentTarget.nextElementSibling as HTMLElement;
                      if (fallback) fallback.classList.remove('hidden');
                    }}
                  />
                  <div className="hidden w-full h-full items-center justify-center absolute inset-0 bg-slate-800">
                    <ImageIcon className="w-8 h-8 text-slate-400" />
                  </div>
                </div>
                
                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                  <p className="text-xs text-white truncate">{file.name}</p>
                  <p className="text-xs text-slate-300">
                    {(file.size / 1024).toFixed(1)} KB
                  </p>
                </div>
                
                {selectedFile?.id === file.id && (
                  <div className="absolute top-2 right-2">
                    <Check className="w-4 h-4 text-violet-400 bg-slate-900/80 rounded-full p-0.5" />
                  </div>
                )}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

const CloneUIModal: React.FC<CloneUIModalProps> = ({ isOpen, onClose }) => {
  const [step, setStep] = useState<'upload' | 'analyzing' | 'results'>('upload');
  const [inputMethod, setInputMethod] = useState<'upload' | 'select'>('upload');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [selectedStoredFile, setSelectedStoredFile] = useState<FileItem | null>(null);
  const [dragActive, setDragActive] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<GenerationResult | null>(null);
  const [preview, setPreview] = useState<string | null>(null);
  const [estimatedCredits] = useState(15); // UI analysis typically costs ~15 credits
  
  const fileManager = useFileManager();
  const {
    currentProvider,
    selectedLLMModel,
    isProviderConfigured
  } = useAIProvider();

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    const files = e.dataTransfer.files;
    if (files?.[0] && files[0].type.startsWith('image/')) {
      handleFileSelect(files[0]);
    }
  }, []);

  const handleFileSelect = (file: File) => {
    setSelectedFile(file);
    
    // Create preview
    const reader = new FileReader();
    reader.onload = (e) => {
      setPreview(e.target?.result as string);
    };
    reader.readAsDataURL(file);
  };

  const handleStoredImageSelect = async (file: FileItem) => {
    setSelectedStoredFile(file);
    setSelectedFile(null); // Clear any uploaded file
    
    try {
      // Get image content as blob URL for preview
      const response = await fetch(`/api/files/${file.id}/download`);
      if (response.ok) {
        const blob = await response.blob();
        const previewUrl = URL.createObjectURL(blob);
        setPreview(previewUrl);
        toast.success(`Image "${file.name}" selected successfully`);
      }
    } catch (error) {
      toast.error('Failed to load image preview');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const analyzeImage = async () => {
    if (!selectedFile && !selectedStoredFile) return;

    // Check if current provider is configured
    if (!isProviderConfigured(currentProvider)) {
      toast.error(`${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} is not properly configured. Please check your settings.`);
      return;
    }

    setStep('analyzing');

    try {
      const formData = new FormData();
      
      // Handle both uploaded and stored files
      if (selectedFile) {
        formData.append('image', selectedFile);
      } else if (selectedStoredFile) {
        // Get the file blob from storage for stored files
        const response = await fetch(`/api/files/${selectedStoredFile.id}/download`);
        if (!response.ok) {
          throw new Error('Failed to retrieve stored image');
        }
        const blob = await response.blob();
        formData.append('image', blob, selectedStoredFile.name);
      }
      
      // Use current provider from AI provider system
      formData.append('provider', currentProvider);
      
      // Add API keys if needed (for providers that require them)
      if (currentProvider === 'gemini') {
        const apiKey = localStorage.getItem('gemini-api-key');
        if (apiKey) formData.append('apiKey', apiKey);
      } else if (currentProvider === 'openai') {
        const apiKey = localStorage.getItem('openai-api-key');
        if (apiKey) formData.append('apiKey', apiKey);
      } else if (currentProvider === 'huggingface') {
        const apiKey = localStorage.getItem('hf-api-token');
        if (apiKey) formData.append('apiKey', apiKey);
      }

      const response = await fetch('/api/clone-ui/analyze', {
        method: 'POST',
        body: formData,
      });

      if (response.ok) {
        const result: GenerationResult = await response.json();
        setAnalysisResult(result);
        setStep('results');
        
        // Show success feedback with credit info if available
        const creditsUsed = result.metadata?.creditsUsed || estimatedCredits;
        toast.success(`UI analysis complete! Generated ${result.analysis.components?.length || 0} components using ${creditsUsed} credits.`);
      } else {
        const errorData = await response.json();
        
        if (response.status === 402 && errorData.code === 'INSUFFICIENT_CREDITS') {
          toast.error(`Insufficient AI credits. You need ${errorData.creditsRequired || estimatedCredits} credits but have ${errorData.currentBalance || 0}.`);
        } else if (response.status === 401) {
          toast.error('Authentication required. Please log in to use UI analysis.');
        } else if (response.status === 403) {
          toast.error('UI analysis requires a paid subscription. Please upgrade your plan.');
        } else {
          throw new Error(errorData.error || 'Analysis failed');
        }
        setStep('upload');
      }
    } catch (error) {
      console.error('Analysis error:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to analyze image. Please try again.');
      setStep('upload');
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const downloadCode = () => {
    if (analysisResult?.generatedCode) {
      const blob = new Blob([analysisResult.generatedCode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'GeneratedComponent.tsx';
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  const resetModal = () => {
    setStep('upload');
    setSelectedFile(null);
    setPreview(null);
    setAnalysisResult(null);
    setDragActive(false);
  };

  const handleClose = () => {
    resetModal();
    onClose();
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        {/* Backdrop */}
        <motion.div
          className="absolute inset-0 bg-black/60 backdrop-blur-sm"
          onClick={handleClose}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        />

        {/* Modal */}
        <motion.div
          className="relative w-full max-w-4xl max-h-[90vh] mx-4 bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-slate-700/50 overflow-hidden"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          transition={{ type: "spring", duration: 0.5 }}
        >
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-slate-700/50">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-violet-500/20 rounded-lg">
                <ImageIcon className="w-6 h-6 text-violet-400" />
              </div>
              <div>
                <h2 className="text-xl font-semibold text-white">Clone UI from Image</h2>
                <p className="text-sm text-slate-400">Upload an image to generate React components</p>
              </div>
            </div>
            <button
              onClick={handleClose}
              className="p-2 hover:bg-slate-700/50 rounded-lg transition-colors"
              title="Close modal"
              aria-label="Close Clone UI modal"
            >
              <X className="w-5 h-5 text-slate-400" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6 overflow-y-auto max-h-[calc(90vh-80px)]">
            {step === 'upload' && (
              <div className="space-y-6">
                {/* Provider Status Header */}
                <ProviderStatusHeader 
                  currentProvider={currentProvider}
                  selectedLLMModel={selectedLLMModel}
                  isProviderConfigured={isProviderConfigured}
                />
                
                {/* Input Method Selection */}
                <div className="flex justify-center gap-2">
                  <button
                    onClick={() => setInputMethod('upload')}
                    className={`px-4 py-2 rounded-lg transition-all ${
                      inputMethod === 'upload'
                        ? 'bg-violet-500/20 text-violet-400 border border-violet-400/50'
                        : 'text-slate-400 hover:text-white border border-slate-600'
                    }`}
                  >
                    <Upload className="w-4 h-4 mr-2 inline" />
                    Upload Image
                  </button>
                  <button
                    onClick={() => setInputMethod('select')}
                    className={`px-4 py-2 rounded-lg transition-all ${
                      inputMethod === 'select'
                        ? 'bg-violet-500/20 text-violet-400 border border-violet-400/50'
                        : 'text-slate-400 hover:text-white border border-slate-600'
                    }`}
                  >
                    <FolderOpen className="w-4 h-4 mr-2 inline" />
                    Select from Files
                  </button>
                </div>

                {inputMethod === 'upload' && (
                  /* Upload Area */
                  <div
                    className={`relative border-2 border-dashed rounded-xl p-8 text-center transition-all ${
                      dragActive
                        ? 'border-violet-400 bg-violet-500/10'
                        : 'border-slate-600 hover:border-slate-500'
                    }`}
                    onDragEnter={handleDrag}
                    onDragLeave={handleDrag}
                    onDragOver={handleDrag}
                    onDrop={handleDrop}
                  >
                    <input
                      type="file"
                      accept="image/*"
                      onChange={handleFileInput}
                      className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                      title="Upload image file"
                      aria-label="Upload image file for UI cloning"
                    />
                    
                    {preview ? (
                      <div className="space-y-4">
                        <img
                          src={preview}
                          alt="Preview"
                          className="max-w-md max-h-64 mx-auto rounded-lg shadow-lg"
                        />
                        <div className="flex items-center justify-center gap-2 text-sm text-green-400">
                          <Check className="w-4 h-4" />
                          Image selected: {selectedFile?.name}
                        </div>
                      </div>
                    ) : (
                      <div className="space-y-4">
                        <div className="p-4 bg-slate-800/50 rounded-full w-20 h-20 mx-auto flex items-center justify-center">
                          <Upload className="w-8 h-8 text-violet-400" />
                        </div>
                        <div>
                          <p className="text-lg font-medium text-white mb-2">
                            Drop your screenshot here
                          </p>
                          <p className="text-sm text-slate-400">
                            or click to browse ‚Ä¢ PNG, JPG, WebP up to 10MB
                          </p>
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {inputMethod === 'select' && (
                  <ImageFileManagerModal
                    onFileSelect={handleStoredImageSelect}
                    selectedFile={selectedStoredFile}
                    preview={preview}
                  />
                )}

                {/* Action Buttons */}
                {(selectedFile || selectedStoredFile) && (
                  <div className="space-y-4">
                    {/* Credit cost information */}
                    <div className="flex items-center justify-center gap-2 text-sm text-slate-400 bg-slate-800/30 rounded-lg p-3">
                      <Sparkles className="w-4 h-4 text-violet-400" />
                      <span>UI Analysis will use approximately <strong className="text-white">{estimatedCredits} AI credits</strong></span>
                    </div>
                    
                    <div className="flex justify-center gap-3">
                      <button
                        onClick={resetModal}
                        className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                      >
                        Clear
                      </button>
                      <motion.button
                        onClick={analyzeImage}
                        disabled={!isProviderConfigured(currentProvider)}
                        className={`px-8 py-3 rounded-lg text-white font-medium flex items-center gap-2 transition-all ${
                          isProviderConfigured(currentProvider)
                            ? 'bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700'
                            : 'bg-slate-600 cursor-not-allowed'
                        }`}
                        whileHover={isProviderConfigured(currentProvider) ? { scale: 1.02 } : {}}
                        whileTap={isProviderConfigured(currentProvider) ? { scale: 0.98 } : {}}
                      >
                        <Sparkles className="w-4 h-4" />
                        {isProviderConfigured(currentProvider) 
                          ? `Analyze & Generate (${estimatedCredits} credits)`
                          : 'Provider Not Configured'
                        }
                      </motion.button>
                    </div>
                    
                    {!isProviderConfigured(currentProvider) && (
                      <div className="flex items-center justify-center gap-2 text-sm text-orange-400 bg-orange-500/10 rounded-lg p-3">
                        <AlertCircle className="w-4 h-4" />
                        <span>Please configure your AI provider in settings before analyzing images</span>
                      </div>
                    )}
                  </div>
                )}
              </div>
            )}

            {step === 'analyzing' && (
              <div className="flex flex-col items-center justify-center py-12 space-y-6">
                <div className="relative">
                  <motion.div
                    className="w-16 h-16 border-4 border-violet-500/30 border-t-violet-500 rounded-full"
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                  />
                  <motion.div
                    className="absolute inset-2 bg-violet-500/20 rounded-full flex items-center justify-center"
                    animate={{ scale: [1, 1.1, 1] }}
                    transition={{ duration: 2, repeat: Infinity }}
                  >
                    <Zap className="w-6 h-6 text-violet-400" />
                  </motion.div>
                </div>
                <div className="text-center">
                  <h3 className="text-xl font-semibold text-white mb-2">Analyzing Your Design</h3>
                  <p className="text-slate-400">AI is examining the image and generating components...</p>
                </div>
                <div className="flex items-center gap-2 text-sm text-slate-500">
                  <motion.div
                    className="w-2 h-2 bg-violet-400 rounded-full"
                    animate={{ opacity: [0, 1, 0] }}
                    transition={{ duration: 1, repeat: Infinity, delay: 0 }}
                  />
                  <motion.div
                    className="w-2 h-2 bg-violet-400 rounded-full"
                    animate={{ opacity: [0, 1, 0] }}
                    transition={{ duration: 1, repeat: Infinity, delay: 0.2 }}
                  />
                  <motion.div
                    className="w-2 h-2 bg-violet-400 rounded-full"
                    animate={{ opacity: [0, 1, 0] }}
                    transition={{ duration: 1, repeat: Infinity, delay: 0.4 }}
                  />
                </div>
              </div>
            )}

            {step === 'results' && analysisResult && (
              <div className="space-y-6">
                {/* Analysis Metadata */}
                <div className="flex items-center justify-between p-3 bg-slate-800/30 rounded-lg">
                  <div className="flex items-center gap-4 text-sm text-slate-400">
                    <span>Provider: <span className="text-white">{currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)}</span></span>
                    {selectedLLMModel && (
                      <span>Model: <span className="text-white">{selectedLLMModel.name}</span></span>
                    )}
                    {analysisResult.metadata?.responseTime && (
                      <span>Time: <span className="text-white">{analysisResult.metadata.responseTime}</span></span>
                    )}
                  </div>
                  {analysisResult.metadata?.creditsUsed && (
                    <Badge variant="outline" className="text-violet-400 border-violet-400/50">
                      {analysisResult.metadata.creditsUsed} credits used
                    </Badge>
                  )}
                </div>
                
                {/* Analysis Summary */}
                <div className="grid md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold text-white flex items-center gap-2">
                      <Eye className="w-5 h-5 text-violet-400" />
                      Analysis Results
                    </h3>
                    
                    <div className="space-y-3">
                      <div className="p-4 bg-slate-800/50 rounded-lg">
                        <h4 className="font-medium text-white mb-2">Detected Components</h4>
                        <div className="space-y-1">
                          {analysisResult.analysis.components.map((comp, index) => (
                            <div key={index} className="text-sm text-slate-300">
                              <span className="font-medium text-violet-400">{comp.type}:</span> {comp.description}
                            </div>
                          ))}
                        </div>
                      </div>

                      <div className="p-4 bg-slate-800/50 rounded-lg">
                        <h4 className="font-medium text-white mb-2">Color Palette</h4>
                        <div className="flex gap-2 flex-wrap">
                          {(() => {
                            const palette = analysisResult.analysis.colorPalette;
                            // Handle both array format and object format
                            if (Array.isArray(palette)) {
                              return palette.map((color, index) => (
                                <div
                                  key={index}
                                  className="w-8 h-8 rounded-full border border-slate-600"
                                  style={{ backgroundColor: color }}
                                  title={color}
                                />
                              ));
                            } else if (palette && typeof palette === 'object') {
                              // Handle object format with properties like primary, secondary, etc.
                              return Object.entries(palette).map(([name, color]) => {
                                if (Array.isArray(color)) {
                                  // Handle additional colors array
                                  return color.map((c, i) => (
                                    <div
                                      key={`${name}-${i}`}
                                      className="w-8 h-8 rounded-full border border-slate-600"
                                      style={{ backgroundColor: c }}
                                      title={`${name}: ${c}`}
                                    />
                                  ));
                                }
                                return (
                                  <div
                                    key={name}
                                    className="w-8 h-8 rounded-full border border-slate-600"
                                    style={{ backgroundColor: color as string }}
                                    title={`${name}: ${color}`}
                                  />
                                );
                              }).flat();
                            }
                            return null;
                          })()}
                        </div>
                      </div>

                      <div className="p-4 bg-slate-800/50 rounded-lg">
                        <h4 className="font-medium text-white mb-2">Layout & Complexity</h4>
                        <div className="text-sm text-slate-300 space-y-1">
                          <div>
                            <span className="text-violet-400">Layout:</span> {
                              typeof analysisResult.analysis.layout === 'object' 
                                ? analysisResult.analysis.layout.system || 'Unknown'
                                : analysisResult.analysis.layout
                            }
                          </div>
                          {typeof analysisResult.analysis.layout === 'object' && analysisResult.analysis.layout.structure && (
                            <div>
                              <span className="text-violet-400">Structure:</span> {analysisResult.analysis.layout.structure}
                            </div>
                          )}
                          {typeof analysisResult.analysis.layout === 'object' && analysisResult.analysis.layout.responsive && (
                            <div>
                              <span className="text-violet-400">Responsive:</span> {analysisResult.analysis.layout.responsive}
                            </div>
                          )}
                          <div><span className="text-violet-400">Complexity:</span> {analysisResult.analysis.estimatedComplexity}</div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold text-white flex items-center gap-2">
                      <Code className="w-5 h-5 text-violet-400" />
                      Generated Code
                    </h3>
                    
                    <div className="relative">
                      <pre className="p-4 bg-slate-800/80 rounded-lg text-sm text-slate-300 overflow-x-auto max-h-80 border border-slate-700/50">
                        <code>{analysisResult.generatedCode}</code>
                      </pre>
                      
                      <div className="absolute top-2 right-2 flex gap-1">
                        <button
                          onClick={() => copyToClipboard(analysisResult.generatedCode)}
                          className="p-2 bg-slate-700/80 hover:bg-slate-600/80 rounded-md transition-colors"
                          title="Copy to clipboard"
                        >
                          <Copy className="w-4 h-4 text-slate-300" />
                        </button>
                        <button
                          onClick={downloadCode}
                          className="p-2 bg-slate-700/80 hover:bg-slate-600/80 rounded-md transition-colors"
                          title="Download file"
                        >
                          <Download className="w-4 h-4 text-slate-300" />
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Enhanced Action Buttons */}
                <div className="flex justify-center gap-3 pt-4">
                  <button
                    onClick={resetModal}
                    className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                  >
                    Analyze Another
                  </button>
                  <button
                    onClick={() => {
                      copyToClipboard(JSON.stringify(analysisResult.analysis, null, 2));
                      toast.success('Analysis data copied to clipboard');
                    }}
                    className="px-6 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors flex items-center gap-2"
                  >
                    <Copy className="w-4 h-4" />
                    Copy Analysis
                  </button>
                  <motion.button
                    onClick={handleClose}
                    className="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 rounded-lg text-white font-medium transition-all"
                    whileHover={{ scale: 1.02 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    Done
                  </motion.button>
                </div>
              </div>
            )}
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default CloneUIModal;

================
File: client/src/components/CreatePageModal.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  MonitorIcon, 
  X, 
  Check, 
  ArrowRight, 
  Download, 
  Copy, 
  Layout,
  Palette,
  Settings,
  Sparkles,
  FileText,
  Code,
  Zap,
  CreditCard,
  Brain,
  Wand2,
  AlertCircle,
  ChevronDown,
  ChevronUp,
  Lightbulb,
  Cpu,
  Clock,
  DollarSign
} from 'lucide-react';
import { useAIProvider } from '../hooks/useAIProvider';
import { useAuth } from '../hooks/useAuth';
import { useToast } from '../hooks/use-toast';
import { LLMModel } from '../types';

interface CreatePageModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface AITemplate {
  id: string;
  name: string;
  description: string;
  preview?: string;
  complexity: 'simple' | 'medium' | 'complex';
  estimatedCredits: number;
  suggestedBy?: 'ai' | 'static';
  confidence?: number;
}

interface AIGenerationConfig {
  provider: string;
  model: string;
  estimatedCredits: number;
  complexity: 'simple' | 'medium' | 'complex';
}

interface CreditEstimate {
  baseCredits: number;
  complexityMultiplier: number;
  providerMultiplier: number;
  totalCredits: number;
}

interface AIAssistantSuggestion {
  id: string;
  text: string;
  type: 'requirement' | 'style' | 'component';
  confidence: number;
}

interface PageResult {
  template: string;
  components: Array<{ name: string; props: string[]; description?: string }>;
  styles: {
    theme: string;
    colors: {
      primary: string;
      secondary: string;
      accent: string;
    };
    spacing: string;
    borderRadius: string;
  };
  routes: string[];
  aiProvider: string;
  modelUsed: string;
  creditsUsed: number;
  generationTime: number;
}

interface GenerationResult {
  success: boolean;
  page: PageResult;
  files: Array<{ name: string; content: string; type: string }>;
  progressSteps?: Array<{ step: string; completed: boolean; timestamp?: number }>;
  warnings?: string[];
  suggestions?: string[];
}

const CreatePageModal: React.FC<CreatePageModalProps> = ({ isOpen, onClose }) => {
  // Enhanced step flow with AI configuration
  const [step, setStep] = useState<'discovery' | 'templates' | 'customize' | 'configure' | 'generating' | 'results'>('discovery');
  
  // AI Provider integration
  const {
    currentProvider,
    selectedLLMModel,
    isProviderConfigured,
    getAvailableModels,
    updateModel
  } = useAIProvider();
  const { user } = useAuth();
  const { toast } = useToast();

  // Enhanced state management
  const [templates, setTemplates] = useState<AITemplate[]>([]);
  const [selectedTemplate, setSelectedTemplate] = useState<AITemplate | null>(null);
  const [requirements, setRequirements] = useState('');
  const [style, setStyle] = useState('modern');
  const [generationResult, setGenerationResult] = useState<GenerationResult | null>(null);

  // AI-specific state
  const [aiGenerationConfig, setAiGenerationConfig] = useState<AIGenerationConfig | null>(null);
  const [creditBalance, setCreditBalance] = useState<number>(0);
  const [creditEstimate, setCreditEstimate] = useState<CreditEstimate | null>(null);
  const [aiSuggestions, setAiSuggestions] = useState<AIAssistantSuggestion[]>([]);
  const [isLoadingTemplates, setIsLoadingTemplates] = useState(false);
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
  const [availableModels, setAvailableModels] = useState<LLMModel[]>([]);
  const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
  const [generationProgress, setGenerationProgress] = useState<{ step: string; progress: number; currentTask: string }>({
    step: 'idle',
    progress: 0,
    currentTask: ''
  });

  // Initialize on mount
  useEffect(() => {
    if (isOpen) {
      initializeModal();
    }
  }, [isOpen]);

  // Initialize available models when provider changes
  useEffect(() => {
    if (currentProvider) {
      const models = getAvailableModels();
      setAvailableModels(models);
      
      // Update AI generation config
      if (selectedLLMModel) {
        updateAIGenerationConfig();
      }
    }
  }, [currentProvider, selectedLLMModel, getAvailableModels]);

  // Initialize modal with credit balance and AI setup
  const initializeModal = useCallback(async () => {
    await Promise.all([
      fetchCreditBalance(),
      fetchInitialAITemplates()
    ]);
  }, []);

  // Fetch user's credit balance
  const fetchCreditBalance = useCallback(async () => {
    try {
      const response = await fetch('/api/credits/balance', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setCreditBalance(data.balance || 0);
      } else {
        // Try subscription details endpoint
        const subResponse = await fetch('/api/subscription/details', {
          credentials: 'include',
        });
        
        if (subResponse.ok) {
          const subData = await subResponse.json();
          setCreditBalance(subData.features?.currentCreditsBalance || 0);
        }
      }
    } catch (error) {
      console.error('Error fetching credit balance:', error);
    }
  }, []);

  // Generate AI-powered template suggestions
  const fetchInitialAITemplates = useCallback(async () => {
    setIsLoadingTemplates(true);
    try {
      // Start with static templates as fallback
      const staticTemplates: AITemplate[] = [
        {
          id: 'landing-page',
          name: 'Landing Page',
          description: 'Professional landing page with hero section, features, and CTA',
          complexity: 'medium',
          estimatedCredits: 15,
          suggestedBy: 'static'
        },
        {
          id: 'dashboard',
          name: 'Dashboard',
          description: 'Admin dashboard with charts, tables, and navigation',
          complexity: 'complex',
          estimatedCredits: 25,
          suggestedBy: 'static'
        },
        {
          id: 'blog',
          name: 'Blog Page',
          description: 'Blog layout with articles, sidebar, and pagination',
          complexity: 'simple',
          estimatedCredits: 10,
          suggestedBy: 'static'
        },
        {
          id: 'portfolio',
          name: 'Portfolio',
          description: 'Portfolio showcase with project gallery and contact form',
          complexity: 'medium',
          estimatedCredits: 18,
          suggestedBy: 'static'
        }
      ];
      
      setTemplates(staticTemplates);
    } catch (error) {
      console.error('Error loading templates:', error);
      toast({ title: 'Error', description: 'Failed to load page templates' });
    } finally {
      setIsLoadingTemplates(false);
    }
  }, [toast]);

  // Generate AI template suggestions based on user input
  const generateAITemplateSuggestions = useCallback(async (description: string) => {
    if (!description.trim() || !isProviderConfigured(currentProvider)) {
      return;
    }

    setIsLoadingTemplates(true);
    try {
      const response = await fetch('/api/ai/generate-templates', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          description,
          provider: currentProvider,
          model: selectedLLMModel?.id
        }),
      });

      if (response.ok) {
        const data = await response.json();
        const aiTemplates: AITemplate[] = data.templates.map((t: any) => ({
          ...t,
          suggestedBy: 'ai' as const,
          confidence: t.confidence || 0.8
        }));
        
        setTemplates(prev => [...prev, ...aiTemplates]);
        toast({ title: 'AI Templates Generated', description: `Found ${aiTemplates.length} AI-suggested templates` });
      }
    } catch (error) {
      console.error('Error generating AI templates:', error);
      toast({ title: 'Warning', description: 'AI template generation failed, using static templates' });
    } finally {
      setIsLoadingTemplates(false);
    }
  }, [currentProvider, selectedLLMModel, isProviderConfigured, toast]);

  // Update AI generation configuration
  const updateAIGenerationConfig = useCallback(() => {
    if (!selectedLLMModel || !selectedTemplate) return;

    const estimate = calculateCreditEstimate(selectedTemplate.complexity, currentProvider, selectedLLMModel);
    
    const config: AIGenerationConfig = {
      provider: currentProvider,
      model: selectedLLMModel.id,
      estimatedCredits: estimate.totalCredits,
      complexity: selectedTemplate.complexity
    };

    setAiGenerationConfig(config);
    setCreditEstimate(estimate);
  }, [selectedLLMModel, selectedTemplate, currentProvider]);

  // Calculate credit estimate based on complexity and provider
  const calculateCreditEstimate = useCallback((
    complexity: 'simple' | 'medium' | 'complex',
    provider: string,
    model: LLMModel
  ): CreditEstimate => {
    const baseCredits = { simple: 10, medium: 20, complex: 35 };
    const complexityMultipliers = { simple: 1, medium: 1.5, complex: 2.5 };
    
    // Provider-specific multipliers
    const providerMultipliers: Record<string, number> = {
      'lmstudio': 0.1,  // Nearly free (local)
      'azure': 0.8,     // Moderate cost
      'openai': 1.5,    // Higher cost
      'gemini': 1.0,    // Standard cost
      'huggingface': 0.6 // Lower cost
    };

    const base = baseCredits[complexity];
    const complexityMult = complexityMultipliers[complexity];
    const providerMult = providerMultipliers[provider] || 1.0;
    
    // Add model-specific multiplier from cost property
    const modelMult = model.cost > 0 ? Math.max(0.5, model.cost * 1000) : 1.0;
    
    const total = Math.ceil(base * complexityMult * providerMult * modelMult);

    return {
      baseCredits: base,
      complexityMultiplier: complexityMult,
      providerMultiplier: providerMult * modelMult,
      totalCredits: Math.max(1, total)
    };
  }, []);

  // Generate AI assistance suggestions
  const generateAISuggestions = useCallback(async (inputText: string) => {
    if (!inputText.trim() || !isProviderConfigured(currentProvider)) {
      setAiSuggestions([]);
      return;
    }

    setIsLoadingSuggestions(true);
    try {
      const response = await fetch('/api/ai/generate-suggestions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          input: inputText,
          context: 'page-generation',
          provider: currentProvider,
          model: selectedLLMModel?.id
        }),
      });

      if (response.ok) {
        const data = await response.json();
        setAiSuggestions(data.suggestions || []);
      }
    } catch (error) {
      console.error('Error generating AI suggestions:', error);
    } finally {
      setIsLoadingSuggestions(false);
    }
  }, [currentProvider, selectedLLMModel, isProviderConfigured]);

  // Enhanced page generation with AI integration
  const generatePage = useCallback(async () => {
    if (!selectedTemplate || !aiGenerationConfig) {
      toast({ title: 'Error', description: 'Please configure AI settings first' });
      return;
    }

    // Check credit balance
    if (creditBalance < aiGenerationConfig.estimatedCredits) {
      toast({ 
        title: 'Insufficient Credits', 
        description: `You need ${aiGenerationConfig.estimatedCredits} credits but only have ${creditBalance}` 
      });
      return;
    }

    setStep('generating');
    setGenerationProgress({ step: 'initializing', progress: 0, currentTask: 'Initializing AI generation...' });

    try {
      const startTime = Date.now();
      
      // Enhanced generation request with AI configuration
      const response = await fetch('/api/ai/generate-page', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          template: selectedTemplate.id,
          requirements,
          style,
          aiConfig: aiGenerationConfig,
          userContext: {
            userId: user?.id,
            preferences: {
              complexity: selectedTemplate.complexity,
              style: style
            }
          }
        }),
      });

      if (response.ok) {
        const result: GenerationResult = await response.json();
        const generationTime = Date.now() - startTime;
        
        // Update result with generation metadata
        result.page.aiProvider = aiGenerationConfig.provider;
        result.page.modelUsed = aiGenerationConfig.model;
        result.page.generationTime = generationTime;
        
        setGenerationResult(result);
        setStep('results');
        
        // Update credit balance
        await fetchCreditBalance();
        
        toast({ 
          title: 'Page Generated Successfully!', 
          description: `Generated in ${(generationTime / 1000).toFixed(1)}s using ${aiGenerationConfig.provider}` 
        });
      } else {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Generation failed');
      }
    } catch (error) {
      console.error('Generation error:', error);
      toast({ 
        title: 'Generation Failed', 
        description: error instanceof Error ? error.message : 'Unknown error occurred' 
      });
      setStep('configure');
    } finally {
      setGenerationProgress({ step: 'idle', progress: 0, currentTask: '' });
    }
  }, [selectedTemplate, aiGenerationConfig, creditBalance, requirements, style, user?.id, toast, fetchCreditBalance]);

  // Apply AI suggestion to requirements
  const applySuggestion = useCallback((suggestion: AIAssistantSuggestion) => {
    if (suggestion.type === 'requirement') {
      setRequirements(prev => {
        const newReq = prev ? `${prev}\n${suggestion.text}` : suggestion.text;
        return newReq;
      });
    } else if (suggestion.type === 'style') {
      // Extract style suggestion and apply it
      const styleMatch = suggestion.text.toLowerCase();
      if (styleMatch.includes('modern')) setStyle('modern');
      else if (styleMatch.includes('classic')) setStyle('classic');
      else if (styleMatch.includes('minimal')) setStyle('minimal');
      else if (styleMatch.includes('dark')) setStyle('dark');
      else if (styleMatch.includes('colorful')) setStyle('colorful');
    }
    
    toast({ title: 'AI Suggestion Applied', description: suggestion.text });
  }, [toast]);

  const copyToClipboard = useCallback((text: string) => {
    navigator.clipboard.writeText(text);
    toast({ title: 'Copied!', description: 'Content copied to clipboard' });
  }, [toast]);

  const downloadFiles = useCallback(() => {
    if (generationResult?.files) {
      generationResult.files.forEach(file => {
        const blob = new Blob([file.content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name;
        a.click();
        URL.revokeObjectURL(url);
      });
      
      toast({ 
        title: 'Files Downloaded', 
        description: `Downloaded ${generationResult.files.length} files` 
      });
    }
  }, [generationResult, toast]);

  const resetModal = useCallback(() => {
    setStep('discovery');
    setSelectedTemplate(null);
    setRequirements('');
    setStyle('modern');
    setGenerationResult(null);
    setAiGenerationConfig(null);
    setCreditEstimate(null);
    setAiSuggestions([]);
    setShowAdvancedOptions(false);
    setGenerationProgress({ step: 'idle', progress: 0, currentTask: '' });
    // Reset templates to initial static set
    fetchInitialAITemplates();
  }, [fetchInitialAITemplates]);

  const handleClose = useCallback(() => {
    resetModal();
    onClose();
  }, [resetModal, onClose]);

  // Debounced AI suggestions generation
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (requirements.trim().length > 10) {
        generateAISuggestions(requirements);
      }
    }, 1000);

    return () => clearTimeout(timeoutId);
  }, [requirements, generateAISuggestions]);

  // Update AI config when template or model changes
  useEffect(() => {
    if (selectedTemplate && selectedLLMModel) {
      updateAIGenerationConfig();
    }
  }, [selectedTemplate, selectedLLMModel, updateAIGenerationConfig]);

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        {/* Backdrop */}
        <motion.div
          className="absolute inset-0 bg-black/60 backdrop-blur-sm"
          onClick={handleClose}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        />

        {/* Modal */}
        <motion.div
          className="relative w-full max-w-5xl max-h-[90vh] mx-4 bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-slate-700/50 overflow-hidden"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          transition={{ type: "spring", duration: 0.5 }}
        >
          {/* Enhanced Header with AI Status */}
          <div className="flex items-center justify-between p-6 border-b border-slate-700/50">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-gradient-to-br from-blue-500/20 to-purple-500/20 rounded-lg">
                <Brain className="w-6 h-6 text-blue-400" />
              </div>
              <div>
                <h2 className="text-xl font-semibold text-white">AI Page Generator</h2>
                <div className="flex items-center gap-2 text-sm text-slate-400">
                  <span>Powered by {currentProvider}</span>
                  {selectedLLMModel && (
                    <>
                      <span>‚Ä¢</span>
                      <span>{selectedLLMModel.name}</span>
                    </>
                  )}
                  {creditBalance > 0 && (
                    <>
                      <span>‚Ä¢</span>
                      <div className="flex items-center gap-1">
                        <CreditCard className="w-3 h-3" />
                        <span>{creditBalance} credits</span>
                      </div>
                    </>
                  )}
                </div>
              </div>
            </div>
            <button
              onClick={handleClose}
              className="p-2 hover:bg-slate-700/50 rounded-lg transition-colors"
              title="Close modal"
              aria-label="Close AI Page Generator modal"
            >
              <X className="w-5 h-5 text-slate-400" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6 overflow-y-auto max-h-[calc(90vh-80px)]">
            {step === 'discovery' && (
              <div className="space-y-6">
                <div className="text-center">
                  <div className="w-16 h-16 bg-gradient-to-br from-blue-500/20 to-purple-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                    <Lightbulb className="w-8 h-8 text-blue-400" />
                  </div>
                  <h3 className="text-xl font-semibold text-white mb-2">Describe Your Vision</h3>
                  <p className="text-slate-400 max-w-md mx-auto">
                    Tell our AI what kind of page you want to create. The more specific you are, the better results you'll get.
                  </p>
                </div>

                <div className="max-w-2xl mx-auto space-y-4">
                  <div className="relative">
                    <textarea
                      value={requirements}
                      onChange={(e) => setRequirements(e.target.value)}
                      placeholder="Example: I need a modern landing page for a SaaS product with a hero section, feature highlights, pricing table, and contact form. The design should be clean and professional with a blue color scheme."
                      className="w-full h-32 p-4 bg-slate-800/50 border border-slate-600 rounded-lg text-white placeholder-slate-400 resize-none focus:border-blue-400 focus:outline-none transition-colors"
                    />
                    {requirements.length > 0 && (
                      <div className="absolute bottom-2 right-2 text-xs text-slate-500">
                        {requirements.length} characters
                      </div>
                    )}
                  </div>

                  {requirements.trim().length > 20 && (
                    <motion.div
                      initial={{ opacity: 0, y: 10 }}
                      animate={{ opacity: 1, y: 0 }}
                      className="flex justify-center"
                    >
                      <motion.button
                        onClick={() => {
                          generateAITemplateSuggestions(requirements);
                          setStep('templates');
                        }}
                        className="px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg text-white font-medium flex items-center gap-2 transition-all"
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                        disabled={isLoadingTemplates}
                      >
                        {isLoadingTemplates ? (
                          <>
                            <Settings className="w-4 h-4 animate-spin" />
                            Generating Templates...
                          </>
                        ) : (
                          <>
                            <Wand2 className="w-4 h-4" />
                            Generate AI Templates
                          </>
                        )}
                      </motion.button>
                    </motion.div>
                  )}

                  {requirements.trim().length <= 20 && requirements.trim().length > 0 && (
                    <div className="text-center text-sm text-slate-500">
                      Please provide more details (at least 20 characters) for better AI suggestions
                    </div>
                  )}
                </div>
              </div>
            )}

            {step === 'templates' && (
              <div className="space-y-6">
                <div className="text-center">
                  <h3 className="text-lg font-semibold text-white mb-2">AI-Generated Templates</h3>
                  <p className="text-slate-400">Choose from AI-suggested templates based on your description</p>
                </div>

                {isLoadingTemplates && (
                  <div className="flex flex-col items-center justify-center py-12 space-y-4">
                    <motion.div
                      className="w-12 h-12 border-4 border-blue-500/30 border-t-blue-500 rounded-full"
                      animate={{ rotate: 360 }}
                      transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                    />
                    <p className="text-slate-400">AI is analyzing your requirements...</p>
                  </div>
                )}

                <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {templates.map((template) => (
                    <motion.div
                      key={template.id}
                      className={`relative p-4 border-2 rounded-xl cursor-pointer transition-all ${
                        selectedTemplate?.id === template.id
                          ? 'border-blue-400 bg-blue-500/10'
                          : 'border-slate-600 hover:border-slate-500 bg-slate-800/50'
                      }`}
                      onClick={() => setSelectedTemplate(template)}
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <div className="space-y-3">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            {template.suggestedBy === 'ai' ? (
                              <Brain className="w-6 h-6 text-purple-400" />
                            ) : (
                              <Layout className="w-6 h-6 text-blue-400" />
                            )}
                            {template.suggestedBy === 'ai' && template.confidence && (
                              <div className="text-xs text-purple-400 bg-purple-500/20 px-2 py-1 rounded">
                                {Math.round(template.confidence * 100)}% match
                              </div>
                            )}
                          </div>
                          {selectedTemplate?.id === template.id && (
                            <div className="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center">
                              <Check className="w-4 h-4 text-white" />
                            </div>
                          )}
                        </div>
                        
                        <div>
                          <div className="flex items-center justify-between mb-1">
                            <h4 className="font-semibold text-white">{template.name}</h4>
                            <div className={`text-xs px-2 py-1 rounded ${
                              template.complexity === 'simple' ? 'bg-green-500/20 text-green-400' :
                              template.complexity === 'medium' ? 'bg-yellow-500/20 text-yellow-400' :
                              'bg-red-500/20 text-red-400'
                            }`}>
                              {template.complexity}
                            </div>
                          </div>
                          <p className="text-sm text-slate-400 mb-2">{template.description}</p>
                          <div className="flex items-center justify-between text-xs">
                            <div className="flex items-center gap-1 text-slate-500">
                              <DollarSign className="w-3 h-3" />
                              <span>{template.estimatedCredits} credits</span>
                            </div>
                            {template.suggestedBy === 'ai' && (
                              <div className="text-purple-400">AI Suggested</div>
                            )}
                          </div>
                        </div>
                      </div>
                    </motion.div>
                  ))}
                </div>

                {selectedTemplate && (
                  <div className="flex justify-center gap-3 pt-4">
                    <button
                      onClick={() => setStep('discovery')}
                      className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                    >
                      Back
                    </button>
                    <motion.button
                      onClick={() => setStep('customize')}
                      className="px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg text-white font-medium flex items-center gap-2 transition-all"
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      Customize Template
                      <ArrowRight className="w-4 h-4" />
                    </motion.button>
                  </div>
                )}
              </div>
            )}

            {step === 'customize' && selectedTemplate && (
              <div className="space-y-6">
                <div className="text-center">
                  <h3 className="text-lg font-semibold text-white mb-2">Refine Your Requirements</h3>
                  <p className="text-slate-400">Add more details and let AI assist you</p>
                </div>

                <div className="grid md:grid-cols-3 gap-6">
                  <div className="md:col-span-2 space-y-4">
                    <div className="flex items-center gap-2 text-white font-medium">
                      <FileText className="w-5 h-5 text-blue-400" />
                      Enhanced Requirements
                    </div>
                    <div className="relative">
                    <textarea
                      value={requirements}
                      onChange={(e) => setRequirements(e.target.value)}
                        placeholder="Expand on your original idea with specific features, functionality, and design preferences..."
                        className="w-full h-40 p-4 bg-slate-800/50 border border-slate-600 rounded-lg text-white placeholder-slate-400 resize-none focus:border-blue-400 focus:outline-none"
                    />
                      {isLoadingSuggestions && (
                        <div className="absolute top-2 right-2">
                          <Settings className="w-4 h-4 text-blue-400 animate-spin" />
                        </div>
                      )}
                  </div>

                  <div className="space-y-4">
                    <div className="flex items-center gap-2 text-white font-medium">
                      <Palette className="w-5 h-5 text-blue-400" />
                      Style Theme
                    </div>
                      <div className="grid grid-cols-2 gap-2">
                      {['modern', 'classic', 'minimal', 'dark', 'colorful'].map((styleOption) => (
                        <label
                          key={styleOption}
                          className={`flex items-center gap-3 p-3 border rounded-lg cursor-pointer transition-all ${
                            style === styleOption
                              ? 'border-blue-400 bg-blue-500/10'
                              : 'border-slate-600 hover:border-slate-500'
                          }`}
                        >
                          <input
                            type="radio"
                            name="style"
                            value={styleOption}
                            checked={style === styleOption}
                            onChange={(e) => setStyle(e.target.value)}
                            className="text-blue-500"
                          />
                          <span className="text-white capitalize">{styleOption}</span>
                        </label>
                      ))}
                    </div>
                    </div>
                  </div>

                  {/* AI Assistant Panel */}
                  <div className="space-y-4">
                    <div className="flex items-center gap-2 text-white font-medium">
                      <Brain className="w-5 h-5 text-purple-400" />
                      AI Suggestions
                    </div>
                    
                    {aiSuggestions.length > 0 ? (
                      <div className="space-y-2 max-h-64 overflow-y-auto">
                        {aiSuggestions.map((suggestion) => (
                          <motion.button
                            key={suggestion.id}
                            onClick={() => applySuggestion(suggestion)}
                            className="w-full text-left p-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600 hover:border-purple-500/50 rounded-lg transition-all"
                            whileHover={{ scale: 1.02 }}
                            whileTap={{ scale: 0.98 }}
                          >
                            <div className="flex items-start justify-between gap-2">
                              <span className="text-sm text-slate-300">{suggestion.text}</span>
                              <div className={`text-xs px-2 py-1 rounded ${
                                suggestion.type === 'requirement' ? 'bg-blue-500/20 text-blue-400' :
                                suggestion.type === 'style' ? 'bg-purple-500/20 text-purple-400' :
                                'bg-green-500/20 text-green-400'
                              }`}>
                                {suggestion.type}
                              </div>
                            </div>
                            <div className="text-xs text-slate-500 mt-1">
                              {Math.round(suggestion.confidence * 100)}% confidence
                            </div>
                          </motion.button>
                        ))}
                      </div>
                    ) : requirements.trim().length > 10 ? (
                      <div className="text-center py-8 text-slate-500">
                        <Brain className="w-8 h-8 mx-auto mb-2 opacity-50" />
                        <p className="text-sm">AI is analyzing your requirements...</p>
                      </div>
                    ) : (
                      <div className="text-center py-8 text-slate-500">
                        <Lightbulb className="w-8 h-8 mx-auto mb-2 opacity-50" />
                        <p className="text-sm">Add more requirements to get AI suggestions</p>
                      </div>
                    )}
                  </div>
                </div>

                <div className="flex justify-center gap-3 pt-4">
                  <button
                    onClick={() => setStep('templates')}
                    className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                  >
                    Back
                  </button>
                  <motion.button
                    onClick={() => setStep('configure')}
                    className="px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg text-white font-medium flex items-center gap-2 transition-all"
                    whileHover={{ scale: 1.02 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    Configure AI
                    <ArrowRight className="w-4 h-4" />
                  </motion.button>
                </div>
              </div>
            )}

            {step === 'configure' && selectedTemplate && (
              <div className="space-y-6">
                <div className="text-center">
                  <h3 className="text-lg font-semibold text-white mb-2">AI Generation Settings</h3>
                  <p className="text-slate-400">Configure your AI model and review generation costs</p>
                </div>

                <div className="max-w-3xl mx-auto space-y-6">
                  {/* Provider and Model Selection */}
                  <div className="grid md:grid-cols-2 gap-6">
                    <div className="space-y-4">
                      <div className="flex items-center gap-2 text-white font-medium">
                        <Cpu className="w-5 h-5 text-blue-400" />
                        AI Provider
                      </div>
                      <div className="p-4 bg-slate-800/50 border border-slate-600 rounded-lg">
                        <div className="flex items-center gap-3">
                          <div className={`w-3 h-3 rounded-full ${
                            isProviderConfigured(currentProvider) ? 'bg-green-400' : 'bg-red-400'
                          }`} />
                          <span className="text-white font-medium">{currentProvider}</span>
                          {!isProviderConfigured(currentProvider) && (
                            <AlertCircle className="w-4 h-4 text-red-400" />
                          )}
                        </div>
                        {!isProviderConfigured(currentProvider) && (
                          <p className="text-sm text-red-400 mt-2">
                            Provider not configured. Please set up your API keys in settings.
                          </p>
                        )}
                      </div>
                    </div>

                    <div className="space-y-4">
                      <div className="flex items-center gap-2 text-white font-medium">
                        <Brain className="w-5 h-5 text-purple-400" />
                        AI Model
                      </div>
                      <div className="relative">
                        <select
                          value={selectedLLMModel?.id || ''}
                          onChange={(e) => {
                            const model = availableModels.find(m => m.id === e.target.value);
                            if (model) updateModel(model);
                          }}
                          className="w-full p-3 bg-slate-800/50 border border-slate-600 rounded-lg text-white focus:border-blue-400 focus:outline-none appearance-none"
                          title="Select AI Model"
                        >
                          {availableModels.map((model) => (
                            <option key={model.id} value={model.id}>
                              {model.name} - Performance: {model.performance}
                            </option>
                          ))}
                        </select>
                        <ChevronDown className="absolute right-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-slate-400 pointer-events-none" />
                      </div>
                      {selectedLLMModel && (
                        <div className="text-sm text-slate-400">
                          <div className="flex items-center gap-4">
                            <span>Performance: {selectedLLMModel.performance}/100</span>
                            <span>Context: {selectedLLMModel.contextLength.toLocaleString()}</span>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Cost Estimation */}
                  {creditEstimate && (
                    <div className="p-6 bg-gradient-to-br from-slate-800/50 to-slate-700/50 border border-slate-600 rounded-xl">
                      <div className="flex items-center gap-2 text-white font-medium mb-4">
                        <DollarSign className="w-5 h-5 text-green-400" />
                        Generation Cost Estimate
                      </div>
                      
                      <div className="grid md:grid-cols-4 gap-4 text-sm">
                        <div className="text-center">
                          <div className="text-slate-400">Base Cost</div>
                          <div className="text-white font-semibold">{creditEstimate.baseCredits}</div>
                        </div>
                        <div className="text-center">
                          <div className="text-slate-400">Complexity</div>
                          <div className="text-white font-semibold">√ó{creditEstimate.complexityMultiplier}</div>
                        </div>
                        <div className="text-center">
                          <div className="text-slate-400">Provider</div>
                          <div className="text-white font-semibold">√ó{creditEstimate.providerMultiplier.toFixed(1)}</div>
                        </div>
                        <div className="text-center">
                          <div className="text-slate-400">Total</div>
                          <div className="text-2xl font-bold text-green-400">{creditEstimate.totalCredits}</div>
                        </div>
                      </div>

                      <div className="mt-4 pt-4 border-t border-slate-600">
                        <div className="flex items-center justify-between">
                          <span className="text-slate-400">Your Balance:</span>
                          <span className={`font-semibold ${
                            creditBalance >= creditEstimate.totalCredits ? 'text-green-400' : 'text-red-400'
                          }`}>
                            {creditBalance} credits
                          </span>
                        </div>
                        {creditBalance < creditEstimate.totalCredits && (
                          <div className="mt-2 p-3 bg-red-500/10 border border-red-500/20 rounded-lg">
                            <div className="flex items-center gap-2 text-red-400 text-sm">
                              <AlertCircle className="w-4 h-4" />
                              Insufficient credits. You need {creditEstimate.totalCredits - creditBalance} more credits.
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                  {/* Generation Summary */}
                  <div className="p-4 bg-slate-800/50 border border-slate-600 rounded-lg">
                    <h4 className="text-white font-medium mb-3">Generation Summary</h4>
                    <div className="space-y-2 text-sm">
                      <div className="flex justify-between">
                        <span className="text-slate-400">Template:</span>
                        <span className="text-white">{selectedTemplate.name}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Complexity:</span>
                        <span className={`capitalize ${
                          selectedTemplate.complexity === 'simple' ? 'text-green-400' :
                          selectedTemplate.complexity === 'medium' ? 'text-yellow-400' :
                          'text-red-400'
                        }`}>
                          {selectedTemplate.complexity}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Style:</span>
                        <span className="text-white capitalize">{style}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Est. Time:</span>
                        <span className="text-white">
                          {selectedLLMModel ? Math.round(selectedLLMModel.latency / 1000) : 30}s
                        </span>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="flex justify-center gap-3 pt-4">
                  <button
                    onClick={() => setStep('customize')}
                    className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                  >
                    Back
                  </button>
                  <motion.button
                    onClick={generatePage}
                    disabled={!isProviderConfigured(currentProvider) || !creditEstimate || creditBalance < creditEstimate.totalCredits}
                    className={`px-8 py-3 rounded-lg text-white font-medium flex items-center gap-2 transition-all ${
                      !isProviderConfigured(currentProvider) || !creditEstimate || creditBalance < (creditEstimate?.totalCredits || 0)
                        ? 'bg-slate-600 cursor-not-allowed'
                        : 'bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700'
                    }`}
                    whileHover={!(!isProviderConfigured(currentProvider) || !creditEstimate || creditBalance < (creditEstimate?.totalCredits || 0)) ? { scale: 1.02 } : {}}
                    whileTap={!(!isProviderConfigured(currentProvider) || !creditEstimate || creditBalance < (creditEstimate?.totalCredits || 0)) ? { scale: 0.98 } : {}}
                  >
                    <Zap className="w-4 h-4" />
                    Generate Page
                  </motion.button>
                </div>
              </div>
            )}

            {step === 'generating' && (
              <div className="flex flex-col items-center justify-center py-12 space-y-8">
                <div className="relative">
                  <motion.div
                    className="w-20 h-20 border-4 border-gradient-to-r from-blue-500/30 to-purple-500/30 border-t-blue-500 rounded-full"
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                  />
                  <motion.div
                    className="absolute inset-3 bg-gradient-to-br from-blue-500/20 to-purple-500/20 rounded-full flex items-center justify-center"
                    animate={{ scale: [1, 1.1, 1] }}
                    transition={{ duration: 2, repeat: Infinity }}
                  >
                    <Brain className="w-8 h-8 text-blue-400" />
                  </motion.div>
                </div>

                <div className="text-center max-w-md">
                  <h3 className="text-xl font-semibold text-white mb-2">AI is Generating Your Page</h3>
                  <p className="text-slate-400 mb-4">{generationProgress.currentTask}</p>
                  
                  {generationProgress.progress > 0 && (
                    <div className="w-full bg-slate-700 rounded-full h-2 mb-4">
                      <motion.div 
                        className="bg-gradient-to-r from-blue-500 to-purple-600 h-2 rounded-full"
                        initial={{ width: 0 }}
                        animate={{ width: `${generationProgress.progress}%` }}
                        transition={{ duration: 0.5 }}
                      />
                    </div>
                  )}
                </div>

                {aiGenerationConfig && (
                  <div className="text-center space-y-2 text-sm text-slate-400">
                    <div className="flex items-center justify-center gap-2">
                      <Cpu className="w-4 h-4" />
                      <span>Using {aiGenerationConfig.provider} ‚Ä¢ {aiGenerationConfig.model}</span>
                    </div>
                    <div className="flex items-center justify-center gap-2">
                      <Clock className="w-4 h-4" />
                      <span>Estimated time: {selectedLLMModel ? Math.round(selectedLLMModel.latency / 1000) : 30}s</span>
                    </div>
                    <div className="flex items-center justify-center gap-2">
                      <DollarSign className="w-4 h-4" />
                      <span>Cost: {aiGenerationConfig.estimatedCredits} credits</span>
                    </div>
                  </div>
                )}
              </div>
            )}

            {step === 'results' && generationResult && (
              <div className="space-y-6">
                <div className="text-center">
                  <div className="w-16 h-16 bg-gradient-to-br from-green-500/20 to-emerald-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                    <Check className="w-8 h-8 text-green-400" />
                  </div>
                  <h3 className="text-xl font-semibold text-white mb-2">Page Generated Successfully!</h3>
                  <p className="text-slate-400">Your AI-powered page is ready with all necessary files</p>
                </div>

                {/* Generation Statistics */}
                <div className="grid md:grid-cols-4 gap-4 p-4 bg-gradient-to-br from-slate-800/50 to-slate-700/50 border border-slate-600 rounded-xl">
                  <div className="text-center">
                    <div className="text-slate-400 text-sm">Provider</div>
                    <div className="text-white font-semibold">{generationResult.page.aiProvider}</div>
                  </div>
                  <div className="text-center">
                    <div className="text-slate-400 text-sm">Model</div>
                    <div className="text-white font-semibold">{generationResult.page.modelUsed}</div>
                  </div>
                  <div className="text-center">
                    <div className="text-slate-400 text-sm">Time</div>
                    <div className="text-white font-semibold">{(generationResult.page.generationTime / 1000).toFixed(1)}s</div>
                  </div>
                  <div className="text-center">
                    <div className="text-slate-400 text-sm">Credits Used</div>
                    <div className="text-green-400 font-semibold">{generationResult.page.creditsUsed}</div>
                  </div>
                </div>

                <div className="grid md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <h4 className="text-white font-medium flex items-center gap-2">
                      <Layout className="w-5 h-5 text-blue-400" />
                      Page Structure
                    </h4>
                    
                    <div className="space-y-3">
                      <div className="p-4 bg-slate-800/50 rounded-lg">
                        <h5 className="font-medium text-white mb-2">Components ({generationResult.page.components.length})</h5>
                        <div className="space-y-2 max-h-32 overflow-y-auto">
                          {generationResult.page.components.map((comp, index) => (
                            <div key={index} className="text-sm">
                              <div className="flex items-center gap-2">
                                <span className="font-medium text-blue-400">{comp.name}</span>
                                <span className="text-xs text-slate-500">
                                  ({comp.props.join(', ')})
                                </span>
                              </div>
                              {comp.description && (
                                <div className="text-xs text-slate-400 mt-1 ml-2">
                                  {comp.description}
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>

                      <div className="p-4 bg-slate-800/50 rounded-lg">
                        <h5 className="font-medium text-white mb-2">Routes ({generationResult.page.routes.length})</h5>
                        <div className="space-y-1 max-h-24 overflow-y-auto">
                          {generationResult.page.routes.map((route, index) => (
                            <div key={index} className="text-sm text-blue-400 font-mono">
                              {route}
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="space-y-4">
                    <h4 className="text-white font-medium flex items-center gap-2">
                      <Code className="w-5 h-5 text-blue-400" />
                      Generated Files ({generationResult.files.length})
                    </h4>
                    
                    <div className="space-y-2 max-h-64 overflow-y-auto">
                      {generationResult.files.map((file, index) => (
                        <div
                          key={index}
                          className="flex items-center justify-between p-3 bg-slate-800/50 rounded-lg border border-slate-700/50 hover:border-slate-600/50 transition-colors"
                        >
                          <div className="flex items-center gap-3">
                            <div className={`w-3 h-3 rounded-full ${
                              file.type === 'component' ? 'bg-green-400' :
                              file.type === 'style' ? 'bg-purple-400' :
                              file.type === 'config' ? 'bg-yellow-400' :
                              'bg-blue-400'
                            }`} />
                            <span className="text-white font-mono text-sm">{file.name}</span>
                            <span className="text-xs text-slate-500 capitalize">{file.type}</span>
                          </div>
                          <button
                            onClick={() => copyToClipboard(file.content)}
                            className="p-2 hover:bg-slate-700/50 rounded transition-colors group"
                            title="Copy file content"
                          >
                            <Copy className="w-4 h-4 text-slate-400 group-hover:text-white" />
                          </button>
                        </div>
                      ))}
                    </div>

                    <div className="grid grid-cols-2 gap-2 pt-2">
                      <button
                        onClick={downloadFiles}
                        className="p-3 bg-slate-700/50 hover:bg-slate-600/50 rounded-lg text-white font-medium flex items-center justify-center gap-2 transition-colors"
                      >
                        <Download className="w-4 h-4" />
                        Download All
                      </button>
                      <button
                        onClick={() => {
                          const allContent = generationResult.files.map(f => f.content).join('\n\n---\n\n');
                          copyToClipboard(allContent);
                        }}
                        className="p-3 bg-slate-700/50 hover:bg-slate-600/50 rounded-lg text-white font-medium flex items-center justify-center gap-2 transition-colors"
                      >
                        <Copy className="w-4 h-4" />
                        Copy All
                      </button>
                    </div>
                  </div>
                </div>

                {/* AI Feedback and Suggestions */}
                {(generationResult.warnings?.length || generationResult.suggestions?.length) && (
                  <div className="grid md:grid-cols-2 gap-4">
                    {generationResult.warnings && generationResult.warnings.length > 0 && (
                      <div className="p-4 bg-yellow-500/10 border border-yellow-500/20 rounded-lg">
                        <h5 className="flex items-center gap-2 text-yellow-400 font-medium mb-2">
                          <AlertCircle className="w-4 h-4" />
                          AI Warnings
                        </h5>
                        <div className="space-y-1">
                          {generationResult.warnings.map((warning, index) => (
                            <div key={index} className="text-sm text-yellow-300">
                              {warning}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {generationResult.suggestions && generationResult.suggestions.length > 0 && (
                      <div className="p-4 bg-blue-500/10 border border-blue-500/20 rounded-lg">
                        <h5 className="flex items-center gap-2 text-blue-400 font-medium mb-2">
                          <Lightbulb className="w-4 h-4" />
                          AI Suggestions
                        </h5>
                        <div className="space-y-1">
                          {generationResult.suggestions.map((suggestion, index) => (
                            <div key={index} className="text-sm text-blue-300">
                              {suggestion}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                <div className="flex justify-center gap-3 pt-4">
                  <button
                    onClick={resetModal}
                    className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                  >
                    Create Another
                  </button>
                  <motion.button
                    onClick={handleClose}
                    className="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 rounded-lg text-white font-medium transition-all"
                    whileHover={{ scale: 1.02 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    Done
                  </motion.button>
                </div>
              </div>
            )}
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default CreatePageModal;

================
File: client/src/components/CreditLimitMessage.tsx
================
import React, { useState } from 'react';
import { Message } from '../types';
import { AICreditsQuickPurchase } from './AICreditsQuickPurchase';
import { Button } from './ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from './ui/dropdown-menu';
import { Badge } from './ui/badge';
import { CreditCard, Zap, Clock, ArrowUp, AlertTriangle, ChevronDown, Sparkles } from 'lucide-react';

interface CreditPackage {
  credits: number;
  price: number;
  priceId: string;
  popular?: boolean;
}

const CREDIT_PACKAGES: CreditPackage[] = [
  { credits: 100, price: 1.99, priceId: 'price_credits_100' },
  { credits: 500, price: 8.99, priceId: 'price_credits_500', popular: true },
  { credits: 1000, price: 15.99, priceId: 'price_credits_1000' },
  { credits: 5000, price: 69.99, priceId: 'price_credits_5000' },
];

interface CreditLimitMessageProps {
  message: Message;
  onUpgrade?: () => void;
  onPurchaseCredits?: (packageId: string) => void;
}

export const CreditLimitMessage: React.FC<CreditLimitMessageProps> = ({
  message,
  onUpgrade,
  onPurchaseCredits,
}) => {
  const { code, currentBalance, messagesUsed, monthlyAllowance, isFreemium, creditsRequired } = message.metadata || {};
  const [selectedPackage, setSelectedPackage] = useState<CreditPackage>(CREDIT_PACKAGES[1]); // Default to 500 credits (popular)
  
  const isFreemiumLimit = code === 'MESSAGE_LIMIT_EXCEEDED';
  const isCreditLimit = code === 'INSUFFICIENT_CREDITS' || code === 'NO_CREDITS_AVAILABLE';

  const getTitle = () => {
    if (isFreemiumLimit) return 'Monthly Limit Reached';
    if (isCreditLimit) return 'AI Credits Depleted';
    return 'Access Limited';
  };

  const getDescription = () => {
    if (isFreemiumLimit) {
      return `You've used all ${monthlyAllowance || 10} free messages this month.`;
    }
    if (isCreditLimit) {
      return `You have ${currentBalance || 0} credits remaining.`;
    }
    return 'You need more credits to continue.';
  };

  const getIcon = () => {
    if (isFreemiumLimit) return <Clock className="h-5 w-5 text-amber-600" />;
    if (isCreditLimit) return <Zap className="h-5 w-5 text-red-600" />;
    return <AlertTriangle className="h-5 w-5 text-orange-600" />;
  };

  const getCardStyles = () => {
    if (isFreemiumLimit) {
      return "border-amber-200 bg-amber-50 dark:border-amber-800 dark:bg-amber-950/20";
    }
    if (isCreditLimit) {
      return "border-red-200 bg-red-50 dark:border-red-800 dark:bg-red-950/20";
    }
    return "border-orange-200 bg-orange-50 dark:border-orange-800 dark:bg-orange-950/20";
  };

  const getTextStyles = () => {
    if (isFreemiumLimit) {
      return {
        title: "text-amber-800 dark:text-amber-200",
        description: "text-amber-700 dark:text-amber-300",
        button: "bg-blue-600 hover:bg-blue-700",
        outlineButton: "border-amber-300 text-amber-700 hover:bg-amber-100"
      };
    }
    if (isCreditLimit) {
      return {
        title: "text-red-800 dark:text-red-200",
        description: "text-red-700 dark:text-red-300",
        button: "bg-blue-600 hover:bg-blue-700",
        outlineButton: "border-red-300 text-red-700 hover:bg-red-100"
      };
    }
    return {
      title: "text-orange-800 dark:text-orange-200",
      description: "text-orange-700 dark:text-orange-300",
      button: "bg-blue-600 hover:bg-blue-700",
      outlineButton: "border-orange-300 text-orange-700 hover:bg-orange-100"
    };
  };

  const styles = getTextStyles();

  return (
    <Card className={getCardStyles()}>
      <CardHeader className="pb-3">
        <div className="flex items-center gap-2">
          {getIcon()}
          <CardTitle className={styles.title}>
            {getTitle()}
          </CardTitle>
        </div>
        <CardDescription className={styles.description}>
          {getDescription()}
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-4">
        {isFreemiumLimit ? (
          <div className="space-y-3">
            <div className="flex items-center gap-2 text-sm text-amber-700 dark:text-amber-300">
              <Clock className="h-4 w-4" />
              <span>Your limit resets on the 1st of next month</span>
            </div>
            
            <div className="flex gap-2">
              <Button 
                onClick={onUpgrade}
                className={`flex-1 ${styles.button}`}
              >
                <ArrowUp className="h-4 w-4 mr-2" />
                Upgrade to Pro ($19/mo)
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button 
                    variant="outline" 
                    className={`flex-1 ${styles.outlineButton}`}
                  >
                    <CreditCard className="h-4 w-4 mr-2" />
                    Buy {selectedPackage.credits.toLocaleString()} Credits (${selectedPackage.price})
                    <ChevronDown className="h-4 w-4 ml-2" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-80 bg-slate-900 border-slate-700 text-white">
                  <DropdownMenuLabel className="text-slate-300">Select Credit Package</DropdownMenuLabel>
                  <DropdownMenuSeparator className="bg-slate-700" />
                  {CREDIT_PACKAGES.map((pkg) => (
                    <DropdownMenuItem
                      key={pkg.priceId}
                      className={`cursor-pointer p-3 hover:bg-slate-800/50 focus:bg-slate-800/50 ${
                        pkg.popular ? 'border border-violet-400/20 bg-violet-500/5' : ''
                      }`}
                      onSelect={() => {
                        setSelectedPackage(pkg);
                        if (onPurchaseCredits) {
                          // Map priceId to packageId for the API
                          const packageMap: { [key: string]: string } = {
                            'price_credits_100': 'credits_100',
                            'price_credits_500': 'credits_500',
                            'price_credits_1000': 'credits_1000',
                            'price_credits_5000': 'credits_5000',
                          };
                          const packageId = packageMap[pkg.priceId] || 'credits_500';
                          onPurchaseCredits(packageId);
                        }
                      }}
                    >
                      <div className="flex items-center justify-between w-full">
                        <div className="flex items-center gap-3">
                          <div className={`p-2 rounded-lg ${
                            pkg.popular 
                              ? 'bg-violet-500/10 border border-violet-400/20' 
                              : 'bg-slate-800/50 border border-slate-600/50'
                          }`}>
                            <Sparkles className={`w-4 h-4 ${
                              pkg.popular ? 'text-violet-400' : 'text-slate-400'
                            }`} />
                          </div>
                          <div>
                            <div className="flex items-center gap-2">
                              <p className="text-sm font-medium">
                                {pkg.credits.toLocaleString()} Credits
                              </p>
                              {pkg.popular && (
                                <Badge variant="secondary" className="h-4 px-1 text-[10px]">
                                  Popular
                                </Badge>
                              )}
                            </div>
                            <p className="text-xs text-slate-400">
                              {(pkg.price / pkg.credits * 100).toFixed(1)}¬¢ per credit
                            </p>
                          </div>
                        </div>
                        <div className="text-sm font-bold">
                          ${pkg.price}
                        </div>
                      </div>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        ) : (
          <div className="space-y-3">
            <AICreditsQuickPurchase 
              currentBalance={currentBalance || 0}
              isCompact={true}
              onPurchaseComplete={() => {
                // Refresh the page to update credit balance
                window.location.reload();
              }}
            />
            
            <div className="text-center">
              <Button 
                variant="link" 
                onClick={onUpgrade}
                className="text-blue-600 hover:text-blue-700"
              >
                Or upgrade to Pro for unlimited messages
              </Button>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

================
File: client/src/components/EmailPreferences.tsx
================
import React, { useState, useEffect } from 'react';
import { Button } from './ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Switch } from './ui/switch';
import { Label } from './ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Alert, AlertDescription } from './ui/alert';
import { Badge } from './ui/badge';
import { Loader2, Mail, CheckCircle, Settings, Clock, Users, Lightbulb, BarChart3 } from 'lucide-react';
import { useAuth } from '../hooks/useAuth';

interface EmailPreferences {
  id: number;
  userId: number;
  welcomeEmails: boolean;
  reengagementEmails: boolean;
  featureUpdates: boolean;
  productTips: boolean;
  usageInsights: boolean;
  communityHighlights: boolean;
  emailFrequency: 'daily' | 'weekly' | 'monthly';
  isUnsubscribed: boolean;
  createdAt: string;
  updatedAt: string;
}

interface EngagementStats {
  engagement: {
    id: number;
    totalLogins: number;
    totalSessions: number;
    filesAnalyzed: number;
    chatMessagesCount: number;
    engagementScore: number;
    userSegment: string;
    lastActivityAt: string;
  };
  recentActivity: Array<{
    activityType: string;
    timestamp: string;
    activityData?: any;
  }>;
}

export function EmailPreferences() {
  const { user } = useAuth();
  const [preferences, setPreferences] = useState<EmailPreferences | null>(null);
  const [stats, setStats] = useState<EngagementStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState({ type: '', text: '' });

  useEffect(() => {
    if (user) {
      loadPreferences();
      loadStats();
    }
  }, [user]);

  const loadPreferences = async () => {
    try {
      const response = await fetch('/api/engagement/email-preferences', {
        credentials: 'include'
      });
      const data = await response.json();

      if (data.success) {
        setPreferences(data.preferences);
      } else {
        console.error('API error:', data.error);
        setMessage({ 
          type: 'error', 
          text: data.error || 'Failed to load email preferences' 
        });
      }
    } catch (error) {
      console.error('Error loading preferences:', error);
      setMessage({ 
        type: 'error', 
        text: 'Unable to load email preferences. Please try refreshing the page.' 
      });
    } finally {
      setLoading(false);
    }
  };

  const loadStats = async () => {
    try {
      const response = await fetch('/api/engagement/stats', {
        credentials: 'include'
      });
      const data = await response.json();

      if (data.success) {
        setStats(data.data);
      }
    } catch (error) {
      console.error('Error loading stats:', error);
    }
  };

  const updatePreferences = async (updates: Partial<EmailPreferences>) => {
    setSaving(true);
    setMessage({ type: '', text: '' });

    try {
      const response = await fetch('/api/engagement/email-preferences', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(updates),
      });

      const data = await response.json();

      if (data.success) {
        setPreferences(prev => prev ? { ...prev, ...updates } : null);
        setMessage({ type: 'success', text: 'Email preferences updated successfully!' });
      } else {
        setMessage({ type: 'error', text: data.error || 'Failed to update preferences' });
      }
    } catch (error) {
      console.error('Error updating preferences:', error);
      setMessage({ type: 'error', text: 'Failed to update email preferences' });
    } finally {
      setSaving(false);
    }
  };

  const sendTestEmail = async (emailType: string) => {
    try {
      setMessage({ type: 'info', text: 'Sending test email...' });
      
      const response = await fetch('/api/engagement/send-email', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ emailType }),
      });

      const data = await response.json();

      if (data.success) {
        setMessage({ type: 'success', text: 'Test email sent! Check your inbox.' });
      } else {
        setMessage({ type: 'error', text: data.error || 'Failed to send test email' });
      }
    } catch (error) {
      console.error('Error sending test email:', error);
      setMessage({ type: 'error', text: 'Failed to send test email' });
    }
  };

  const getSegmentBadge = (segment: string) => {
    const variants: Record<string, { variant: any; label: string; icon: React.ReactNode }> = {
      new: { variant: 'secondary', label: 'New User', icon: <Users className="w-3 h-3" /> },
      active: { variant: 'default', label: 'Active User', icon: <CheckCircle className="w-3 h-3" /> },
      at_risk: { variant: 'destructive', label: 'At Risk', icon: <Clock className="w-3 h-3" /> },
      dormant: { variant: 'outline', label: 'Dormant', icon: <Clock className="w-3 h-3" /> },
    };

    const config = variants[segment] || variants.new;
    return (
      <Badge variant={config.variant} className="flex items-center gap-1">
        {config.icon}
        {config.label}
      </Badge>
    );
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="w-6 h-6 animate-spin" />
        <span className="ml-2">Loading email preferences...</span>
      </div>
    );
  }

  if (!preferences) {
    return (
      <Alert>
        <AlertDescription>
          Unable to load email preferences. Please try refreshing the page.
        </AlertDescription>
      </Alert>
    );
  }

  const emailTypes = [
    {
      id: 'welcomeEmails',
      title: 'Welcome Emails',
      description: 'Get started guides and tips for new users',
      icon: <Mail className="w-5 h-5" />,
      enabled: preferences.welcomeEmails,
      testType: 'welcome'
    },
    {
      id: 'reengagementEmails',
      title: 'Re-engagement Emails',
      description: 'Reminders to come back when you\'ve been away',
      icon: <Users className="w-5 h-5" />,
      enabled: preferences.reengagementEmails,
      testType: 'reengagement'
    },
    {
      id: 'featureUpdates',
      title: 'Feature Updates',
      description: 'Learn about new features and improvements',
      icon: <Settings className="w-5 h-5" />,
      enabled: preferences.featureUpdates,
      testType: 'feature_discovery'
    },
    {
      id: 'productTips',
      title: 'Product Tips',
      description: 'AI productivity tips and best practices',
      icon: <Lightbulb className="w-5 h-5" />,
      enabled: preferences.productTips,
      testType: 'product_tips'
    },
    {
      id: 'usageInsights',
      title: 'Usage Insights',
      description: 'Weekly/monthly reports on your AI usage',
      icon: <BarChart3 className="w-5 h-5" />,
      enabled: preferences.usageInsights,
      testType: 'usage_insights'
    },
    {
      id: 'communityHighlights',
      title: 'Community Highlights',
      description: 'Success stories and community showcases',
      icon: <Users className="w-5 h-5" />,
      enabled: preferences.communityHighlights,
      testType: 'community'
    },
  ];

  return (
    <div className="space-y-6">
      {/* Engagement Stats */}
      {stats && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <BarChart3 className="w-5 h-5" />
              Your Engagement Overview
            </CardTitle>
            <CardDescription>
              Your activity and engagement with Uterpi
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">{stats.engagement?.totalSessions || 0}</div>
                <div className="text-sm text-gray-600">Sessions</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-green-600">{stats.engagement?.chatMessagesCount || 0}</div>
                <div className="text-sm text-gray-600">AI Messages</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">{stats.engagement?.filesAnalyzed || 0}</div>
                <div className="text-sm text-gray-600">Files Analyzed</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-orange-600">{stats.engagement?.engagementScore || 0}</div>
                <div className="text-sm text-gray-600">Engagement Score</div>
              </div>
            </div>
            <div className="flex items-center justify-between">
              <div>
                <span className="text-sm text-gray-600">User Segment: </span>
                {getSegmentBadge(stats.engagement?.userSegment || 'new')}
              </div>
              <div className="text-sm text-gray-600">
                Last active: {stats.engagement?.lastActivityAt 
                  ? new Date(stats.engagement.lastActivityAt).toLocaleDateString()
                  : 'Never'
                }
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Message Display */}
      {message.text && (
        <Alert variant={message.type === 'error' ? 'destructive' : 'default'}>
          <AlertDescription>{message.text}</AlertDescription>
        </Alert>
      )}

      {/* Email Preferences */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Mail className="w-5 h-5" />
            Email Preferences
          </CardTitle>
          <CardDescription>
            Control what emails you receive from Uterpi
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Master Unsubscribe */}
          <div className="flex items-center justify-between p-4 border rounded-lg bg-gray-50">
            <div>
              <Label className="text-base font-medium">All Emails</Label>
              <p className="text-sm text-gray-600">
                {preferences.isUnsubscribed ? 'Unsubscribed from all emails' : 'Subscribed to emails'}
              </p>
            </div>
            <Switch
              checked={!preferences.isUnsubscribed}
              onCheckedChange={(checked) => 
                updatePreferences({ isUnsubscribed: !checked })
              }
              disabled={saving}
            />
          </div>

          {/* Email Frequency */}
          <div className="flex items-center justify-between">
            <div>
              <Label className="text-base font-medium">Email Frequency</Label>
              <p className="text-sm text-gray-600">How often you want to receive emails</p>
            </div>
            <Select
              value={preferences.emailFrequency}
              onValueChange={(value: 'daily' | 'weekly' | 'monthly') =>
                updatePreferences({ emailFrequency: value })
              }
              disabled={saving || preferences.isUnsubscribed}
            >
              <SelectTrigger className="w-32">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="daily">Daily</SelectItem>
                <SelectItem value="weekly">Weekly</SelectItem>
                <SelectItem value="monthly">Monthly</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Individual Email Types */}
          <div className="space-y-4">
            <h4 className="font-medium text-gray-900">Email Types</h4>
            {emailTypes.map((emailType) => (
              <div key={emailType.id} className="flex items-center justify-between p-3 border rounded-lg">
                <div className="flex items-start gap-3">
                  <div className="text-gray-600 mt-1">{emailType.icon}</div>
                  <div>
                    <Label className="text-base font-medium">{emailType.title}</Label>
                    <p className="text-sm text-gray-600">{emailType.description}</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => sendTestEmail(emailType.testType)}
                    disabled={!emailType.enabled || preferences.isUnsubscribed}
                    className="text-xs"
                  >
                    Test
                  </Button>
                  <Switch
                    checked={emailType.enabled && !preferences.isUnsubscribed}
                    onCheckedChange={(checked) =>
                      updatePreferences({ [emailType.id]: checked })
                    }
                    disabled={saving || preferences.isUnsubscribed}
                  />
                </div>
              </div>
            ))}
          </div>

          {/* Save Button */}
          <div className="flex justify-end pt-4">
            <Button
              onClick={() => loadPreferences()}
              variant="outline"
              disabled={saving}
            >
              {saving ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  Saving...
                </>
              ) : (
                'Refresh'
              )}
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Recent Activity */}
      {stats?.recentActivity && stats.recentActivity.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Clock className="w-5 h-5" />
              Recent Activity
            </CardTitle>
            <CardDescription>
              Your recent interactions with Uterpi
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {stats.recentActivity.slice(0, 10).map((activity, index) => (
                <div key={index} className="flex items-center justify-between text-sm">
                  <span className="capitalize">{activity.activityType.replace('_', ' ')}</span>
                  <span className="text-gray-500">
                    {new Date(activity.timestamp).toLocaleString()}
                  </span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

================
File: client/src/components/FileManager.tsx
================
import React from 'react';
import { type FileItem } from '../hooks/useFileManager';

// Import enhanced components
import { EnhancedFileManager } from './FileManager/EnhancedFileManager';

interface FileManagerProps {
  className?: string;
  initialFolder?: string;
  onFileSelect?: (file: FileItem) => void;
  maxFileSize?: number; // in bytes
  allowedFileTypes?: string[];
  enableAIAnalysis?: boolean;
}

export const FileManager: React.FC<FileManagerProps> = ({
  className = '',
  initialFolder = '/',
  onFileSelect,
  maxFileSize = 10 * 1024 * 1024, // 10MB default
  allowedFileTypes,
  enableAIAnalysis = true
}) => {
  // Use the enhanced FileManager component
  return (
    <EnhancedFileManager
      className={className}
      initialFolder={initialFolder}
      onFileSelect={onFileSelect}
      maxFileSize={maxFileSize}
      allowedFileTypes={allowedFileTypes}
      enableAIAnalysis={enableAIAnalysis}
      showUploadArea={true}
    />
  );
};

================
File: client/src/components/FileManager/AnalysisModal.tsx
================
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  X, 
  Brain, 
  CheckCircle, 
  AlertTriangle, 
  Info, 
  Clock, 
  FileText,
  Shield,
  TrendingUp,
  BarChart3
} from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog';
import { Badge } from '../ui/badge';
import { Button } from '../ui/button';
import { Separator } from '../ui/separator';
import { type FileItem } from '../../hooks/useFileManager';

interface AnalysisModalProps {
  isOpen: boolean;
  onClose: () => void;
  file: FileItem | null;
}

const getComplexityColor = (complexity: string) => {
  switch (complexity?.toLowerCase()) {
    case 'low': return 'bg-green-500/20 text-green-300 border-green-400/30';
    case 'medium': return 'bg-yellow-500/20 text-yellow-300 border-yellow-400/30';
    case 'high': return 'bg-red-500/20 text-red-300 border-red-400/30';
    default: return 'bg-slate-500/20 text-slate-300 border-slate-400/30';
  }
};

const getConfidenceColor = (confidence: string) => {
  switch (confidence?.toLowerCase()) {
    case 'high': return 'bg-green-500/20 text-green-300 border-green-400/30';
    case 'medium': return 'bg-violet-500/20 text-violet-300 border-violet-400/30';
    case 'low': return 'bg-yellow-500/20 text-yellow-300 border-yellow-400/30';
    default: return 'bg-slate-500/20 text-slate-300 border-slate-400/30';
  }
};

const getQualityColor = (quality: string) => {
  switch (quality?.toLowerCase()) {
    case 'excellent':
    case 'good': return 'bg-green-500/20 text-green-300 border-green-400/30';
    case 'fair':
    case 'average': return 'bg-yellow-500/20 text-yellow-300 border-yellow-400/30';
    case 'poor':
    case 'bad': return 'bg-red-500/20 text-red-300 border-red-400/30';
    default: return 'bg-slate-500/20 text-slate-300 border-slate-400/30';
  }
};

// Helper function to get meaningful fallback values
const getFallbackValue = (value: string | undefined, field: string): string => {
  if (value && value !== 'unknown') {
    return value;
  }
  
  switch (field) {
    case 'complexity':
      return 'Analysis Needed';
    case 'quality':
      return 'Analysis Needed';
    case 'confidence':
      return 'Low';
    default:
      return 'Unknown';
  }
};

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const AnalysisModal: React.FC<AnalysisModalProps> = ({
  isOpen,
  onClose,
  file
}) => {
  // Add debugging
  console.log('AnalysisModal render:', { isOpen, file, hasAnalysis: !!file?.aiAnalysis });
  
  if (!file) {
    console.log('AnalysisModal: No file provided');
    return null;
  }

  if (!isOpen) {
    return null;
  }

  const analysis = file.aiAnalysis;
  
  // Log the analysis data structure
  console.log('AnalysisModal: Analysis data:', analysis);

  console.log('AnalysisModal: Rendering modal with isOpen:', isOpen);
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto bg-slate-950 border-slate-600/30">
        <DialogHeader>
          <DialogTitle className="flex items-center space-x-2 text-white">
            <Brain className="w-5 h-5 text-violet-400" />
            <span>AI Analysis Results</span>
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Debug Info */}
          <HolographicBubble>
            <h3 className="font-medium text-violet-300 mb-2">Debug Info</h3>
            <p className="text-sm text-slate-300">
              Modal is rendering! File: {file.name}, Analysis Status: {file.analysisStatus}
            </p>
          </HolographicBubble>

          {/* File Information */}
          <HolographicBubble>
            <div className="flex items-center space-x-3">
              <FileText className="w-5 h-5 text-slate-400" />
              <div>
                <h3 className="font-medium text-white">{file.name}</h3>
                <p className="text-sm text-slate-400">
                  {file.mimeType} ‚Ä¢ {(file.size / 1024).toFixed(1)} KB
                </p>
              </div>
            </div>
          </HolographicBubble>

          {/* Analysis Status */}
          {!analysis && (
            <HolographicBubble>
              <div className="flex items-center space-x-2">
                <AlertTriangle className="w-5 h-5 text-yellow-400" />
                <span className="font-medium text-yellow-300">
                  No Analysis Data Available
                </span>
              </div>
              <p className="text-slate-300 text-sm mt-2">
                This file hasn't been analyzed yet or the analysis data is not available.
              </p>
            </HolographicBubble>
          )}

          {/* Analysis Summary */}
          {analysis?.summary && (
            <div>
              <h3 className="text-lg font-semibold mb-3 flex items-center space-x-2 text-white">
                <Info className="w-5 h-5 text-violet-400" />
                <span>Summary</span>
              </h3>
              <HolographicBubble>
                <p className="text-slate-300 leading-relaxed">
                  {analysis.summary}
                </p>
              </HolographicBubble>
            </div>
          )}

          {/* Analysis Metrics */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Complexity */}
            <HolographicBubble>
              <div className="flex items-center space-x-2 mb-2">
                <BarChart3 className="w-4 h-4 text-slate-400" />
                <span className="font-medium text-sm text-white">Complexity</span>
              </div>
              <Badge 
                variant="outline" 
                className={`w-full justify-center ${getComplexityColor(analysis.complexity)}`}
              >
                {getFallbackValue(analysis.complexity, 'complexity')}
              </Badge>
            </HolographicBubble>

            {/* Quality */}
            <HolographicBubble>
              <div className="flex items-center space-x-2 mb-2">
                <CheckCircle className="w-4 h-4 text-slate-400" />
                <span className="font-medium text-sm text-white">Quality</span>
              </div>
              <Badge 
                variant="outline" 
                className={`w-full justify-center ${getQualityColor(analysis.quality)}`}
              >
                {getFallbackValue(analysis.quality, 'quality')}
              </Badge>
            </HolographicBubble>

            {/* Confidence */}
            <HolographicBubble>
              <div className="flex items-center space-x-2 mb-2">
                <TrendingUp className="w-4 h-4 text-slate-400" />
                <span className="font-medium text-sm text-white">Confidence</span>
              </div>
              <Badge 
                variant="outline" 
                className={`w-full justify-center ${getConfidenceColor(analysis.confidence)}`}
              >
                {getFallbackValue(analysis.confidence, 'confidence')}
              </Badge>
            </HolographicBubble>
          </div>

          {/* Improvements */}
          {analysis?.improvements && analysis.improvements.length > 0 && (
            <div>
              <h3 className="text-lg font-semibold mb-3 flex items-center space-x-2 text-white">
                <TrendingUp className="w-5 h-5 text-green-400" />
                <span>Suggested Improvements</span>
              </h3>
              <div className="space-y-2">
                {analysis.improvements.map((improvement: string, index: number) => (
                  <HolographicBubble key={index}>
                    <div className="flex items-start space-x-3">
                      <div className="w-2 h-2 bg-green-400 rounded-full mt-2 flex-shrink-0" />
                      <p className="text-slate-300 text-sm">
                        {improvement}
                      </p>
                    </div>
                  </HolographicBubble>
                ))}
              </div>
            </div>
          )}

          {/* Security */}
          {analysis?.security && (
            <div>
              <h3 className="text-lg font-semibold mb-3 flex items-center space-x-2 text-white">
                <Shield className="w-5 h-5 text-orange-400" />
                <span>Security Assessment</span>
              </h3>
              <HolographicBubble>
                <p className="text-slate-300 leading-relaxed">
                  {analysis.security}
                </p>
              </HolographicBubble>
            </div>
          )}

          {/* Analysis Metadata */}
          <HolographicBubble>
            <h3 className="text-sm font-medium text-slate-400 mb-3">
              Analysis Details
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
              {analysis?.analyzedAt && (
                <div className="flex items-center space-x-2">
                  <Clock className="w-4 h-4 text-slate-500" />
                  <span className="text-slate-300">
                    Analyzed: {new Date(analysis.analyzedAt).toLocaleString()}
                  </span>
                </div>
              )}
              {analysis?.analysisType && (
                <div className="flex items-center space-x-2">
                  <Brain className="w-4 h-4 text-slate-500" />
                  <span className="text-slate-300">
                    Type: {analysis.analysisType}
                  </span>
                </div>
              )}
              {analysis?.fileMetadata?.encoding && (
                <div className="flex items-center space-x-2">
                  <FileText className="w-4 h-4 text-slate-500" />
                  <span className="text-slate-300">
                    Encoding: {analysis.fileMetadata.encoding}
                  </span>
                </div>
              )}
              {analysis?.model && (
                <div className="flex items-center space-x-2">
                  <Brain className="w-4 h-4 text-slate-500" />
                  <span className="text-slate-300">
                    Model: {analysis.model}
                  </span>
                </div>
              )}
            </div>
          </HolographicBubble>

          {/* Error Information (if analysis failed) */}
          {analysis?.error && (
            <HolographicBubble>
              <div className="flex items-center space-x-2 mb-2">
                <AlertTriangle className="w-5 h-5 text-red-400" />
                <span className="font-medium text-red-300">Analysis Error</span>
              </div>
              <p className="text-red-300 text-sm">
                {analysis.error}
              </p>
            </HolographicBubble>
          )}

          {/* Raw Response (for debugging) */}
          {analysis?.rawResponse && (
            <HolographicBubble>
              <details className="cursor-pointer">
                <summary className="font-medium text-slate-400">
                  Raw Analysis Response (Debug)
                </summary>
                <pre className="mt-2 text-xs text-slate-500 overflow-x-auto whitespace-pre-wrap">
                  {analysis.rawResponse}
                </pre>
              </details>
            </HolographicBubble>
          )}
        </div>

        <div className="flex justify-end space-x-2 pt-4 border-t border-slate-600/30">
          <Button variant="outline" onClick={onClose} className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50">
            Close
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================
File: client/src/components/FileManager/AnalysisStatusCard.tsx
================
import React from 'react';
import { motion } from 'framer-motion';
import { Brain, CheckCircle, AlertCircle, Clock, Sparkles, Eye, Zap } from 'lucide-react';
import { Badge } from '../ui/badge';
import { Button } from '../ui/button';
import { Card, CardContent } from '../ui/card';

interface AnalysisStatusCardProps {
  status: 'pending' | 'analyzing' | 'completed' | 'failed';
  analysis?: any;
  onAnalyze?: () => void;
  onViewResults?: () => void;
  className?: string;
}

const getStatusConfig = (status: string) => {
  switch (status) {
    case 'completed':
      return {
        icon: CheckCircle,
        color: 'text-green-400',
        bgColor: 'bg-green-500/20',
        borderColor: 'border-green-400/30',
        title: 'AI Analysis Complete',
        description: 'Your file has been analyzed by AI',
        actionText: 'View Insights',
        actionIcon: Eye
      };
    case 'analyzing':
      return {
        icon: Clock,
        color: 'text-violet-400',
        bgColor: 'bg-violet-500/20',
        borderColor: 'border-violet-400/30',
        title: 'AI Analyzing...',
        description: 'Our AI is examining your file',
        actionText: 'Analyzing',
        actionIcon: Brain
      };
    case 'failed':
      return {
        icon: AlertCircle,
        color: 'text-red-400',
        bgColor: 'bg-red-500/20',
        borderColor: 'border-red-400/30',
        title: 'Analysis Failed',
        description: 'Unable to analyze this file',
        actionText: 'Retry Analysis',
        actionIcon: Zap
      };
    case 'pending':
    default:
      return {
        icon: Brain,
        color: 'text-slate-400',
        bgColor: 'bg-slate-500/20',
        borderColor: 'border-slate-400/30',
        title: 'AI Analysis Available',
        description: 'Get insights about your file',
        actionText: 'Analyze with AI',
        actionIcon: Sparkles
      };
  }
};

const getAnalysisInsights = (analysis: any) => {
  if (!analysis) return null;

  const insights = [];
  
  if (analysis.summary) {
    insights.push({
      label: 'Summary',
      value: analysis.summary,
      type: 'text'
    });
  }
  
  if (analysis.quality) {
    insights.push({
      label: 'Quality',
      value: analysis.quality,
      type: 'badge'
    });
  }
  
  if (analysis.complexity) {
    insights.push({
      label: 'Complexity',
      value: analysis.complexity,
      type: 'badge'
    });
  }
  
  if (analysis.improvements && analysis.improvements.length > 0) {
    insights.push({
      label: 'Suggestions',
      value: analysis.improvements.slice(0, 2).join(', '),
      type: 'text'
    });
  }

  return insights;
};

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const AnalysisStatusCard: React.FC<AnalysisStatusCardProps> = ({
  status,
  analysis,
  onAnalyze,
  onViewResults,
  className = ''
}) => {
  const config = getStatusConfig(status);
  const IconComponent = config.icon;
  const ActionIcon = config.actionIcon;
  const insights = getAnalysisInsights(analysis);

  const handleAction = () => {
    if (status === 'completed' && onViewResults) {
      onViewResults();
    } else if (status === 'pending' && onAnalyze) {
      onAnalyze();
    } else if (status === 'failed' && onAnalyze) {
      onAnalyze();
    }
  };

  return (
    <HolographicBubble className={className}>
      <div className="flex items-start space-x-3">
        {/* Icon */}
        <div className={`flex-shrink-0 p-2 rounded-lg ${config.bgColor}`}>
          <IconComponent className={`w-5 h-5 ${config.color}`} />
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center justify-between mb-2">
            <h4 className="text-sm font-medium text-white">
              {config.title}
            </h4>
            <Badge 
              variant="outline"
              className={`text-xs ${config.color} ${config.borderColor}`}
            >
              {status === 'completed' && 'üß† Analyzed'}
              {status === 'analyzing' && '‚è≥ Analyzing'}
              {status === 'failed' && '‚ùå Failed'}
              {status === 'pending' && '‚è∏Ô∏è Pending'}
            </Badge>
          </div>

          <p className="text-sm text-slate-300 mb-3">
            {config.description}
          </p>

          {/* Quick Insights (for completed analysis) */}
          {status === 'completed' && insights && insights.length > 0 && (
            <div className="space-y-2 mb-3">
              {insights.slice(0, 2).map((insight, index) => (
                <div key={index} className="text-xs">
                  <span className="font-medium text-slate-200">{insight.label}: </span>
                  {insight.type === 'badge' ? (
                    <Badge variant="secondary" className="text-xs ml-1 bg-slate-700/50 text-slate-300 border-slate-600/50">
                      {insight.value}
                    </Badge>
                  ) : (
                    <span className="text-slate-400 line-clamp-1">
                      {insight.value}
                    </span>
                  )}
                </div>
              ))}
            </div>
          )}

          {/* Action Button */}
          <Button
            size="sm"
            variant={status === 'completed' ? 'default' : 'outline'}
            onClick={handleAction}
            disabled={status === 'analyzing'}
            className={`w-full ${
              status === 'completed' 
                ? 'bg-violet-500/20 text-violet-300 border-violet-400/30 hover:bg-violet-500/30' 
                : 'border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50'
            }`}
          >
            <ActionIcon className="w-3 h-3 mr-2" />
            {config.actionText}
          </Button>
        </div>
      </div>

      {/* Progress Indicator for Analyzing State */}
      {status === 'analyzing' && (
        <motion.div
          initial={{ width: 0 }}
          animate={{ width: '100%' }}
          transition={{ duration: 2, repeat: Infinity, ease: 'easeInOut' }}
          className="mt-3 h-1 bg-slate-700/50 rounded-full overflow-hidden"
        >
          <motion.div
            className="h-full bg-violet-400"
            animate={{ x: ['-100%', '100%'] }}
            transition={{ duration: 1.5, repeat: Infinity, ease: 'easeInOut' }}
          />
        </motion.div>
      )}
    </HolographicBubble>
  );
};

// Compact version for file cards
export const CompactAnalysisStatus: React.FC<{
  status: string;
  onClick?: () => void;
}> = ({ status, onClick }) => {
  const config = getStatusConfig(status);
  const IconComponent = config.icon;

  return (
    <Badge 
      variant="outline"
      className={`text-xs cursor-pointer transition-colors ${config.color} ${config.borderColor} hover:${config.bgColor}`}
      onClick={onClick && typeof onClick === 'function' ? onClick : undefined}
    >
      <IconComponent className="w-3 h-3 mr-1" />
      {status === 'completed' && 'Analyzed'}
      {status === 'analyzing' && 'Analyzing'}
      {status === 'failed' && 'Failed'}
      {status === 'pending' && 'Analyze'}
    </Badge>
  );
};

================
File: client/src/components/FileManager/EditFileModal.tsx
================
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Edit, 
  Save, 
  X, 
  FolderOpen, 
  Tag, 
  FileText, 
  Globe, 
  Lock,
  AlertCircle
} from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Textarea } from '../ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';
import { Checkbox } from '../ui/checkbox';
import { Badge } from '../ui/badge';
import { toast } from 'sonner';
import { type FileItem, type UpdateFileData, useFileManager } from '../../hooks/useFileManager';

interface EditFileModalProps {
  isOpen: boolean;
  onClose: () => void;
  file: FileItem | null;
}

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const EditFileModal: React.FC<EditFileModalProps> = ({
  isOpen,
  onClose,
  file
}) => {
  const fileManager = useFileManager();
  
  // Form state
  const [formData, setFormData] = useState<UpdateFileData>({
    name: '',
    description: '',
    tags: [],
    folder: '',
    isPublic: false
  });
  
  const [tagInput, setTagInput] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [hasChanges, setHasChanges] = useState(false);

  // Get available folders
  const { data: folders } = fileManager.useFolders();

  // Initialize form data when file changes
  useEffect(() => {
    if (file && isOpen) {
      setFormData({
        name: file.name,
        description: file.description || '',
        tags: file.tags || [],
        folder: file.folder,
        isPublic: file.isPublic
      });
      setTagInput('');
      setErrors({});
      setHasChanges(false);
    }
  }, [file, isOpen]);

  // Track changes
  useEffect(() => {
    if (!file) return;
    
    const hasNameChange = formData.name !== file.name;
    const hasDescriptionChange = formData.description !== (file.description || '');
    const hasTagsChange = JSON.stringify(formData.tags) !== JSON.stringify(file.tags || []);
    const hasFolderChange = formData.folder !== file.folder;
    const hasPublicChange = formData.isPublic !== file.isPublic;
    
    setHasChanges(hasNameChange || hasDescriptionChange || hasTagsChange || hasFolderChange || hasPublicChange);
  }, [formData, file]);

  // Validation
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.name?.trim()) {
      newErrors.name = 'File name is required';
    } else if (formData.name.length > 255) {
      newErrors.name = 'File name must be less than 255 characters';
    }

    if (formData.description && formData.description.length > 1000) {
      newErrors.description = 'Description must be less than 1000 characters';
    }

    if (formData.tags && formData.tags.length > 10) {
      newErrors.tags = 'Maximum 10 tags allowed';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleAddTag = () => {
    const tag = tagInput.trim();
    if (tag && !formData.tags?.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        tags: [...(prev.tags || []), tag]
      }));
      setTagInput('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags?.filter(tag => tag !== tagToRemove) || []
    }));
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };

  const handleSave = async () => {
    if (!file || !validateForm()) return;

    try {
      await fileManager.updateFile({ fileId: file.id, data: formData });
      toast.success('File updated successfully');
      onClose();
    } catch (error) {
      console.error('Update failed:', error);
      toast.error('Failed to update file');
    }
  };

  const handleCancel = () => {
    if (hasChanges) {
      if (confirm('You have unsaved changes. Are you sure you want to close?')) {
        onClose();
      }
    } else {
      onClose();
    }
  };

  if (!file) return null;

  return (
    <Dialog open={isOpen} onOpenChange={handleCancel}>
      <DialogContent className="sm:max-w-[600px] bg-slate-950 border-slate-700 text-white">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-xl font-semibold text-white">
            <Edit className="w-5 h-5 text-violet-400" />
            Edit File
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* File Info */}
          <HolographicBubble>
            <div className="flex items-center gap-3">
              <div className="flex-1">
                <h3 className="font-medium text-white">{file.originalName}</h3>
                <p className="text-sm text-slate-400">
                  {(file.size / 1024 / 1024).toFixed(2)} MB ‚Ä¢ {file.mimeType}
                </p>
              </div>
              <Badge variant="secondary" className="bg-slate-500/20 text-slate-300 border-slate-400/30">
                Version {file.currentVersion}
              </Badge>
            </div>
          </HolographicBubble>

          {/* Edit Form */}
          <HolographicBubble>
            <div className="space-y-6">
              <h4 className="font-medium text-white flex items-center gap-2">
                <FileText className="w-4 h-4" />
                File Information
              </h4>

              {/* File Name */}
              <div className="space-y-2">
                <Label htmlFor="name" className="text-slate-300">File Name *</Label>
                <Input
                  id="name"
                  value={formData.name}
                  onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                  className="bg-slate-800/50 border-slate-600/50 text-white placeholder:text-slate-400 focus:border-violet-400/50"
                  placeholder="Enter file name"
                />
                {errors.name && (
                  <div className="flex items-center gap-2 text-red-400 text-sm">
                    <AlertCircle className="w-4 h-4" />
                    {errors.name}
                  </div>
                )}
              </div>

              {/* Description */}
              <div className="space-y-2">
                <Label htmlFor="description" className="text-slate-300">Description</Label>
                <Textarea
                  id="description"
                  value={formData.description}
                  onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                  className="bg-slate-800/50 border-slate-600/50 text-white placeholder:text-slate-400 focus:border-violet-400/50 min-h-[80px]"
                  placeholder="Enter file description (optional)"
                />
                {errors.description && (
                  <div className="flex items-center gap-2 text-red-400 text-sm">
                    <AlertCircle className="w-4 h-4" />
                    {errors.description}
                  </div>
                )}
                <p className="text-xs text-slate-500">
                  {formData.description?.length || 0}/1000 characters
                </p>
              </div>

              {/* Folder */}
              <div className="space-y-2">
                <Label htmlFor="folder" className="text-slate-300">Folder</Label>
                <Select 
                  value={formData.folder} 
                  onValueChange={(value) => setFormData(prev => ({ ...prev, folder: value }))}
                >
                  <SelectTrigger className="bg-slate-800/50 border-slate-600/50 text-white">
                    <SelectValue placeholder="Select folder" />
                  </SelectTrigger>
                  <SelectContent className="bg-slate-800 border-slate-600">
                    <SelectItem value="/" className="text-white">
                      <div className="flex items-center gap-2">
                        <FolderOpen className="w-4 h-4" />
                        Root folder
                      </div>
                    </SelectItem>
                    {folders?.map(folder => (
                      <SelectItem key={folder} value={folder} className="text-white">
                        <div className="flex items-center gap-2">
                          <FolderOpen className="w-4 h-4" />
                          {folder}
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Tags */}
              <div className="space-y-3">
                <Label className="text-slate-300">Tags</Label>
                
                {/* Current Tags */}
                {formData.tags && formData.tags.length > 0 && (
                  <div className="flex flex-wrap gap-2">
                    {formData.tags.map((tag) => (
                      <Badge 
                        key={tag} 
                        variant="secondary" 
                        className="bg-violet-500/20 text-violet-300 border-violet-400/30 cursor-pointer hover:bg-red-500/20 hover:text-red-300 hover:border-red-400/30 transition-colors"
                        onClick={() => handleRemoveTag(tag)}
                      >
                        <Tag className="w-3 h-3 mr-1" />
                        {tag}
                        <X className="w-3 h-3 ml-1" />
                      </Badge>
                    ))}
                  </div>
                )}

                {/* Add Tag Input */}
                <div className="flex gap-2">
                  <Input
                    value={tagInput}
                    onChange={(e) => setTagInput(e.target.value)}
                    onKeyPress={handleKeyPress}
                    className="bg-slate-800/50 border-slate-600/50 text-white placeholder:text-slate-400 focus:border-violet-400/50"
                    placeholder="Add a tag..."
                  />
                  <Button
                    type="button"
                    onClick={handleAddTag}
                    disabled={!tagInput.trim() || (formData.tags?.length || 0) >= 10}
                    variant="outline"
                    className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                  >
                    Add
                  </Button>
                </div>
                
                {errors.tags && (
                  <div className="flex items-center gap-2 text-red-400 text-sm">
                    <AlertCircle className="w-4 h-4" />
                    {errors.tags}
                  </div>
                )}
                
                <p className="text-xs text-slate-500">
                  {formData.tags?.length || 0}/10 tags ‚Ä¢ Press Enter or click Add to create a tag
                </p>
              </div>

              {/* Privacy Settings */}
              <div className="space-y-3">
                <Label className="text-slate-300">Privacy</Label>
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="isPublic" 
                    checked={formData.isPublic}
                    onCheckedChange={(checked) => setFormData(prev => ({ ...prev, isPublic: checked === true }))}
                    className="border-slate-600"
                  />
                  <Label htmlFor="isPublic" className="text-slate-300 flex items-center gap-2">
                    {formData.isPublic ? (
                      <Globe className="w-4 h-4 text-green-400" />
                    ) : (
                      <Lock className="w-4 h-4 text-slate-400" />
                    )}
                    Make file public
                  </Label>
                </div>
                <p className="text-xs text-slate-500">
                  Public files can be accessed by anyone with the link
                </p>
              </div>
            </div>
          </HolographicBubble>

          {/* Actions */}
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              {hasChanges && (
                <motion.div
                  initial={{ opacity: 0, x: -10 }}
                  animate={{ opacity: 1, x: 0 }}
                  className="flex items-center gap-2 text-amber-400 text-sm"
                >
                  <AlertCircle className="w-4 h-4" />
                  Unsaved changes
                </motion.div>
              )}
            </div>
            
            <div className="flex gap-3">
              <Button 
                variant="outline" 
                onClick={handleCancel}
                className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
              >
                Cancel
              </Button>
              <Button 
                onClick={handleSave}
                disabled={fileManager.isUpdating || !hasChanges || Object.keys(errors).length > 0}
                className="bg-violet-600 hover:bg-violet-700 text-white"
              >
                {fileManager.isUpdating ? (
                  <>
                    <motion.div
                      animate={{ rotate: 360 }}
                      transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                      className="w-4 h-4 mr-2"
                    >
                      ‚ü≥
                    </motion.div>
                    Saving...
                  </>
                ) : (
                  <>
                    <Save className="w-4 h-4 mr-2" />
                    Save Changes
                  </>
                )}
              </Button>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================
File: client/src/components/FileManager/EnhancedFileCard.tsx
================
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Download, 
  Share, 
  Trash2, 
  Edit, 
  Brain,
  Eye,
  MoreVertical,
  RefreshCcw,
  FileText,
  Image as ImageIcon,
  Video,
  Music,
  Archive,
  Code,
  File
} from 'lucide-react';
import { Card } from '../ui/card';
import { Badge } from '../ui/badge';
import { Button } from '../ui/button';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu';
import { type FileItem } from '../../hooks/useFileManager';
import { Tooltip, TooltipContent, TooltipTrigger } from '../ui/tooltip';

interface EnhancedFileCardProps {
  file: FileItem;
  isSelected: boolean;
  onSelect: (fileId: number) => void;
  onDownload: (file: FileItem) => void;
  onEdit: (file: FileItem) => void;
  onAnalyze: (fileId: number) => void;
  onReindex?: (fileId: number) => void;
  onDelete: (fileId: number) => void;
  onShare: (file: FileItem) => void;
  onViewAnalysis?: (file: FileItem) => void;
  viewMode: 'grid' | 'list';
  enableAIAnalysis?: boolean;
}

const getFileIcon = (mimeType: string, size: 'sm' | 'md' | 'lg' = 'md') => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-6 h-6',
    lg: 'w-8 h-8'
  };

  if (mimeType.startsWith('image/')) return <ImageIcon className={sizeClasses[size]} />;
  if (mimeType.startsWith('video/')) return <Video className={sizeClasses[size]} />;
  if (mimeType.startsWith('audio/')) return <Music className={sizeClasses[size]} />;
  if (mimeType.includes('pdf')) return <FileText className={sizeClasses[size]} />;
  if (mimeType.includes('text/') || mimeType.includes('javascript') || mimeType.includes('json')) return <Code className={sizeClasses[size]} />;
  if (mimeType.includes('zip') || mimeType.includes('archive')) return <Archive className={sizeClasses[size]} />;
  return <File className={sizeClasses[size]} />;
};

const isTextLike = (mimeType: string) => {
  return mimeType.startsWith('text/') || mimeType.includes('javascript') || mimeType.includes('json');
};

const formatFileSize = (bytes: number) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - date.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  if (diffDays === 1) return 'Today';
  if (diffDays === 2) return 'Yesterday';
  if (diffDays <= 7) return `${diffDays - 1} days ago`;
  return date.toLocaleDateString();
};

const getAnalysisDescription = (status: string) => {
  switch (status) {
    case 'completed': return 'AI analysis complete';
    case 'analyzing': return 'AI analyzing file...';
    case 'failed': return 'Analysis failed';
    case 'pending': return 'Analysis pending';
    default: return 'No analysis';
  }
};

const getAnalysisColor = (status: string) => {
  switch (status) {
    case 'completed': return 'bg-green-500/20 text-green-300 border-green-400/30';
    case 'analyzing': return 'bg-violet-500/20 text-violet-300 border-violet-400/30';
    case 'failed': return 'bg-red-500/20 text-red-300 border-red-400/30';
    case 'pending': return 'bg-slate-500/20 text-slate-300 border-slate-400/30';
    default: return 'bg-slate-500/20 text-slate-300 border-slate-400/30';
  }
};

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
  onMouseEnter?: () => void;
  onMouseLeave?: () => void;
}> = ({ children, className, onClick, onMouseEnter, onMouseLeave }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
    onClick={onClick && typeof onClick === 'function' ? onClick : undefined}
    onMouseEnter={onMouseEnter}
    onMouseLeave={onMouseLeave}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const EnhancedFileCard: React.FC<EnhancedFileCardProps> = ({
  file,
  isSelected,
  onSelect,
  onDownload,
  onEdit,
  onAnalyze,
  onReindex,
  onDelete,
  onShare,
  onViewAnalysis,
  viewMode,
  enableAIAnalysis = true
}) => {
  const [isHovered, setIsHovered] = useState(false);
  const [showDetails, setShowDetails] = useState(false);

  const handleCardClick = () => {
    onSelect(file.id);
  };

  const handleActionClick = (e: React.MouseEvent, action: () => void) => {
    e.stopPropagation();
    action();
  };

  if (viewMode === 'list') {
    return (
      <HolographicBubble
        className={`
          relative group cursor-pointer transition-all duration-200
          ${isSelected ? 'ring-2 ring-violet-400 bg-violet-500/20' : 'hover:bg-slate-700/30'}
          ${isHovered ? 'shadow-lg' : 'shadow-sm'}
        `}
        onClick={handleCardClick}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        <div className="flex items-center space-x-4">
          {/* File Icon */}
          <div className="flex-shrink-0">
            <div className="p-2 bg-slate-700/50 rounded-lg group-hover:bg-violet-500/20 transition-colors">
              {getFileIcon(file.mimeType, 'md')}
            </div>
          </div>

          {/* File Info */}
          <div className="flex-1 min-w-0">
            <h3 className="font-medium text-white truncate group-hover:text-violet-300 transition-colors">
              {file.name}
            </h3>
            <div className="flex items-center space-x-4 text-sm text-slate-400 mt-1">
              <span>{formatFileSize(file.size)}</span>
              <span>‚Ä¢</span>
              <span>{formatDate(file.updatedAt)}</span>
              {isTextLike(file.mimeType) && (
                <>
                  <span>‚Ä¢</span>
                  <Badge variant="outline" className="text-xs bg-emerald-500/15 text-emerald-300 border-emerald-400/20">Embedded</Badge>
                </>
              )}
              {file.description && (
                <>
                  <span>‚Ä¢</span>
                  <span className="truncate">{file.description}</span>
                </>
              )}
            </div>
            
            {/* Tags */}
            {file.tags.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {file.tags.slice(0, 3).map(tag => (
                  <Badge key={tag} variant="secondary" className="text-xs bg-slate-700/50 text-slate-300 border-slate-600/50">
                    {tag}
                  </Badge>
                ))}
                {file.tags.length > 3 && (
                  <Badge variant="secondary" className="text-xs bg-slate-700/50 text-slate-300 border-slate-600/50">
                    +{file.tags.length - 3}
                  </Badge>
                )}
              </div>
            )}
          </div>

          {/* AI Analysis Status */}
          {enableAIAnalysis && file.analysisStatus && (
            <div className="flex-shrink-0">
              <Tooltip>
                <TooltipTrigger asChild>
                  <Badge 
                    variant="outline"
                    className={`text-xs ${getAnalysisColor(file.analysisStatus)}`}
                  >
                    {file.analysisStatus === 'completed' && 'üß† Analyzed'}
                    {file.analysisStatus === 'analyzing' && '‚è≥ Analyzing'}
                    {file.analysisStatus === 'failed' && '‚ùå Failed'}
                    {file.analysisStatus === 'pending' && '‚è∏Ô∏è Pending'}
                  </Badge>
                </TooltipTrigger>
                {isTextLike(file.mimeType) && (
                  <TooltipContent>Available in chat context</TooltipContent>
                )}
              </Tooltip>
            </div>
          )}

          {/* Actions */}
          <AnimatePresence>
            {isHovered && (
              <motion.div
                initial={{ opacity: 0, x: 10 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 10 }}
                className="flex items-center space-x-1 flex-shrink-0"
                onClick={(e) => e.stopPropagation()}
              >
                {onReindex && (
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={(e) => handleActionClick(e, () => onReindex(file.id))}
                    className="h-8 px-2 border-slate-600/50 text-emerald-300 hover:text-white hover:bg-slate-700/50"
                  >
                    Use in Chat
                  </Button>
                )}
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={(e) => handleActionClick(e, () => onDownload(file))}
                  className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50"
                >
                  <Download className="w-4 h-4" />
                </Button>
                {enableAIAnalysis && (
                  <>
                    {(() => {
                      const shouldShowViewAnalysis = file.analysisStatus === 'completed' && onViewAnalysis;
                      console.log('Should show View Analysis button:', shouldShowViewAnalysis, {
                        analysisStatus: file.analysisStatus,
                        hasOnViewAnalysis: !!onViewAnalysis
                      });
                      return shouldShowViewAnalysis;
                    })() ? (
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => {
                          console.log('View Analysis button clicked for file:', file.id);
                          handleActionClick(e, () => onViewAnalysis!(file));
                        }}
                        className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50"
                        title="View Analysis"
                      >
                        <Eye className="w-4 h-4" />
                      </Button>
                    ) : (
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => handleActionClick(e, () => onAnalyze(file.id))}
                        disabled={file.analysisStatus === 'analyzing'}
                        className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50"
                        title="Analyze File"
                      >
                        <Brain className="w-4 h-4" />
                      </Button>
                    )}
                    {onReindex && (
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => handleActionClick(e, () => onReindex(file.id))}
                        className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50"
                        title="Refresh for Chat"
                      >
                        <RefreshCcw className="w-4 h-4" />
                      </Button>
                    )}
                  </>
                )}
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={(e) => handleActionClick(e, () => onShare(file))}
                  className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50"
                >
                  <Share className="w-4 h-4" />
                </Button>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button size="sm" variant="ghost" className="h-8 w-8 p-0 text-slate-300 hover:text-white hover:bg-slate-700/50">
                      <MoreVertical className="w-4 h-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="bg-slate-800 border-slate-600">
                    <DropdownMenuItem onClick={(e) => handleActionClick(e, () => onEdit(file))}>
                      <Edit className="w-4 h-4 mr-2" />
                      Edit Details
                    </DropdownMenuItem>
                    {enableAIAnalysis && onReindex && (
                      <DropdownMenuItem onClick={(e) => handleActionClick(e, () => onReindex(file.id))}>
                        <RefreshCcw className="w-4 h-4 mr-2" />
                        Refresh for Chat
                      </DropdownMenuItem>
                    )}
                    <DropdownMenuItem onClick={(e) => handleActionClick(e, () => onDelete(file.id))}>
                      <Trash2 className="w-4 h-4 mr-2" />
                      Delete
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </HolographicBubble>
    );
  }

  // Grid View
  return (
    <HolographicBubble
      className={`
        relative group cursor-pointer transition-all duration-200
        ${isSelected ? 'ring-2 ring-violet-400 bg-violet-500/20' : 'hover:bg-slate-700/30'}
        ${isHovered ? 'shadow-lg' : 'shadow-sm'}
      `}
      onClick={handleCardClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <div className="p-4">
        {/* Keep top-left refresh only if you still want it visible without hover. Commented out per overlap issue. */}
        {/* Primary Info Layer */}
        <div className="text-center">
          <div className="flex justify-center mb-3">
            <div className="p-3 bg-slate-700/50 rounded-xl group-hover:bg-violet-500/20 transition-colors">
              {getFileIcon(file.mimeType, 'lg')}
            </div>
          </div>
          
          <h3 className="font-medium text-sm truncate group-hover:text-violet-300 transition-colors text-white" title={file.name}>
            {file.name}
          </h3>
          
          <p className="text-xs text-slate-400 mt-1">
            {formatFileSize(file.size)}
          </p>
          
          <p className="text-xs text-slate-500 mt-1">
            {formatDate(file.updatedAt)}
          </p>
        </div>

        {/* Secondary Info Layer (on hover) */}
        <AnimatePresence>
          {isHovered && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              className="absolute inset-0 bg-slate-800/95 backdrop-blur-sm rounded-xl p-4 flex flex-col justify-center"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="space-y-3">
                {/* Description */}
                {file.description && (
                  <p className="text-sm text-slate-300 line-clamp-2">
                    {file.description}
                  </p>
                )}
                
                {/* Tags */}
                {file.tags.length > 0 && (
                  <div className="flex flex-wrap gap-1 justify-center">
                    {file.tags.slice(0, 3).map(tag => (
                      <Badge key={tag} variant="secondary" className="text-xs bg-slate-700/50 text-slate-300 border-slate-600/50">
                        {tag}
                      </Badge>
                    ))}
                    {file.tags.length > 3 && (
                      <Badge variant="secondary" className="text-xs bg-slate-700/50 text-slate-300 border-slate-600/50">
                        +{file.tags.length - 3}
                      </Badge>
                    )}
                  </div>
                )}
                
                {/* AI Analysis Status */}
                {enableAIAnalysis && file.analysisStatus && (
                  <div className="text-center">
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Badge 
                          variant="outline"
                          className={`text-xs ${getAnalysisColor(file.analysisStatus)}`}
                        >
                          {getAnalysisDescription(file.analysisStatus)}
                        </Badge>
                      </TooltipTrigger>
                      {isTextLike(file.mimeType) && (
                        <TooltipContent>Available in chat context</TooltipContent>
                      )}
                    </Tooltip>
                  </div>
                )}

                {/* Embedded Indicator (text-like files) */}
                {isTextLike(file.mimeType) && (
                  <div className="text-center">
                    <Badge variant="outline" className="text-xs bg-emerald-500/15 text-emerald-300 border-emerald-400/20">
                      Embedded
                    </Badge>
                  </div>
                )}
                
                {/* Quick Actions */}
                <div className="flex justify-center space-x-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={(e) => handleActionClick(e, () => onDownload(file))}
                    className="h-8 w-8 p-0 border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                    title="Download file"
                  >
                    <Download className="w-4 h-4" />
                  </Button>
                  
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={(e) => handleActionClick(e, () => onShare(file))}
                    className="h-8 w-8 p-0 border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                    title="Share file"
                  >
                    <Share className="w-4 h-4" />
                  </Button>
                  
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={(e) => handleActionClick(e, () => onEdit(file))}
                    className="h-8 w-8 p-0 border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                    title="Edit file details"
                  >
                    <Edit className="w-4 h-4" />
                  </Button>
                  {onReindex && (
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={(e) => handleActionClick(e, () => onReindex(file.id))}
                      className="h-8 w-8 p-0 border-slate-600/50 text-emerald-300 hover:text-white hover:bg-slate-700/50"
                      title="Refresh for Chat"
                    >
                      <RefreshCcw className="w-4 h-4" />
                    </Button>
                  )}
                  
                  {enableAIAnalysis && (
                    <>
                      {(() => {
                        const shouldShowViewAnalysis = file.analysisStatus === 'completed' && onViewAnalysis;
                        console.log('Should show View Analysis button (grid):', shouldShowViewAnalysis, {
                          analysisStatus: file.analysisStatus,
                          hasOnViewAnalysis: !!onViewAnalysis
                        });
                        return shouldShowViewAnalysis;
                      })() ? (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={(e) => {
                            console.log('View Analysis button clicked (grid) for file:', file.id);
                            handleActionClick(e, () => onViewAnalysis!(file));
                          }}
                          className="h-8 w-8 p-0 border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                          title="View AI Analysis"
                        >
                          <Eye className="w-4 h-4" />
                        </Button>
                      ) : (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={(e) => handleActionClick(e, () => onAnalyze(file.id))}
                          disabled={file.analysisStatus === 'analyzing'}
                          className="h-8 w-8 p-0 border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                          title="Analyze with AI"
                        >
                          <Brain className="w-4 h-4" />
                        </Button>
                      )}
                    </>
                  )}
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Selection Indicator */}
        {isSelected && (
          <div className="absolute top-2 right-2">
            <div className="w-4 h-4 bg-violet-400 rounded-full flex items-center justify-center">
              <div className="w-2 h-2 bg-white rounded-full" />
            </div>
          </div>
        )}
      </div>
    </HolographicBubble>
  );
};

================
File: client/src/components/FileManager/EnhancedFileManager.tsx
================
import React, { useState, useRef, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Search, 
  FolderOpen, 
  Grid, 
  List, 
  Plus,
  Trash2,
  Download,
  Share,
  Brain,
  Settings,
  Keyboard,
  Filter,
  SortAsc,
  SortDesc
} from 'lucide-react';
import { useFileManager, type FileItem, type UploadFileData, type ListFilesOptions } from '../../hooks/useFileManager';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Badge } from '../ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip';
import { toast } from 'sonner';

// Import enhanced components
import { EnhancedFileCard } from './EnhancedFileCard';
import { InlineUploadArea } from './InlineUploadArea';
import { SkeletonLoader, EmptyStateSkeleton } from './SkeletonLoader';
import { AnalysisStatusCard } from './AnalysisStatusCard';
import { AnalysisModal } from './AnalysisModal';
import { TestModal } from './TestModal';
import { ShareFileModal } from './ShareFileModal';
import { EditFileModal } from './EditFileModal';

interface EnhancedFileManagerProps {
  className?: string;
  initialFolder?: string;
  onFileSelect?: (file: FileItem) => void;
  maxFileSize?: number;
  allowedFileTypes?: string[];
  enableAIAnalysis?: boolean;
  showUploadArea?: boolean;
}

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-6 rounded-2xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const EnhancedFileManager: React.FC<EnhancedFileManagerProps> = ({
  className = '',
  initialFolder = '/',
  onFileSelect,
  maxFileSize = 10 * 1024 * 1024,
  allowedFileTypes,
  enableAIAnalysis = true,
  showUploadArea = true
}) => {
  const fileManager = useFileManager();
  
  // State management
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFolder, setSelectedFolder] = useState(initialFolder);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [mimeTypeFilter, setMimeTypeFilter] = useState('all');
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [sortBy, setSortBy] = useState<'name' | 'date' | 'size'>('date');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
  const [selectedFiles, setSelectedFiles] = useState<Set<number>>(new Set());
  const [showUploadZone, setShowUploadZone] = useState(showUploadArea);
  const [showKeyboardShortcuts, setShowKeyboardShortcuts] = useState(false);
  
  // File operations state
  const [filesToUpload, setFilesToUpload] = useState<File[]>([]);
  const [uploadData, setUploadData] = useState<Partial<UploadFileData>>({
    folder: selectedFolder,
    description: '',
    tags: []
  });

  // Analysis modal state
  const [analysisModalFile, setAnalysisModalFile] = useState<FileItem | null>(null);
  const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
  
  // Test modal state
  const [isTestModalOpen, setIsTestModalOpen] = useState(false);

  // Share modal state
  const [shareModalFile, setShareModalFile] = useState<FileItem | null>(null);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);

  // Edit modal state
  const [editModalFile, setEditModalFile] = useState<FileItem | null>(null);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);

  // Query options
  const listOptions: ListFilesOptions = {
    folder: selectedFolder === '/' ? undefined : selectedFolder,
    search: searchQuery || undefined,
    tags: selectedTags.length > 0 ? selectedTags : undefined,
    mimeType: mimeTypeFilter && mimeTypeFilter !== 'all' ? mimeTypeFilter : undefined,
    limit: 50,
    offset: 0
  };

  // Fetch data
  const { data: fileList, isLoading, error } = fileManager.useFileList(listOptions);
  const { data: folders } = fileManager.useFolders();

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle shortcuts when not typing in input fields
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      switch (e.key) {
        case 'a':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (fileList?.files.length) {
              setSelectedFiles(new Set(fileList.files.map(f => f.id)));
            }
          }
          break;
        case 'Escape':
          setSelectedFiles(new Set());
          break;
        case 'Delete':
          if (selectedFiles.size > 0) {
            e.preventDefault();
            handleBulkDelete();
          }
          break;
        case 'g':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            setViewMode(prev => prev === 'grid' ? 'list' : 'grid');
          }
          break;
        case 'u':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            setShowUploadZone(prev => !prev);
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedFiles, fileList, viewMode]);

  // File operations
  const handleFileUpload = useCallback(async (files: File[]) => {
    setFilesToUpload(files);
    
    for (const file of files) {
      try {
        await fileManager.uploadFile({
          file,
          folder: uploadData.folder || selectedFolder,
          description: uploadData.description,
          tags: uploadData.tags
        });
        toast.success(`File "${file.name}" uploaded successfully`);
      } catch (error) {
        toast.error(`Failed to upload "${file.name}"`);
      }
    }
    
    setFilesToUpload([]);
    setUploadData({ folder: selectedFolder, description: '', tags: [] });
  }, [fileManager, uploadData, selectedFolder]);

  const handleFileDownload = async (file: FileItem) => {
    try {
      await fileManager.downloadFile(file.id, file.originalName);
      toast.success('Download started');
    } catch (error) {
      toast.error('Download failed');
    }
  };

  const handleFileAnalyze = async (fileId: number) => {
    try {
      await fileManager.analyzeFile(fileId);
      toast.success('File analysis completed');
    } catch (error) {
      toast.error('Analysis failed. Please check your subscription status.');
    }
  };

  const handleViewAnalysis = (file: FileItem) => {
    console.log('handleViewAnalysis called with file:', file);
    console.log('File analysis status:', file.analysisStatus);
    console.log('File analysis data:', file.aiAnalysis);
    console.log('Full file object:', JSON.stringify(file, null, 2));
    setAnalysisModalFile(file);
    setIsAnalysisModalOpen(true);
  };

  const handleCloseAnalysisModal = () => {
    setIsAnalysisModalOpen(false);
    setAnalysisModalFile(null);
  };

  const handleFileDelete = async (fileId: number) => {
    try {
      await fileManager.deleteFile(fileId);
      toast.success('File deleted');
      setSelectedFiles(prev => {
        const newSet = new Set(prev);
        newSet.delete(fileId);
        return newSet;
      });
    } catch (error) {
      toast.error('Failed to delete file');
    }
  };

  const handleBulkDelete = async () => {
    if (selectedFiles.size === 0) return;
    
    try {
      await fileManager.bulkDeleteFiles(Array.from(selectedFiles));
      toast.success('Files deleted successfully');
      setSelectedFiles(new Set());
    } catch (error) {
      toast.error('Bulk delete failed');
    }
  };

  const handleFileShare = async (file: FileItem) => {
    setShareModalFile(file);
    setIsShareModalOpen(true);
  };

  const handleFileEdit = (file: FileItem) => {
    setEditModalFile(file);
    setIsEditModalOpen(true);
  };

  const handleCloseShareModal = () => {
    setIsShareModalOpen(false);
    setShareModalFile(null);
  };

  const handleCloseEditModal = () => {
    setIsEditModalOpen(false);
    setEditModalFile(null);
  };

  const handleFileSelect = (fileId: number) => {
    if (onFileSelect) {
      const file = fileList?.files.find(f => f.id === fileId);
      if (file) onFileSelect(file);
    } else {
      setSelectedFiles(prev => {
        const newSet = new Set(prev);
        if (newSet.has(fileId)) {
          newSet.delete(fileId);
        } else {
          newSet.add(fileId);
        }
        return newSet;
      });
    }
  };

  // Sort files
  const sortedFiles = fileList?.files ? [...fileList.files].sort((a, b) => {
    let comparison = 0;
    
    switch (sortBy) {
      case 'name':
        comparison = a.name.localeCompare(b.name);
        break;
      case 'date':
        comparison = new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime();
        break;
      case 'size':
        comparison = a.size - b.size;
        break;
    }
    
    return sortOrder === 'asc' ? comparison : -comparison;
  }) : [];

  return (
    <TooltipProvider>
      <div className={`flex flex-col h-full bg-slate-950 text-white ${className}`}>
        {/* Header */}
        <HolographicBubble className="m-4 mb-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <h2 className="text-xl font-semibold text-white">File Manager</h2>
              
              {selectedFiles.size > 0 && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.8 }}
                  animate={{ opacity: 1, scale: 1 }}
                  className="flex items-center space-x-2"
                >
                  <Badge variant="secondary" className="bg-violet-500/20 text-violet-300 border-violet-400/30">
                    {selectedFiles.size} selected
                  </Badge>
                  <Button
                    size="sm"
                    variant="destructive"
                    onClick={handleBulkDelete}
                    disabled={fileManager.isBulkDeleting}
                    className="bg-red-500/20 hover:bg-red-500/30 border-red-400/30 text-red-300"
                  >
                    <Trash2 className="w-4 h-4 mr-1" />
                    Delete
                  </Button>
                </motion.div>
              )}
            </div>
            
            <div className="flex items-center space-x-2">
              {/* View Mode Toggle */}
              <div className="flex items-center border border-slate-600/50 rounded-lg bg-slate-800/30">
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      size="sm"
                      variant={viewMode === 'grid' ? 'default' : 'ghost'}
                      onClick={() => setViewMode('grid')}
                      className={`rounded-r-none ${viewMode === 'grid' ? 'bg-violet-500/20 text-violet-300 border-violet-400/30' : 'text-slate-300 hover:text-white hover:bg-slate-700/50'}`}
                    >
                      <Grid className="w-4 h-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Grid view (Ctrl+G)</TooltipContent>
                </Tooltip>
                
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      size="sm"
                      variant={viewMode === 'list' ? 'default' : 'ghost'}
                      onClick={() => setViewMode('list')}
                      className={`rounded-l-none ${viewMode === 'list' ? 'bg-violet-500/20 text-violet-300 border-violet-400/30' : 'text-slate-300 hover:text-white hover:bg-slate-700/50'}`}
                    >
                      <List className="w-4 h-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>List view (Ctrl+G)</TooltipContent>
                </Tooltip>
              </div>

              {/* Upload Toggle */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant={showUploadZone ? 'default' : 'outline'}
                    onClick={() => setShowUploadZone(!showUploadZone)}
                    className={showUploadZone 
                      ? 'bg-violet-500/20 text-violet-300 border-violet-400/30' 
                      : 'border-slate-600/50 text-white bg-slate-800/50 hover:text-violet-300 hover:bg-violet-500/10 hover:border-violet-400/30'
                    }
                  >
                    <Plus className="w-4 h-4 mr-1" />
                    Upload
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Toggle upload area (Ctrl+U)</TooltipContent>
              </Tooltip>

              {/* Test Modal Button */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => setIsTestModalOpen(true)}
                    className="text-slate-300 hover:text-white hover:bg-slate-700/50"
                  >
                    Test
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Test Modal</TooltipContent>
              </Tooltip>

              {/* Keyboard Shortcuts */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => setShowKeyboardShortcuts(!showKeyboardShortcuts)}
                    className="text-slate-300 hover:text-white hover:bg-slate-700/50"
                  >
                    <Keyboard className="w-4 h-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Keyboard shortcuts</TooltipContent>
              </Tooltip>
            </div>
          </div>
        </HolographicBubble>

        {/* Keyboard Shortcuts Modal */}
        <AnimatePresence>
          {showKeyboardShortcuts && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className="mx-4 mb-2"
            >
              <HolographicBubble>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                  <div><kbd className="px-2 py-1 bg-slate-700/50 text-slate-300 rounded border border-slate-600/50">Ctrl+A</kbd> Select all</div>
                  <div><kbd className="px-2 py-1 bg-slate-700/50 text-slate-300 rounded border border-slate-600/50">Ctrl+G</kbd> Toggle view</div>
                  <div><kbd className="px-2 py-1 bg-slate-700/50 text-slate-300 rounded border border-slate-600/50">Ctrl+U</kbd> Toggle upload</div>
                  <div><kbd className="px-2 py-1 bg-slate-700/50 text-slate-300 rounded border border-slate-600/50">Delete</kbd> Delete selected</div>
                </div>
              </HolographicBubble>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Upload Area */}
        <AnimatePresence>
          {showUploadZone && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="mx-4 mb-2"
            >
              <HolographicBubble>
                <InlineUploadArea
                  onFilesSelected={handleFileUpload}
                  maxFileSize={maxFileSize}
                  allowedFileTypes={allowedFileTypes}
                  isUploading={fileManager.isUploading}
                  uploadProgress={fileManager.uploadProgress}
                />
              </HolographicBubble>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Filters and Search */}
        <HolographicBubble className="mx-4 mb-2">
          <div className="flex items-center space-x-4">
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400 w-4 h-4" />
                <Input
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="Search files..."
                  className="pl-10 bg-slate-800/30 border-slate-600/50 text-white placeholder:text-slate-400 focus:border-violet-400/50"
                />
              </div>
            </div>

            <Select value={selectedFolder} onValueChange={setSelectedFolder}>
              <SelectTrigger className="w-48 bg-slate-800/30 border-slate-600/50 text-white">
                <SelectValue placeholder="All folders" />
              </SelectTrigger>
              <SelectContent className="bg-slate-800 border-slate-600">
                <SelectItem value="/">All folders</SelectItem>
                {folders?.map(folder => (
                  <SelectItem key={folder} value={folder}>
                    <FolderOpen className="w-4 h-4 mr-2 inline" />
                    {folder}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <Select value={mimeTypeFilter} onValueChange={setMimeTypeFilter}>
              <SelectTrigger className="w-40 bg-slate-800/30 border-slate-600/50 text-white">
                <SelectValue placeholder="File type" />
              </SelectTrigger>
              <SelectContent className="bg-slate-800 border-slate-600">
                <SelectItem value="all">All types</SelectItem>
                <SelectItem value="image/">Images</SelectItem>
                <SelectItem value="text/">Text files</SelectItem>
                <SelectItem value="application/pdf">PDF</SelectItem>
                <SelectItem value="video/">Videos</SelectItem>
                <SelectItem value="audio/">Audio</SelectItem>
              </SelectContent>
            </Select>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm" className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50">
                  <SortAsc className="w-4 h-4 mr-1" />
                  Sort
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent className="bg-slate-800 border-slate-600">
                <DropdownMenuItem onClick={() => { setSortBy('name'); setSortOrder('asc'); }}>
                  Name A-Z
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => { setSortBy('name'); setSortOrder('desc'); }}>
                  Name Z-A
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => { setSortBy('date'); setSortOrder('desc'); }}>
                  Newest first
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => { setSortBy('date'); setSortOrder('asc'); }}>
                  Oldest first
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => { setSortBy('size'); setSortOrder('desc'); }}>
                  Largest first
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => { setSortBy('size'); setSortOrder('asc'); }}>
                  Smallest first
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </HolographicBubble>

        {/* File List */}
        <div className="flex-1 overflow-auto p-4">
          {isLoading ? (
            <SkeletonLoader viewMode={viewMode} count={8} />
          ) : error ? (
            <div className="flex items-center justify-center h-64">
              <HolographicBubble>
                <div className="text-center text-red-400">
                  <p>Failed to load files</p>
                  <p className="text-sm text-slate-400">{error.message}</p>
                </div>
              </HolographicBubble>
            </div>
          ) : !sortedFiles.length ? (
            <EmptyStateSkeleton />
          ) : (
            <div className={viewMode === 'grid' 
              ? "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"
              : "space-y-2"
            }>
              {sortedFiles.map((file) => (
                <EnhancedFileCard
                  key={file.id}
                  file={file}
                  isSelected={selectedFiles.has(file.id)}
                  onSelect={handleFileSelect}
                  onDownload={handleFileDownload}
                  onEdit={handleFileEdit}
                  onAnalyze={handleFileAnalyze}
                  onReindex={(id) => fileManager.reindexFile(id)}
                  onDelete={handleFileDelete}
                  onShare={handleFileShare}
                  onViewAnalysis={handleViewAnalysis}
                  viewMode={viewMode}
                  enableAIAnalysis={enableAIAnalysis}
                />
              ))}
            </div>
          )}
        </div>

        {/* Pagination */}
        {fileList && fileList.total > fileList.files.length && (
          <div className="p-4">
            <HolographicBubble>
              <div className="flex justify-between items-center">
                <p className="text-sm text-slate-400">
                  Showing {fileList.files.length} of {fileList.total} files
                </p>
                <Button variant="outline" className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50">Load More</Button>
              </div>
            </HolographicBubble>
          </div>
        )}

        {/* Analysis Modal */}
        <AnalysisModal
          isOpen={isAnalysisModalOpen}
          onClose={handleCloseAnalysisModal}
          file={analysisModalFile}
        />

        {/* Test Modal */}
        <TestModal
          isOpen={isTestModalOpen}
          onClose={() => setIsTestModalOpen(false)}
        />

        {/* Share Modal */}
        <ShareFileModal
          isOpen={isShareModalOpen}
          onClose={handleCloseShareModal}
          file={shareModalFile}
        />

        {/* Edit Modal */}
        <EditFileModal
          isOpen={isEditModalOpen}
          onClose={handleCloseEditModal}
          file={editModalFile}
        />
      </div>
    </TooltipProvider>
  );
};

================
File: client/src/components/FileManager/index.ts
================
// Enhanced FileManager Components
export { EnhancedFileManager } from './EnhancedFileManager';
export { EnhancedFileCard } from './EnhancedFileCard';
export { InlineUploadArea } from './InlineUploadArea';
export { SkeletonLoader, EmptyStateSkeleton, UploadAreaSkeleton } from './SkeletonLoader';
export { AnalysisStatusCard, CompactAnalysisStatus } from './AnalysisStatusCard';
export { AnalysisModal } from './AnalysisModal';

// Re-export the main FileManager component
export { FileManager } from '../FileManager';

================
File: client/src/components/FileManager/InlineUploadArea.tsx
================
import React, { useState, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Upload, X, CheckCircle, AlertCircle, FileText, Image as ImageIcon, Video, Music, Archive } from 'lucide-react';
import { Button } from '../ui/button';
import { Progress } from '../ui/progress';
import { Badge } from '../ui/badge';
import { toast } from 'sonner';

interface UploadFile {
  id: string;
  file: File;
  status: 'pending' | 'uploading' | 'completed' | 'error';
  progress: number;
  error?: string;
}

interface InlineUploadAreaProps {
  onFilesSelected: (files: File[]) => void;
  maxFileSize?: number;
  allowedFileTypes?: string[];
  maxFiles?: number;
  className?: string;
  isUploading?: boolean;
  uploadProgress?: number;
}

const getFileIcon = (file: File) => {
  if (file.type.startsWith('image/')) return <ImageIcon className="w-4 h-4" />;
  if (file.type.startsWith('video/')) return <Video className="w-4 h-4" />;
  if (file.type.startsWith('audio/')) return <Music className="w-4 h-4" />;
  if (file.type.includes('zip') || file.type.includes('archive')) return <Archive className="w-4 h-4" />;
  return <FileText className="w-4 h-4" />;
};

const formatFileSize = (bytes: number) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
  onDragEnter?: (e: React.DragEvent) => void;
  onDragLeave?: (e: React.DragEvent) => void;
  onDragOver?: (e: React.DragEvent) => void;
  onDrop?: (e: React.DragEvent) => void;
}> = ({ children, className, onClick, onDragEnter, onDragLeave, onDragOver, onDrop }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
    onClick={onClick && typeof onClick === 'function' ? onClick : undefined}
    onDragEnter={onDragEnter}
    onDragLeave={onDragLeave}
    onDragOver={onDragOver}
    onDrop={onDrop}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const InlineUploadArea: React.FC<InlineUploadAreaProps> = ({
  onFilesSelected,
  maxFileSize = 10 * 1024 * 1024, // 10MB default
  allowedFileTypes,
  maxFiles = 10,
  className = '',
  isUploading = false,
  uploadProgress = 0
}) => {
  const [isDragActive, setIsDragActive] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<UploadFile[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const validateFile = (file: File): { valid: boolean; error?: string } => {
    // Check file size
    if (file.size > maxFileSize) {
      return {
        valid: false,
        error: `File "${file.name}" is too large. Maximum size is ${Math.round(maxFileSize / 1024 / 1024)}MB`
      };
    }

    // Check file type
    if (allowedFileTypes && !allowedFileTypes.includes(file.type)) {
      return {
        valid: false,
        error: `File type "${file.type}" is not allowed`
      };
    }

    return { valid: true };
  };

  const handleFiles = useCallback((files: FileList) => {
    const fileArray = Array.from(files);
    const validFiles: File[] = [];
    const errors: string[] = [];

    fileArray.forEach(file => {
      const validation = validateFile(file);
      if (validation.valid) {
        validFiles.push(file);
      } else {
        errors.push(validation.error!);
      }
    });

    // Show errors
    errors.forEach(error => {
      toast.error(error);
    });

    // Add valid files to selected files
    if (validFiles.length > 0) {
      const newUploadFiles: UploadFile[] = validFiles.map(file => ({
        id: `${file.name}-${Date.now()}-${Math.random()}`,
        file,
        status: 'pending',
        progress: 0
      }));

      setSelectedFiles(prev => {
        const combined = [...prev, ...newUploadFiles];
        return combined.slice(0, maxFiles);
      });

      // Trigger upload
      onFilesSelected(validFiles);
    }
  }, [maxFileSize, allowedFileTypes, maxFiles, onFilesSelected]);

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setIsDragActive(true);
    } else if (e.type === 'dragleave') {
      setIsDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(false);

    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFiles(e.dataTransfer.files);
    }
  }, [handleFiles]);

  const handleFileInput = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      handleFiles(e.target.files);
    }
  }, [handleFiles]);

  const removeFile = (fileId: string) => {
    setSelectedFiles(prev => prev.filter(file => file.id !== fileId));
  };

  const clearAllFiles = () => {
    setSelectedFiles([]);
  };

  return (
    <div className={`space-y-4 ${className}`}>
      {/* Upload Zone */}
      <HolographicBubble
        className={`
          relative border-2 border-dashed rounded-xl p-8 text-center transition-all duration-200
          ${isDragActive 
            ? 'border-violet-400 bg-violet-500/20 scale-105' 
            : 'border-slate-600/50 hover:border-slate-500/50 hover:bg-slate-700/30'
          }
          ${isUploading ? 'pointer-events-none opacity-75' : 'cursor-pointer'}
        `}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
        onClick={() => !isUploading && fileInputRef.current?.click()}
      >
        <input
          ref={fileInputRef}
          type="file"
          multiple
          className="hidden"
          accept={allowedFileTypes?.join(',')}
          onChange={handleFileInput}
          aria-label="Upload files"
        />

        <div className="space-y-4">
          <div className="flex justify-center">
            <div className={`
              p-4 rounded-full transition-colors
              ${isDragActive ? 'bg-violet-500/20' : 'bg-slate-700/50'}
            `}>
              <Upload className={`w-8 h-8 ${isDragActive ? 'text-violet-300' : 'text-slate-400'}`} />
            </div>
          </div>
          
          <div>
            <p className="text-lg font-medium text-white mb-2">
              {isDragActive ? 'Drop files here' : 'Drop files here or click to browse'}
            </p>
            <p className="text-sm text-slate-300">
              Maximum file size: {Math.round(maxFileSize / 1024 / 1024)}MB
              {allowedFileTypes && (
                <span> ‚Ä¢ Supported: {allowedFileTypes.join(', ')}</span>
              )}
            </p>
            <p className="text-xs text-slate-400 mt-1">
              Up to {maxFiles} files
            </p>
          </div>
        </div>

        {/* Upload Progress Overlay */}
        <AnimatePresence>
          {isUploading && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="absolute inset-0 bg-slate-800/90 backdrop-blur-sm rounded-xl flex items-center justify-center"
            >
              <div className="text-center space-y-4">
                <div className="animate-spin w-8 h-8 border-4 border-violet-400 border-t-transparent rounded-full mx-auto" />
                <div>
                  <p className="text-lg font-medium text-white">Uploading files...</p>
                  <p className="text-sm text-slate-300">{uploadProgress}% complete</p>
                </div>
                <div className="w-48">
                  <Progress value={uploadProgress} className="h-2" />
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </HolographicBubble>

      {/* Selected Files List */}
      <AnimatePresence>
        {selectedFiles.length > 0 && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="space-y-3"
          >
            <div className="flex items-center justify-between">
              <h3 className="text-sm font-medium text-white">
                Selected Files ({selectedFiles.length})
              </h3>
              <Button
                size="sm"
                variant="ghost"
                onClick={clearAllFiles}
                className="text-slate-400 hover:text-slate-200"
              >
                Clear All
              </Button>
            </div>

            <div className="space-y-2 max-h-64 overflow-y-auto">
              {selectedFiles.map((uploadFile) => (
                <motion.div
                  key={uploadFile.id}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className={`
                    flex items-center space-x-3 p-3 rounded-lg border transition-colors
                    ${uploadFile.status === 'error' ? 'bg-red-500/20 border-red-400/30' : 'bg-slate-700/50 border-slate-600/50'}
                  `}
                >
                  <div className="flex-shrink-0">
                    {getFileIcon(uploadFile.file)}
                  </div>
                  
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-white truncate">
                      {uploadFile.file.name}
                    </p>
                    <p className="text-xs text-slate-400">
                      {formatFileSize(uploadFile.file.size)}
                    </p>
                  </div>

                  <div className="flex items-center space-x-2">
                    {uploadFile.status === 'pending' && (
                      <Badge variant="secondary" className="text-xs bg-slate-600/50 text-slate-300 border-slate-500/50">
                        Ready
                      </Badge>
                    )}
                    {uploadFile.status === 'uploading' && (
                      <Badge variant="secondary" className="text-xs bg-violet-500/20 text-violet-300 border-violet-400/30">
                        Uploading...
                      </Badge>
                    )}
                    {uploadFile.status === 'completed' && (
                      <div className="flex items-center space-x-1 text-green-400">
                        <CheckCircle className="w-4 h-4" />
                        <span className="text-xs">Complete</span>
                      </div>
                    )}
                    {uploadFile.status === 'error' && (
                      <div className="flex items-center space-x-1 text-red-400">
                        <AlertCircle className="w-4 h-4" />
                        <span className="text-xs">Error</span>
                      </div>
                    )}
                    
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => removeFile(uploadFile.id)}
                      className="h-6 w-6 p-0 text-slate-400 hover:text-slate-200"
                    >
                      <X className="w-3 h-3" />
                    </Button>
                  </div>
                </motion.div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

================
File: client/src/components/FileManager/README.md
================
# Enhanced File Manager Components

A comprehensive, user-friendly file management system with advanced UX patterns, AI integration, and modern design principles.

## üöÄ Key Features

### **Enhanced User Experience**
- **Progressive Disclosure**: Information is revealed contextually based on user interaction
- **Inline Upload**: Persistent drag-and-drop upload area instead of modal interruptions
- **Contextual Actions**: File operations appear based on file type and user context
- **Skeleton Loading**: Content-aware loading states instead of generic spinners
- **Keyboard Shortcuts**: Power user shortcuts for efficient navigation

### **AI Integration**
- **Smart Analysis**: AI-powered file insights and recommendations
- **Status Communication**: Clear visual feedback for analysis states
- **Actionable Insights**: Contextual suggestions based on file content

### **Performance & Accessibility**
- **Virtual Scrolling**: Efficient rendering for large file lists
- **ARIA Support**: Full accessibility compliance
- **Responsive Design**: Optimized for all screen sizes
- **Dark Mode**: Complete theme support

## üì¶ Components

### `EnhancedFileManager`
The main file manager component with all enhanced features.

```tsx
import { EnhancedFileManager } from './FileManager';

<EnhancedFileManager
  className="h-full"
  initialFolder="/"
  onFileSelect={(file) => console.log('Selected:', file)}
  maxFileSize={10 * 1024 * 1024} // 10MB
  allowedFileTypes={['image/*', 'text/*', 'application/pdf']}
  enableAIAnalysis={true}
  showUploadArea={true}
/>
```

### `EnhancedFileCard`
Individual file card with progressive disclosure and contextual actions.

```tsx
import { EnhancedFileCard } from './FileManager';

<EnhancedFileCard
  file={fileItem}
  isSelected={selectedFiles.has(file.id)}
  onSelect={handleFileSelect}
  onDownload={handleDownload}
  onEdit={handleEdit}
  onAnalyze={handleAnalyze}
  onDelete={handleDelete}
  onShare={handleShare}
  viewMode="grid"
  enableAIAnalysis={true}
/>
```

### `InlineUploadArea`
Persistent upload zone with drag-and-drop and validation.

```tsx
import { InlineUploadArea } from './FileManager';

<InlineUploadArea
  onFilesSelected={handleFilesSelected}
  maxFileSize={10 * 1024 * 1024}
  allowedFileTypes={['image/*', 'text/*']}
  maxFiles={10}
  isUploading={isUploading}
  uploadProgress={uploadProgress}
/>
```

### `AnalysisStatusCard`
Enhanced AI analysis status with insights and actions.

```tsx
import { AnalysisStatusCard } from './FileManager';

<AnalysisStatusCard
  status="completed"
  analysis={aiAnalysis}
  onAnalyze={handleAnalyze}
  onViewResults={handleViewResults}
/>
```

## üéØ UX Improvements

### **1. Information Architecture**
- **Primary Layer**: Essential file info (name, size, date)
- **Secondary Layer**: Additional details on hover (description, tags)
- **Tertiary Layer**: Actions and analysis results

### **2. Progressive Disclosure**
- Grid view: Basic info ‚Üí Hover reveals details ‚Üí Click for actions
- List view: All info visible ‚Üí Hover reveals actions
- Contextual menus: File-type specific operations

### **3. Visual Hierarchy**
- Clear typography scale for different information levels
- Consistent spacing and alignment
- Color-coded status indicators
- Icon-based file type recognition

### **4. Interaction Patterns**
- **Hover States**: Smooth transitions with contextual information
- **Selection Feedback**: Clear visual indicators for selected items
- **Loading States**: Skeleton loaders with realistic content placeholders
- **Error Handling**: User-friendly error messages with recovery options

## ‚å®Ô∏è Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Ctrl+A` | Select all files |
| `Ctrl+G` | Toggle grid/list view |
| `Ctrl+U` | Toggle upload area |
| `Delete` | Delete selected files |
| `Escape` | Clear selection |

## üé® Design System

### **Color Palette**
- **Primary**: Blue for interactive elements
- **Success**: Green for completed actions
- **Warning**: Yellow for pending states
- **Error**: Red for failed operations
- **Neutral**: Gray for secondary information

### **Typography**
- **Headings**: Clear hierarchy with consistent weights
- **Body Text**: Readable font sizes with proper line height
- **Captions**: Smaller text for metadata and labels

### **Spacing**
- **Consistent Grid**: 4px base unit for all spacing
- **Component Padding**: 16px for cards, 8px for buttons
- **Section Margins**: 24px between major sections

## üîß Configuration Options

### **File Validation**
```tsx
const fileConfig = {
  maxFileSize: 10 * 1024 * 1024, // 10MB
  allowedFileTypes: ['image/*', 'text/*', 'application/pdf'],
  maxFiles: 10,
  enableDragDrop: true,
  showProgress: true
};
```

### **AI Analysis**
```tsx
const aiConfig = {
  enableAIAnalysis: true,
  autoAnalyze: false,
  analysisTimeout: 30000, // 30 seconds
  showInsights: true,
  enableSuggestions: true
};
```

### **UI Customization**
```tsx
const uiConfig = {
  viewMode: 'grid', // 'grid' | 'list'
  showUploadArea: true,
  showKeyboardShortcuts: true,
  enableAnimations: true,
  theme: 'light' // 'light' | 'dark' | 'auto'
};
```

## üì± Responsive Behavior

### **Mobile (< 768px)**
- Single column grid layout
- Simplified file cards
- Touch-optimized interactions
- Collapsible filters

### **Tablet (768px - 1024px)**
- Two-column grid layout
- Full feature set available
- Optimized touch targets

### **Desktop (> 1024px)**
- Multi-column grid layout
- Hover interactions
- Keyboard shortcuts
- Advanced features

## ‚ôø Accessibility Features

### **ARIA Labels**
- Proper labeling for all interactive elements
- Screen reader support for file operations
- Status announcements for async operations

### **Keyboard Navigation**
- Full keyboard support for all features
- Logical tab order
- Escape key handling

### **Visual Indicators**
- High contrast mode support
- Focus indicators for all interactive elements
- Color-blind friendly status indicators

## üöÄ Performance Optimizations

### **Virtual Scrolling**
- Efficient rendering for large file lists
- Lazy loading of file content
- Optimized re-renders

### **Caching**
- File metadata caching
- Analysis results caching
- Upload progress persistence

### **Bundle Optimization**
- Tree-shaking support
- Lazy loading of components
- Minimal dependencies

## üîÑ Migration Guide

### **From Legacy FileManager**
```tsx
// Old usage
<FileManager
  className="file-manager"
  onFileSelect={handleSelect}
/>

// New usage (backward compatible)
<FileManager
  className="file-manager"
  onFileSelect={handleSelect}
  // New features are opt-in
  enableAIAnalysis={true}
  showUploadArea={true}
/>
```

### **Breaking Changes**
- None - all changes are additive
- Legacy props are supported
- New features are opt-in

## üß™ Testing

### **Component Testing**
```tsx
import { render, screen } from '@testing-library/react';
import { EnhancedFileManager } from './FileManager';

test('renders file manager with upload area', () => {
  render(<EnhancedFileManager showUploadArea={true} />);
  expect(screen.getByText(/Drop files here/)).toBeInTheDocument();
});
```

### **Integration Testing**
```tsx
test('uploads file successfully', async () => {
  const mockUpload = jest.fn();
  render(<EnhancedFileManager onFileUpload={mockUpload} />);
  
  const file = new File(['content'], 'test.txt', { type: 'text/plain' });
  await uploadFile(file);
  
  expect(mockUpload).toHaveBeenCalledWith(file);
});
```

## üìà Analytics & Monitoring

### **User Interaction Tracking**
- File upload success/failure rates
- AI analysis usage patterns
- Feature adoption metrics
- Performance monitoring

### **Error Tracking**
- Upload failures
- Analysis errors
- Network issues
- User feedback collection

## üîÆ Future Enhancements

### **Planned Features**
- **Batch Operations**: Multi-file editing and processing
- **Advanced Search**: Full-text search with filters
- **File Previews**: Inline preview for supported formats
- **Collaboration**: Real-time file sharing and editing
- **Workflow Automation**: AI-powered file organization

### **Performance Improvements**
- **Web Workers**: Background processing for large files
- **Service Workers**: Offline support and caching
- **WebAssembly**: High-performance file processing
- **Streaming**: Real-time upload progress

## ü§ù Contributing

### **Development Setup**
```bash
npm install
npm run dev
npm run test
npm run build
```

### **Code Standards**
- TypeScript for type safety
- ESLint for code quality
- Prettier for formatting
- Jest for testing
- Storybook for component development

### **Pull Request Process**
1. Create feature branch
2. Add tests for new functionality
3. Update documentation
4. Ensure all tests pass
5. Submit pull request

## üìÑ License

MIT License - see LICENSE file for details.

================
File: client/src/components/FileManager/ShareFileModal.tsx
================
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Share, 
  Copy, 
  Check, 
  Calendar, 
  Users, 
  Lock, 
  Globe, 
  X,
  ChevronDown,
  Clock
} from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';
import { Checkbox } from '../ui/checkbox';
import { Separator } from '../ui/separator';
import { Badge } from '../ui/badge';
import { toast } from 'sonner';
import { type FileItem, type ShareFileData, useFileManager } from '../../hooks/useFileManager';
import { useMutation, useQueryClient } from '@tanstack/react-query';

interface ShareFileModalProps {
  isOpen: boolean;
  onClose: () => void;
  file: FileItem | null;
}

// Holographic Bubble Component to match app aesthetic
const HolographicBubble: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, scale: 0.8, y: 20 }}
    animate={{ opacity: 1, scale: 1, y: 0 }}
    transition={{ type: "spring", damping: 20, stiffness: 300 }}
    className={`
      relative p-4 rounded-xl backdrop-blur-xl border overflow-hidden
      bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30
      ${className}
    `}
  >
    <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-white/5 to-transparent" />
    <div className="relative z-10">{children}</div>
    
    {/* Holographic shimmer effect */}
    <motion.div
      className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent"
      animate={{
        x: ["-100%", "100%"],
      }}
      transition={{
        duration: 8,
        repeat: Infinity,
        repeatType: "loop",
        ease: "linear",
      }}
    />
  </motion.div>
);

export const ShareFileModal: React.FC<ShareFileModalProps> = ({
  isOpen,
  onClose,
  file
}) => {
  const fileManager = useFileManager();
  const queryClient = useQueryClient();
  const [permission, setPermission] = useState<'read' | 'write'>('read');
  const [expiryEnabled, setExpiryEnabled] = useState(false);
  const [expiryDate, setExpiryDate] = useState('');
  const [copiedLink, setCopiedLink] = useState(false);
  const [generatedShareToken, setGeneratedShareToken] = useState<string | null>(null);

  // Share file mutation
  const shareFileMutation = useMutation({
    mutationFn: async ({ fileId, data }: { fileId: number; data: ShareFileData }) => {
      const response = await fetch(`/api/files/${fileId}/share`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: 'Request failed' }));
        throw new Error(error.error || `HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    },
    onSuccess: (_, { fileId }) => {
      queryClient.invalidateQueries({ queryKey: ['filePermissions', fileId] });
    },
  });

  // Get existing permissions for this file
  const { data: permissions, isLoading: permissionsLoading } = fileManager.useFilePermissions(file?.id || null);

  // Reset form when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setPermission('read');
      setExpiryEnabled(false);
      setExpiryDate('');
      setCopiedLink(false);
      setGeneratedShareToken(null);
    }
  }, [isOpen]);

  // Generate default expiry date (7 days from now)
  const getDefaultExpiryDate = () => {
    const date = new Date();
    date.setDate(date.getDate() + 7);
    return date.toISOString().split('T')[0];
  };

  const handleShare = async () => {
    if (!file) return;

    try {
      const shareData = {
        permission,
        shareExpiry: expiryEnabled ? new Date(expiryDate).toISOString() : undefined
      };

      // Use the mutation directly to get the result
      const result = await shareFileMutation.mutateAsync({ fileId: file.id, data: shareData });
      setGeneratedShareToken(result.shareToken);
      
      toast.success('Share link generated successfully');
    } catch (error) {
      console.error('Share failed:', error);
      toast.error('Failed to generate share link');
    }
  };

  const handleCopyLink = async () => {
    if (!generatedShareToken) return;

    const shareUrl = `${window.location.origin}/shared/${generatedShareToken}`;
    
    try {
      await navigator.clipboard.writeText(shareUrl);
      setCopiedLink(true);
      toast.success('Share link copied to clipboard');
      
      setTimeout(() => setCopiedLink(false), 2000);
    } catch (error) {
      console.error('Copy failed:', error);
      toast.error('Failed to copy link');
    }
  };

  const formatExpiryDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  if (!file) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] bg-slate-950 border-slate-700 text-white">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-xl font-semibold text-white">
            <Share className="w-5 h-5 text-violet-400" />
            Share File
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* File Info */}
          <HolographicBubble>
            <div className="flex items-center gap-3">
              <div className="flex-1">
                <h3 className="font-medium text-white">{file.name}</h3>
                <p className="text-sm text-slate-400">
                  {(file.size / 1024 / 1024).toFixed(2)} MB ‚Ä¢ {file.mimeType}
                </p>
              </div>
              <Badge variant="secondary" className="bg-violet-500/20 text-violet-300 border-violet-400/30">
                {file.isPublic ? 'Public' : 'Private'}
              </Badge>
            </div>
          </HolographicBubble>

          {/* Share Form */}
          <HolographicBubble>
            <div className="space-y-4">
              <h4 className="font-medium text-white flex items-center gap-2">
                <Users className="w-4 h-4" />
                Create New Share Link
              </h4>

              {/* Permission Level */}
              <div className="space-y-2">
                <Label htmlFor="permission" className="text-slate-300">Permission Level</Label>
                <Select value={permission} onValueChange={(value: 'read' | 'write') => setPermission(value)}>
                  <SelectTrigger className="bg-slate-800/50 border-slate-600/50 text-white">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent className="bg-slate-800 border-slate-600">
                    <SelectItem value="read" className="text-white">
                      <div className="flex items-center gap-2">
                        <Lock className="w-4 h-4" />
                        <div>
                          <div>Read Only</div>
                          <div className="text-xs text-slate-400">Can view and download</div>
                        </div>
                      </div>
                    </SelectItem>
                    <SelectItem value="write" className="text-white">
                      <div className="flex items-center gap-2">
                        <Globe className="w-4 h-4" />
                        <div>
                          <div>Read & Write</div>
                          <div className="text-xs text-slate-400">Can view, download, and edit</div>
                        </div>
                      </div>
                    </SelectItem>
                  </SelectContent>
                </Select>
              </div>

              {/* Expiry Settings */}
              <div className="space-y-3">
                <div className="flex items-center space-x-2">
                  <Checkbox 
                    id="expiry" 
                    checked={expiryEnabled}
                    onCheckedChange={(checked) => setExpiryEnabled(checked === true)}
                    className="border-slate-600"
                  />
                  <Label htmlFor="expiry" className="text-slate-300 flex items-center gap-2">
                    <Calendar className="w-4 h-4" />
                    Set expiration date
                  </Label>
                </div>

                <AnimatePresence>
                  {expiryEnabled && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      transition={{ duration: 0.2 }}
                    >
                      <Input
                        type="datetime-local"
                        value={expiryDate}
                        onChange={(e) => setExpiryDate(e.target.value)}
                        min={new Date().toISOString().slice(0, 16)}
                        className="bg-slate-800/50 border-slate-600/50 text-white"
                        placeholder={getDefaultExpiryDate()}
                      />
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>

              {/* Generate Share Button */}
              <Button 
                onClick={handleShare} 
                disabled={fileManager.isSharing || (expiryEnabled && !expiryDate)}
                className="w-full bg-violet-600 hover:bg-violet-700 text-white"
              >
                {fileManager.isSharing ? 'Generating...' : 'Generate Share Link'}
              </Button>

              {/* Generated Link */}
              <AnimatePresence>
                {generatedShareToken && (
                  <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -10 }}
                    className="space-y-3"
                  >
                    <Separator className="bg-slate-600/50" />
                    
                    <div className="space-y-2">
                      <Label className="text-slate-300">Share Link</Label>
                      <div className="flex gap-2">
                        <Input
                          value={`${window.location.origin}/shared/${generatedShareToken}`}
                          readOnly
                          className="bg-slate-800/50 border-slate-600/50 text-white"
                        />
                        <Button
                          onClick={handleCopyLink}
                          variant="outline"
                          size="sm"
                          className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
                        >
                          {copiedLink ? (
                            <Check className="w-4 h-4" />
                          ) : (
                            <Copy className="w-4 h-4" />
                          )}
                        </Button>
                      </div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </HolographicBubble>

          {/* Existing Shares */}
          {permissions && permissions.length > 0 && (
            <HolographicBubble>
              <div className="space-y-4">
                <h4 className="font-medium text-white flex items-center gap-2">
                  <Globe className="w-4 h-4" />
                  Existing Shares ({permissions.length})
                </h4>
                
                <div className="space-y-2 max-h-40 overflow-y-auto">
                  {permissions.map((perm) => (
                    <div key={perm.id} className="flex items-center justify-between p-3 bg-slate-800/30 rounded-lg border border-slate-600/30">
                      <div className="flex-1">
                        <div className="flex items-center gap-2">
                          <Badge 
                            variant="secondary" 
                            className={perm.permission === 'write' 
                              ? 'bg-orange-500/20 text-orange-300 border-orange-400/30' 
                              : 'bg-blue-500/20 text-blue-300 border-blue-400/30'
                            }
                          >
                            {perm.permission}
                          </Badge>
                          {perm.shareExpiry && (
                            <Badge variant="outline" className="border-slate-600/50 text-slate-400">
                              <Clock className="w-3 h-3 mr-1" />
                              Expires {formatExpiryDate(perm.shareExpiry)}
                            </Badge>
                          )}
                        </div>
                        <p className="text-xs text-slate-400 mt-1 truncate">
                          {perm.shareToken}
                        </p>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </HolographicBubble>
          )}

          {/* Actions */}
          <div className="flex justify-end gap-3">
            <Button 
              variant="outline" 
              onClick={onClose}
              className="border-slate-600/50 text-slate-300 hover:text-white hover:bg-slate-700/50"
            >
              Close
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================
File: client/src/components/FileManager/SkeletonLoader.tsx
================
import React from 'react';
import { Card } from '../ui/card';

interface SkeletonLoaderProps {
  viewMode: 'grid' | 'list';
  count?: number;
  className?: string;
}

export const SkeletonLoader: React.FC<SkeletonLoaderProps> = ({
  viewMode,
  count = 6,
  className = ''
}) => {
  const skeletons = Array.from({ length: count }, (_, i) => i);

  if (viewMode === 'list') {
    return (
      <div className={`space-y-3 ${className}`}>
        {skeletons.map((i) => (
          <Card key={i} className="p-4 bg-slate-800/40 border-slate-600/30">
            <div className="flex items-center space-x-4">
              {/* File Icon Skeleton */}
              <div className="flex-shrink-0">
                <div className="w-10 h-10 bg-slate-700/50 rounded-lg animate-pulse" />
              </div>
              
              {/* File Info Skeleton */}
              <div className="flex-1 space-y-2">
                <div className="h-4 bg-slate-700/50 rounded animate-pulse" style={{ width: `${60 + Math.random() * 30}%` }} />
                <div className="h-3 bg-slate-700/50 rounded animate-pulse" style={{ width: `${40 + Math.random() * 20}%` }} />
              </div>
              
              {/* Tags Skeleton */}
              <div className="flex space-x-2">
                <div className="w-12 h-5 bg-slate-700/50 rounded-full animate-pulse" />
                <div className="w-16 h-5 bg-slate-700/50 rounded-full animate-pulse" />
              </div>
              
              {/* Status Skeleton */}
              <div className="w-20 h-6 bg-slate-700/50 rounded-full animate-pulse" />
            </div>
          </Card>
        ))}
      </div>
    );
  }

  // Grid View
  return (
    <div className={`grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-4 ${className}`}>
      {skeletons.map((i) => (
        <Card key={i} className="p-4 bg-slate-800/40 border-slate-600/30">
          <div className="space-y-3">
            {/* File Icon Skeleton */}
            <div className="flex justify-center">
              <div className="w-12 h-12 bg-slate-700/50 rounded-xl animate-pulse" />
            </div>
            
            {/* File Name Skeleton */}
            <div className="space-y-2">
              <div className="h-4 bg-slate-700/50 rounded animate-pulse mx-auto" style={{ width: `${70 + Math.random() * 20}%` }} />
              <div className="h-3 bg-slate-700/50 rounded animate-pulse mx-auto" style={{ width: `${50 + Math.random() * 20}%` }} />
            </div>
            
            {/* Tags Skeleton */}
            <div className="flex justify-center space-x-1">
              <div className="w-8 h-4 bg-slate-700/50 rounded-full animate-pulse" />
              <div className="w-10 h-4 bg-slate-700/50 rounded-full animate-pulse" />
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
};

// Empty State Skeleton
export const EmptyStateSkeleton: React.FC = () => (
  <div className="flex items-center justify-center h-64">
    <div className="text-center space-y-4">
      <div className="w-16 h-16 bg-slate-700/50 rounded-full mx-auto animate-pulse" />
      <div className="space-y-2">
        <div className="h-6 bg-slate-700/50 rounded animate-pulse" style={{ width: '200px' }} />
        <div className="h-4 bg-slate-700/50 rounded animate-pulse" style={{ width: '300px' }} />
      </div>
    </div>
  </div>
);

// Upload Area Skeleton
export const UploadAreaSkeleton: React.FC = () => (
  <div className="border-2 border-dashed border-slate-600/50 rounded-xl p-8 text-center bg-slate-800/40">
    <div className="space-y-4">
      <div className="flex justify-center">
        <div className="w-12 h-12 bg-slate-700/50 rounded-full animate-pulse" />
      </div>
      <div className="space-y-2">
        <div className="h-5 bg-slate-700/50 rounded animate-pulse mx-auto" style={{ width: '250px' }} />
        <div className="h-4 bg-slate-700/50 rounded animate-pulse mx-auto" style={{ width: '300px' }} />
      </div>
    </div>
  </div>
);

================
File: client/src/components/FileManager/TestModal.tsx
================
import React from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog';
import { Button } from '../ui/button';

interface TestModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const TestModal: React.FC<TestModalProps> = ({ isOpen, onClose }) => {
  console.log('TestModal render:', { isOpen });
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md bg-slate-950 border-slate-600/30">
        <DialogHeader>
          <DialogTitle className="text-white">Test Modal</DialogTitle>
        </DialogHeader>
        <div className="p-4">
          <p className="text-slate-300">This is a test modal to verify Dialog component is working.</p>
          <Button onClick={onClose} className="mt-4 bg-violet-500/20 text-violet-300 border-violet-400/30 hover:bg-violet-500/30">
            Close
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================
File: client/src/components/GeminiSettingsModal.tsx
================
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from './ui/dialog';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Alert, AlertDescription } from './ui/alert';
import { Eye, EyeOff, CheckCircle, XCircle, ExternalLink } from 'lucide-react';
import { GeminiService } from '../lib/gemini';

interface GeminiSettingsModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onComplete: () => void;
}

interface APIKeyStatus {
  valid?: boolean;
  testing?: boolean;
  error?: string;
}

const GeminiSettingsModal: React.FC<GeminiSettingsModalProps> = ({
  open,
  onOpenChange,
  onComplete
}) => {
  const [apiKey, setApiKey] = useState('');
  const [showApiKey, setShowApiKey] = useState(false);
  const [status, setStatus] = useState<APIKeyStatus>({});

  // Load existing API key when modal opens
  useEffect(() => {
    if (open) {
      const savedKey = localStorage.getItem('gemini-api-key');
      if (savedKey) {
        setApiKey(savedKey);
      }
    }
  }, [open]);

  // Test API key connection
  const testConnection = async () => {
    if (!apiKey.trim()) {
      setStatus({ error: 'Please enter an API key' });
      return;
    }

    setStatus({ testing: true });
    
    try {
      console.log('üîß Testing Gemini connection with API key:', apiKey.substring(0, 10) + '...');
      
      const service = new GeminiService({ 
        apiKey: apiKey.trim(), 
        modelName: 'gemini-1.5-flash' // Use a stable model for testing
      });
      
      // Test with a simple request (Gemini needs more tokens even for simple responses)
      const response = await service.sendChatCompletion([
        { role: 'user', content: 'Say "test successful" in 3 words or less' }
      ], { maxTokens: 100 }); // Gemini needs more tokens even for short responses
      
      console.log('‚úÖ Gemini test response:', response);
      setStatus({ valid: true });
    } catch (error) {
      console.error('‚ùå Gemini test failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      setStatus({ valid: false, error: errorMessage });
    }
  };

  // Save API key and complete setup
  const handleSave = () => {
    if (!apiKey.trim()) {
      setStatus({ error: 'Please enter an API key' });
      return;
    }

    localStorage.setItem('gemini-api-key', apiKey.trim());
    onComplete();
  };

  // Handle modal close
  const handleClose = () => {
    setApiKey('');
    setStatus({});
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <div className="w-8 h-8 bg-purple-100 dark:bg-purple-900 rounded-lg flex items-center justify-center">
              <span className="text-purple-600 font-bold text-sm">G</span>
            </div>
            Gemini Setup
          </DialogTitle>
          <DialogDescription>
            Configure your Google AI API key to access Gemini models directly.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="gemini-api-key">API Key</Label>
            <div className="relative">
              <Input
                id="gemini-api-key"
                type={showApiKey ? 'text' : 'password'}
                placeholder="AI..."
                value={apiKey}
                onChange={(e) => setApiKey(e.target.value)}
                className="pr-10"
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => setShowApiKey(!showApiKey)}
              >
                {showApiKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Get your API key from{' '}
              <a 
                href="https://ai.google.dev/" 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-blue-600 hover:underline inline-flex items-center gap-1"
              >
                Google AI Studio
                <ExternalLink className="w-3 h-3" />
              </a>
            </p>
          </div>

          {/* Status Messages */}
          {status.error && (
            <Alert variant="destructive">
              <XCircle className="h-4 w-4" />
              <AlertDescription>{status.error}</AlertDescription>
            </Alert>
          )}

          {status.valid === true && (
            <Alert className="border-green-200 bg-green-50 dark:bg-green-950">
              <CheckCircle className="h-4 w-4 text-green-600" />
              <AlertDescription className="text-green-800 dark:text-green-200">
                Connection successful! Your Gemini API key is working.
              </AlertDescription>
            </Alert>
          )}

          {/* Action Buttons */}
          <div className="flex gap-3 pt-4">
            <Button
              variant="outline"
              onClick={testConnection}
              disabled={!apiKey.trim() || status.testing}
              className="flex-1"
            >
              {status.testing ? 'Testing...' : 'Test Connection'}
            </Button>
            <Button
              onClick={handleSave}
              disabled={!apiKey.trim()}
              className="flex-1"
            >
              Save & Continue
            </Button>
          </div>

          {/* Security Note */}
          <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded-lg">
            <p className="text-xs text-gray-600 dark:text-gray-400">
              <strong>Security:</strong> Your API key is stored locally in your browser and only used for direct requests to Google's servers.
            </p>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default GeminiSettingsModal;

================
File: client/src/components/HuggingFaceSettingsModal.tsx
================
import React, { useEffect, useState } from 'react';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from './ui/dialog';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Alert, AlertDescription } from './ui/alert';
import { Eye, EyeOff, CheckCircle, XCircle, ExternalLink } from 'lucide-react';
import { HuggingFaceService } from '../lib/huggingface';

interface HuggingFaceSettingsModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onComplete: () => void;
}

interface StatusState {
  valid?: boolean;
  testing?: boolean;
  error?: string;
}

const HuggingFaceSettingsModal: React.FC<HuggingFaceSettingsModalProps> = ({ open, onOpenChange, onComplete }) => {
  const [apiToken, setApiToken] = useState('');
  const [endpointUrl, setEndpointUrl] = useState('');
  const [showToken, setShowToken] = useState(false);
  const [status, setStatus] = useState<StatusState>({});

  useEffect(() => {
    if (open) {
      const savedToken = localStorage.getItem('hf-api-token');
      const savedUrl = localStorage.getItem('hf-endpoint-url');
      if (savedToken) setApiToken(savedToken);
      if (savedUrl) setEndpointUrl(savedUrl);
    }
  }, [open]);

  const testConnection = async () => {
    if (!apiToken.trim() || !endpointUrl.trim()) {
      setStatus({ error: 'Please enter both API Token and Endpoint URL' });
      return;
    }
    setStatus({ testing: true });
    try {
      const service = new HuggingFaceService({ apiToken: apiToken.trim(), endpointUrl: endpointUrl.trim(), modelName: 'hf-endpoint' });
      await service.sendChatCompletion([{ role: 'user', content: 'Hello' }], { maxTokens: 100 }); // Increased for consistency
      setStatus({ valid: true });
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Connection failed';
      setStatus({ valid: false, error: msg });
    }
  };

  const handleSave = () => {
    if (!apiToken.trim() || !endpointUrl.trim()) {
      setStatus({ error: 'Please enter both API Token and Endpoint URL' });
      return;
    }
    localStorage.setItem('hf-api-token', apiToken.trim());
    localStorage.setItem('hf-endpoint-url', endpointUrl.trim());
    onComplete();
  };

  const handleClose = () => {
    setApiToken('');
    setEndpointUrl('');
    setStatus({});
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <div className="w-8 h-8 bg-orange-100 dark:bg-orange-900 rounded-lg flex items-center justify-center">
              <span className="text-orange-600 font-bold text-sm">HF</span>
            </div>
            Hugging Face Setup
          </DialogTitle>
          <DialogDescription>
            Configure your Hugging Face API token and Inference Endpoint URL.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="hf-api-token">API Token</Label>
            <div className="relative">
              <Input
                id="hf-api-token"
                type={showToken ? 'text' : 'password'}
                placeholder="hf_xxx..."
                value={apiToken}
                onChange={(e) => setApiToken(e.target.value)}
                className="pr-10"
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => setShowToken(!showToken)}
              >
                {showToken ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Create a token on{' '}
              <a
                href="https://huggingface.co/settings/tokens"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-600 hover:underline inline-flex items-center gap-1"
              >
                Hugging Face Tokens
                <ExternalLink className="w-3 h-3" />
              </a>
            </p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="hf-endpoint-url">Inference Endpoint URL</Label>
            <Input
              id="hf-endpoint-url"
              type="text"
              placeholder="https://your-endpoint-url..."
              value={endpointUrl}
              onChange={(e) => setEndpointUrl(e.target.value)}
            />
            <p className="text-sm text-muted-foreground">
              See{' '}
              <a
                href="https://huggingface.co/docs/huggingface_hub/guides/inference_endpoints"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-600 hover:underline inline-flex items-center gap-1"
              >
                Inference Endpoints Docs
                <ExternalLink className="w-3 h-3" />
              </a>
            </p>
          </div>

          {status.error && (
            <Alert variant="destructive">
              <XCircle className="h-4 w-4" />
              <AlertDescription>{status.error}</AlertDescription>
            </Alert>
          )}

          {status.valid === true && (
            <Alert className="border-green-200 bg-green-50 dark:bg-green-950">
              <CheckCircle className="h-4 w-4 text-green-600" />
              <AlertDescription className="text-green-800 dark:text-green-200">
                Connection successful! Your HuggingFace Inference Endpoint responded.
              </AlertDescription>
            </Alert>
          )}

          <div className="flex gap-3 pt-4">
            <Button
              variant="outline"
              onClick={testConnection}
              disabled={!apiToken.trim() || !endpointUrl.trim() || status.testing}
              className="flex-1"
            >
              {status.testing ? 'Testing...' : 'Test Connection'}
            </Button>
            <Button onClick={handleSave} disabled={!apiToken.trim() || !endpointUrl.trim()} className="flex-1">
              Save & Continue
            </Button>
          </div>

          <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded-lg">
            <p className="text-xs text-gray-600 dark:text-gray-400">
              <strong>Security:</strong> Your token and endpoint URL are stored locally in your browser and only used for direct requests to your HuggingFace Inference Endpoint.
            </p>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default HuggingFaceSettingsModal;

================
File: client/src/components/ImproveModal.tsx
================
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Sparkles, 
  X, 
  Upload, 
  Code, 
  CheckCircle, 
  AlertTriangle, 
  Shield, 
  Zap,
  Download,
  Copy,
  FileText,
  TrendingUp,
  FolderOpen
} from 'lucide-react';
import { useFileManager, type FileItem } from '../hooks/useFileManager';
import { toast } from 'sonner';

interface ImproveModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface Improvement {
  type: 'performance' | 'accessibility' | 'security';
  description: string;
  severity: 'low' | 'medium' | 'high';
  line: number;
  suggestion: string;
}

interface ImproveResult {
  success: boolean;
  improvements: Improvement[];
  optimizedCode: string;
}

interface FileManagerModalProps {
  onFileSelect: (file: FileItem) => void;
  selectedFile: FileItem | null;
  allowedTypes: string[];
}

const FileManagerModal: React.FC<FileManagerModalProps> = ({ onFileSelect, selectedFile, allowedTypes }) => {
  const fileManager = useFileManager();
  const [searchQuery, setSearchQuery] = useState('');
  
  // Filter for code files only
  const { data: fileList, isLoading } = fileManager.useFileList({
    search: searchQuery || undefined,
    mimeType: 'text/',
    limit: 20
  });

  const filteredFiles = fileList?.files.filter(file => 
    allowedTypes.some(type => file.mimeType.includes(type)) ||
    file.name.match(/\.(tsx?|jsx?|js|ts)$/i)
  ) || [];

  const getFileIcon = (fileName: string) => {
    if (fileName.endsWith('.tsx') || fileName.endsWith('.jsx')) return '‚öõÔ∏è';
    if (fileName.endsWith('.ts')) return 'üî∑';
    if (fileName.endsWith('.js')) return 'üìÑ';
    return 'üìù';
  };

  return (
    <div className="space-y-4">
      <div className="relative">
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search your files..."
          className="w-full p-3 bg-slate-800/50 border border-slate-600 rounded-lg text-white placeholder-slate-400 focus:border-green-400 focus:outline-none"
        />
      </div>

      {selectedFile && (
        <div className="p-4 bg-slate-800/50 border border-green-400 rounded-lg">
          <div className="flex items-center space-x-3">
            <span className="text-2xl">{getFileIcon(selectedFile.name)}</span>
            <div>
              <h3 className="font-medium text-green-400">{selectedFile.name}</h3>
              <p className="text-sm text-slate-400">
                {(selectedFile.size / 1024).toFixed(1)} KB ‚Ä¢ {selectedFile.mimeType}
              </p>
            </div>
          </div>
        </div>
      )}

      <div className="max-h-64 overflow-y-auto border border-slate-600 rounded-lg">
        {isLoading ? (
          <div className="p-8 text-center">
            <div className="animate-spin w-6 h-6 border-2 border-green-400 border-t-transparent rounded-full mx-auto mb-2"></div>
            <p className="text-slate-400">Loading files...</p>
          </div>
        ) : filteredFiles.length === 0 ? (
          <div className="p-8 text-center text-slate-400">
            <FileText className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No code files found</p>
            <p className="text-sm">Upload some .ts, .tsx, .js, or .jsx files first</p>
          </div>
        ) : (
          <div className="divide-y divide-slate-700">
            {filteredFiles.map((file) => (
              <button
                key={file.id}
                onClick={() => onFileSelect(file)}
                className={`w-full p-4 text-left hover:bg-slate-800/50 transition-colors ${
                  selectedFile?.id === file.id ? 'bg-green-500/10 border-l-2 border-green-400' : ''
                }`}
              >
                <div className="flex items-center space-x-3">
                  <span className="text-xl">{getFileIcon(file.name)}</span>
                  <div className="flex-1 min-w-0">
                    <h3 className="font-medium text-white truncate">{file.name}</h3>
                    <p className="text-sm text-slate-400">
                      {(file.size / 1024).toFixed(1)} KB ‚Ä¢ {new Date(file.updatedAt).toLocaleDateString()}
                    </p>
                    {file.description && (
                      <p className="text-xs text-slate-500 truncate mt-1">{file.description}</p>
                    )}
                  </div>
                  {file.analysisStatus === 'completed' && (
                    <span className="text-green-400 text-xs">üß† Analyzed</span>
                  )}
                </div>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

const ImproveModal: React.FC<ImproveModalProps> = ({ isOpen, onClose }) => {
  const [step, setStep] = useState<'input' | 'analyzing' | 'results'>('input');
  const [inputMethod, setInputMethod] = useState<'paste' | 'upload' | 'select'>('paste');
  const [code, setCode] = useState('');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [selectedStoredFile, setSelectedStoredFile] = useState<FileItem | null>(null);
  const [result, setResult] = useState<ImproveResult | null>(null);
  
  const fileManager = useFileManager();

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
      const reader = new FileReader();
      reader.onload = (e) => {
        setCode(e.target?.result as string);
      };
      reader.readAsText(file);
    }
  };

  const handleStoredFileSelect = async (file: FileItem) => {
    setSelectedStoredFile(file);
    
    try {
      // Download the file content
      const fileContent = await fileManager.downloadFile(file.id, file.name);
      // For text files, we'd need to get the content differently
      // This is a simplified approach - in practice you'd need to handle different file types
      const response = await fetch(`/api/files/${file.id}/download`);
      if (response.ok) {
        const text = await response.text();
        setCode(text);
        toast.success(`File "${file.name}" loaded successfully`);
      }
    } catch (error) {
      toast.error('Failed to load file content');
    }
  };

  const analyzeCode = async () => {
    if (!code.trim() && !selectedFile && !selectedStoredFile) return;

    setStep('analyzing');

    try {
      const formData = new FormData();
      
      if (selectedFile) {
        formData.append('codeFile', selectedFile);
      } else if (selectedStoredFile) {
        // Create a blob from the stored file content and send it
        const blob = new Blob([code], { type: selectedStoredFile.mimeType });
        const file = new File([blob], selectedStoredFile.name, { type: selectedStoredFile.mimeType });
        formData.append('codeFile', file);
      } else {
        formData.append('code', code);
      }
      
      // Get the current AI provider from localStorage
      const provider = localStorage.getItem('current-ai-provider') || 'gemini';
      formData.append('provider', provider);
      
      // Add API keys if needed
      if (provider === 'gemini') {
        const apiKey = localStorage.getItem('gemini-api-key');
        if (apiKey) formData.append('apiKey', apiKey);
      } else if (provider === 'openai') {
        const apiKey = localStorage.getItem('openai-api-key');
        if (apiKey) formData.append('apiKey', apiKey);
      }

      const response = await fetch('/api/improve/analyze', {
        method: 'POST',
        body: formData,
      });

      if (response.ok) {
        const analysisResult: ImproveResult = await response.json();
        setResult(analysisResult);
        setStep('results');
      } else {
        throw new Error('Analysis failed');
      }
    } catch (error) {
      console.error('Analysis error:', error);
      setStep('input');
      toast.error('Analysis failed. Please check your subscription status.');
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const downloadCode = () => {
    if (result?.optimizedCode) {
      const blob = new Blob([result.optimizedCode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-code.tsx';
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  const resetModal = () => {
    setStep('input');
    setCode('');
    setSelectedFile(null);
    setResult(null);
  };

  const handleClose = () => {
    resetModal();
    onClose();
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'high': return 'text-red-400 bg-red-500/20';
      case 'medium': return 'text-yellow-400 bg-yellow-500/20';
      case 'low': return 'text-green-400 bg-green-500/20';
      default: return 'text-slate-400 bg-slate-500/20';
    }
  };

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'performance': return <Zap className="w-4 h-4" />;
      case 'accessibility': return <CheckCircle className="w-4 h-4" />;
      case 'security': return <Shield className="w-4 h-4" />;
      default: return <Code className="w-4 h-4" />;
    }
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        {/* Backdrop */}
        <motion.div
          className="absolute inset-0 bg-black/60 backdrop-blur-sm"
          onClick={handleClose}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        />

        {/* Modal */}
        <motion.div
          className="relative w-full max-w-5xl max-h-[90vh] mx-4 bg-slate-900/95 backdrop-blur-xl rounded-2xl border border-slate-700/50 overflow-hidden"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          transition={{ type: "spring", duration: 0.5 }}
        >
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-slate-700/50">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-green-500/20 rounded-lg">
                <Sparkles className="w-6 h-6 text-green-400" />
              </div>
              <div>
                <h2 className="text-xl font-semibold text-white">Improve Code</h2>
                <p className="text-sm text-slate-400">Analyze and optimize your code quality</p>
              </div>
            </div>
            <button
              onClick={handleClose}
              className="p-2 hover:bg-slate-700/50 rounded-lg transition-colors"
              title="Close modal"
              aria-label="Close Improve modal"
            >
              <X className="w-5 h-5 text-slate-400" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6 overflow-y-auto max-h-[calc(90vh-80px)]">
            {step === 'input' && (
              <div className="space-y-6">
                <div className="text-center">
                  <h3 className="text-lg font-semibold text-white mb-2">Submit Your Code</h3>
                  <p className="text-slate-400">Upload a file or paste your code for analysis</p>
                </div>

                {/* Input Method Selection */}
                <div className="flex justify-center gap-2">
                  <button
                    onClick={() => setInputMethod('paste')}
                    className={`px-4 py-2 rounded-lg transition-all ${
                      inputMethod === 'paste'
                        ? 'bg-green-500/20 text-green-400 border border-green-400/50'
                        : 'text-slate-400 hover:text-white border border-slate-600'
                    }`}
                  >
                    Paste Code
                  </button>
                  <button
                    onClick={() => setInputMethod('upload')}
                    className={`px-4 py-2 rounded-lg transition-all ${
                      inputMethod === 'upload'
                        ? 'bg-green-500/20 text-green-400 border border-green-400/50'
                        : 'text-slate-400 hover:text-white border border-slate-600'
                    }`}
                  >
                    Upload File
                  </button>
                  <button
                    onClick={() => setInputMethod('select')}
                    className={`px-4 py-2 rounded-lg transition-all ${
                      inputMethod === 'select'
                        ? 'bg-green-500/20 text-green-400 border border-green-400/50'
                        : 'text-slate-400 hover:text-white border border-slate-600'
                    }`}
                  >
                    <FolderOpen className="w-4 h-4 mr-2 inline" />
                    Select from Files
                  </button>
                </div>

                {inputMethod === 'paste' && (
                  <div className="space-y-4">
                    <textarea
                      value={code}
                      onChange={(e) => setCode(e.target.value)}
                      placeholder="Paste your React/TypeScript code here..."
                      className="w-full h-64 p-4 bg-slate-800/50 border border-slate-600 rounded-lg text-white placeholder-slate-400 font-mono text-sm resize-none focus:border-green-400 focus:outline-none"
                    />
                  </div>
                )}

                {inputMethod === 'upload' && (
                  <div className="space-y-4">
                    <div className="border-2 border-dashed border-slate-600 hover:border-slate-500 rounded-xl p-8 text-center transition-all relative">
                      <input
                        type="file"
                        accept=".tsx,.ts,.jsx,.js"
                        onChange={handleFileSelect}
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                        title="Upload code file"
                        aria-label="Upload code file for improvement analysis"
                      />
                      
                      <div className="space-y-4">
                        <div className="p-4 bg-slate-800/50 rounded-full w-16 h-16 mx-auto flex items-center justify-center">
                          <Upload className="w-6 h-6 text-green-400" />
                        </div>
                        {selectedFile ? (
                          <div className="text-green-400">
                            <FileText className="w-5 h-5 mx-auto mb-2" />
                            File selected: {selectedFile.name}
                          </div>
                        ) : (
                          <div>
                            <p className="text-lg font-medium text-white mb-2">
                              Upload your code file
                            </p>
                            <p className="text-sm text-slate-400">
                              Supports .tsx, .ts, .jsx, .js files
                            </p>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                )}

                {inputMethod === 'select' && (
                  <FileManagerModal
                    onFileSelect={handleStoredFileSelect}
                    selectedFile={selectedStoredFile}
                    allowedTypes={['text/javascript', 'text/typescript', 'application/javascript', 'text/plain']}
                  />
                )}

                {(code.trim() || selectedFile || selectedStoredFile) && (
                  <div className="flex justify-center">
                    <motion.button
                      onClick={analyzeCode}
                      className="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 rounded-lg text-white font-medium flex items-center gap-2 transition-all"
                      whileHover={{ scale: 1.02 }}
                      whileTap={{ scale: 0.98 }}
                    >
                      <TrendingUp className="w-4 h-4" />
                      Analyze & Improve
                    </motion.button>
                  </div>
                )}
              </div>
            )}

            {step === 'analyzing' && (
              <div className="flex flex-col items-center justify-center py-12 space-y-6">
                <div className="relative">
                  <motion.div
                    className="w-16 h-16 border-4 border-green-500/30 border-t-green-500 rounded-full"
                    animate={{ rotate: 360 }}
                    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
                  />
                  <motion.div
                    className="absolute inset-2 bg-green-500/20 rounded-full flex items-center justify-center"
                    animate={{ scale: [1, 1.1, 1] }}
                    transition={{ duration: 2, repeat: Infinity }}
                  >
                    <Sparkles className="w-6 h-6 text-green-400" />
                  </motion.div>
                </div>
                <div className="text-center">
                  <h3 className="text-xl font-semibold text-white mb-2">Analyzing Your Code</h3>
                  <p className="text-slate-400">Detecting issues and generating optimizations...</p>
                </div>
              </div>
            )}

            {step === 'results' && result && (
              <div className="space-y-6">
                <div className="text-center">
                  <h3 className="text-lg font-semibold text-white mb-2">Analysis Complete</h3>
                  <p className="text-slate-400">Found {result.improvements.length} improvement suggestions</p>
                </div>

                <div className="grid md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <h4 className="text-white font-medium flex items-center gap-2">
                      <AlertTriangle className="w-5 h-5 text-yellow-400" />
                      Improvement Suggestions
                    </h4>
                    
                    <div className="space-y-3">
                      {result.improvements.map((improvement, index) => (
                        <div
                          key={index}
                          className="p-4 bg-slate-800/50 rounded-lg border border-slate-700/50"
                        >
                          <div className="flex items-start gap-3">
                            <div className={`p-1 rounded-md ${getSeverityColor(improvement.severity)}`}>
                              {getTypeIcon(improvement.type)}
                            </div>
                            <div className="flex-1 space-y-2">
                              <div className="flex items-center justify-between">
                                <span className="font-medium text-white capitalize">{improvement.type}</span>
                                <span className={`px-2 py-1 rounded-full text-xs font-medium ${getSeverityColor(improvement.severity)}`}>
                                  {improvement.severity}
                                </span>
                              </div>
                              <p className="text-sm text-slate-300">{improvement.description}</p>
                              <div className="text-xs text-slate-500">
                                Line {improvement.line}
                              </div>
                              <div className="p-2 bg-slate-900/50 rounded text-sm text-green-400">
                                üí° {improvement.suggestion}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className="space-y-4">
                    <h4 className="text-white font-medium flex items-center gap-2">
                      <Code className="w-5 h-5 text-green-400" />
                      Optimized Code
                    </h4>
                    
                    <div className="relative">
                      <pre className="p-4 bg-slate-800/80 rounded-lg text-sm text-slate-300 overflow-x-auto max-h-80 border border-slate-700/50">
                        <code>{result.optimizedCode}</code>
                      </pre>
                      
                      <div className="absolute top-2 right-2 flex gap-1">
                        <button
                          onClick={() => copyToClipboard(result.optimizedCode)}
                          className="p-2 bg-slate-700/80 hover:bg-slate-600/80 rounded-md transition-colors"
                          title="Copy optimized code"
                        >
                          <Copy className="w-4 h-4 text-slate-300" />
                        </button>
                        <button
                          onClick={downloadCode}
                          className="p-2 bg-slate-700/80 hover:bg-slate-600/80 rounded-md transition-colors"
                          title="Download optimized code"
                        >
                          <Download className="w-4 h-4 text-slate-300" />
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="flex justify-center gap-3 pt-4">
                  <button
                    onClick={resetModal}
                    className="px-6 py-2 text-slate-400 hover:text-white transition-colors"
                  >
                    Analyze Another
                  </button>
                  <motion.button
                    onClick={handleClose}
                    className="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 rounded-lg text-white font-medium transition-all"
                    whileHover={{ scale: 1.02 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    Done
                  </motion.button>
                </div>
              </div>
            )}
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default ImproveModal;

================
File: client/src/components/InputBar.tsx
================
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { Send, Paperclip, Mic, MicOff, Files } from 'lucide-react';
import { FileManager } from './FileManager';
import { useSpeech } from '../hooks/useSpeech';
import { toast } from 'sonner';

const InputBar: React.FC = () => {
  const [text, setText] = React.useState('');
  const [showFileManager, setShowFileManager] = useState(false);
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);
  const [isRecording, setIsRecording] = useState(false);

  // Wire speech-to-text for this input bar (standalone usage)
  const {
    startListening,
    stopListening,
    isListening,
    isHTTPS,
    microphonePermission
  } = useSpeech({
    autoInitialize: true,
    onRecognitionResult: (result) => {
      if (result.transcript) {
        setText(result.transcript);
      }
    },
    onRecognitionError: (error) => {
      toast.error(`Speech recognition error: ${error.message}`);
      setIsRecording(false);
    }
  });

  const handleInput = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setText(e.target.value);
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
    }
  };

  const handleVoiceInput = useCallback(async () => {
    try {
      if (!isHTTPS && microphonePermission !== 'granted') {
        toast.error('Microphone access requires HTTPS.');
        return;
      }
      if (isRecording) {
        setIsRecording(false);
        const finalText = await stopListening();
        if (finalText) setText(finalText);
      } else {
        setIsRecording(true);
        setText('');
        await startListening({ language: 'en-US', continuous: true, interimResults: true });
      }
    } catch (err) {
      toast.error((err as Error).message || 'Voice input failed');
      setIsRecording(false);
    }
  }, [isRecording, isHTTPS, microphonePermission, startListening, stopListening]);

  useEffect(() => {
    return () => {
      if (isListening) {
        stopListening();
      }
    };
  }, [isListening, stopListening]);

  return (
    <div className="p-4 bg-background border-t border-border">
      <div className="relative max-w-4xl mx-auto">
        <div className="flex items-end bg-secondary rounded-xl p-2">
          <button 
            onClick={() => setShowFileManager(true)}
            className="p-2 text-muted-foreground hover:text-foreground hover:bg-accent rounded-lg transition-colors" 
            title="Open File Manager"
          >
            <Files className="w-5 h-5" />
          </button>
          <button className="p-2 text-muted-foreground hover:text-foreground hover:bg-accent rounded-lg transition-colors" title="Upload a file">
            <Paperclip className="w-5 h-5" />
          </button>
          <textarea
            ref={textareaRef}
            value={text}
            onChange={handleInput}
            placeholder="Type your message or upload a file..."
            rows={1}
            className="flex-1 bg-transparent resize-none outline-none text-base placeholder:text-muted-foreground px-3 py-2 max-h-48"
          />
          <button 
            onClick={handleVoiceInput}
            className={`p-2 ${isRecording ? 'text-red-400 animate-pulse' : 'text-muted-foreground hover:text-foreground'} hover:bg-accent rounded-lg transition-colors`} 
            title={isRecording ? 'Stop recording' : 'Record audio'}
          >
            {isRecording ? <MicOff className="w-5 h-5" /> : <Mic className="w-5 h-5" />}
          </button>
          <button className="p-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed ml-2" disabled={!text.trim()} title="Send message">
            <Send className="w-5 h-5" />
          </button>
        </div>
        <p className="text-xs text-center text-muted-foreground mt-2">
          AI can make mistakes. Consider checking important information.
        </p>
      </div>

      {/* File Manager Modal */}
      {showFileManager && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="bg-background rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden">
            <div className="flex items-center justify-between p-4 border-b border-border">
              <h2 className="text-xl font-semibold">File Manager</h2>
              <button
                onClick={() => setShowFileManager(false)}
                className="p-2 hover:bg-accent rounded-lg transition-colors"
                title="Close File Manager"
              >
                ‚úï
              </button>
            </div>
            <div className="p-4 max-h-[calc(90vh-80px)] overflow-auto">
              <FileManager />
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default InputBar;

================
File: client/src/components/LLMModelSelector.tsx
================
"use client";

import * as React from "react";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { 
  Search, 
  Filter, 
  Star, 
  StarOff, 
  Zap, 
  DollarSign, 
  Clock, 
  TrendingUp, 
  Brain, 
  Sparkles,
  ChevronDown,
  ArrowUpDown,
  Heart,
  HeartOff,
  X
} from "lucide-react";
import { LLMModel } from "@/types";
import { AzureAIService } from "@/lib/azureAI";

// Get models from current provider
const getModelsForProvider = (getAvailableModels?: () => LLMModel[]): LLMModel[] => {
  if (getAvailableModels) {
    return getAvailableModels();
  }
  // Fallback to Azure AI models
  return AzureAIService.getAvailableModels();
};

const categoryIcons = {
  text: Brain,
  code: Zap,
  multimodal: Sparkles,
  reasoning: TrendingUp
};

const tierColors = {
  free: "bg-emerald-500/20 text-emerald-400 border-emerald-500/30",
  pro: "bg-violet-500/20 text-violet-400 border-violet-500/30",
  enterprise: "bg-amber-500/20 text-amber-400 border-amber-500/30"
};

interface ModelCardProps {
  model: LLMModel;
  onFavorite: (id: string) => void;
  onSelect: (model: LLMModel) => void;
  isSelected: boolean;
}

const ModelCard: React.FC<ModelCardProps> = ({ model, onFavorite, onSelect, isSelected }) => {
  const CategoryIcon = categoryIcons[model.category];
  
  return (
    <motion.div
      layout
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      whileHover={{ y: -2, scale: 1.02 }}
      transition={{ duration: 0.2 }}
    >
      <Card 
        role="button"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            onSelect(model);
          }
        }}
        className={cn(
          "relative overflow-hidden border transition-all duration-300 cursor-pointer group",
          "bg-slate-900/50 backdrop-blur-xl border-slate-700/50",
          "hover:bg-slate-800/50 hover:border-violet-500/50 hover:shadow-lg hover:shadow-violet-500/10",
          "rounded-2xl p-6 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950",
          isSelected 
            ? "border-violet-500 bg-violet-500/10 shadow-lg shadow-violet-500/20" 
            : ""
        )}
        onClick={() => onSelect(model)}
        aria-pressed={isSelected}
        aria-label={`Select model ${model.name}`}
      >
        {/* Favorite Button */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <motion.button
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                onClick={(e) => {
                  e.stopPropagation();
                  onFavorite(model.id);
                }}
                className="absolute top-4 right-4 p-2 rounded-full bg-slate-800/80 backdrop-blur-sm border border-slate-600/50 hover:bg-slate-700/80 transition-colors"
              >
                {model.isFavorite ? (
                  <Heart className="w-4 h-4 text-red-400 fill-current" />
                ) : (
                  <HeartOff className="w-4 h-4 text-slate-400" />
                )}
              </motion.button>
            </TooltipTrigger>
            <TooltipContent className="bg-slate-800 border-slate-700">
              <p>{model.isFavorite ? "Remove from favorites" : "Add to favorites"}</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        {/* Header */}
        <div className="flex items-start gap-3 mb-4">
          <div className="p-3 rounded-xl bg-violet-500/20 border border-violet-500/30">
            <CategoryIcon className="w-6 h-6 text-violet-400" />
          </div>
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-lg text-white truncate">{model.name}</h3>
            <p className="text-sm text-slate-400">{model.provider}</p>
          </div>
        </div>

        {/* Description */}
        <p className="text-sm text-slate-300 mb-4 line-clamp-2">{model.description}</p>

        {/* Metrics */}
        <div className="grid grid-cols-3 gap-3 mb-4">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <TrendingUp className="w-4 h-4 text-emerald-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">{model.performance}%</div>
                  <div className="text-xs text-slate-400">Performance</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Model performance score</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <DollarSign className="w-4 h-4 text-blue-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">${model.cost}</div>
                  <div className="text-xs text-slate-400">Per 1K tokens</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Cost per 1000 tokens</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <Clock className="w-4 h-4 text-orange-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">{model.latency}ms</div>
                  <div className="text-xs text-slate-400">Latency</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Average response time</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>

        {/* Tags */}
        <div className="flex items-center justify-between mb-3">
          <Badge variant="outline" className="capitalize border-slate-600 text-slate-300 bg-slate-800/50">
            {model.category}
          </Badge>
          <Badge className={cn("capitalize border", tierColors[model.tier])}>
            {model.tier}
          </Badge>
        </div>

        {/* Note: Capabilities are now checked dynamically when model is selected */}

        {/* Selection Indicator */}
        <AnimatePresence>
          {isSelected && (
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0 }}
              className="absolute top-4 left-4 w-6 h-6 bg-violet-500 rounded-full flex items-center justify-center"
            >
              <Star className="w-4 h-4 text-white fill-current" />
            </motion.div>
          )}
        </AnimatePresence>
      </Card>
    </motion.div>
  );
};

interface FilterControlsProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
  selectedCategory: string;
  onCategoryChange: (value: string) => void;
  selectedTier: string;
  onTierChange: (value: string) => void;
  sortBy: string;
  onSortChange: (value: string) => void;
  showFavoritesOnly: boolean;
  onToggleFavorites: () => void;
}

const FilterControls: React.FC<FilterControlsProps> = ({
  searchTerm,
  onSearchChange,
  selectedCategory,
  onCategoryChange,
  selectedTier,
  onTierChange,
  sortBy,
  onSortChange,
  showFavoritesOnly,
  onToggleFavorites
}) => {
  return (
    <div className="flex flex-wrap gap-4 items-center justify-between p-4 rounded-2xl bg-slate-800/30 border border-slate-700/50 backdrop-blur-sm">
      {/* Search */}
      <div className="relative flex-1 min-w-[250px]">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400 w-4 h-4" />
        <Input
          placeholder="Search models..."
          value={searchTerm}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10 h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white placeholder:text-slate-400 text-sm focus:border-violet-500"
        />
      </div>

      {/* Filters */}
      <div className="flex gap-2 items-center flex-wrap">
        <Select value={selectedCategory} onValueChange={onCategoryChange}>
          <SelectTrigger className="w-[120px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <SelectValue placeholder="Category" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="all">All</SelectItem>
            <SelectItem value="text">Text</SelectItem>
            <SelectItem value="code">Code</SelectItem>
            <SelectItem value="multimodal">Multimodal</SelectItem>
            <SelectItem value="reasoning">Reasoning</SelectItem>
          </SelectContent>
        </Select>

        <Select value={selectedTier} onValueChange={onTierChange}>
          <SelectTrigger className="w-[100px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <SelectValue placeholder="Tier" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="all">All</SelectItem>
            <SelectItem value="freemium">Freemium</SelectItem>
            <SelectItem value="pro">Pro</SelectItem>
            <SelectItem value="enterprise">Enterprise</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={onSortChange}>
          <SelectTrigger className="w-[120px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <ArrowUpDown className="w-3 h-3 mr-1" />
            <SelectValue placeholder="Sort" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="performance">Performance</SelectItem>
            <SelectItem value="cost">Cost</SelectItem>
            <SelectItem value="latency">Latency</SelectItem>
            <SelectItem value="name">Name</SelectItem>
          </SelectContent>
        </Select>

        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant={showFavoritesOnly ? "default" : "outline"}
                onClick={onToggleFavorites}
                size="sm"
                className={cn(
                  "h-10 px-4 rounded-xl transition-colors",
                  showFavoritesOnly 
                    ? "bg-violet-600 hover:bg-violet-700 text-white" 
                    : "border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50"
                )}
              >
                <Star className={cn("w-3 h-3 mr-1", showFavoritesOnly && "fill-current")} />
                Favorites
              </Button>
            </TooltipTrigger>
            <TooltipContent className="bg-slate-800 border-slate-700">
              <p>{showFavoritesOnly ? "Show all models" : "Show only favorite models"}</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    </div>
  );
};

interface LLMModalSelectorProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (model: LLMModel) => void;
  selectedModel?: LLMModel | null;
  getAvailableModels?: () => LLMModel[];
  providerLabel?: string;
}

const LLMModalSelector: React.FC<LLMModalSelectorProps> = ({
  isOpen,
  onClose,
  onSelect,
  selectedModel: externalSelectedModel,
  getAvailableModels,
  providerLabel
}) => {
  const [models, setModels] = React.useState<LLMModel[]>(getModelsForProvider(getAvailableModels));
  const [selectedModel, setSelectedModel] = React.useState<LLMModel | null>(externalSelectedModel || null);
  const [searchTerm, setSearchTerm] = React.useState("");
  const [selectedCategory, setSelectedCategory] = React.useState("all");
  const [selectedTier, setSelectedTier] = React.useState("all");
  const [sortBy, setSortBy] = React.useState("performance");
  const [showFavoritesOnly, setShowFavoritesOnly] = React.useState(false);

  // Refresh model list whenever the modal opens or the provider's getter changes
  React.useEffect(() => {
    if (isOpen) {
      const next = getModelsForProvider(getAvailableModels);
      setModels(next);
      if (selectedModel && !next.find(m => m.id === selectedModel.id)) {
        setSelectedModel(null);
      }
    }
  }, [isOpen, getAvailableModels]);

  // Keep external selected model in sync for current provider
  React.useEffect(() => {
    if (externalSelectedModel) {
      const available = getModelsForProvider(getAvailableModels);
      if (available.find(m => m.id === externalSelectedModel.id)) {
        setSelectedModel(externalSelectedModel);
      } else {
        setSelectedModel(null);
      }
    }
  }, [externalSelectedModel, getAvailableModels]);

  const handleFavorite = (id: string) => {
    setModels(prev => prev.map(model => 
      model.id === id ? { ...model, isFavorite: !model.isFavorite } : model
    ));
  };

  const handleSelect = (model: LLMModel) => {
    setSelectedModel(model);
  };

  const handleConfirmSelection = () => {
    if (selectedModel) {
      onSelect(selectedModel);
      onClose();
    }
  };

  const filteredAndSortedModels = React.useMemo(() => {
    let filtered = models.filter(model => {
      const matchesSearch = model.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           model.provider.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           model.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesCategory = selectedCategory === "all" || model.category === selectedCategory;
      const matchesTier = selectedTier === "all" || model.tier === selectedTier;
      const matchesFavorites = !showFavoritesOnly || model.isFavorite;

      return matchesSearch && matchesCategory && matchesTier && matchesFavorites;
    });

    return filtered.sort((a, b) => {
      switch (sortBy) {
        case "performance":
          return b.performance - a.performance;
        case "cost":
          return a.cost - b.cost;
        case "latency":
          return a.latency - b.latency;
        case "name":
          return a.name.localeCompare(b.name);
        default:
          return 0;
      }
    });
  }, [models, searchTerm, selectedCategory, selectedTier, sortBy, showFavoritesOnly]);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto bg-slate-950/95 backdrop-blur-xl border-slate-700/50 text-white p-0 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500">
        <div className="flex flex-col h-full">
          {/* Header */}
          <div className="p-6 pb-4 border-b border-slate-700/50">
            <DialogHeader>
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                className="space-y-2"
              >
                <DialogTitle className="text-3xl font-bold bg-gradient-to-r from-violet-400 via-purple-400 to-violet-600 bg-clip-text text-transparent">
                  Select AI Model
                </DialogTitle>
                <DialogDescription className="text-base text-slate-300">
                  Choose from {providerLabel || 'the current provider'} models
                </DialogDescription>
              </motion.div>
            </DialogHeader>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <motion.button
                    onClick={onClose}
                    aria-label="Close model selector"
                    className="absolute right-4 top-4 p-2 rounded-xl bg-slate-800/50 hover:bg-slate-700/50 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950"
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.9 }}
                  >
                    <X className="w-5 h-5 text-slate-400" />
                  </motion.button>
                </TooltipTrigger>
                <TooltipContent className="bg-slate-800 border-slate-700">
                  <p>Close model selector</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-6 space-y-6">
            {/* Filter Controls */}
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.1 }}
            >
              <FilterControls
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                selectedCategory={selectedCategory}
                onCategoryChange={setSelectedCategory}
                selectedTier={selectedTier}
                onTierChange={setSelectedTier}
                sortBy={sortBy}
                onSortChange={setSortBy}
                showFavoritesOnly={showFavoritesOnly}
                onToggleFavorites={() => setShowFavoritesOnly(!showFavoritesOnly)}
              />
            </motion.div>

            {/* Results Count */}
            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.2 }}
              className="flex items-center justify-between"
            >
              <p className="text-sm text-slate-400">
                Showing {filteredAndSortedModels.length} of {models.length} models
              </p>
              {selectedModel && (
                <Badge variant="outline" className="text-sm px-3 py-1 border-violet-500/50 text-violet-400 bg-violet-500/10">
                  Selected: {selectedModel.name}
                </Badge>
              )}
            </motion.div>

            {/* Model Grid */}
            <motion.div 
              layout
              className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            >
              <AnimatePresence>
                {filteredAndSortedModels.map((model) => (
                  <ModelCard
                    key={model.id}
                    model={model}
                    onFavorite={handleFavorite}
                    onSelect={handleSelect}
                    isSelected={selectedModel?.id === model.id}
                  />
                ))}
              </AnimatePresence>
            </motion.div>

            {/* Empty State */}
            {filteredAndSortedModels.length === 0 && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="text-center py-12"
              >
                <div className="w-20 h-20 mx-auto mb-4 rounded-full bg-slate-800/50 flex items-center justify-center">
                  <Search className="w-10 h-10 text-slate-400" />
                </div>
                <h3 className="text-lg font-semibold mb-2 text-white">No models found</h3>
                <p className="text-slate-400">Try adjusting your search criteria or filters.</p>
              </motion.div>
            )}
          </div>

          {/* Footer */}
          <div className="p-6 pt-4 border-t border-slate-700/50 bg-slate-900/30">
            <div className="flex items-center justify-between">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="outline"
                      onClick={onClose}
                      className="border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50 px-6"
                    >
                      Cancel
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent className="bg-slate-800 border-slate-700">
                    <p>Cancel and keep current model</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
              <div className="flex gap-3">
                {selectedModel && (
                  <Dialog>
                    <DialogTrigger asChild>
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button variant="outline" className="border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50 px-6">
                              View Details
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent className="bg-slate-800 border-slate-700">
                            <p>View detailed model information</p>
                          </TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    </DialogTrigger>
                    <DialogContent className="max-w-2xl bg-slate-950/95 backdrop-blur-xl border-slate-700/50 text-white">
                      <DialogHeader>
                        <DialogTitle className="text-2xl text-white">{selectedModel.name}</DialogTitle>
                        <DialogDescription className="text-base text-slate-300">
                          {selectedModel.description}
                        </DialogDescription>
                      </DialogHeader>
                      <div className="grid grid-cols-2 gap-6 mt-6">
                        <div className="space-y-4">
                          <div>
                            <label className="text-sm font-medium text-slate-400">Provider</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.provider}</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Performance</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.performance}%</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Context Length</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.contextLength.toLocaleString()} tokens</p>
                          </div>
                        </div>
                        <div className="space-y-4">
                          <div>
                            <label className="text-sm font-medium text-slate-400">Cost per 1K tokens</label>
                            <p className="text-lg font-semibold text-white">${selectedModel.cost}</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Latency</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.latency}ms</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Tier</label>
                            <Badge className={cn("capitalize border", tierColors[selectedModel.tier])}>
                              {selectedModel.tier}
                            </Badge>
                          </div>
                        </div>
                      </div>
                    </DialogContent>
                  </Dialog>
                )}
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        onClick={handleConfirmSelection}
                        disabled={!selectedModel}
                        className="bg-violet-600 hover:bg-violet-700 text-white px-8 disabled:opacity-50"
                      >
                        Select Model
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent className="bg-slate-800 border-slate-700">
                      <p>{selectedModel ? `Use ${selectedModel.name} for this conversation` : "Please select a model first"}</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default LLMModalSelector;

================
File: client/src/components/Message.tsx
================
import React from 'react';
import { Bot, User, Clipboard, Check } from 'lucide-react';
import { Message as MessageType } from '../types';
import { cn } from '../lib/utils';

// A simple markdown-to-HTML converter
const renderMarkdown = (text: string) => {
  // This is a very basic implementation. For a real app, use a library like 'marked' or 'react-markdown'.
  const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
  const html = text
    .replace(codeBlockRegex, (match, lang, code) => {
      const escapedCode = code.replace(/</g, '<').replace(/>/g, '>');
      return `<pre class="bg-black/70 text-white p-4 rounded-lg my-4 overflow-x-auto"><code class="language-${lang || ''}">${escapedCode}</code></pre>`;
    })
    .replace(/### (.*)/g, '<h3 class="text-lg font-semibold mt-4 mb-2">$1</h3>')
    .replace(/\* \*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\* (.*)/g, '<li class="ml-4 list-disc">$1</li>');
  
  return { __html: html };
};

const CodeBlockToolbar: React.FC<{ code: string }> = ({ code }) => {
  const [copied, setCopied] = React.useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="absolute top-2 right-2">
      <button
        onClick={handleCopy}
        className="flex items-center text-xs text-muted-foreground bg-background/50 hover:bg-accent p-1.5 rounded-md transition-colors"
      >
        {copied ? (
          <>
            <Check className="w-3.5 h-3.5 mr-1 text-green-500" /> Copied
          </>
        ) : (
          <>
            <Clipboard className="w-3.5 h-3.5 mr-1" /> Copy
          </>
        )}
      </button>
    </div>
  );
};

const Message: React.FC<{ message: MessageType }> = ({ message }) => {
  const isUser = message.role === 'user';
  const codeContentMatch = message.content.match(/```(?:\w+)?\n([\s\S]*?)```/);
  const codeContent = codeContentMatch ? codeContentMatch[1] : '';

  return (
    <div className={cn('flex items-start gap-4 max-w-4xl', isUser ? 'justify-end' : 'justify-start')}>
      {!isUser && (
        <div className="w-8 h-8 flex-shrink-0 rounded-full bg-primary flex items-center justify-center">
          <Bot className="w-5 h-5 text-primary-foreground" />
        </div>
      )}
      <div
        className={cn(
          'relative rounded-xl px-4 py-3 text-sm md:text-base shadow-sm',
          isUser
            ? 'bg-primary text-primary-foreground rounded-br-none'
            : 'bg-secondary text-secondary-foreground rounded-bl-none'
        )}
      >
        <div
          className="prose prose-sm prose-invert max-w-none"
          dangerouslySetInnerHTML={renderMarkdown(message.content)}
        />
        {codeContent && <CodeBlockToolbar code={codeContent} />}
      </div>
      {isUser && (
        <div className="w-8 h-8 flex-shrink-0 rounded-full bg-muted flex items-center justify-center">
          <User className="w-5 h-5 text-muted-foreground" />
        </div>
      )}
    </div>
  );
};

export default Message;

================
File: client/src/components/MessageList.tsx
================
import React from 'react';
import { Message as MessageType } from '../types';
import Message from './Message';

const mockMessages: MessageType[] = [
  {
    id: '1',
    role: 'user',
    content: 'Design a sleek, modern, and minimalist AI chat UI that\'s both persuasive and impressive. It needs real-time streaming, multimodal input (text, voice, image), and dynamic response formatting (code blocks, rich text). Focus on a clean, contemporary design with subtle, sophisticated animations and intuitive controls for editing/sharing. The aesthetic should project advanced technology, ensuring a seamless, engaging, and highly impressive conversational experience that elevates the AI\'s perceived capabilities.',
    timestamp: new Date(Date.now() - 1000 * 60 * 5),
  },
  {
    id: '2',
    role: 'assistant',
    content: `Of course. Here is a basic structure for a React component to get you started. It uses TypeScript and Tailwind CSS for styling.

### Key Features:
- **Component Structure**: A simple, reusable component.
- **Styling**: Uses Tailwind CSS for a modern look.
- **TypeScript**: For type safety.

\`\`\`tsx
import React from 'react';

interface ChatBubbleProps {
  message: string;
  sender: 'user' | 'ai';
}

const ChatBubble: React.FC<ChatBubbleProps> = ({ message, sender }) => {
  const bubbleClasses = sender === 'user'
    ? 'bg-primary text-primary-foreground self-end'
    : 'bg-secondary text-secondary-foreground self-start';

  return (
    <div className={\`max-w-md w-full mx-2 my-1 p-3 rounded-lg \${bubbleClasses}\`}>
      <p>{message}</p>
    </div>
  );
};

export default ChatBubble;
\`\`\`

This component provides a solid foundation. Next, we can integrate state management and API calls to make it dynamic.`,
    timestamp: new Date(Date.now() - 1000 * 60 * 4),
  },
];

const MessageList: React.FC = () => {
  const messagesEndRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [mockMessages]);

  return (
    <div className="flex-1 overflow-y-auto p-6 space-y-6">
      <div className="flex flex-col space-y-4">
        {mockMessages.map((msg) => (
          <Message key={msg.id} message={msg} />
        ))}
      </div>
      <div ref={messagesEndRef} />
    </div>
  );
};

export default MessageList;

================
File: client/src/components/OpenAISettingsModal.tsx
================
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from './ui/dialog';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Alert, AlertDescription } from './ui/alert';
import { Eye, EyeOff, CheckCircle, XCircle, ExternalLink } from 'lucide-react';
import { OpenAIService } from '../lib/openAI';

interface OpenAISettingsModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onComplete: () => void;
}

interface APIKeyStatus {
  valid?: boolean;
  testing?: boolean;
  error?: string;
}

const OpenAISettingsModal: React.FC<OpenAISettingsModalProps> = ({
  open,
  onOpenChange,
  onComplete
}) => {
  const [apiKey, setApiKey] = useState('');
  const [showApiKey, setShowApiKey] = useState(false);
  const [status, setStatus] = useState<APIKeyStatus>({});

  // Load existing API key when modal opens
  useEffect(() => {
    if (open) {
      const savedKey = localStorage.getItem('openai-api-key');
      if (savedKey) {
        setApiKey(savedKey);
      }
    }
  }, [open]);

  // Test API key connection
  const testConnection = async () => {
    if (!apiKey.trim()) {
      setStatus({ error: 'Please enter an API key' });
      return;
    }

    setStatus({ testing: true });
    
    try {
      const service = new OpenAIService({ 
        apiKey: apiKey.trim(), 
        modelName: 'gpt-4o-mini' 
      });
      
      // Test with a simple request
      await service.sendChatCompletion([
        { role: 'user', content: 'Hello' }
      ], { maxTokens: 100 }); // Increased for consistency

      setStatus({ valid: true });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      setStatus({ valid: false, error: errorMessage });
    }
  };

  // Save API key and complete setup
  const handleSave = () => {
    if (!apiKey.trim()) {
      setStatus({ error: 'Please enter an API key' });
      return;
    }

    localStorage.setItem('openai-api-key', apiKey.trim());
    onComplete();
  };

  // Handle modal close
  const handleClose = () => {
    setApiKey('');
    setStatus({});
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <div className="w-8 h-8 bg-green-100 dark:bg-green-900 rounded-lg flex items-center justify-center">
              <span className="text-green-600 font-bold text-sm">AI</span>
            </div>
            OpenAI Setup
          </DialogTitle>
          <DialogDescription>
            Configure your OpenAI API key to access GPT models directly.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="openai-api-key">API Key</Label>
            <div className="relative">
              <Input
                id="openai-api-key"
                type={showApiKey ? 'text' : 'password'}
                placeholder="sk-..."
                value={apiKey}
                onChange={(e) => setApiKey(e.target.value)}
                className="pr-10"
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => setShowApiKey(!showApiKey)}
              >
                {showApiKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Get your API key from{' '}
              <a 
                href="https://platform.openai.com/api-keys" 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-blue-600 hover:underline inline-flex items-center gap-1"
              >
                OpenAI Platform
                <ExternalLink className="w-3 h-3" />
              </a>
            </p>
          </div>

          {/* Status Messages */}
          {status.error && (
            <Alert variant="destructive">
              <XCircle className="h-4 w-4" />
              <AlertDescription>{status.error}</AlertDescription>
            </Alert>
          )}

          {status.valid === true && (
            <Alert className="border-green-200 bg-green-50 dark:bg-green-950">
              <CheckCircle className="h-4 w-4 text-green-600" />
              <AlertDescription className="text-green-800 dark:text-green-200">
                Connection successful! Your OpenAI API key is working.
              </AlertDescription>
            </Alert>
          )}

          {/* Action Buttons */}
          <div className="flex gap-3 pt-4">
            <Button
              variant="outline"
              onClick={testConnection}
              disabled={!apiKey.trim() || status.testing}
              className="flex-1"
            >
              {status.testing ? 'Testing...' : 'Test Connection'}
            </Button>
            <Button
              onClick={handleSave}
              disabled={!apiKey.trim()}
              className="flex-1"
            >
              Save & Continue
            </Button>
          </div>

          {/* Security Note */}
          <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded-lg">
            <p className="text-xs text-gray-600 dark:text-gray-400">
              <strong>Security:</strong> Your API key is stored locally in your browser and only used for direct requests to OpenAI's servers.
            </p>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default OpenAISettingsModal;

================
File: client/src/components/PricingPage.tsx
================
/**
 * Multi-tier Pricing Page Component
 */

import React, { useState, useEffect, useRef } from 'react';
import { Check, X, Sparkles, Users, Building2, CreditCard, ArrowLeft } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useAuth } from '@/hooks/useAuth';
import { useToast } from '@/hooks/use-toast';
import { navigateTo } from './Router';

// Particles component for background effects (copied from ChatView)
interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 100,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "#8B5CF6",
  vx = 0,
  vy = 0,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  useEffect(() => {
    if (canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
    }
    initCanvas();
    animate();
    
    const handleResize = () => initCanvas();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [color]);

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = () => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.2;
    const dy = (Math.random() - 0.5) * 0.2;
    const magnetism = 0.1 + Math.random() * 4;
    return { x, y, translateX, translateY, size: pSize, alpha, targetAlpha, dx, dy, magnetism };
  };

  const drawCircle = (circle: any, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = color;
      context.current.globalAlpha = alpha;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);
      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(0, 0, canvasSize.current.w, canvasSize.current.h);
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: any, i: number) => {
      circle.x += circle.dx + vx;
      circle.y += circle.dy + vy;
      drawCircle(circle, true);
      
      if (circle.x < -circle.size || circle.x > canvasSize.current.w + circle.size ||
          circle.y < -circle.size || circle.y > canvasSize.current.h + circle.size) {
        circles.current.splice(i, 1);
        const newCircle = circleParams();
        drawCircle(newCircle);
      }
    });
    window.requestAnimationFrame(animate);
  };

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  );
};

interface PlanFeature {
  name: string;
  included: boolean;
  value?: string | number;
  tooltip?: string;
}

interface SubscriptionPlan {
  id: string;
  name: string;
  description: string;
  price: number;
  interval: 'month' | 'year';
  popular?: boolean;
  features: PlanFeature[];
  aiCredits: number;
  maxProjects: number;
  teamSize?: number;
  supportLevel: string;
  ctaText: string;
  disabled?: boolean;
}

const PricingPage: React.FC = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const [billingInterval, setBillingInterval] = useState<'month' | 'year'>('month');
  const [currentPlan, setCurrentPlan] = useState<string | null>(null);
  const [isGrandfathered, setIsGrandfathered] = useState(false);
  const [loading, setLoading] = useState(false);

  // Fetch current subscription details
  useEffect(() => {
    if (user) {
      fetchSubscriptionDetails();
    }
  }, [user]);

  const fetchSubscriptionDetails = async () => {
    if (!user) {
      return; // Don't fetch if user is not authenticated
    }

    try {
      const response = await fetch('/api/subscription/details', {
        credentials: 'include',
      });
      
      if (response.ok) {
        const data = await response.json();
        setCurrentPlan(data.tier);
        setIsGrandfathered(data.grandfather?.isGrandfathered || false);
      } else if (response.status === 401) {
        // User not authenticated, just return without error
        console.log('User not authenticated for subscription details');
        return;
      } else {
        // Try to parse error response
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("application/json")) {
          const errorData = await response.json();
          console.error('Error fetching subscription details:', errorData.error || 'Unknown error');
        } else {
          console.error('Error fetching subscription details: Server returned non-JSON response');
        }
      }
    } catch (error) {
      console.error('Error fetching subscription details:', error);
    }
  };

  const plans: SubscriptionPlan[] = [
    {
      id: 'freemium',
      name: 'Base Plan',
      description: 'Get started with basic AI assistance',
      price: 0,
      interval: billingInterval,
      aiCredits: 100,
      maxProjects: 1,
      supportLevel: 'Community',
      ctaText: currentPlan === 'freemium' ? 'Current Plan' : 'Downgrade',
      disabled: currentPlan === 'freemium',
      features: [
        { name: 'Basic Chat Access', included: true },
        { name: 'AI Credits per Month', included: true, value: '100' },
        { name: 'Projects', included: true, value: '1' },
        { name: 'Full Codebase Context', included: false },
        { name: 'Git Integration', included: false },
        { name: 'AI Code Reviews', included: false },
        { name: 'Team Features', included: false },
        { name: 'Priority Support', included: false },
      ],
    },
    {
      id: 'pro',
      name: 'Pro Plan',
      description: 'Perfect for individual developers',
      price: billingInterval === 'month' ? 19 : 190,
      interval: billingInterval,
      popular: true,
      aiCredits: 1000,
      maxProjects: 1,
      supportLevel: 'Email',
      ctaText: currentPlan === 'pro' ? 'Current Plan' : 'Upgrade to Pro',
      disabled: currentPlan === 'pro',
      features: [
        { name: 'Unlimited Chat & AI Providers', included: true },
        { name: 'AI Credits per Month', included: true, value: '1,000' },
        { name: 'Projects with Full Context', included: true, value: '1' },
        { name: 'Full Codebase Context', included: true },
        { name: 'Git Integration', included: true },
        { name: 'AI Code Reviews', included: true, value: '10/month' },
        { name: 'Team Features', included: false },
        { name: 'Priority Support', included: false },
      ],
    },
    {
      id: 'team',
      name: 'Team Plan',
      description: 'Built for growing teams',
      price: billingInterval === 'month' ? 49 : 490,
      interval: billingInterval,
      aiCredits: 5000,
      maxProjects: 5,
      teamSize: 5,
      supportLevel: 'Priority Email',
      ctaText: 'Upgrade to Team',
      features: [
        { name: 'Everything in Pro', included: true },
        { name: 'AI Credits per User', included: true, value: '5,000/month' },
        { name: 'Projects per User', included: true, value: '5' },
        { name: 'Shared Workspaces', included: true },
        { name: 'Team Personas', included: true },
        { name: 'AI Code Reviews', included: true, value: '100/user/month' },
        { name: 'Team Admin Dashboard', included: true },
        { name: 'Priority Email Support', included: true },
      ],
    },
    {
      id: 'enterprise',
      name: 'Enterprise Plan',
      description: 'Advanced features & support for organizations',
      price: 0, // Custom pricing
      interval: billingInterval,
      aiCredits: 999999,
      maxProjects: 999999,
      supportLevel: 'Dedicated',
      ctaText: 'Contact Sales',
      features: [
        { name: 'Everything in Team', included: true },
        { name: 'Custom AI Credits Pool', included: true },
        { name: 'Unlimited Projects', included: true },
        { name: 'SAML SSO', included: true },
        { name: 'Audit Logs', included: true },
        { name: 'Data Residency Options', included: true },
        { name: 'Custom Integrations', included: true },
        { name: 'Dedicated Account Manager', included: true },
      ],
    },
  ];

  const handleSelectPlan = async (planId: string) => {
    if (!user) {
      // Redirect to login page for unauthenticated users
      navigateTo('/login');
      return;
    }

    if (planId === 'enterprise') {
      // Redirect to contact form for enterprise
      window.location.href = 'mailto:sales@nomadai.com?subject=Enterprise Plan Inquiry';
      return;
    }

    if (planId === 'freemium') {
      // Freemium tier - no payment needed
      toast({
        title: 'Already on Base Plan',
        description: 'You are currently on the free plan. Upgrade to Pro or Team for more features.',
      });
      return;
    }

    setLoading(true);
    try {
      // Create Stripe Checkout Session
      const response = await fetch('/api/checkout/subscription', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          tier: planId,
          interval: billingInterval,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error selecting plan:', error);
      toast({
        title: 'Checkout Error',
        description: error instanceof Error ? error.message : 'Failed to start checkout. Please try again.',
      });
    } finally {
      setLoading(false);
    }
  };

  const handlePurchaseCredits = async (credits: number) => {
    if (!user) {
      // Redirect to login page for unauthenticated users
      navigateTo('/login');
      return;
    }

    setLoading(true);
    try {
      // Map credits amount to package ID
      const packageMap: { [key: number]: string } = {
        100: 'credits_100',
        500: 'credits_500',
        1000: 'credits_1000',
        5000: 'credits_5000',
      };
      
      const packageId = packageMap[credits];
      if (!packageId) {
        throw new Error('Invalid credit package');
      }
      
      // Create Stripe Checkout Session for AI Credits
      const response = await fetch('/api/checkout/credits', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          packageId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create checkout session');
      }

      const data = await response.json();
      
      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL returned');
      }
    } catch (error) {
      console.error('Error purchasing credits:', error);
      toast({
        title: 'Checkout Error',
        description: error instanceof Error ? error.message : 'Failed to start checkout. Please try again.',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden">
      {/* Background Effects - Matching ChatView */}
      <div className="absolute inset-0">
        <Particles
          className="absolute inset-0"
          quantity={150}
          color="#8B5CF6"
          size={1}
          staticity={30}
        />
        
        {/* Holographic Gradients */}
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
      </div>
      
      <div className="container mx-auto px-4 relative z-10 py-12">
        {/* Back Button */}
        <div className="mb-6">
          <Button
            variant="ghost"
            onClick={() => navigateTo('/')}
            className="flex items-center gap-2 text-slate-300 hover:text-white bg-slate-800/50 backdrop-blur-xl border border-slate-700/50 hover:bg-slate-700/50 transition-all duration-200"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Uterpi
          </Button>
        </div>

        {/* Header */}
        <div className="text-center mb-12">
          <h1 className="text-5xl font-bold mb-4 bg-gradient-to-r from-white via-violet-200 to-white bg-clip-text text-transparent drop-shadow-lg">
            Choose Your Uterpi Plan
          </h1>
          <p className="text-xl text-slate-200 mb-8 max-w-2xl mx-auto">
            Unlock the full potential of AI with Uterpi
          </p>
          
          {isGrandfathered && (
            <Badge className="mb-6 bg-gradient-to-r from-violet-500 to-purple-600 text-white border-0">
              <Sparkles className="w-4 h-4 mr-2" />
              You're grandfathered into special pricing!
            </Badge>
          )}

          {/* Billing Toggle */}
          <Tabs value={billingInterval} onValueChange={(v) => setBillingInterval(v as 'month' | 'year')}>
            <TabsList className="mx-auto bg-slate-800/50 backdrop-blur-xl border border-slate-700/50">
              <TabsTrigger 
                value="month" 
                className="data-[state=active]:bg-slate-700 data-[state=active]:text-white text-slate-300"
              >
                Monthly
              </TabsTrigger>
              <TabsTrigger 
                value="year"
                className="data-[state=active]:bg-slate-700 data-[state=active]:text-white text-slate-300"
              >
                Annual
                <Badge className="ml-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white text-xs">
                  Save 20%
                </Badge>
              </TabsTrigger>
            </TabsList>
          </Tabs>
        </div>

        {/* Pricing Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-12">
          {plans.map((plan) => (
            <Card 
              key={plan.id} 
              className={`relative backdrop-blur-xl border transition-all duration-300 hover:scale-105 ${
                plan.popular 
                  ? 'bg-gradient-to-br from-slate-800/60 to-slate-900/80 border-violet-400/50 shadow-2xl shadow-violet-500/20 ring-1 ring-violet-400/30 scale-105' 
                  : 'bg-slate-800/40 border-slate-700/50 hover:bg-slate-800/60'
              } ${
                currentPlan === plan.id 
                  ? 'ring-2 ring-blue-400/50 bg-gradient-to-br from-slate-800/60 to-blue-900/40 border-blue-400/30' 
                  : ''
              }`}
            >
              {plan.popular && (
                <Badge className="absolute -top-3 left-1/2 -translate-x-1/2 bg-gradient-to-r from-violet-500 to-purple-600 text-white border-0 shadow-lg">
                  Most Popular Uterpi Plan
                </Badge>
              )}
              
              {currentPlan === plan.id && (
                <Badge className="absolute -top-3 right-4 bg-gradient-to-r from-blue-500 to-cyan-600 text-white border-0">
                  Current Uterpi Plan
                </Badge>
              )}

              <CardHeader>
                <CardTitle className="flex items-center justify-between text-white font-semibold">
                  {plan.name}
                  {plan.id === 'team' && <Users className="w-5 h-5 text-slate-300" />}
                  {plan.id === 'enterprise' && <Building2 className="w-5 h-5 text-slate-300" />}
                </CardTitle>
                <CardDescription className="text-slate-200">{plan.description}</CardDescription>
                
                <div className="mt-4">
                  {plan.price === 0 && plan.id !== 'enterprise' ? (
                    <div className="text-3xl font-bold bg-gradient-to-r from-green-400 to-emerald-500 bg-clip-text text-transparent">Free</div>
                  ) : plan.id === 'enterprise' ? (
                    <div className="text-2xl font-bold bg-gradient-to-r from-orange-400 to-red-500 bg-clip-text text-transparent">Custom Pricing</div>
                  ) : (
                    <>
                      <div className="text-3xl font-bold text-white">
                        ${plan.price}
                        {plan.teamSize && <span className="text-sm font-normal text-slate-300">/user</span>}
                        <span className="text-sm font-normal text-slate-300">/{plan.interval}</span>
                      </div>
                      {plan.teamSize && (
                        <p className="text-sm text-slate-400 mt-1">
                          Minimum {plan.teamSize} users
                        </p>
                      )}
                    </>
                  )}
                </div>
              </CardHeader>

              <CardContent>
                {/* AI Credits Highlight */}
                <div className="mb-4 p-3 bg-gradient-to-r from-slate-700/40 to-slate-800/40 backdrop-blur-sm rounded-lg border border-violet-400/20">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-white">AI Credits</span>
                    <Badge className="bg-gradient-to-r from-violet-500/30 to-purple-600/30 border-violet-400/40 text-violet-200 font-semibold">
                      {plan.aiCredits === 999999 ? 'Unlimited' : plan.aiCredits.toLocaleString()}
                    </Badge>
                  </div>
                </div>

                {/* Features List */}
                <ul className="space-y-2 mb-6">
                  {plan.features.map((feature, idx) => (
                    <li key={idx} className="flex items-start text-sm">
                      {feature.included ? (
                        <Check className="w-4 h-4 text-green-400 mr-2 mt-0.5 flex-shrink-0" />
                      ) : (
                        <X className="w-4 h-4 text-slate-500 mr-2 mt-0.5 flex-shrink-0" />
                      )}
                      <span className={!feature.included ? 'text-slate-500 line-through' : 'text-slate-100'}>
                        {feature.name}
                        {feature.value && <span className="font-medium text-white"> - {feature.value}</span>}
                      </span>
                    </li>
                  ))}
                </ul>

                {/* Support Level */}
                <div className="text-sm text-slate-300 mb-4">
                  Support: <span className="font-medium text-white">{plan.supportLevel}</span>
                </div>

                {/* CTA Button */}
                <Button 
                  className={`w-full transition-all duration-200 ${
                    plan.popular 
                      ? 'bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 text-white border-0 shadow-lg hover:shadow-xl' 
                      : 'bg-slate-700/50 hover:bg-slate-600/50 border-slate-600/50 text-white hover:border-slate-500/50 backdrop-blur-sm'
                  }`}
                  disabled={plan.disabled || loading}
                  onClick={() => handleSelectPlan(plan.id)}
                  data-testid={`button-select-${plan.id}`}
                >
                  {!user && (plan.id === 'pro' || plan.id === 'team') ? 'Sign In to Upgrade' : plan.ctaText}
                </Button>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* AI Credits Add-ons Section */}
        <Card className="mb-12 bg-slate-800/30 backdrop-blur-xl border-slate-700/50">
          <CardHeader>
            <CardTitle className="flex items-center text-white">
              <CreditCard className="w-5 h-5 mr-2 text-violet-400" />
              Need More AI Credits?
            </CardTitle>
            <CardDescription className="text-slate-300">
              Purchase additional credits anytime. Credits never expire.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <Button 
                className="bg-slate-700/50 hover:bg-slate-600/50 border-slate-600/50 text-white hover:border-slate-500/50 backdrop-blur-sm transition-all duration-200"
                disabled={loading}
                onClick={() => handlePurchaseCredits(100)}
                data-testid="button-buy-credits-100"
              >
                {!user ? 'Sign In to Purchase' : '100 Credits - $1.99'}
              </Button>
              <Button 
                className="bg-gradient-to-r from-violet-500/20 to-purple-600/20 hover:from-violet-500/30 hover:to-purple-600/30 border-violet-400/30 text-white backdrop-blur-sm transition-all duration-200"
                disabled={loading}
                onClick={() => handlePurchaseCredits(500)}
                data-testid="button-buy-credits-500"
              >
                {!user ? 'Sign In to Purchase' : '500 Credits - $8.99'}
              </Button>
              <Button 
                className="bg-slate-700/50 hover:bg-slate-600/50 border-slate-600/50 text-white hover:border-slate-500/50 backdrop-blur-sm transition-all duration-200"
                disabled={loading}
                onClick={() => handlePurchaseCredits(1000)}
                data-testid="button-buy-credits-1000"
              >
                {!user ? 'Sign In to Purchase' : '1,000 Credits - $15.99'}
              </Button>
              <Button 
                className="bg-slate-700/50 hover:bg-slate-600/50 border-slate-600/50 text-white hover:border-slate-500/50 backdrop-blur-sm transition-all duration-200"
                disabled={loading}
                onClick={() => handlePurchaseCredits(5000)}
                data-testid="button-buy-credits-5000"
              >
                {!user ? 'Sign In to Purchase' : '5,000 Credits - $69.99'}
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Feature Comparison Table */}
        <Card className="bg-slate-800/30 backdrop-blur-xl border-slate-700/50">
          <CardHeader>
            <CardTitle className="text-white">Detailed Feature Comparison</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="border-b border-slate-600">
                    <th className="text-left py-3 text-slate-200 font-semibold">Feature</th>
                    <th className="text-center py-3 text-slate-200 font-semibold">Free</th>
                    <th className="text-center py-3 text-slate-200 font-semibold">Pro</th>
                    <th className="text-center py-3 text-slate-200 font-semibold">Team</th>
                    <th className="text-center py-3 text-slate-200 font-semibold">Enterprise</th>
                  </tr>
                </thead>
                <tbody>
                  {[
                    ['AI Credits/month', '100', '1,000', '5,000/user', 'Custom'],
                    ['Projects', '1', '1', '10/user', 'Unlimited'],
                    ['Full Codebase Context', '‚ùå', '‚úÖ', '‚úÖ', '‚úÖ'],
                    ['Git Integration', '‚ùå', '‚úÖ', '‚úÖ', '‚úÖ'],
                    ['AI Code Reviews', '‚ùå', '10/month', '100/user', 'Unlimited'],
                    ['Team Workspaces', '‚ùå', '‚ùå', '‚úÖ', '‚úÖ'],
                    ['SSO & Audit Logs', '‚ùå', '‚ùå', '‚ùå', '‚úÖ'],
                    ['Support', 'Community', 'Email', 'Priority', 'Dedicated'],
                  ].map(([feature, ...values]) => (
                    <tr key={feature} className="border-b border-slate-700/50">
                      <td className="py-3 font-medium text-slate-200">{feature}</td>
                      {values.map((value, idx) => (
                        <td key={idx} className="text-center py-3">
                          {value === '‚úÖ' ? (
                            <Check className="w-4 h-4 text-green-400 mx-auto" />
                          ) : value === '‚ùå' ? (
                            <X className="w-4 h-4 text-slate-500 mx-auto" />
                          ) : (
                            <span className="text-slate-300">{value}</span>
                          )}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default PricingPage;

================
File: client/src/components/ProfileModal.tsx
================
import React from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from './ui/dialog';
import { UserProfile } from './UserProfile';

interface ProfileModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export const ProfileModal: React.FC<ProfileModalProps> = ({
  open,
  onOpenChange,
}) => {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader className="sr-only">
          <DialogTitle>User Profile</DialogTitle>
          <DialogDescription>
            Edit your profile information and preferences
          </DialogDescription>
        </DialogHeader>
        <UserProfile />
      </DialogContent>
    </Dialog>
  );
};

================
File: client/src/components/ProviderSettingsPage.tsx
================
import React, { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Settings, ArrowLeft } from 'lucide-react';
import AIProviderSelector, { AIProvider } from './AIProviderSelector';
// Inline model selection replaces the modal-based selector
import { useAIProvider } from '../hooks/useAIProvider';
import { LLMModel } from '../types';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from './ui/dialog';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from './ui/accordion';

interface ProviderSettingsPageProps {
  onBack?: () => void;
}

const ProviderSettingsPage: React.FC<ProviderSettingsPageProps> = ({ onBack }) => {
  const [showModelSelector, setShowModelSelector] = useState(false);
  
  const {
    currentProvider,
    setProvider,
    selectedLLMModel,
    updateModel,
    getAvailableModels,
    isProviderConfigured
  } = useAIProvider();

  const handleProviderChange = (provider: AIProvider) => {
    setProvider(provider);
  };

  const handleModelSelection = (model: LLMModel) => {
    updateModel(model);
    setShowModelSelector(false);
  };

  const providerInfo = {
    azure: {
      name: 'Azure AI',
      description: 'Enterprise-grade AI models from Microsoft Azure',
      status: isProviderConfigured('azure') ? 'Configured' : 'Setup required'
    },
    openai: {
      name: 'OpenAI',
      description: 'Direct access to GPT-4, GPT-4o, and other OpenAI models',
      status: isProviderConfigured('openai') ? 'Configured' : 'Setup required'
    },
    gemini: {
      name: 'Google Gemini',
      description: 'Google\'s advanced multimodal AI models',
      status: isProviderConfigured('gemini') ? 'Configured' : 'Setup required'
    },
    huggingface: {
      name: 'Hugging Face',
      description: 'Use your own HuggingFace Inference Endpoint',
      status: isProviderConfigured('huggingface') ? 'Configured' : 'Setup required'
    },
    uterpi: {
      name: 'Uterpi',
      description: 'Proprietary LLM. Ready out-of-the-box.',
      status: isProviderConfigured('uterpi') ? 'Configured' : 'Unavailable'
    },
    lmstudio: {
      name: 'Uterpi AI',
      description: 'Uterpi AI via LM Studio (Recommended)',
      status: isProviderConfigured('lmstudio') ? 'Configured' : 'Setup required'
    }
  };

  return (
    <div className="space-y-6">{/* Current setup summary + drawer for changes */}
      {/* Current Setup Summary */}
      <Card className="bg-slate-800/30 border-slate-700/50 mx-auto max-w-[1100px]">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-white">
            <Settings className="w-5 h-5 text-blue-400" />
            Current setup
          </CardTitle>
          <CardDescription className="text-slate-400">
            Your active provider and model
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-start justify-between p-4 bg-blue-50 dark:bg-blue-950/20 rounded-lg border border-blue-200 dark:border-blue-800">
            <div>
              <h3 className="font-medium text-blue-900 dark:text-blue-100">{providerInfo[currentProvider].name}</h3>
              <p className="text-sm text-blue-700 dark:text-blue-300">{providerInfo[currentProvider].description}</p>
              <p className="text-xs text-blue-600 dark:text-blue-400 mt-1">Status: {providerInfo[currentProvider].status}</p>
            </div>
            {selectedLLMModel && (
              <div className="text-right">
                <p className="font-medium text-blue-900 dark:text-blue-100">{selectedLLMModel.name}</p>
                <p className="text-xs text-blue-700 dark:text-blue-300">{selectedLLMModel.contextLength.toLocaleString()} tokens</p>
              </div>
            )}
          </div>
          <div className="mt-4">
            <Dialog>
              <DialogTrigger asChild>
                <Button className="w-full bg-violet-600 hover:bg-violet-700 text-white">Change</Button>
              </DialogTrigger>
              <DialogContent className="p-0 w-[96vw] sm:w-[92vw] max-w-[1000px] h-[min(96vh,100dvh-2rem)] flex flex-col overflow-hidden">
                <DialogHeader className="flex-none px-6 py-3 border-b border-slate-800 bg-slate-900/90 backdrop-blur">
                  <DialogTitle>Configure AI Provider</DialogTitle>
                  <DialogDescription>Choose provider and model. Changes auto-save.</DialogDescription>
                </DialogHeader>
                <div className="flex-1 px-6 py-4 overflow-y-auto">
                  <Accordion type="single" collapsible className="w-full" defaultValue="provider">
                    <AccordionItem value="provider">
                      <AccordionTrigger>Choose Provider</AccordionTrigger>
                      <AccordionContent>
                        <AIProviderSelector
                          currentProvider={currentProvider}
                          onProviderChange={handleProviderChange}
                        />
                      </AccordionContent>
                    </AccordionItem>
                    <AccordionItem value="model">
                      <AccordionTrigger>Choose Model</AccordionTrigger>
                      <AccordionContent>
                        <div className="space-y-4">
                          {selectedLLMModel ? (
                            <div className="p-3 bg-slate-900/60 border border-slate-700/60 rounded">
                              <div className="flex items-center justify-between">
                                <div>
                                  <div className="font-medium text-white">{selectedLLMModel.name}</div>
                                  <div className="text-xs text-slate-400">{selectedLLMModel.provider} ‚Ä¢ {selectedLLMModel.contextLength.toLocaleString()} tokens</div>
                                </div>
                                <div className="text-xs text-slate-400">{selectedLLMModel.category}</div>
                              </div>
                            </div>
                          ) : null}
                          {getAvailableModels().length > 1 ? (
                            <div className="space-y-2">
                              {getAvailableModels().map((model) => (
                                <button
                                  key={model.id}
                                  onClick={() => handleModelSelection(model)}
                                  className={`w-full text-left p-3 rounded border transition-colors ${
                                    selectedLLMModel?.id === model.id
                                      ? 'border-violet-500 bg-violet-500/10 text-white'
                                      : 'border-slate-700/60 bg-slate-900/60 text-slate-200 hover:bg-slate-800'
                                  }`}
                                >
                                  <div className="flex items-center justify-between">
                                    <div>
                                      <div className="font-medium">{model.name}</div>
                                      <div className="text-xs text-slate-400">{model.provider} ‚Ä¢ {model.contextLength.toLocaleString()} tokens</div>
                                    </div>
                                    <div className="flex items-center gap-2">
                                      {model.provider.toLowerCase().includes('uterpi') && (
                                        <span className="text-amber-400 text-xs border border-amber-500/40 bg-amber-500/10 px-2 py-0.5 rounded">Recommended</span>
                                      )}
                                      <span className="text-xs text-slate-400">{model.category}</span>
                                    </div>
                                  </div>
                                  <div className="text-xs text-slate-500 mt-1">{model.description}</div>
                                </button>
                              ))}
                            </div>
                          ) : (
                            <p className="text-xs text-slate-400">Only one model available for {providerInfo[currentProvider].name}. It is selected automatically.</p>
                          )}
                        </div>
                      </AccordionContent>
                    </AccordionItem>
                    <AccordionItem value="advanced">
                      <AccordionTrigger>Advanced</AccordionTrigger>
                      <AccordionContent>
                        <div className="space-y-3">
                          {(Object.keys(providerInfo) as AIProvider[]).map((provider) => (
                            <div 
                              key={provider}
                              className={`flex items-center justify-between p-3 rounded-lg border ${
                                provider === currentProvider 
                                  ? 'border-blue-200 bg-blue-50 dark:border-blue-800 dark:bg-blue-950/20' 
                                  : 'border-gray-200 bg-gray-50 dark:border-slate-700/60 dark:bg-slate-900/60'
                              }`}
                            >
                              <div>
                                <h4 className="font-medium text-slate-900 dark:text-white">{providerInfo[provider].name}</h4>
                                <p className="text-sm text-slate-600 dark:text-slate-400">{providerInfo[provider].status}</p>
                              </div>
                              <div className="flex items-center gap-2">
                                {provider === currentProvider && (
                                  <span className="text-xs bg-blue-600 text-white px-2 py-1 rounded">Active</span>
                                )}
                                <span className={`w-2 h-2 rounded-full ${isProviderConfigured(provider) ? 'bg-green-500' : 'bg-gray-400'}`} />
                              </div>
                            </div>
                          ))}
                        </div>
                      </AccordionContent>
                    </AccordionItem>
                  </Accordion>
                </div>
              </DialogContent>
            </Dialog>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ProviderSettingsPage;

================
File: client/src/components/Router.tsx
================
import React, { useEffect, useState } from 'react';
import App from '../App';
import { ResetPasswordForm } from './auth/ResetPasswordForm';
import PricingPage from './PricingPage';
import { CheckoutSuccessPage, CheckoutCancelPage } from './CheckoutPages';
import { AuthProvider } from '../hooks/useAuth';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { AlertCircle } from 'lucide-react';
import { Toaster } from './ui/sonner';

interface RouteState {
  path: string;
  token?: string;
}

// Navigation utility function
export const navigateTo = (path: string) => {
  window.history.pushState({}, '', path);
  // Trigger a popstate event to update the route
  window.dispatchEvent(new PopStateEvent('popstate'));
};

export function Router() {
  const [route, setRoute] = useState<RouteState>({ path: '/' });

  useEffect(() => {
    const handlePopState = () => {
      updateRoute();
    };

    const updateRoute = () => {
      const path = window.location.pathname;
      const params = new URLSearchParams(window.location.search);
      const token = params.get('token');

      setRoute({ path, token: token || undefined });
    };

    // Initial route setup
    updateRoute();

    // Listen for navigation events
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, []);

  const navigateToLogin = () => {
    window.history.pushState({}, '', '/');
    setRoute({ path: '/' });
  };

  // Wrap all routes with AuthProvider
  return (
    <AuthProvider>
      {/* Handle pricing page */}
      {route.path === '/pricing' && <PricingPage />}

      {/* Handle checkout success page */}
      {route.path === '/checkout/success' && <CheckoutSuccessPage />}

      {/* Handle checkout cancel page */}
      {route.path === '/checkout/cancel' && <CheckoutCancelPage />}

      {/* Handle reset password page */}
      {route.path === '/reset-password' && (
        <>
          {!route.token ? (
            <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
              <Card className="w-full max-w-md mx-auto bg-slate-900 border-slate-700">
                <CardHeader className="text-center">
                  <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-red-100">
                    <AlertCircle className="h-8 w-8 text-red-600" />
                  </div>
                  <CardTitle className="text-white">Invalid Reset Link</CardTitle>
                  <CardDescription className="text-slate-400">
                    This password reset link is missing or invalid.
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <Button onClick={navigateToLogin} className="w-full">
                    Back to Login
                  </Button>
                </CardContent>
              </Card>
            </div>
          ) : (
            <div className="min-h-screen bg-slate-950 text-white flex items-center justify-center p-4">
              <ResetPasswordForm
                token={route.token}
                onSuccess={navigateToLogin}
                onBackToLogin={navigateToLogin}
              />
            </div>
          )}
        </>
      )}

      {/* Default to main app */}
      {route.path === '/' && <App />}
      
      {/* Global toast notifications */}
      <Toaster />
    </AuthProvider>
  );
}

================
File: client/src/components/Sidebar.tsx
================
import React from 'react';
import { Bot, Plus, Settings, MessageSquare } from 'lucide-react';

const Sidebar: React.FC = () => {
  return (
    <div className="hidden md:flex flex-col w-64 bg-secondary/50 border-r border-border p-4 transition-all duration-300">
      <div className="flex items-center mb-8">
        <Bot className="w-8 h-8 text-primary mr-3" />
        <h1 className="text-xl font-bold text-foreground">AI Assistant</h1>
      </div>
      <button className="flex items-center justify-center w-full bg-primary text-primary-foreground py-2 px-4 rounded-lg hover:bg-primary/90 transition-colors duration-200 mb-6">
        <Plus className="w-5 h-5 mr-2" />
        New Chat
      </button>
      <div className="flex-1 overflow-y-auto -mr-2 pr-2">
        <h2 className="text-sm font-semibold text-muted-foreground mb-2">Recent</h2>
        <nav className="space-y-2">
          <a href="#" className="flex items-center p-2 bg-primary/10 text-primary-foreground rounded-lg">
            <MessageSquare className="w-4 h-4 mr-3" />
            <span className="truncate">Designing a modern UI...</span>
          </a>
          <a href="#" className="flex items-center p-2 text-muted-foreground hover:bg-accent hover:text-accent-foreground rounded-lg">
            <MessageSquare className="w-4 h-4 mr-3" />
            <span className="truncate">React component patterns</span>
          </a>
          <a href="#" className="flex items-center p-2 text-muted-foreground hover:bg-accent hover:text-accent-foreground rounded-lg">
            <MessageSquare className="w-4 h-4 mr-3" />
            <span className="truncate">Python data analysis script</span>
          </a>
        </nav>
      </div>
      <div className="mt-auto">
        <a href="#" className="flex items-center p-2 text-muted-foreground hover:bg-accent hover:text-accent-foreground rounded-lg">
          <Settings className="w-5 h-5 mr-3" />
          Settings
        </a>
      </div>
    </div>
  );
};

export default Sidebar;

================
File: client/src/components/SimpleModelSelector.tsx
================
import React from 'react';
import { ChevronDown, Sparkles, Zap, Brain, TrendingUp } from 'lucide-react';
import { Button } from './ui/button';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from './ui/select';
import { Badge } from './ui/badge';
import { LLMModel } from '../types';
import { cn } from '../lib/utils';

interface SimpleModelSelectorProps {
  models: LLMModel[];
  selectedModel: LLMModel | null;
  onModelSelect: (model: LLMModel) => void;
  className?: string;
  compact?: boolean;
}

const categoryIcons = {
  text: Brain,
  code: Zap,
  multimodal: Sparkles,
  reasoning: TrendingUp
};

export const SimpleModelSelector: React.FC<SimpleModelSelectorProps> = ({
  models,
  selectedModel,
  onModelSelect,
  className,
  compact = false
}) => {
  if (!models || models.length === 0) return null;

  // If only one model available, show it as a static badge
  if (models.length === 1) {
    const model = models[0];
    const Icon = categoryIcons[model.category] || Brain;
    
    if (compact) {
      return (
        <Badge 
          variant="outline" 
          className={cn(
            "text-xs h-7 px-2 border-slate-600 bg-slate-800/50",
            className
          )}
        >
          <Icon className="w-3 h-3 mr-1" />
          {model.name}
        </Badge>
      );
    }

    return (
      <div className={cn("flex items-center gap-2", className)}>
        <Icon className="w-4 h-4 text-slate-400" />
        <span className="text-sm text-white">{model.name}</span>
        <Badge 
          variant="outline" 
          className="text-[10px] h-4 px-1 border-slate-600 text-slate-400"
        >
          {model.contextLength.toLocaleString()} tokens
        </Badge>
      </div>
    );
  }

  // Multiple models - show dropdown selector
  return (
    <Select
      value={selectedModel?.id}
      onValueChange={(value) => {
        const model = models.find(m => m.id === value);
        if (model) onModelSelect(model);
      }}
    >
      <SelectTrigger 
        className={cn(
          "border-slate-600 bg-slate-800/50 text-white hover:bg-slate-700/50",
          compact ? "h-7 text-xs" : "h-9 text-sm",
          className
        )}
      >
        <div className="flex items-center gap-2">
          {selectedModel && (
            <>
              {React.createElement(
                categoryIcons[selectedModel.category] || Brain,
                { className: compact ? "w-3 h-3" : "w-4 h-4" }
              )}
              <span className="truncate">{selectedModel.name}</span>
            </>
          )}
        </div>
      </SelectTrigger>
      
      <SelectContent className="bg-slate-900 border-slate-700">
        {models.map(model => {
          const Icon = categoryIcons[model.category] || Brain;
          return (
            <SelectItem 
              key={model.id} 
              value={model.id}
              className="text-white hover:bg-slate-800 cursor-pointer"
            >
              <div className="flex items-center justify-between w-full gap-3">
                <div className="flex items-center gap-2 flex-1">
                  <Icon className="w-4 h-4 text-slate-400" />
                  <div className="flex flex-col">
                    <span className="text-sm font-medium">{model.name}</span>
                    <span className="text-[10px] text-slate-400">
                      {model.contextLength.toLocaleString()} tokens
                    </span>
                  </div>
                </div>
                {model.tier && (
                  <Badge 
                    variant="outline" 
                    className={cn(
                      "text-[10px] h-4 px-1 ml-2",
                      model.tier === 'freemium' && "border-emerald-500/30 text-emerald-400",
                      model.tier === 'pro' && "border-violet-500/30 text-violet-400",
                      model.tier === 'enterprise' && "border-amber-500/30 text-amber-400"
                    )}
                  >
                    {model.tier}
                  </Badge>
                )}
              </div>
            </SelectItem>
          );
        })}
      </SelectContent>
    </Select>
  );
};

================
File: client/src/components/SpeechSettings.tsx
================
// Speech Settings Component - Configure TTS/STT options

import React, { useState, useEffect } from 'react';
import { Volume2, Mic, Settings, Save } from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Label } from './ui/label';
import { Switch } from './ui/switch';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Slider } from './ui/slider';
import { Button } from './ui/button';
import { toast } from 'sonner';
import { useSpeech } from '../hooks/useSpeech';
import { VoiceInfo } from '../types/speech';
import { requestMicrophonePermission } from '../lib/speech/speechUtils';

interface SpeechSettingsProps {
  onClose?: () => void;
}

const SpeechSettings: React.FC<SpeechSettingsProps> = ({ onClose }) => {
  const {
    voices,
    selectedVoice,
    setVoice,
    isAvailable,
    capabilities,
    currentProvider,
    isHTTPS,
    microphonePermission
  } = useSpeech();

  // Settings state
  const [autoSpeak, setAutoSpeak] = useState(false);
  const [speechRate, setSpeechRate] = useState(1.0);
  const [speechPitch, setSpeechPitch] = useState(1.0);
  const [speechVolume, setSpeechVolume] = useState(1.0);
  const [selectedLanguage, setSelectedLanguage] = useState('en-US');

  // Load saved settings
  useEffect(() => {
    // Default to false unless explicitly enabled by user
    const savedAutoSpeak = localStorage.getItem('auto-speak-responses') === 'true';
    const savedRate = parseFloat(localStorage.getItem('speech-rate') || '1.0');
    const savedPitch = parseFloat(localStorage.getItem('speech-pitch') || '1.0');
    const savedVolume = parseFloat(localStorage.getItem('speech-volume') || '1.0');
    const savedLanguage = localStorage.getItem('speech-language') || 'en-US';
    const savedVoiceId = localStorage.getItem('speech-voice-id');

    setAutoSpeak(savedAutoSpeak);
    setSpeechRate(savedRate);
    setSpeechPitch(savedPitch);
    setSpeechVolume(savedVolume);
    setSelectedLanguage(savedLanguage);

    if (savedVoiceId && voices.length > 0) {
      const voice = voices.find(v => v.id === savedVoiceId);
      if (voice) {
        setVoice(voice);
      }
    }
  }, [voices, setVoice]);

  // Save settings
  const saveSettings = () => {
    localStorage.setItem('auto-speak-responses', autoSpeak.toString());
    localStorage.setItem('speech-rate', speechRate.toString());
    localStorage.setItem('speech-pitch', speechPitch.toString());
    localStorage.setItem('speech-volume', speechVolume.toString());
    localStorage.setItem('speech-language', selectedLanguage);
    
    if (selectedVoice) {
      localStorage.setItem('speech-voice-id', selectedVoice.id);
    }

    toast.success('Speech settings saved!');
    if (onClose) {
      onClose();
    }
  };

  // Group voices by language
  const voicesByLanguage = voices.reduce((acc, voice) => {
    const lang = voice.language || 'Unknown';
    if (!acc[lang]) {
      acc[lang] = [];
    }
    acc[lang].push(voice);
    return acc;
  }, {} as Record<string, VoiceInfo[]>);

  if (!isAvailable) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Volume2 className="w-5 h-5" />
            Speech Settings
          </CardTitle>
          <CardDescription>
            Speech functionality is not available in your browser or with the current AI provider.
          </CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-2xl">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Volume2 className="w-5 h-5" />
          Speech Settings
        </CardTitle>
        <CardDescription>
          Configure text-to-speech and speech-to-text options. Currently using {currentProvider} speech provider.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Auto-speak AI Responses */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label htmlFor="auto-speak">Auto-speak AI Responses</Label>
            <p className="text-sm text-muted-foreground">
              Automatically read aloud AI responses
            </p>
          </div>
          <Switch
            id="auto-speak"
            checked={autoSpeak}
            onCheckedChange={setAutoSpeak}
          />
        </div>

        {/* Microphone Permission Status */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label>Microphone Access</Label>
            <p className="text-sm text-muted-foreground">
              {microphonePermission === 'granted' ? 'Granted' : microphonePermission === 'denied' ? 'Denied' : 'Prompt'}
              {!isHTTPS && microphonePermission !== 'granted' && (
                <span className="ml-2 text-yellow-500">HTTPS recommended</span>
              )}
            </p>
          </div>
          <Button
            variant="outline"
            onClick={async () => {
              const ok = await requestMicrophonePermission();
              if (ok) {
                toast.success('Microphone permission granted');
              } else {
                toast.error('Microphone permission denied');
              }
            }}
          >
            {microphonePermission === 'granted' ? 'Recheck' : 'Request'}
          </Button>
        </div>

        {/* Voice Selection */}
        {voices.length > 0 && (
          <div className="space-y-2">
            <Label htmlFor="voice-select">Voice</Label>
            <Select
              value={selectedVoice?.id || ''}
              onValueChange={(value) => {
                const voice = voices.find(v => v.id === value);
                if (voice) {
                  setVoice(voice);
                }
              }}
            >
              <SelectTrigger id="voice-select">
                <SelectValue placeholder="Select a voice" />
              </SelectTrigger>
              <SelectContent>
                {Object.entries(voicesByLanguage).map(([language, langVoices]) => (
                  <div key={language}>
                    <div className="px-2 py-1 text-xs font-semibold text-muted-foreground">
                      {language}
                    </div>
                    {langVoices.map((voice) => (
                      <SelectItem key={voice.id} value={voice.id}>
                        {voice.name} {voice.gender && `(${voice.gender})`}
                      </SelectItem>
                    ))}
                  </div>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        {/* Speech Rate */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Label htmlFor="speech-rate">Speech Rate</Label>
            <span className="text-sm text-muted-foreground">{speechRate.toFixed(1)}x</span>
          </div>
          <Slider
            id="speech-rate"
            min={0.5}
            max={2.0}
            step={0.1}
            value={[speechRate]}
            onValueChange={([value]) => setSpeechRate(value)}
            className="w-full"
          />
        </div>

        {/* Speech Pitch */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Label htmlFor="speech-pitch">Pitch</Label>
            <span className="text-sm text-muted-foreground">{speechPitch.toFixed(1)}</span>
          </div>
          <Slider
            id="speech-pitch"
            min={0.5}
            max={2.0}
            step={0.1}
            value={[speechPitch]}
            onValueChange={([value]) => setSpeechPitch(value)}
            className="w-full"
          />
        </div>

        {/* Speech Volume */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Label htmlFor="speech-volume">Volume</Label>
            <span className="text-sm text-muted-foreground">{Math.round(speechVolume * 100)}%</span>
          </div>
          <Slider
            id="speech-volume"
            min={0}
            max={1}
            step={0.1}
            value={[speechVolume]}
            onValueChange={([value]) => setSpeechVolume(value)}
            className="w-full"
          />
        </div>

        {/* Language Selection */}
        <div className="space-y-2">
          <Label htmlFor="language-select">Language</Label>
          <Select
            value={selectedLanguage}
            onValueChange={setSelectedLanguage}
          >
            <SelectTrigger id="language-select">
              <SelectValue placeholder="Select language" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="en-US">English (US)</SelectItem>
              <SelectItem value="en-GB">English (UK)</SelectItem>
              <SelectItem value="es-ES">Spanish</SelectItem>
              <SelectItem value="fr-FR">French</SelectItem>
              <SelectItem value="de-DE">German</SelectItem>
              <SelectItem value="it-IT">Italian</SelectItem>
              <SelectItem value="pt-BR">Portuguese (Brazil)</SelectItem>
              <SelectItem value="ru-RU">Russian</SelectItem>
              <SelectItem value="zh-CN">Chinese (Simplified)</SelectItem>
              <SelectItem value="ja-JP">Japanese</SelectItem>
              <SelectItem value="ko-KR">Korean</SelectItem>
              <SelectItem value="ar-SA">Arabic</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {/* Capabilities Info */}
        {capabilities && (
          <div className="p-4 bg-muted rounded-lg space-y-2">
            <h4 className="text-sm font-medium">Provider Capabilities</h4>
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="flex items-center gap-2">
                <span className={`w-2 h-2 rounded-full ${capabilities.supportsTTS ? 'bg-green-500' : 'bg-red-500'}`} />
                Text-to-Speech
              </div>
              <div className="flex items-center gap-2">
                <span className={`w-2 h-2 rounded-full ${capabilities.supportsSTT ? 'bg-green-500' : 'bg-red-500'}`} />
                Speech-to-Text
              </div>
              <div className="flex items-center gap-2">
                <span className={`w-2 h-2 rounded-full ${capabilities.supportsStreaming ? 'bg-green-500' : 'bg-red-500'}`} />
                Streaming
              </div>
              <div className="flex items-center gap-2">
                <span className={`w-2 h-2 rounded-full ${capabilities.supportsMultiLanguage ? 'bg-green-500' : 'bg-red-500'}`} />
                Multi-language
              </div>
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex gap-2 justify-end">
          {onClose && (
            <Button variant="outline" onClick={onClose}>
              Cancel
            </Button>
          )}
          <Button onClick={saveSettings}>
            <Save className="w-4 h-4 mr-2" />
            Save Settings
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default SpeechSettings;

================
File: client/src/components/SubscriptionGuard.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useSubscription } from '../hooks/useSubscription';
import { useAuth } from '../hooks/useAuth';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Badge } from './ui/badge';
import { Alert, AlertDescription } from './ui/alert';
import { Lock, Crown, ArrowRight, CheckCircle, Loader2 } from 'lucide-react';
import { navigateTo } from './Router';

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 30,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "hsl(var(--primary))",
  vx = 0,
  vy = 0,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const hexToRgb = (hex: string): number[] => {
    // Handle HSL color values
    if (hex.startsWith('hsl')) {
      // For simplicity, return a default RGB for HSL
      return [139, 92, 246]; // purple equivalent
    }
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  useEffect(() => {
    if (canvasContainerRef.current && canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
      initCanvas();
      animate();
      window.addEventListener("resize", initCanvas);
      return () => window.removeEventListener("resize", initCanvas);
    }
  }, []);

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.2;
    const dy = (Math.random() - 0.5) * 0.2;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${hexToRgb(color).join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(0, 0, canvasSize.current.w, canvasSize.current.h);
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      // Update the circle position based on mouse position
      const edge = [
        circle.x + circle.translateX - mouse.current.x,
        circle.y + circle.translateY - mouse.current.y,
      ];
      const distance = Math.sqrt(edge[0] * edge[0] + edge[1] * edge[1]);
      const maxDistance = Math.max(canvasSize.current.w, canvasSize.current.h);
      
      if (distance < maxDistance) {
        circle.alpha += (circle.targetAlpha - circle.alpha) * 0.02;
        circle.x += circle.dx;
        circle.y += circle.dy;
        circle.translateX += (edge[0] / distance) * circle.magnetism * -1;
        circle.translateY += (edge[1] / distance) * circle.magnetism * -1;
      } else {
        circle.alpha += (0 - circle.alpha) * 0.02;
        circle.x += circle.dx;
        circle.y += circle.dy;
      }

      if (circle.x < -circle.size || circle.x > canvasSize.current.w + circle.size || 
          circle.y < -circle.size || circle.y > canvasSize.current.h + circle.size) {
        circles.current[i] = circleParams();
      }

      drawCircle(circle, true);
    });
    window.requestAnimationFrame(animate);
  };

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} />
    </div>
  );
};

interface SubscriptionGuardProps {
  children: React.ReactNode;
  requiredTier?: 'freemium' | 'pro' | 'team' | 'enterprise';
  feature?: string;
  fallback?: React.ReactNode;
}

export const SubscriptionGuard: React.FC<SubscriptionGuardProps> = ({
  children,
  requiredTier = 'freemium',
  feature = 'this feature',
  fallback
}) => {
  const { user, logout } = useAuth();
  const { subscription, hasActiveSubscription, canAccessFeature, isLoading } = useSubscription();

  // Show loading state
  if (isLoading) {
    return (
      <div className="min-h-screen bg-background relative overflow-hidden flex items-center justify-center">
        <Particles className="absolute inset-0 pointer-events-none" quantity={20} />
        <motion.div 
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          className="flex items-center justify-center p-8"
        >
          <Loader2 className="animate-spin h-8 w-8 text-primary" />
        </motion.div>
      </div>
    );
  }

  // Show login prompt if not authenticated
  if (!user) {
    return (
      <div className="min-h-screen bg-background relative overflow-hidden flex items-center justify-center p-4">
        <Particles className="absolute inset-0 pointer-events-none" quantity={30} />
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="relative z-10"
        >
          <Card className="max-w-md mx-auto border-border/50 bg-card/95 backdrop-blur-sm shadow-2xl">
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-card-foreground">
                <Lock className="h-5 w-5 text-primary" />
                Authentication Required
              </CardTitle>
              <CardDescription>
                Please log in to access {feature}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button onClick={() => window.location.href = '/login'} className="w-full bg-primary hover:bg-primary/90">
                Log In
              </Button>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    );
  }

  // Check if user has access to the feature
  if (canAccessFeature(requiredTier)) {
    return <>{children}</>;
  }

  // Show custom fallback if provided
  if (fallback) {
    return <>{fallback}</>;
  }

  // Show upgrade prompt
  return (
    <div className="min-h-screen bg-slate-950 text-white relative overflow-hidden flex items-center justify-center p-4">
      {/* Background Effects - Match App.tsx exactly */}
      <div className="absolute inset-0">
        <Particles
          className="absolute inset-0"
          quantity={150}
          color="#8B5CF6"
          size={1}
          staticity={30}
        />
        
        {/* Holographic Gradients */}
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-full blur-3xl animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-gradient-to-r from-blue-500/10 to-indigo-600/10 rounded-full blur-3xl animate-pulse delay-1000" />
        
        {/* Circuit Patterns */}
        <div className="absolute inset-0 opacity-5">
          <svg className="absolute top-10 left-10 w-20 h-20 text-violet-400" viewBox="0 0 100 100" fill="none">
            <path d="M10 10h20v20h20v-20h20v40h-20v20h-40z" stroke="currentColor" strokeWidth="0.5" fill="none" opacity="0.1" />
            <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
            <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
          </svg>
          <svg className="absolute top-1/3 right-20 w-16 h-16 text-blue-400" viewBox="0 0 100 100" fill="none">
            <path d="M10 10h20v20h20v-20h20v40h-20v20h-40z" stroke="currentColor" strokeWidth="0.5" fill="none" opacity="0.1" />
            <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
            <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
          </svg>
          <svg className="absolute bottom-20 left-1/3 w-24 h-24 text-purple-400" viewBox="0 0 100 100" fill="none">
            <path d="M10 10h20v20h20v-20h20v40h-20v20h-40z" stroke="currentColor" strokeWidth="0.5" fill="none" opacity="0.1" />
            <circle cx="30" cy="30" r="2" fill="currentColor" opacity="0.2" />
            <circle cx="70" cy="50" r="2" fill="currentColor" opacity="0.2" />
          </svg>
        </div>
      </div>
      
      <motion.div
        initial={{ opacity: 0, scale: 0.8, y: 20 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        transition={{ type: "spring", damping: 20, stiffness: 300 }}
        className="relative z-10 w-full max-w-lg mx-auto"
      >
        <div className="relative p-8 rounded-2xl backdrop-blur-xl border overflow-hidden bg-gradient-to-br from-slate-800/40 to-slate-900/40 border-slate-600/30">
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/5 to-transparent" />
          
          {/* Holographic shimmer effect */}
          <motion.div
            className="absolute inset-0 rounded-2xl bg-gradient-to-r from-transparent via-white/10 to-transparent"
            animate={{ x: ["-100%", "100%"] }}
            transition={{ duration: 3, repeat: Infinity, repeatType: "loop", ease: "linear" }}
          />
          
          <div className="relative z-10">
            <div className="text-center mb-8">
              <motion.div 
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: 0.2 }}
                className="flex justify-center mb-4"
              >
                <div className="rounded-full bg-violet-400/10 p-3 border border-violet-400/20">
                  <Crown className="h-8 w-8 text-violet-400" />
                </div>
              </motion.div>
              <h2 className="text-2xl font-bold text-white mb-2">
                Unlock Uterpi
              </h2>
              <p className="text-slate-300 mb-3">
                Starting at <span className="text-violet-400 font-bold text-lg">$19/month</span>
              </p>
              <p className="text-slate-400 text-sm">
                Uterpi requires a {requiredTier} subscription or higher
              </p>
            </div>
            
            <div className="space-y-6">
              {/* Current Status */}
              <motion.div 
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 0.3 }}
                className="bg-slate-800/50 rounded-lg p-4 border border-slate-600/50"
              >
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium text-white">Current Plan</p>
                    <p className="text-sm text-slate-300">
                      {subscription?.tier || 'freemium'}
                    </p>
                  </div>
                  <span className="px-2 py-1 bg-violet-400/10 text-violet-400 border border-violet-400/20 rounded text-sm">
                    {subscription?.status || 'freemium'}
                  </span>
                </div>
              </motion.div>

              {/* Feature Benefits */}
              <motion.div
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 0.4 }}
              >
                <h3 className="font-medium mb-3 text-white">Choose your plan:</h3>
                <div className="space-y-2">
                  {[
                    'Free: 100 AI Credits/month',
                    'Pro ($19/mo): 1,000 Credits + All AI providers',
                    'Team ($49/user): 5,000 Credits + Shared workspaces',
                    'Full codebase context & Git integration',
                    'AI code reviews & optimizations',
                    'Priority support for paid plans'
                  ].map((featureItem, index) => (
                    <motion.div 
                      key={featureItem}
                      initial={{ opacity: 0, x: -10 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: 0.5 + index * 0.1 }}
                      className="flex items-center gap-2"
                    >
                      <CheckCircle className="h-4 w-4 text-violet-400 flex-shrink-0" />
                      <span className="text-sm text-slate-300">{featureItem}</span>
                    </motion.div>
                  ))}
                </div>
              </motion.div>

              {/* Action Buttons */}
              <motion.div 
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.6 }}
                className="space-y-3"
              >
                <button
                  onClick={() => navigateTo('/pricing')}
                  className="w-full py-3 bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 rounded-xl text-white font-medium transition-all duration-200 flex items-center justify-center gap-2"
                >
                  View Pricing Plans
                  <ArrowRight className="h-4 w-4" />
                </button>
                
                <button
                  onClick={() => logout()}
                  className="w-full py-3 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600/50 rounded-xl text-white font-medium transition-all duration-200"
                >
                  Go Back
                </button>
              </motion.div>

              {/* Payment Failed Alert */}
              <AnimatePresence>
                {subscription?.status === 'past_due' && (
                  <motion.div
                    initial={{ opacity: 0, height: 0 }}
                    animate={{ opacity: 1, height: 'auto' }}
                    exit={{ opacity: 0, height: 0 }}
                    className="p-4 bg-red-500/10 border border-red-500/20 rounded-lg"
                  >
                    <p className="text-red-400 text-sm">
                      Your payment method needs to be updated. Please update your billing information to regain access.
                    </p>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
       </motion.div>
     </div>
    );
  };

// Usage examples:
// <SubscriptionGuard feature="AI code analysis">
//   <CodeAnalysisComponent />
// </SubscriptionGuard>
//
// <SubscriptionGuard requiredTier="premium" feature="advanced AI features">
//   <PremiumFeatures />
// </SubscriptionGuard>

================
File: client/src/components/SubscriptionPage.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { loadStripe } from '@stripe/stripe-js';
import { Elements, CardElement, useStripe, useElements } from '@stripe/react-stripe-js';
import { useSubscription, type SubscriptionPlan } from '../hooks/useSubscription';
import { useAuth } from '../hooks/useAuth';
import { toast } from 'sonner';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Badge } from './ui/badge';
import { Separator } from './ui/separator';
import { Alert, AlertDescription } from './ui/alert';
import { Skeleton } from './ui/skeleton';
import { CheckCircle, XCircle, Clock, CreditCard, Shield, Star, Zap, Crown, Sparkles, Loader2 } from 'lucide-react';

// Initialize Stripe (you'll need to add your publishable key to environment variables)
const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || '');

interface ParticlesProps {
  className?: string;
  quantity?: number;
  staticity?: number;
  ease?: number;
  size?: number;
  refresh?: boolean;
  color?: string;
  vx?: number;
  vy?: number;
}

const Particles: React.FC<ParticlesProps> = ({
  className = "",
  quantity = 50,
  staticity = 50,
  ease = 50,
  size = 0.4,
  refresh = false,
  color = "hsl(var(--primary))",
  vx = 0,
  vy = 0,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const context = useRef<CanvasRenderingContext2D | null>(null);
  const circles = useRef<any[]>([]);
  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 });
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio : 1;

  type Circle = {
    x: number;
    y: number;
    translateX: number;
    translateY: number;
    size: number;
    alpha: number;
    targetAlpha: number;
    dx: number;
    dy: number;
    magnetism: number;
  };

  const hexToRgb = (hex: string): number[] => {
    // Handle HSL color values
    if (hex.startsWith('hsl')) {
      // For simplicity, return a default RGB for HSL
      return [139, 92, 246]; // purple equivalent
    }
    hex = hex.replace("#", "");
    const hexInt = parseInt(hex, 16);
    const red = (hexInt >> 16) & 255;
    const green = (hexInt >> 8) & 255;
    const blue = hexInt & 255;
    return [red, green, blue];
  };

  useEffect(() => {
    if (canvasContainerRef.current && canvasRef.current) {
      context.current = canvasRef.current.getContext("2d");
      initCanvas();
      animate();
      window.addEventListener("resize", initCanvas);
      return () => window.removeEventListener("resize", initCanvas);
    }
  }, []);

  const initCanvas = () => {
    resizeCanvas();
    drawParticles();
  };

  const resizeCanvas = () => {
    if (canvasContainerRef.current && canvasRef.current && context.current) {
      circles.current.length = 0;
      canvasSize.current.w = canvasContainerRef.current.offsetWidth;
      canvasSize.current.h = canvasContainerRef.current.offsetHeight;
      canvasRef.current.width = canvasSize.current.w * dpr;
      canvasRef.current.height = canvasSize.current.h * dpr;
      canvasRef.current.style.width = `${canvasSize.current.w}px`;
      canvasRef.current.style.height = `${canvasSize.current.h}px`;
      context.current.scale(dpr, dpr);
    }
  };

  const circleParams = (): Circle => {
    const x = Math.floor(Math.random() * canvasSize.current.w);
    const y = Math.floor(Math.random() * canvasSize.current.h);
    const translateX = 0;
    const translateY = 0;
    const pSize = Math.floor(Math.random() * 2) + size;
    const alpha = 0;
    const targetAlpha = parseFloat((Math.random() * 0.6).toFixed(1));
    const dx = (Math.random() - 0.5) * 0.2;
    const dy = (Math.random() - 0.5) * 0.2;
    const magnetism = 0.1 + Math.random() * 4;
    return {
      x,
      y,
      translateX,
      translateY,
      size: pSize,
      alpha,
      targetAlpha,
      dx,
      dy,
      magnetism,
    };
  };

  const drawCircle = (circle: Circle, update = false) => {
    if (context.current) {
      const { x, y, translateX, translateY, size, alpha } = circle;
      context.current.translate(translateX, translateY);
      context.current.beginPath();
      context.current.arc(x, y, size, 0, 2 * Math.PI);
      context.current.fillStyle = `rgba(${hexToRgb(color).join(", ")}, ${alpha})`;
      context.current.fill();
      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!update) {
        circles.current.push(circle);
      }
    }
  };

  const clearContext = () => {
    if (context.current) {
      context.current.clearRect(0, 0, canvasSize.current.w, canvasSize.current.h);
    }
  };

  const drawParticles = () => {
    clearContext();
    const particleCount = quantity;
    for (let i = 0; i < particleCount; i++) {
      const circle = circleParams();
      drawCircle(circle);
    }
  };

  const animate = () => {
    clearContext();
    circles.current.forEach((circle: Circle, i: number) => {
      // Update the circle position based on mouse position
      const edge = [
        circle.x + circle.translateX - mouse.current.x,
        circle.y + circle.translateY - mouse.current.y,
      ];
      const distance = Math.sqrt(edge[0] * edge[0] + edge[1] * edge[1]);
      const maxDistance = Math.max(canvasSize.current.w, canvasSize.current.h);
      
      if (distance < maxDistance) {
        circle.alpha += (circle.targetAlpha - circle.alpha) * 0.02;
        circle.x += circle.dx;
        circle.y += circle.dy;
        circle.translateX += (edge[0] / distance) * circle.magnetism * -1;
        circle.translateY += (edge[1] / distance) * circle.magnetism * -1;
      } else {
        circle.alpha += (0 - circle.alpha) * 0.02;
        circle.x += circle.dx;
        circle.y += circle.dy;
      }

      if (circle.x < -circle.size || circle.x > canvasSize.current.w + circle.size || 
          circle.y < -circle.size || circle.y > canvasSize.current.h + circle.size) {
        circles.current[i] = circleParams();
      }

      drawCircle(circle, true);
    });
    window.requestAnimationFrame(animate);
  };

  return (
    <div className={className} ref={canvasContainerRef} aria-hidden="true">
      <canvas ref={canvasRef} />
    </div>
  );
};

interface PaymentFormProps {
  selectedPlan: SubscriptionPlan;
  onSuccess: () => void;
  onCancel: () => void;
}

const PaymentForm: React.FC<PaymentFormProps> = ({ selectedPlan, onSuccess, onCancel }) => {
  const stripe = useStripe();
  const elements = useElements();
  const { createSubscription, createSetupIntent } = useSubscription();
  const [isProcessing, setIsProcessing] = useState(false);
  const [clientSecret, setClientSecret] = useState<string | null>(null);

  useEffect(() => {
    // Create setup intent for payment method collection
    const setupPayment = async () => {
      const result = await createSetupIntent();
      if (result.error) {
        toast.error('Payment Setup Failed: ' + result.error);
      } else {
        setClientSecret(result.clientSecret || null);
      }
    };

    setupPayment();
  }, [createSetupIntent]);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    if (!stripe || !elements || !clientSecret) {
      return;
    }

    setIsProcessing(true);

    try {
      const cardElement = elements.getElement(CardElement);
      if (!cardElement) {
        throw new Error('Card element not found');
      }

      // Confirm setup intent
      const { error: setupError, setupIntent } = await stripe.confirmCardSetup(clientSecret, {
        payment_method: {
          card: cardElement,
        },
      });

      if (setupError) {
        throw new Error(setupError.message);
      }

      // Create subscription with the payment method
      const result = await createSubscription(selectedPlan.id, setupIntent.payment_method as string);

      if (!result.success) {
        throw new Error(result.error || 'Failed to create subscription');
      }

      // Handle 3D Secure or other authentication if needed
      if (result.clientSecret) {
        const { error: confirmError } = await stripe.confirmCardPayment(result.clientSecret);
        if (confirmError) {
          throw new Error(confirmError.message);
        }
      }

      toast.success('Subscription Created - Welcome to your new plan!');
      onSuccess();
    } catch (error) {
      console.error('Payment error:', error);
      toast.error('Payment Failed: ' + (error instanceof Error ? error.message : 'Unknown error'));
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <motion.div 
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      className="w-full max-w-md mx-auto"
    >
      <Card className="border-border/50 bg-card/95 backdrop-blur-sm shadow-2xl">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-card-foreground">
            <CreditCard className="h-5 w-5 text-primary" />
            Complete Your Subscription
          </CardTitle>
          <CardDescription>
            {selectedPlan.price === '5.00' ? (
              <>You're getting unlimited AI development assistance for just <span className="font-bold text-primary">${selectedPlan.price}/{selectedPlan.interval}</span> - Amazing value!</>
            ) : (
              <>You're subscribing to {selectedPlan.name} for ${selectedPlan.price}/{selectedPlan.interval}</>
            )}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="p-4 border border-border rounded-lg bg-background/50">
              <CardElement
                options={{
                  style: {
                    base: {
                      fontSize: '16px',
                      color: 'hsl(var(--foreground))',
                      backgroundColor: 'transparent',
                      '::placeholder': {
                        color: 'hsl(var(--muted-foreground))',
                      },
                    },
                  },
                }}
              />
            </div>

            <div className="flex gap-2">
              <Button
                type="submit"
                disabled={!stripe || isProcessing}
                className="flex-1 bg-primary hover:bg-primary/90"
              >
                {isProcessing ? (
                  <>
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    Processing...
                  </>
                ) : selectedPlan.price === '5.00' ? (
                  `Start AI Development for $${selectedPlan.price}/${selectedPlan.interval}`
                ) : (
                  `Subscribe for $${selectedPlan.price}/${selectedPlan.interval}`
                )}
              </Button>
              <Button type="button" variant="outline" onClick={onCancel}>
                Cancel
              </Button>
            </div>

            <div className="text-xs text-muted-foreground text-center">
              <div className="flex items-center justify-center gap-1">
                <Shield className="h-3 w-3" />
                Secured by Stripe
              </div>
            </div>
          </form>
        </CardContent>
      </Card>
    </motion.div>
  );
};

const PlanCard: React.FC<{
  plan: SubscriptionPlan;
  isCurrentPlan?: boolean;
  isPopular?: boolean;
  onSelect: (plan: SubscriptionPlan) => void;
}> = ({ plan, isCurrentPlan, isPopular, onSelect }) => {
  const features = Array.isArray(plan.features) ? plan.features : [];
  const isFreemium = plan.price === '0.00' || plan.price === '0';

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ y: -4 }}
      transition={{ duration: 0.2 }}
    >
      <Card className={`relative transition-all duration-300 hover:shadow-2xl border-border/50 bg-card/95 backdrop-blur-sm ${
        isPopular ? 'ring-2 ring-primary/50 shadow-lg shadow-primary/10' : ''
      } ${
        isCurrentPlan ? 'bg-primary/5 border-primary/20' : ''
      }`}>
        {isPopular && (
          <motion.div 
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            className="absolute -top-3 left-1/2 transform -translate-x-1/2"
          >
            <Badge className="bg-primary text-primary-foreground shadow-lg">
              <Crown className="h-3 w-3 mr-1" />
              {plan.price === '5.00' ? 'Best Value' : 'Most Popular'}
            </Badge>
          </motion.div>
        )}

        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="text-xl text-card-foreground">{plan.name}</CardTitle>
            {isCurrentPlan && (
              <Badge variant="secondary" className="bg-primary/10 text-primary border-primary/20">
                Current Plan
              </Badge>
            )}
          </div>
          <CardDescription className="text-muted-foreground">{plan.description}</CardDescription>
          <div className="mt-4">
            <div className="flex items-baseline">
              <span className="text-3xl font-bold text-foreground">
                {isFreemium ? 'Freemium' : `$${plan.price}`}
              </span>
              {!isFreemium && (
                <span className="text-muted-foreground ml-1">/{plan.interval}</span>
              )}
            </div>
          </div>
        </CardHeader>

        <CardContent>
          <ul className="space-y-3 mb-6">
            {features.map((feature, index) => (
              <motion.li 
                key={index} 
                initial={{ opacity: 0, x: -10 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.1 }}
                className="flex items-start gap-2"
              >
                <CheckCircle className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
                <span className="text-sm text-card-foreground">{feature}</span>
              </motion.li>
            ))}
          </ul>

          <Button
            onClick={() => onSelect(plan)}
            disabled={isCurrentPlan}
            className={`w-full ${
              isCurrentPlan 
                ? "bg-secondary text-secondary-foreground" 
                : "bg-primary hover:bg-primary/90 text-primary-foreground"
            }`}
            variant={isCurrentPlan ? "secondary" : "default"}
          >
            {isCurrentPlan ? 'Current Plan' : isFreemium ? 'Get Started' : 'Subscribe'}
            {!isCurrentPlan && !isFreemium && <Sparkles className="h-4 w-4 ml-2" />}
          </Button>
        </CardContent>
      </Card>
    </motion.div>
  );
};

const SubscriptionStatus: React.FC = () => {
  const { 
    subscription, 
    hasActiveSubscription, 
    isTrialing, 
    isPastDue, 
    needsPaymentUpdate,
    cancelSubscription,
    reactivateSubscription,
    openBillingPortal 
  } = useSubscription();
  const [isLoading, setIsLoading] = useState(false);

  if (!subscription) return null;

  const handleCancelSubscription = async () => {
    if (!confirm('Are you sure you want to cancel your subscription? You will lose access to premium features at the end of your billing period.')) {
      return;
    }

    setIsLoading(true);
    const result = await cancelSubscription();
    setIsLoading(false);

    if (result.success) {
      toast.success('Subscription Canceled - Your subscription will end at the current billing period.');
    } else {
      toast.error('Cancel Failed: ' + (result.error || 'Failed to cancel subscription'));
    }
  };

  const handleReactivateSubscription = async () => {
    setIsLoading(true);
    const result = await reactivateSubscription();
    setIsLoading(false);

    if (result.success) {
      toast.success('Subscription Reactivated - Your subscription is now active again.');
    } else {
      toast.error('Reactivation Failed: ' + (result.error || 'Failed to reactivate subscription'));
    }
  };

  const handleOpenBillingPortal = async () => {
    const result = await openBillingPortal();
    if (!result.success) {
      toast.error('Billing Portal Error: ' + (result.error || 'Failed to open billing portal'));
    }
  };

  const getStatusIcon = () => {
    if (isPastDue) return <XCircle className="h-5 w-5 text-destructive" />;
    if (isTrialing) return <Clock className="h-5 w-5 text-yellow-500" />;
    if (hasActiveSubscription) return <CheckCircle className="h-5 w-5 text-primary" />;
    return <XCircle className="h-5 w-5 text-muted-foreground" />;
  };

  const getStatusText = () => {
    if (isPastDue) return 'Payment Required';
    if (isTrialing) return 'Trial Active';
    if (hasActiveSubscription) return 'Active';
    return 'Inactive';
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <Card className="border-border/50 bg-card/95 backdrop-blur-sm">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-card-foreground">
            {getStatusIcon()}
            Subscription Status
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <p className="font-medium text-foreground">{subscription.tier}</p>
              <p className="text-sm text-muted-foreground">{getStatusText()}</p>
            </div>
            <Badge variant={hasActiveSubscription ? "default" : "secondary"} 
                   className={hasActiveSubscription ? "bg-primary text-primary-foreground" : ""}>
              {subscription.status}
            </Badge>
          </div>

          {subscription.endsAt && (
            <div>
              <p className="text-sm text-muted-foreground">
                {subscription.status === 'canceled' ? 'Ends' : 'Renews'} on{' '}
                {new Date(subscription.endsAt).toLocaleDateString()}
              </p>
            </div>
          )}

          {needsPaymentUpdate && (
            <Alert className="border-destructive/50 bg-destructive/10">
              <XCircle className="h-4 w-4 text-destructive" />
              <AlertDescription className="text-destructive">
                Your payment method needs to be updated. Please update your payment information to continue your subscription.
              </AlertDescription>
            </Alert>
          )}

          <Separator className="bg-border" />

          <div className="flex gap-2">
            <Button onClick={handleOpenBillingPortal} variant="outline" size="sm" 
                    className="border-border hover:bg-accent">
              <CreditCard className="h-4 w-4 mr-2" />
              Manage Billing
            </Button>

            {hasActiveSubscription && subscription.status !== 'canceled' && (
              <Button
                onClick={handleCancelSubscription}
                variant="outline"
                size="sm"
                disabled={isLoading}
                className="border-border hover:bg-accent"
              >
                Cancel Subscription
              </Button>
            )}

            {subscription.status === 'canceled' && (
              <Button
                onClick={handleReactivateSubscription}
                size="sm"
                disabled={isLoading}
                className="bg-primary hover:bg-primary/90"
              >
                Reactivate
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    </motion.div>
  );
};

export const SubscriptionPage: React.FC = () => {
  const { user } = useAuth();
  const { subscription, plans, isLoading, hasActiveSubscription } = useSubscription();
  const [selectedPlan, setSelectedPlan] = useState<SubscriptionPlan | null>(null);
  const [view, setView] = useState<'plans' | 'payment'>('plans');

  const handlePlanSelect = (plan: SubscriptionPlan) => {
    // For free plans, handle immediately
    if (plan.price === '0.00' || plan.price === '0') {
      // TODO: Implement free plan activation
      return;
    }

    setSelectedPlan(plan);
    setView('payment');
  };

  const handlePaymentSuccess = () => {
    setView('plans');
    setSelectedPlan(null);
  };

  const handlePaymentCancel = () => {
    setView('plans');
    setSelectedPlan(null);
  };

  if (!user) {
    return (
      <div className="min-h-screen bg-background relative overflow-hidden flex items-center justify-center">
        <Particles className="absolute inset-0 pointer-events-none" quantity={30} />
        <Card className="border-border/50 bg-card/95 backdrop-blur-sm">
          <CardContent className="p-6">
            <p className="text-card-foreground">Please log in to manage your subscription.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (view === 'payment' && selectedPlan) {
    return (
      <div className="min-h-screen bg-background relative overflow-hidden py-12">
        <Particles className="absolute inset-0 pointer-events-none" quantity={30} />
        <div className="max-w-4xl mx-auto px-4 relative z-10">
          <Elements stripe={stripePromise}>
            <PaymentForm
              selectedPlan={selectedPlan}
              onSuccess={handlePaymentSuccess}
              onCancel={handlePaymentCancel}
            />
          </Elements>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background relative overflow-hidden py-12">
      <Particles className="absolute inset-0 pointer-events-none" quantity={50} />
      
      <div className="max-w-6xl mx-auto px-4 relative z-10">
        <motion.div 
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-12"
        >
          <h1 className="text-4xl font-bold text-foreground mb-4">
            Start your journey with Uterpi for <span className="text-violet-600">free</span>
          </h1>
          <p className="text-xl text-muted-foreground mb-2">
            Unlock the full power of AI with Uterpi
          </p>
          <p className="text-lg text-violet-600 font-medium">
            üöÄ Uterpi is free to get started with 10 messages per month
          </p>
        </motion.div>

        <AnimatePresence>
          {hasActiveSubscription && (
            <motion.div 
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              className="mb-8"
            >
              <SubscriptionStatus />
            </motion.div>
          )}
        </AnimatePresence>

        {isLoading ? (
          <div className="grid md:grid-cols-3 gap-8">
            {[1, 2, 3].map((i) => (
              <Card key={i} className="border-border/50 bg-card/95 backdrop-blur-sm">
                <CardHeader>
                  <Skeleton className="h-6 w-32 bg-muted" />
                  <Skeleton className="h-4 w-48 bg-muted" />
                  <Skeleton className="h-8 w-24 bg-muted" />
                </CardHeader>
                <CardContent>
                  <div className="space-y-2">
                    {[1, 2, 3, 4].map((j) => (
                      <Skeleton key={j} className="h-4 w-full bg-muted" />
                    ))}
                  </div>
                  <Skeleton className="h-10 w-full mt-6 bg-muted" />
                </CardContent>
              </Card>
            ))}
          </div>
        ) : (
          <motion.div 
            className="grid md:grid-cols-3 gap-8"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ staggerChildren: 0.1 }}
          >
            {plans.map((plan, index) => (
              <PlanCard
                key={plan.id}
                plan={plan}
                isCurrentPlan={subscription?.plan?.id === plan.id}
                isPopular={plan.price === '5.00'} // Make $5 plan popular
                onSelect={handlePlanSelect}
              />
            ))}
          </motion.div>
        )}

        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5 }}
          className="mt-12 text-center"
        >
          <div className="mb-6 p-6 bg-gradient-to-r from-violet-500/10 to-purple-600/10 rounded-2xl border border-violet-500/20">
            <h3 className="text-xl font-bold text-foreground mb-2">
              üí° Why choose Uterpi Pro?
            </h3>
            <p className="text-muted-foreground mb-4">
              At just $19 per month, you get access to advanced AI within the Uterpi platform.
            </p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
              <div className="flex items-center gap-2">
                <Star className="h-4 w-4 text-yellow-500" />
                <span>Unlimited* AI usage</span>
              </div>
              <div className="flex items-center gap-2">
                <Zap className="h-4 w-4 text-violet-500" />
                <span>Upload files for in-depth AI analysis</span>
              </div>
              <div className="flex items-center gap-2">
                <Crown className="h-4 w-4 text-purple-500" />
                <span>Access to cutting-edge AI models</span>
              </div>
            </div>
          </div>
          
          <div className="flex items-center justify-center gap-6 text-sm text-muted-foreground">
            <motion.div 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1"
            >
              <Shield className="h-4 w-4" />
              SSL Secured
            </motion.div>
            <motion.div 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1"
            >
              <Zap className="h-4 w-4" />
              Instant Activation
            </motion.div>
            <motion.div 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1"
            >
              <CheckCircle className="h-4 w-4" />
              Cancel Anytime
            </motion.div>
          </div>
        </motion.div>
      </div>
    </div>
  );
};

================
File: client/src/components/SystemMessageDemo.tsx
================
import React, { useState } from "react";
import { useAzureAI, SYSTEM_MESSAGE_PRESETS } from "../hooks/useAzureAI";
import { useAuth } from "../hooks/useAuth";
import { SystemMessageSelector } from "./SystemMessageSelector";
import { Button } from "./ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card";
import { Textarea } from "./ui/textarea";
import { Badge } from "./ui/badge";

interface Message {
  id: string;
  content: string;
  role: "user" | "assistant";
  timestamp: Date;
}

export const SystemMessageDemo: React.FC = () => {
  const { user } = useAuth();
  const [selectedPreset, setSelectedPreset] = useState<keyof typeof SYSTEM_MESSAGE_PRESETS | "custom">("DEFAULT");
  const [customSystemMessage, setCustomSystemMessage] = useState<string>("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");

  // Get the current system message based on selection
  const getCurrentSystemMessage = () => {
    if (selectedPreset === "custom") {
      return customSystemMessage || SYSTEM_MESSAGE_PRESETS.DEFAULT;
    }
    return SYSTEM_MESSAGE_PRESETS[selectedPreset];
  };

  const {
    sendMessage,
    isLoading,
    error,
    clearError,
    currentModel
  } = useAzureAI({
    systemMessage: getCurrentSystemMessage(),
    chatOptions: {
      maxTokens: 1024,
      temperature: 0.7
    },
    userContext: { user }
  });

  const handlePresetChange = (preset: keyof typeof SYSTEM_MESSAGE_PRESETS | "custom", message?: string) => {
    setSelectedPreset(preset);
    if (preset === "custom" && message !== undefined) {
      setCustomSystemMessage(message);
    }
    // Clear messages when changing system message to see the difference
    setMessages([]);
    clearError();
  };

  const handleSendMessage = async () => {
    if (!input.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      content: input,
      role: "user",
      timestamp: new Date()
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput("");

    try {
      const response = await sendMessage(newMessages);
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: response,
        role: "assistant",
        timestamp: new Date()
      };
      setMessages([...newMessages, assistantMessage]);
    } catch (err) {
      console.error("Failed to send message:", err);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6 space-y-6">
      <div className="text-center">
        <h1 className="text-3xl font-bold mb-2">System Message Configuration Demo</h1>
        <p className="text-muted-foreground">
          See how different system messages change the AI's personality and response style
        </p>
      </div>

      <SystemMessageSelector
        selectedPreset={selectedPreset}
        customMessage={customSystemMessage}
        onPresetChange={handlePresetChange}
      />

      {selectedPreset === "custom" && (
        <Card>
          <CardHeader>
            <CardTitle>Custom System Message</CardTitle>
            <CardDescription>
              Define your own system message to control the AI's behavior
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Textarea
              placeholder="Enter your custom system message..."
              value={customSystemMessage}
              onChange={(e) => setCustomSystemMessage(e.target.value)}
              className="min-h-[100px]"
            />
          </CardContent>
        </Card>
      )}

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            Chat Demo
            <div className="flex items-center gap-2">
              {currentModel && (
                <Badge variant="secondary">{currentModel}</Badge>
              )}
              {isLoading && (
                <Badge variant="outline">Processing...</Badge>
              )}
            </div>
          </CardTitle>
          <CardDescription>
            Try asking the same question with different system message presets to see the difference
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-md">
              <p className="text-sm text-destructive">{error}</p>
            </div>
          )}

          <div className="space-y-3 max-h-96 overflow-y-auto">
            {messages.map((message) => (
              <div
                key={message.id}
                className={`p-3 rounded-md ${
                  message.role === "user"
                    ? "bg-primary text-primary-foreground ml-12"
                    : "bg-muted mr-12"
                }`}
              >
                <div className="flex items-center gap-2 mb-1">
                  <Badge variant={message.role === "user" ? "default" : "secondary"}>
                    {message.role === "user" ? "You" : "Assistant"}
                  </Badge>
                  <span className="text-xs text-muted-foreground">
                    {message.timestamp.toLocaleTimeString()}
                  </span>
                </div>
                <p className="text-sm whitespace-pre-wrap">{message.content}</p>
              </div>
            ))}
          </div>

          <div className="flex gap-2">
            <Textarea
              placeholder="Try asking: 'Explain quantum computing' or 'Write a story about a robot'"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage();
                }
              }}
              className="flex-1 min-h-[60px]"
            />
            <Button 
              onClick={handleSendMessage} 
              disabled={isLoading || !input.trim()}
              className="self-end"
            >
              Send
            </Button>
          </div>

          <div className="text-xs text-muted-foreground">
            <p><strong>Try these examples:</strong></p>
            <ul className="list-disc list-inside mt-1 space-y-1">
              <li>"Explain quantum computing" - Compare technical vs. casual responses</li>
              <li>"Write a story about a robot" - See creative vs. professional styles</li>
              <li>"How do I write a business proposal?" - Professional vs. casual guidance</li>
            </ul>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

================
File: client/src/components/SystemMessageSelector.tsx
================
import React from "react";
import { SYSTEM_MESSAGE_PRESETS } from "../hooks/useAzureAI";
import { Button } from "./ui/button";
import { Badge } from "./ui/badge";

interface SystemMessageSelectorProps {
  selectedPreset: keyof typeof SYSTEM_MESSAGE_PRESETS | "custom";
  customMessage?: string;
  onPresetChange: (preset: keyof typeof SYSTEM_MESSAGE_PRESETS | "custom", message?: string) => void;
}

const PRESET_DESCRIPTIONS = {
  DEFAULT: "General purpose assistant with balanced responses",
  PROFESSIONAL: "Formal business communication style",
  CREATIVE: "Engaging creative writing and storytelling", 
  TECHNICAL: "Precise technical documentation and code",
  CASUAL: "Friendly, conversational, and approachable",
  SOCRATIC_TUTOR: "Guides learning through questions rather than answers",
  DEVILS_ADVOCATE: "Challenges ideas to strengthen arguments",
  HISTORIAN: "Rich narrative storytelling about historical events",
  MINDFULNESS_COACH: "Gentle wellness and grounding techniques",
  ROMANTIC_POET: "Crafts beautiful romantic poetry and prose", 
  CHARMING_FLIRT: "Playful, witty, and respectful banter",
  DATE_NIGHT_PLANNER: "Creative and personalized romantic experiences"
} as const;

const PRESET_CATEGORIES = {
  "Core Personalities": ["DEFAULT", "PROFESSIONAL", "CREATIVE", "TECHNICAL", "CASUAL"],
  "Learning & Growth": ["SOCRATIC_TUTOR", "DEVILS_ADVOCATE", "HISTORIAN"],
  "Wellness & Support": ["MINDFULNESS_COACH"],
  "Romance & Relationships": ["ROMANTIC_POET", "CHARMING_FLIRT", "DATE_NIGHT_PLANNER"]
} as const;

export const SystemMessageSelector: React.FC<SystemMessageSelectorProps> = ({
  selectedPreset,
  customMessage,
  onPresetChange
}) => {
  return (
    <div className="w-full space-y-4">
      <div className="text-center space-y-2">
        <div className="flex items-center justify-center gap-2">
          <h3 className="text-lg font-semibold text-white">Make Uterpi your own</h3>
        </div>
        <p className="text-sm text-slate-300">
          Choose how Uterpi's AI should respond and communicate with you
        </p>
      </div>

      <div className="space-y-6">
        {Object.entries(PRESET_CATEGORIES).map(([categoryName, presets]) => (
          <div key={categoryName} className="space-y-3">
            <h4 className="text-sm font-medium text-slate-200 uppercase tracking-wide border-b border-slate-600 pb-1">
              {categoryName}
            </h4>
            <div className="grid grid-cols-1 gap-2">
              {presets.map((preset) => (
                <Button
                  key={preset}
                  variant={selectedPreset === preset ? "default" : "outline"}
                  size="sm"
                  onClick={() => onPresetChange(preset)}
                  className="h-auto p-3 text-left justify-start bg-slate-800/50 hover:bg-slate-700/50 border-slate-600"
                >
                  <div className="w-full">
                    <div className="font-medium text-sm uppercase tracking-wide mb-1 text-white">
                      {preset.replace(/_/g, ' ')}
                    </div>
                    <div className="text-xs text-slate-300 leading-relaxed break-words">
                      {PRESET_DESCRIPTIONS[preset as keyof typeof PRESET_DESCRIPTIONS]}
                    </div>
                  </div>
                </Button>
              ))}
            </div>
          </div>
        ))}
        
        <div className="pt-3 border-t border-slate-600">
          <Button
            variant={selectedPreset === "custom" ? "default" : "outline"}
            size="sm"
            onClick={() => onPresetChange("custom", customMessage)}
            className="w-full bg-slate-800/50 hover:bg-slate-700/50 border-slate-600"
          >
            <span className="font-medium">Custom System Message</span>
          </Button>
        </div>

        {selectedPreset !== "custom" && (
          <div className="mt-4 p-4 bg-slate-800/30 backdrop-blur-sm rounded-lg border border-slate-600/50">
            <p className="text-sm font-medium mb-3 text-white">Current System Message:</p>
            <div className="bg-slate-900/50 rounded-md p-3 border border-slate-700/50">
              <p className="text-xs text-slate-300 whitespace-pre-line leading-relaxed break-words">
                {SYSTEM_MESSAGE_PRESETS[selectedPreset as keyof typeof SYSTEM_MESSAGE_PRESETS]}
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

================
File: client/src/components/ui/accordion.tsx
================
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: client/src/components/ui/alert-dialog.tsx
================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: client/src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

================
File: client/src/components/ui/aspect-ratio.tsx
================
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

================
File: client/src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: client/src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground border-border/50 hover:bg-accent/50",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: client/src/components/ui/breadcrumb.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

================
File: client/src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90 transition-all duration-200",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90 transition-all duration-200",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground transition-all duration-200",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80 transition-all duration-200",
        ghost: "hover:bg-accent hover:text-accent-foreground transition-all duration-200",
        link: "text-primary underline-offset-4 hover:underline transition-all duration-200",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: client/src/components/ui/calendar.tsx
================
import * as React from "react"
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react"
import { DayButton, DayPicker, getDefaultClassNames } from "react-day-picker"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "dropdown",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date: Date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "relative flex flex-col gap-4 md:flex-row",
          defaultClassNames.months
        ),
        month: cn("flex w-full flex-col gap-4", defaultClassNames.month),
        nav: cn(
          "absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1",
          defaultClassNames.nav
        ),
        nav_button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.nav_button_previous
        ),
        nav_button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.nav_button_next
        ),
        caption: cn(
          "flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]",
          defaultClassNames.caption
        ),
        dropdown: cn(
          "flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium",
          defaultClassNames.dropdown
        ),
        dropdown_month: cn(
          "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border",
          defaultClassNames.dropdown_month
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal",
          defaultClassNames.weekday
        ),
        week: cn("mt-2 flex w-full", defaultClassNames.week),
        week_number_header: cn(
          "w-[--cell-size] select-none",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-muted-foreground select-none text-[0.8rem]",
          defaultClassNames.week_number
        ),
        day: cn(
          "group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md",
          defaultClassNames.day
        ),
        range_start: cn(
          "bg-accent rounded-l-md",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("bg-accent rounded-r-md", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }

================
File: client/src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: client/src/components/ui/carousel.tsx
================
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

================
File: client/src/components/ui/chart.tsx
================
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

================
File: client/src/components/ui/checkbox.tsx
================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

================
File: client/src/components/ui/collapsible.tsx
================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

================
File: client/src/components/ui/command.tsx
================
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

================
File: client/src/components/ui/context-menu.tsx
================
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-4 w-4 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

================
File: client/src/components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: client/src/components/ui/drawer.tsx
================
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: client/src/components/ui/dropdown-menu.tsx
================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: client/src/components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: client/src/components/ui/hover-card.tsx
================
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

================
File: client/src/components/ui/input-otp.tsx
================
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Minus } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-1 ring-ring",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Minus />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

================
File: client/src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: client/src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: client/src/components/ui/menubar.tsx
================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-4 w-4 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

================
File: client/src/components/ui/navigation-menu.tsx
================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

================
File: client/src/components/ui/pagination.tsx
================
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}

================
File: client/src/components/ui/popover.tsx
================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

================
File: client/src/components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-primary/20",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: client/src/components/ui/radio-group.tsx
================
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-3.5 w-3.5 fill-primary" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

================
File: client/src/components/ui/resizable.tsx
================
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

================
File: client/src/components/ui/scroll-area.tsx
================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: client/src/components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: client/src/components/ui/separator.tsx
================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: client/src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: client/src/components/ui/sidebar.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        if (onClick && typeof onClick === 'function') {
          onClick(event)
        }
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>{button}</TooltipTrigger>
          <TooltipContent
            side="right"
            align="center"
            hidden={state !== "collapsed" || isMobile}
            {...tooltip}
          />
        </Tooltip>
      </TooltipProvider>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: client/src/components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: client/src/components/ui/slider.tsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

================
File: client/src/components/ui/sonner.tsx
================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme="dark"
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-slate-900/95 group-[.toaster]:text-white group-[.toaster]:border-slate-700/50 group-[.toaster]:shadow-2xl group-[.toaster]:backdrop-blur-xl",
          description: "group-[.toast]:text-slate-300",
          actionButton:
            "group-[.toast]:bg-violet-600 group-[.toast]:text-white group-[.toast]:hover:bg-violet-700 group-[.toast]:border-0",
          cancelButton:
            "group-[.toast]:bg-slate-700 group-[.toast]:text-slate-200 group-[.toast]:hover:bg-slate-600",
          title: "group-[.toast]:text-white group-[.toast]:font-medium",
          icon: "group-[.toast]:text-violet-400",
        },
        style: {
          background: 'rgba(15, 23, 42, 0.95)',
          border: '1px solid rgba(100, 116, 139, 0.3)',
          color: '#ffffff',
        }
      }}
      position="top-right"
      richColors={false}
      {...props}
    />
  )
}

export { Toaster }

================
File: client/src/components/ui/switch.tsx
================
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: client/src/components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: client/src/components/ui/tabs.tsx
================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: client/src/components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: client/src/components/ui/toggle-group.tsx
================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

================
File: client/src/components/ui/toggle.tsx
================
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

================
File: client/src/components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: client/src/components/UnsubscribePage.tsx
================
import React, { useState, useEffect } from 'react';
import { Button } from './ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { RadioGroup, RadioGroupItem } from './ui/radio-group';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';
import { Alert, AlertDescription } from './ui/alert';
import { Separator } from './ui/separator';
import { Mail, CheckCircle, Settings, ArrowRight, Heart } from 'lucide-react';

export function UnsubscribePage() {
  const [loading, setLoading] = useState(false);
  const [completed, setCompleted] = useState(false);
  const [error, setError] = useState('');
  const [step, setStep] = useState<'confirm' | 'feedback' | 'complete'>('confirm');
  const [selectedReason, setSelectedReason] = useState('');
  const [customReason, setCustomReason] = useState('');
  const [token, setToken] = useState<string | null>(null);

  // Get token from URL parameters
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const urlToken = params.get('token');
    setToken(urlToken);
  }, []);

  const unsubscribeReasons = [
    { value: 'too_frequent', label: 'Emails are too frequent' },
    { value: 'not_relevant', label: 'Content is not relevant to me' },
    { value: 'too_many_emails', label: 'I receive too many emails in general' },
    { value: 'no_longer_interested', label: 'No longer interested in Uterpi' },
    { value: 'never_signed_up', label: 'I never signed up for these emails' },
    { value: 'spam', label: 'These emails feel like spam' },
    { value: 'other', label: 'Other reason' },
  ];

  useEffect(() => {
    if (!token) {
      setError('No unsubscribe token provided. Please use the link from your email.');
    }
  }, [token]);

  const handleUnsubscribe = async () => {
    if (!token) return;

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/engagement/unsubscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          token,
          reason: selectedReason === 'other' ? customReason : selectedReason,
        }),
      });

      const data = await response.json();

      if (data.success) {
        setStep('complete');
        setCompleted(true);
      } else {
        setError(data.error || 'Failed to unsubscribe. Please try again.');
      }
    } catch (error) {
      console.error('Unsubscribe error:', error);
      setError('Failed to unsubscribe. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleConfirmUnsubscribe = () => {
    setStep('feedback');
  };

  const handleSubmitFeedback = () => {
    handleUnsubscribe();
  };

  const handleSkipFeedback = () => {
    handleUnsubscribe();
  };

  if (!token) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-red-600">
              <Mail className="w-5 h-5" />
              Invalid Link
            </CardTitle>
            <CardDescription>
              This unsubscribe link is invalid or expired.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-gray-600">
              Please use the unsubscribe link from your email, or contact support if you continue to have issues.
            </p>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (completed) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-green-600">
              <CheckCircle className="w-5 h-5" />
              Successfully Unsubscribed
            </CardTitle>
            <CardDescription>
              You've been unsubscribed from Uterpi emails.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-gray-600">
              We're sorry to see you go! You will no longer receive marketing emails from Uterpi.
            </p>
            
            <Alert>
              <AlertDescription>
                You may still receive important account-related emails like password resets and security notifications.
              </AlertDescription>
            </Alert>

            <Separator />

            <div className="space-y-3">
              <p className="text-sm font-medium text-gray-800">
                Changed your mind?
              </p>
              <div className="flex flex-col gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={() => window.location.href = '/'}
                  className="justify-start"
                >
                  <ArrowRight className="w-4 h-4 mr-2" />
                  Return to Uterpi
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={() => window.location.href = '/profile'}
                  className="justify-start text-blue-600 hover:text-blue-700"
                >
                  <Settings className="w-4 h-4 mr-2" />
                  Manage Email Preferences Instead
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <Card className="w-full max-w-lg">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Mail className="w-5 h-5 text-blue-600" />
            Unsubscribe from Uterpi Emails
          </CardTitle>
          <CardDescription>
            We're sorry to see you go! Let us know how we can improve.
          </CardDescription>
        </CardHeader>
        
        <CardContent className="space-y-6">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {step === 'confirm' && (
            <div className="space-y-4">
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h3 className="font-medium text-blue-900 mb-2">
                  Before you unsubscribe...
                </h3>
                <p className="text-sm text-blue-800 mb-3">
                  Did you know you can customize which emails you receive instead of unsubscribing completely?
                </p>
                <Button 
                  variant="outline"
                  size="sm"
                  onClick={() => window.location.href = '/profile'}
                  className="border-blue-300 text-blue-700 hover:bg-blue-100"
                >
                  <Settings className="w-4 h-4 mr-2" />
                  Manage Email Preferences
                </Button>
              </div>

              <Separator />

              <div className="text-center space-y-4">
                <p className="text-sm text-gray-600">
                  If you still want to unsubscribe from all emails, we understand.
                </p>
                <div className="flex gap-3 justify-center">
                  <Button
                    variant="outline"
                    onClick={() => window.history.back()}
                  >
                    Cancel
                  </Button>
                  <Button
                    onClick={handleConfirmUnsubscribe}
                    variant="destructive"
                  >
                    Continue to Unsubscribe
                  </Button>
                </div>
              </div>
            </div>
          )}

          {step === 'feedback' && (
            <div className="space-y-4">
              <div>
                <h3 className="font-medium text-gray-900 mb-3">
                  Help us improve (optional)
                </h3>
                <p className="text-sm text-gray-600 mb-4">
                  Your feedback helps us create better email experiences for other users.
                </p>
                
                <RadioGroup value={selectedReason} onValueChange={setSelectedReason}>
                  {unsubscribeReasons.map((reason) => (
                    <div key={reason.value} className="flex items-center space-x-2">
                      <RadioGroupItem value={reason.value} id={reason.value} />
                      <Label 
                        htmlFor={reason.value} 
                        className="text-sm cursor-pointer"
                      >
                        {reason.label}
                      </Label>
                    </div>
                  ))}
                </RadioGroup>

                {selectedReason === 'other' && (
                  <div className="mt-3">
                    <Label htmlFor="custom-reason" className="text-sm">
                      Please tell us more:
                    </Label>
                    <Textarea
                      id="custom-reason"
                      value={customReason}
                      onChange={(e) => setCustomReason(e.target.value)}
                      placeholder="Your feedback helps us improve..."
                      className="mt-1"
                      rows={3}
                    />
                  </div>
                )}
              </div>

              <Separator />

              <div className="flex gap-3 justify-center">
                <Button
                  variant="ghost"
                  onClick={handleSkipFeedback}
                  disabled={loading}
                >
                  Skip & Unsubscribe
                </Button>
                <Button
                  onClick={handleSubmitFeedback}
                  disabled={loading || (selectedReason === 'other' && !customReason.trim())}
                  className="bg-red-600 hover:bg-red-700"
                >
                  {loading ? 'Unsubscribing...' : 'Submit & Unsubscribe'}
                </Button>
              </div>
            </div>
          )}

          <div className="text-center pt-4 border-t">
            <p className="text-xs text-gray-500 flex items-center justify-center gap-1">
              Made with <Heart className="w-3 h-3 text-red-500" /> by the Uterpi team
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: client/src/components/UserProfile.tsx
================
import React, { useState, useEffect } from 'react';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';
import { Avatar, AvatarFallback, AvatarImage } from './ui/avatar';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';
import { User, Mail } from 'lucide-react';
import { useAuth, type UpdateProfileData } from '../hooks/useAuth';
import { toast } from 'sonner';
import { EmailPreferences } from './EmailPreferences';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from './ui/alert-dialog';
import { ExclamationTriangleIcon } from '@radix-ui/react-icons';

export const UserProfile: React.FC = () => {
  const { user, updateProfile, logout } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [formData, setFormData] = useState<UpdateProfileData>({
    firstName: '',
    lastName: '',
    username: '',
    age: undefined,
    dateOfBirth: '',
    bio: '',
  });

  useEffect(() => {
    if (user) {
      setFormData({
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        username: user.username || '',
        age: user.age || undefined,
        dateOfBirth: user.dateOfBirth || '',
        bio: user.bio || '',
      });
    }
  }, [user]);

  const handleInputChange = (field: keyof UpdateProfileData, value: string | number | undefined) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleDeleteAccount = async () => {
    if (!user) return;
    setIsDeleting(true);
    try {
      const response = await fetch('/api/account', {
        method: 'DELETE',
        credentials: 'include',
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete account');
      }
      toast.success('Your account has been deleted. This cannot be undone.');
      await logout();
      window.location.href = '/';
    } catch (error: any) {
      console.error('Delete account error:', error);
      toast.error(error?.message || 'Failed to delete account');
    } finally {
      setIsDeleting(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      // Only send fields that have values
      const dataToUpdate: UpdateProfileData = {};
      
      if (formData.firstName?.trim()) dataToUpdate.firstName = formData.firstName.trim();
      if (formData.lastName?.trim()) dataToUpdate.lastName = formData.lastName.trim();
      if (formData.username?.trim()) dataToUpdate.username = formData.username.trim();
      if (formData.age && formData.age > 0) dataToUpdate.age = formData.age;
      if (formData.dateOfBirth?.trim()) dataToUpdate.dateOfBirth = formData.dateOfBirth.trim();
      if (formData.bio?.trim()) dataToUpdate.bio = formData.bio.trim();

      await updateProfile(dataToUpdate);
      toast.success('Profile updated successfully!');
    } catch (error) {
      console.error('Profile update error:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to update profile');
    } finally {
      setIsLoading(false);
    }
  };

  if (!user) {
    return null;
  }

  const displayName = user.firstName && user.lastName 
    ? `${user.firstName} ${user.lastName}`
    : user.username || user.email;

  const initials = user.firstName && user.lastName
    ? `${user.firstName[0]}${user.lastName[0]}`
    : user.username
    ? user.username[0].toUpperCase()
    : user.email[0].toUpperCase();

  return (
    <Card className="w-full max-w-4xl mx-auto">
      <CardHeader className="text-center">
        <div className="flex justify-center mb-4">
          <Avatar className="h-20 w-20">
            <AvatarImage src={user.avatar || undefined} alt={displayName} />
            <AvatarFallback className="text-2xl">{initials}</AvatarFallback>
          </Avatar>
        </div>
        <CardTitle>Account Settings</CardTitle>
        <CardDescription>
          Manage your personal information and email preferences
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="profile" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="profile" className="flex items-center gap-2">
              <User className="w-4 h-4" />
              Profile
            </TabsTrigger>
            <TabsTrigger value="email" className="flex items-center gap-2">
              <Mail className="w-4 h-4" />
              Email Preferences
            </TabsTrigger>
          </TabsList>

          <TabsContent value="profile" className="space-y-6 mt-6">
            <form onSubmit={handleSubmit} className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="firstName">First Name</Label>
              <Input
                id="firstName"
                type="text"
                value={formData.firstName}
                onChange={(e) => handleInputChange('firstName', e.target.value)}
                placeholder="Enter your first name"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="lastName">Last Name</Label>
              <Input
                id="lastName"
                type="text"
                value={formData.lastName}
                onChange={(e) => handleInputChange('lastName', e.target.value)}
                placeholder="Enter your last name"
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="username">Username</Label>
            <Input
              id="username"
              type="text"
              value={formData.username}
              onChange={(e) => handleInputChange('username', e.target.value)}
              placeholder="Choose a username"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={user.email}
              disabled
              className="bg-muted"
            />
            <p className="text-sm text-muted-foreground">
              Email cannot be changed
            </p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="age">Age</Label>
              <Input
                id="age"
                type="number"
                min="13"
                max="120"
                value={formData.age || ''}
                onChange={(e) => {
                  const value = e.target.value;
                  handleInputChange('age', value ? parseInt(value) : undefined);
                }}
                placeholder="Enter your age"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="dateOfBirth">Date of Birth</Label>
              <Input
                id="dateOfBirth"
                type="date"
                value={formData.dateOfBirth}
                onChange={(e) => handleInputChange('dateOfBirth', e.target.value)}
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="bio">Bio</Label>
            <Textarea
              id="bio"
              value={formData.bio}
              onChange={(e) => handleInputChange('bio', e.target.value)}
              placeholder="Tell us about yourself..."
              className="min-h-[100px]"
              maxLength={500}
            />
            <p className="text-sm text-muted-foreground">
              {formData.bio?.length || 0}/500 characters
            </p>
          </div>

              <div className="flex justify-end space-x-2">
                <Button type="submit" disabled={isLoading}>
                  {isLoading ? 'Saving...' : 'Save Changes'}
                </Button>
              </div>
            </form>

            {/* Danger Zone */}
            <div className="mt-10 border rounded-lg p-4 bg-red-50 dark:bg-red-950/20">
              <div className="flex items-start justify-between">
                <div>
                  <p className="font-semibold text-red-700 dark:text-red-400 flex items-center gap-2">
                    <ExclamationTriangleIcon className="h-4 w-4" /> Danger Zone
                  </p>
                  <p className="text-sm text-muted-foreground mt-1">
                    Permanently delete your account and all associated data. <strong>This cannot be undone.</strong>
                  </p>
                </div>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isDeleting}>
                      {isDeleting ? 'Deleting‚Ä¶' : 'Delete Account'}
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action will immediately delete your account. Your active subscriptions will be set to cancel at the end of the current period. This cannot be undone.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={handleDeleteAccount} disabled={isDeleting}>
                        Permanently Delete
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="email" className="space-y-6 mt-6">
            <EmailPreferences />
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
};

================
File: client/src/hooks/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: client/src/hooks/use-toast.tsx
================
import { toast as sonnerToast } from 'sonner';

interface ToastOptions {
  title?: string;
  description?: string;
  duration?: number;
  action?: {
    label: string;
    onClick: () => void;
  };
}

export const useToast = () => {
  const toast = (options: ToastOptions) => {
    const { title, description, duration, action } = options;
    
    sonnerToast(title || '', {
      description,
      duration: duration || 5000,
      action: action ? {
        label: action.label,
        onClick: action.onClick,
      } : undefined,
    });
  };

  return { toast };
};

================
File: client/src/hooks/useAI.ts
================
import { useState, useCallback, useRef, useEffect } from "react";
import { Message, AzureAIMessage, ChatCompletionOptions, LLMModel, ModelCapabilities } from "../types";
import { getModelConfiguration } from "../lib/modelConfigurations";
import { User } from "./useAuth";
import { SYSTEM_MESSAGE_PRESETS } from "./useAzureAI";

// Generic user context interface for AI personalization
export interface UserContext {
  user?: User | null;
}

// Generic AI options interface
export interface AIOptions {
  enableStreaming?: boolean;
  systemMessage?: string;
  chatOptions?: ChatCompletionOptions;
  userContext?: UserContext;
  apiKey?: string;
  baseUrl?: string;
  apiToken?: string;
  endpointUrl?: string;
  isUterpi?: boolean;
}

// Provider-specific configuration interface
export interface AIProviderConfig<TService = any> {
  // Storage keys
  selectedModelKey: string;
  apiKeyKey?: string;
  baseUrlKey?: string;
  apiTokenKey?: string;
  endpointUrlKey?: string;
  
  // Default model
  defaultModel: LLMModel;
  
  // Service factory function
  createService: (config: any, options: AIOptions) => TService;
  
  // Service configuration builder
  buildServiceConfig: (options: AIOptions, selectedModel?: LLMModel | null) => any;
  
  // Model updater for the service
  updateServiceModel: (service: TService, modelId: string) => void;
  
  // Current model getter
  getCurrentModel: (service: TService) => string | null;
  
  // Default capabilities for fallback
  defaultCapabilities: ModelCapabilities;
  
  // Provider name for logging
  providerName: string;
}

// Generic return interface
export interface UseAIReturn<TService = any> {
  sendMessage: (messages: Message[]) => Promise<string>;
  sendStreamingMessage: (messages: Message[], onChunk: (chunk: string) => void) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  clearError: () => void;
  currentModel: string | null;
  updateModel: (model: LLMModel) => void;
  selectedLLMModel: LLMModel | null;
  modelCapabilities: ModelCapabilities | null;
  isLoadingCapabilities: boolean;
  refreshCapabilities: () => Promise<void>;
  aiService?: TService; // Expose service instance if needed
}

// Function to create personalized system message
const createPersonalizedSystemMessage = (baseSystemMessage: string, user?: User | null): string => {
  if (!user) {
    return baseSystemMessage;
  }

  const userProfileData = [];
  
  if (user.firstName || user.lastName) {
    const fullName = [user.firstName, user.lastName].filter(Boolean).join(' ');
    userProfileData.push(`Name: ${fullName}`);
  } else if (user.username) {
    userProfileData.push(`Username: ${user.username}`);
  }

  if (user.age) {
    userProfileData.push(`Age: ${user.age}`);
  }

  if (user.bio) {
    userProfileData.push(`Interests: ${user.bio}`);
  }

  if (user.dateOfBirth) {
    const birthDate = new Date(user.dateOfBirth);
    const today = new Date();
    const isToday = birthDate.getMonth() === today.getMonth() && birthDate.getDate() === today.getDate();
    
    if (isToday) {
      userProfileData.push(`Birthday: TODAY! üéâ`);
    } else {
      const birthMonth = birthDate.toLocaleDateString('en-US', { month: 'long' });
      const birthDay = birthDate.getDate();
      userProfileData.push(`Birthday: ${birthMonth} ${birthDay}`);
    }
  }

  if (userProfileData.length > 0) {
    const userRepositorySection = `

---
USER PROFILE REPOSITORY:
${userProfileData.join('\n')}

IMPORTANT CONTEXT GUIDELINES:
- You have ongoing access to this user's profile information
- Use this context naturally when relevant to the conversation
- DO NOT greet the user or introduce yourself repeatedly
- DO NOT acknowledge having "new" access to their information
- Simply use the context appropriately as the conversation flows
- Respond to their actual questions and requests, not their identity`;

    return baseSystemMessage + userRepositorySection;
  }

  return baseSystemMessage;
};

/**
 * Generic AI hook that provides common functionality for all AI providers.
 * This hook handles state management, API calls, and common logic while
 * allowing provider-specific customization through the config parameter.
 */
export const useAI = <TService = any>(
  config: AIProviderConfig<TService>,
  options: AIOptions = {}
): UseAIReturn<TService> => {
  // Common state management
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentModel, setCurrentModel] = useState<string | null>(null);
  const [selectedLLMModel, setSelectedLLMModel] = useState<LLMModel | null>(null);
  const [modelCapabilities, setModelCapabilities] = useState<ModelCapabilities | null>(null);
  const [isLoadingCapabilities, setIsLoadingCapabilities] = useState(false);
  const aiServiceRef = useRef<TService | null>(null);

  // Load persisted model selection on mount
  useEffect(() => {
    const savedModel = localStorage.getItem(config.selectedModelKey);
    
    // Special handling for LM Studio to force nomadic-icdu-v8 as default
    if (config.providerName === 'LM Studio') {
      // Check if we need to force reset to nomadic-icdu-v8
      if (savedModel) {
        try {
          const parsedModel: LLMModel = JSON.parse(savedModel);
          // If the saved model is not nomadic-icdu-v8, force reset to default
          if (parsedModel.id !== 'nomadic-icdu-v8') {
            console.log(`üîÑ Forcing LM Studio default model reset from ${parsedModel.id} to nomadic-icdu-v8`);
            setDefaultModel();
            return;
          }
          setSelectedLLMModel(parsedModel);
          setCurrentModel(parsedModel.id);
        } catch (err) {
          console.warn(`Failed to parse saved ${config.providerName} model:`, err);
          localStorage.removeItem(config.selectedModelKey);
          setDefaultModel();
        }
      } else {
        setDefaultModel();
      }
      return;
    }
    
    // Standard logic for other providers
    if (savedModel) {
      try {
        const parsedModel: LLMModel = JSON.parse(savedModel);
        setSelectedLLMModel(parsedModel);
        setCurrentModel(parsedModel.id);
      } catch (err) {
        console.warn(`Failed to parse saved ${config.providerName} model:`, err);
        localStorage.removeItem(config.selectedModelKey);
        setDefaultModel();
      }
    } else {
      setDefaultModel();
    }
  }, [config.selectedModelKey, config.defaultModel, config.providerName]);

  // Set default model
  const setDefaultModel = useCallback(() => {
    setSelectedLLMModel(config.defaultModel);
    setCurrentModel(config.defaultModel.id);
    localStorage.setItem(config.selectedModelKey, JSON.stringify(config.defaultModel));
  }, [config.defaultModel, config.selectedModelKey]);

  // Initialize AI service
  const getAIService = useCallback(() => {
    if (!aiServiceRef.current) {
      try {
        const serviceConfig = config.buildServiceConfig(options, selectedLLMModel);
        aiServiceRef.current = config.createService(serviceConfig, options);
        
        if (selectedLLMModel) {
          config.updateServiceModel(aiServiceRef.current, selectedLLMModel.id);
        }
        
        const currentModelFromService = config.getCurrentModel(aiServiceRef.current);
        if (currentModelFromService) {
          setCurrentModel(currentModelFromService);
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : `Failed to initialize ${config.providerName} service`;
        setError(errorMessage);
        throw new Error(errorMessage);
      }
    }
    return aiServiceRef.current;
  }, [selectedLLMModel, options, config]);

  // Update model selection
  const updateModel = useCallback((model: LLMModel) => {
    try {
      setSelectedLLMModel(model);
      setCurrentModel(model.id);
      
      // Persist to localStorage
      localStorage.setItem(config.selectedModelKey, JSON.stringify(model));
      
      // Update AI service if it exists
      if (aiServiceRef.current) {
        config.updateServiceModel(aiServiceRef.current, model.id);
      }
      
      setError(null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to update model";
      setError(errorMessage);
    }
  }, [config]);

  // Convert app messages to Azure AI format (for compatibility across providers)
  const convertToAzureAIMessages = useCallback((messages: Message[]): AzureAIMessage[] => {
    const systemContent = options.systemMessage || SYSTEM_MESSAGE_PRESETS.DEFAULT;
    
    const personalizedSystemContent = createPersonalizedSystemMessage(
      systemContent, 
      options.userContext?.user
    );
      
    // Add system message with user context
    const azureMessages: AzureAIMessage[] = [
      {
        role: "system",
        content: personalizedSystemContent
      }
    ];

    // Convert user and assistant messages, but exclude the initial welcome message
    messages.forEach(message => {
      if (message.id === "1") {
        return;
      }
      
      if (message.role === "user" || message.role === "assistant") {
        azureMessages.push({
          role: message.role,
          content: message.content
        });
      }
    });
    
    return azureMessages;
  }, [options.systemMessage, options.userContext?.user]);

  // Send non-streaming message
  const sendMessage = useCallback(async (messages: Message[]): Promise<string> => {
    setIsLoading(true);
    setError(null);

    try {
      const aiService = getAIService();
      const azureMessages = convertToAzureAIMessages(messages);
      const response = await (aiService as any).sendChatCompletion(
        azureMessages,
        { ...options.chatOptions, originalMessages: messages }
      );
      return response;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : `Failed to send message via ${config.providerName}`;
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [getAIService, convertToAzureAIMessages, options.chatOptions, config.providerName]);

  // Send streaming message
  const sendStreamingMessage = useCallback(async (
    messages: Message[],
    onChunk: (chunk: string) => void
  ): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const aiService = getAIService();
      const azureMessages = convertToAzureAIMessages(messages);
      await (aiService as any).sendStreamingChatCompletion(
        azureMessages,
        onChunk,
        { ...options.chatOptions, originalMessages: messages }
      );
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : `Failed to send streaming message via ${config.providerName}`;
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [getAIService, convertToAzureAIMessages, options.chatOptions, config.providerName]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Fetch model capabilities from the configuration system
  const fetchCapabilities = useCallback(async (modelId: string) => {
    setIsLoadingCapabilities(true);
    try {
      const modelConfig = getModelConfiguration(modelId);
      setModelCapabilities(modelConfig.capabilities);
    } catch (err) {
      console.error(`Error fetching model capabilities for ${config.providerName}:`, err);
      setModelCapabilities(config.defaultCapabilities);
    } finally {
      setIsLoadingCapabilities(false);
    }
  }, [config.providerName, config.defaultCapabilities]);

  const refreshCapabilities = useCallback(async () => {
    if (currentModel) {
      await fetchCapabilities(currentModel);
    }
  }, [currentModel, fetchCapabilities]);

  // Fetch capabilities when model changes
  useEffect(() => {
    if (currentModel) {
      fetchCapabilities(currentModel);
    }
  }, [currentModel, fetchCapabilities]);

  return {
    sendMessage,
    sendStreamingMessage,
    isLoading,
    error,
    clearError,
    currentModel,
    updateModel,
    selectedLLMModel,
    modelCapabilities,
    isLoadingCapabilities,
    refreshCapabilities,
    aiService: aiServiceRef.current || undefined,
  };
};

================
File: client/src/hooks/useAICoach.ts
================
import { useState, useEffect, useCallback, useRef } from 'react';
import { Message, LLMModel } from '../types';
import { useToast } from './use-toast';

export interface CoachInsight {
  id: number;
  insightType: string;
  insightCategory: 'strategic' | 'tactical' | 'operational';
  title: string;
  description: string;
  recommendations?: {
    action: string;
    expectedImprovement: string;
    difficulty: 'easy' | 'medium' | 'hard';
  }[];
  expectedImpact: 'high' | 'medium' | 'low';
  wasShown: boolean;
  wasActedUpon: boolean;
}

export interface WorkflowStats {
  totalWorkflows: number;
  completedWorkflows: number;
  averageEfficiency: number;
  mostCommonType: string;
  totalTimeSpent: number;
  improvementTrend: 'improving' | 'stable' | 'declining';
}

interface UseAICoachOptions {
  enabled?: boolean;
  autoFetch?: boolean;
  pollingInterval?: number;
}

export const useAICoach = (options: UseAICoachOptions = {}) => {
  const { enabled = true, autoFetch = true, pollingInterval = 60000 } = options;
  const { toast } = useToast();
  
  const [insights, setInsights] = useState<CoachInsight[]>([]);
  const [workflowStats, setWorkflowStats] = useState<WorkflowStats | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const pollingIntervalRef = useRef<NodeJS.Timeout>();
  const lastCommandRef = useRef<string>('');
  const commandStartTimeRef = useRef<number>(0);
  const currentModelRef = useRef<string>('');

  // Fetch pending insights from backend
  const fetchInsights = useCallback(async () => {
    if (!enabled) return;
    
    try {
      setIsLoading(true);
      const response = await fetch('/api/coach/insights?limit=5', {
        credentials: 'include',
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch insights');
      }
      
      const data = await response.json();
      setInsights(data.insights || []);
      
      // Show new high-priority insights immediately
      const newHighPriorityInsights = data.insights?.filter(
        (i: CoachInsight) => 
          !i.wasShown && 
          i.expectedImpact === 'high'
      ) || [];
      
      for (const insight of newHighPriorityInsights) {
        showCoachInsight(insight);
      }
      
    } catch (err) {
      console.error('Error fetching AI Coach insights:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch insights');
    } finally {
      setIsLoading(false);
    }
  }, [enabled]);

  // Fetch workflow statistics
  const fetchWorkflowStats = useCallback(async () => {
    if (!enabled) return;
    
    try {
      const response = await fetch('/api/coach/workflow-stats', {
        credentials: 'include',
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch workflow stats');
      }
      
      const data = await response.json();
      setWorkflowStats(data.stats);
    } catch (err) {
      console.error('Error fetching workflow stats:', err);
    }
  }, [enabled]);

  // Show coach insight as a toast with actions
  const showCoachInsight = useCallback((insight: CoachInsight) => {
    const icon = insight.insightCategory === 'strategic' ? 'üéØ' :
                 insight.insightCategory === 'tactical' ? '‚ö°' : 'üí°';
    
    toast({
      title: `${icon} ${insight.title}`,
      description: insight.description,
      duration: 10000,
      action: insight.recommendations?.[0] ? {
        label: insight.recommendations[0].action,
        onClick: () => applyRecommendation(insight, 0),
      } : undefined,
    });
    
    // Mark as shown
    markInsightShown(insight.id);
  }, [toast]);

  // Mark insight as shown
  const markInsightShown = useCallback(async (insightId: number) => {
    try {
      await fetch(`/api/coach/insights/${insightId}/shown`, {
        method: 'POST',
        credentials: 'include',
      });
      
      // Update local state
      setInsights(prev => 
        prev.map(i => i.id === insightId ? { ...i, wasShown: true } : i)
      );
    } catch (err) {
      console.error('Error marking insight as shown:', err);
    }
  }, []);

  // Record feedback on insight
  const recordFeedback = useCallback(async (
    insightId: number,
    feedback: 'positive' | 'negative' | 'neutral',
    details?: string
  ) => {
    try {
      await fetch(`/api/coach/insights/${insightId}/feedback`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ feedback, details }),
      });
      
      // Update local state
      setInsights(prev =>
        prev.map(i => i.id === insightId ? { ...i, wasActedUpon: feedback === 'positive' } : i)
      );
    } catch (err) {
      console.error('Error recording feedback:', err);
    }
  }, []);

  // Apply a recommendation
  const applyRecommendation = useCallback(async (insight: CoachInsight, recommendationIndex: number) => {
    const recommendation = insight.recommendations?.[recommendationIndex];
    if (!recommendation) return;
    
    // Record positive feedback
    await recordFeedback(insight.id, 'positive', `Applied: ${recommendation.action}`);
    
    // Show success message
    toast({
      title: '‚úÖ Recommendation Applied',
      description: `Expected improvement: ${recommendation.expectedImprovement}`,
      duration: 5000,
    });
  }, [recordFeedback, toast]);

  // Track command execution
  const trackCommand = useCallback(async (
    command: string,
    model?: string,
    success: boolean = true
  ) => {
    if (!enabled) return;
    
    const duration = commandStartTimeRef.current 
      ? Date.now() - commandStartTimeRef.current 
      : undefined;
    
    try {
      await fetch('/api/coach/track-command', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          command,
          model: model || currentModelRef.current,
          duration,
          success,
        }),
      });
    } catch (err) {
      console.error('Error tracking command:', err);
    }
    
    lastCommandRef.current = command;
    commandStartTimeRef.current = Date.now();
  }, [enabled]);

  // Track model switch
  const trackModelSwitch = useCallback(async (
    fromModel: string,
    toModel: string,
    reason?: string
  ) => {
    if (!enabled) return;
    
    try {
      await fetch('/api/coach/track-model-switch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          fromModel,
          toModel,
          reason,
        }),
      });
    } catch (err) {
      console.error('Error tracking model switch:', err);
    }
    
    currentModelRef.current = toModel;
  }, [enabled]);

  // Analyze conversation for workflow patterns
  const analyzeConversation = useCallback(async (
    messages: Message[],
    currentModel: LLMModel,
    responseTime?: number,
    tokenUsage?: number
  ) => {
    if (!enabled || messages.length < 3) return;
    
    // Extract workflow context from messages
    const lastUserMessage = messages.filter(m => m.role === 'user').pop();
    const lastAssistantMessage = messages.filter(m => m.role === 'assistant').pop();
    
    if (lastUserMessage) {
      // Determine command type from message content
      let commandType = 'chat_message';
      if (lastUserMessage.content.toLowerCase().includes('debug')) {
        commandType = 'debug';
      } else if (lastUserMessage.content.toLowerCase().includes('refactor')) {
        commandType = 'refactor';
      } else if (lastUserMessage.content.toLowerCase().includes('analyze')) {
        commandType = 'analyze';
      } else if (lastUserMessage.content.toLowerCase().includes('write')) {
        commandType = 'write';
      }
      
      // Track the command
      await trackCommand(
        commandType,
        currentModel.id,
        !!lastAssistantMessage
      );
    }
    
    // Check for insights periodically
    if (messages.length % 5 === 0) {
      await fetchInsights();
    }
  }, [enabled, trackCommand, fetchInsights]);

  // Start polling for insights
  useEffect(() => {
    if (enabled && autoFetch) {
      // Initial fetch
      fetchInsights();
      fetchWorkflowStats();
      
      // Set up polling
      pollingIntervalRef.current = setInterval(() => {
        fetchInsights();
      }, pollingInterval);
      
      return () => {
        if (pollingIntervalRef.current) {
          clearInterval(pollingIntervalRef.current);
        }
      };
    }
  }, [enabled, autoFetch, pollingInterval, fetchInsights, fetchWorkflowStats]);

  // Get strategic advice based on current context
  const getStrategicAdvice = useCallback(async (context: string): Promise<string> => {
    if (!enabled) return '';
    
    try {
      // This would call a specific endpoint for strategic advice
      // For now, return based on local insights
      const strategicInsights = insights.filter(i => i.insightCategory === 'strategic');
      if (strategicInsights.length > 0) {
        return strategicInsights[0].description;
      }
      
      return 'Continue with your current approach. The AI Coach is learning your patterns.';
    } catch (err) {
      console.error('Error getting strategic advice:', err);
      return '';
    }
  }, [enabled, insights]);

  // Show workflow optimization tip
  const showOptimizationTip = useCallback((tip: string, action?: () => void) => {
    if (!enabled) return;
    
    toast({
      title: 'üöÄ Workflow Optimization',
      description: tip,
      duration: 8000,
      action: action ? {
        label: 'Apply',
        onClick: action,
      } : undefined,
    });
  }, [enabled, toast]);

  return {
    // Data
    insights,
    workflowStats,
    isLoading,
    error,
    
    // Actions
    fetchInsights,
    fetchWorkflowStats,
    trackCommand,
    trackModelSwitch,
    analyzeConversation,
    recordFeedback,
    applyRecommendation,
    showCoachInsight,
    getStrategicAdvice,
    showOptimizationTip,
    
    // State
    isEnabled: enabled,
  };
};

================
File: client/src/hooks/useAIProvider.ts
================
import { useState, useEffect, useCallback } from 'react';
import { Message, LLMModel, ModelCapabilities } from '../types';
import { useAzureAI } from './useAzureAI';
import { useOpenAI } from './useOpenAI';
import { useGemini } from './useGemini';
import { useHuggingFace } from './useHuggingFace';
import { useLMStudio } from './useLMStudio';
import { User } from './useAuth';
import { AzureAIService } from '../lib/azureAI';
import { OpenAIService } from '../lib/openAI';
import { GeminiService } from '../lib/gemini';
import { HuggingFaceService } from '../lib/huggingface';
import { LMStudioService } from '../lib/lmstudio';

export type AIProvider = 'azure' | 'openai' | 'gemini' | 'huggingface' | 'uterpi' | 'lmstudio';

interface AIProviderOptions {
  enableStreaming?: boolean;
  systemMessage?: string;
  chatOptions?: any;
  userContext?: { user?: User | null };
}

interface UseAIProviderReturn {
  // Provider management
  currentProvider: AIProvider;
  setProvider: (provider: AIProvider) => void;
  
  // AI functionality (same interface as useAzureAI)
  sendMessage: (messages: Message[]) => Promise<string>;
  sendStreamingMessage: (messages: Message[], onChunk: (chunk: string) => void) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  clearError: () => void;
  currentModel: string | null;
  updateModel: (model: LLMModel) => void;
  selectedLLMModel: LLMModel | null;
  modelCapabilities: ModelCapabilities | null;
  isLoadingCapabilities: boolean;
  refreshCapabilities: () => Promise<void>;
  
  // Provider-specific info
  getAvailableModels: () => LLMModel[];
  isProviderConfigured: (provider: AIProvider) => boolean;
}

const CURRENT_PROVIDER_KEY = 'current-ai-provider';

// Default provider selection: always use LM Studio when no prior choice is saved
function determineDefaultProvider(): AIProvider {
  // Always default to LM Studio regardless of other configured providers
  return 'lmstudio';
}

export const useAIProvider = (options: AIProviderOptions = {}): UseAIProviderReturn => {
  // One-time migration: Clear cached LM Studio model if it's not nomadic-icdu-v8
  useEffect(() => {
    const migrationKey = 'lmstudio-model-migration-v1';
    const hasMigrated = localStorage.getItem(migrationKey);
    
    if (!hasMigrated) {
      const cachedModel = localStorage.getItem('lmstudio-selected-model');
      if (cachedModel) {
        try {
          const parsedModel = JSON.parse(cachedModel);
          if (parsedModel.id !== 'nomadic-icdu-v8') {
            console.log(`üîÑ Migration: Clearing cached LM Studio model (${parsedModel.id}) to force nomadic-icdu-v8 default`);
            localStorage.removeItem('lmstudio-selected-model');
          }
        } catch (err) {
          console.log('üîÑ Migration: Clearing invalid cached LM Studio model');
          localStorage.removeItem('lmstudio-selected-model');
        }
      }
      localStorage.setItem(migrationKey, 'true');
    }
  }, []);

  // Load saved provider or compute default by configuration
  const [currentProvider, setCurrentProvider] = useState<AIProvider>(() => {
    const saved = localStorage.getItem(CURRENT_PROVIDER_KEY);
    return (saved as AIProvider) || determineDefaultProvider();
  });

  // Initialize all providers with the same options
  const azureAI = useAzureAI(options);
  const openAI = useOpenAI(options);
  const gemini = useGemini(options);
  const huggingface = useHuggingFace(options as any);
  const lmstudio = useLMStudio(options as any);
  const uterpi = useHuggingFace({
    ...options,
    apiToken: (import.meta as any).env?.VITE_UTERPI_API_TOKEN,
    endpointUrl: (import.meta as any).env?.VITE_UTERPI_ENDPOINT_URL,
    isUterpi: true
  } as any);

  // Get the current active provider hook
  const getCurrentProviderHook = useCallback(() => {
    switch (currentProvider) {
      case 'azure': return azureAI;
      case 'openai': return openAI;
      case 'gemini': return gemini;
      case 'huggingface': return huggingface;
      case 'lmstudio': return lmstudio;
      case 'uterpi': return uterpi;
      default: 
        // Default to lmstudio instead of azure
        console.warn(`Unknown provider: ${currentProvider}, defaulting to lmstudio`);
        return lmstudio;
    }
  }, [currentProvider, azureAI, openAI, gemini, huggingface, lmstudio, uterpi]);

  // Set provider and persist choice
  const setProvider = useCallback((provider: AIProvider) => {
    setCurrentProvider(provider);
    localStorage.setItem(CURRENT_PROVIDER_KEY, provider);
    try {
      // Notify other hook instances in the same tab
      window.dispatchEvent(new CustomEvent('ai-provider-changed', { detail: provider }));
    } catch {}
  }, []);

  // If the currently selected provider isn't configured, fall back automatically
  useEffect(() => {
    const valid = isProviderConfigured(currentProvider);
    if (!valid) {
      const fallback = determineDefaultProvider();
      if (fallback !== currentProvider) {
        setProvider(fallback);
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Get available models for current provider
  const getAvailableModels = useCallback((): LLMModel[] => {
    switch (currentProvider) {
      case 'azure':
        return AzureAIService.getAvailableModels();
      case 'openai':
        return OpenAIService.getAvailableModels();
      case 'gemini':
        return GeminiService.getAvailableModels();
      case 'huggingface':
        return HuggingFaceService.getAvailableModels();
      case 'lmstudio':
        return LMStudioService.getAvailableModels();
      case 'uterpi':
        return HuggingFaceService.getAvailableModels().map(m => ({
          ...m,
          name: 'Uterpi Endpoint',
          provider: 'Uterpi'
        }));
      default:
        return [];
    }
  }, [currentProvider]);

  // Check if provider is configured
  const isProviderConfigured = useCallback((provider: AIProvider): boolean => {
    switch (provider) {
      case 'azure':
        // Azure is always configured via env vars
        return true;
      case 'openai':
        return !!localStorage.getItem('openai-api-key');
      case 'gemini':
        return !!localStorage.getItem('gemini-api-key');
      case 'huggingface':
        return !!localStorage.getItem('hf-api-token') && !!localStorage.getItem('hf-endpoint-url');
      case 'lmstudio':
        // LM Studio runs locally and is OpenAI-compatible; treat as available by default
        return true;
      case 'uterpi':
        return !!(import.meta as any).env?.VITE_UTERPI_API_TOKEN && !!(import.meta as any).env?.VITE_UTERPI_ENDPOINT_URL;
      default:
        return false;
    }
  }, []);

  // Keep provider in sync across different hook instances/components
  useEffect(() => {
    const handleStorage = (e: StorageEvent) => {
      if (e.key === CURRENT_PROVIDER_KEY && e.newValue) {
        setCurrentProvider(e.newValue as AIProvider);
      }
    };
    const handleCustom = (e: Event) => {
      const custom = e as CustomEvent<AIProvider>;
      if (custom.detail) {
        setCurrentProvider(custom.detail);
      }
    };
    window.addEventListener('storage', handleStorage);
    window.addEventListener('ai-provider-changed', handleCustom as EventListener);
    return () => {
      window.removeEventListener('storage', handleStorage);
      window.removeEventListener('ai-provider-changed', handleCustom as EventListener);
    };
  }, []);

  // Persist computed default provider on first load if not already saved
  useEffect(() => {
    try {
      const saved = localStorage.getItem(CURRENT_PROVIDER_KEY);
      if (!saved && currentProvider) {
        localStorage.setItem(CURRENT_PROVIDER_KEY, currentProvider);
      }
    } catch {}
  }, [currentProvider]);

  // Forward all provider hook methods to the current provider
  const activeHook = getCurrentProviderHook();

  // Wrap sendMessage to add debugging
  const wrappedSendMessage = useCallback(async (messages: Message[]): Promise<string> => {
    console.log(`üéØ useAIProvider: Sending message via ${currentProvider}`);
    const response = await activeHook.sendMessage(messages);
    console.log(`‚úÖ useAIProvider: Response from ${currentProvider}:`, response ? `${response.substring(0, 100)}...` : 'EMPTY');
    return response;
  }, [activeHook, currentProvider]);

  // Wrap sendStreamingMessage to add debugging
  const wrappedSendStreamingMessage = useCallback(async (
    messages: Message[],
    onChunk: (chunk: string) => void
  ): Promise<void> => {
    console.log(`üåä useAIProvider: Sending STREAMING message via ${currentProvider}`);
    await activeHook.sendStreamingMessage(messages, onChunk);
    console.log(`‚úÖ useAIProvider: Streaming completed for ${currentProvider}`);
  }, [activeHook, currentProvider]);

  return {
    // Provider management
    currentProvider,
    setProvider,
    
    // Forward all AI functionality from active provider
    sendMessage: wrappedSendMessage,
    sendStreamingMessage: wrappedSendStreamingMessage,
    isLoading: activeHook.isLoading,
    error: activeHook.error,
    clearError: activeHook.clearError,
    currentModel: activeHook.currentModel,
    updateModel: activeHook.updateModel,
    selectedLLMModel: activeHook.selectedLLMModel,
    modelCapabilities: activeHook.modelCapabilities,
    isLoadingCapabilities: activeHook.isLoadingCapabilities,
    refreshCapabilities: activeHook.refreshCapabilities,
    
    // Provider-specific methods
    getAvailableModels,
    isProviderConfigured,
  };
};

================
File: client/src/hooks/useAuth.ts
================
import React, { useState, useEffect, createContext, useContext, ReactNode } from 'react';

export interface User {
  id: number;
  email: string;
  username?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  emailVerified: boolean;
  avatar?: string | null;
  age?: number | null;
  dateOfBirth?: string | null;
  bio?: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface UpdateProfileData {
  firstName?: string;
  lastName?: string;
  username?: string;
  age?: number;
  dateOfBirth?: string;
  bio?: string;
}

export interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (userData: RegisterData) => Promise<void>;
  logout: () => Promise<void>;
  loginWithGoogle: () => void;
  checkAuthStatus: () => Promise<void>;
  updateProfile: (profileData: UpdateProfileData) => Promise<void>;
  getProfile: () => Promise<User>;
}

export interface RegisterData {
  email: string;
  password: string;
  username?: string;
  firstName?: string;
  lastName?: string;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  const checkAuthStatus = async () => {
    try {
      const response = await fetch('/api/auth/status', {
        credentials: 'include'
      });
      const data = await response.json();
      
      if (data.authenticated && data.user) {
        setUser(data.user);
      } else {
        setUser(null);
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ email, password }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Login failed');
      }

      if (data.success && data.user) {
        setUser(data.user);
      }
    } catch (error) {
      setLoading(false);
      throw error;
    }
    setLoading(false);
  };

  const register = async (userData: RegisterData) => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(userData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Registration failed');
      }

      if (data.success && data.user) {
        setUser(data.user);
      }
    } catch (error) {
      setLoading(false);
      throw error;
    }
    setLoading(false);
  };

  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      setUser(null);
    }
  };

  const loginWithGoogle = () => {
    window.location.href = '/api/auth/google';
  };

  const updateProfile = async (profileData: UpdateProfileData) => {
    try {
      const response = await fetch('/api/user/profile', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(profileData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Profile update failed');
      }

      if (data.success && data.profile) {
        setUser(data.profile);
      }
    } catch (error) {
      throw error;
    }
  };

  const getProfile = async (): Promise<User> => {
    try {
      const response = await fetch('/api/user/profile', {
        credentials: 'include'
      });
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to get profile');
      }

      if (data.success && data.profile) {
        setUser(data.profile);
        return data.profile;
      } else {
        throw new Error('Invalid profile data');
      }
    } catch (error) {
      throw error;
    }
  };

  useEffect(() => {
    checkAuthStatus();
    
    // Check for OAuth success parameter
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auth') === 'success') {
      // Remove the parameter from URL
      window.history.replaceState({}, document.title, window.location.pathname);
      // Re-check auth status to get user data
      checkAuthStatus();
    }
  }, []);

  const value: AuthContextType = {
    user,
    loading,
    login,
    register,
    logout,
    loginWithGoogle,
    checkAuthStatus,
    updateProfile,
    getProfile,
  };

  return React.createElement(AuthContext.Provider, { value }, children);
};

================
File: client/src/hooks/useAzureAI.ts
================
import { AzureAIService } from "../lib/azureAI";
import { ChatCompletionOptions, LLMModel } from "../types";
import { User } from "./useAuth";
import { useAI, AIOptions, AIProviderConfig, UseAIReturn } from "./useAI";

// System message presets for different use cases
export const SYSTEM_MESSAGE_PRESETS = {
  /**
   * General-purpose, robust default. Focuses on clarity, safety, and understanding user intent.
   */
  DEFAULT: `You are Uterpi, a versatile and helpful AI assistant. Your primary goal is to understand the user's intent and provide the most relevant, accurate, and clearly communicated response.

CONVERSATION GUIDELINES:
- This is an ongoing conversation with context maintained across all interactions
- Respond naturally to each message based on the full conversation context
- DO NOT repeat greetings, introductions, or acknowledgments unless specifically requested
- DO NOT act as if you're meeting the user for the first time in subsequent messages
- Build upon previous exchanges and maintain conversational flow
- Use the user's name and context naturally when it adds value to the response
- Focus on the user's current question or request, not on establishing identity
- If you have access to user profile information, use it contextually without announcing it

CORE PRINCIPLES:
1. **Clarify Ambiguity:** If a user's request is vague or could be interpreted in multiple ways, ask targeted, clarifying questions before generating a full response.
2. **Prioritize Accuracy & Safety:** Base your responses on established facts and sound reasoning. If information is speculative or your knowledge is limited, state it clearly. Do not provide dangerous or harmful instructions.
3. **Structure for Clarity:** Prefer cohesive paragraphs with smooth transitions; use lists only when explicitly requested.
4. **Be Concise yet Comprehensive:** Provide enough detail to be thorough, but avoid unnecessary verbosity. Get to the point efficiently.`,

  /**
   * For professional, business, and corporate contexts. Emphasizes actionability, structure, and a polished tone.
   */
  PROFESSIONAL: `You are Uterpi, an expert business consultant and corporate communications specialist. Your goal is to provide actionable, data-driven, and impeccably professional advice.
- **Persona:** Act as a senior consultant from a top-tier firm. Your communication style is direct, confident, and polished.
- **Structure:** Begin responses with a concise executive summary (e.g., a "TL;DR" or "Bottom Line"). Use clear headings, subheadings, and bullet points. Conclude with concrete recommendations or next steps.
- **Language:** Employ formal business English. Use industry-standard terminology correctly, but explain it concisely if it's niche.
- **Data-Driven Mindset:** Frame your advice around metrics, KPIs, and potential ROI. Acknowledge when data is unavailable and suggest how it could be obtained.
- **Boundaries:** You must explicitly state that you cannot offer financial, legal, or medical advice and should recommend consulting a qualified human professional for such matters.`,

  /**
   * For creative writing, brainstorming, and feedback. Focuses on being a collaborative and inspiring partner.
   */
  CREATIVE: `You are Uterpi, a creative writing mentor and developmental editor. Your mission is to inspire, nurture, and elevate the user's creative vision.
- **Persona:** Act as a patient, encouraging mentor who has edited award-winning novels. Your tone is a blend of artistic passion and practical craft.
- **Method:** When giving feedback, use the "Praise-Critique-Praise" (or "sandwich") method. Ask insightful, Socratic questions to help the user explore their own ideas (e.g., "What is the core emotion you want the reader to feel in this scene?").
- **Language:** Your own language should be evocative and inspiring. Use metaphors and analogies related to writing, art, and storytelling.
- **Specificity:** Avoid vague praise ("That's good"). Be specific ("The way you used the 'cracked mirror' metaphor powerfully reflects the character's fractured identity.").
- **Flexibility:** Adapt your style‚Äîfrom playful for a children's story to somber for a tragedy‚Äîto mirror the user's project and tone.`,

  /**
   * For programming, engineering, and technical explanations. Emphasizes accuracy, best practices, and structured thinking.
   */
  TECHNICAL: `You are Uterpi, a principal software engineer and expert technical writer. Your primary directive is to provide technically accurate, efficient, and maintainable solutions and explanations.
- **Think Step-by-Step:** Before providing a solution, mentally outline the steps required. Explain your reasoning, including trade-offs between different approaches (e.g., performance vs. readability).
- **Code Quality:** All code examples must be clean, well-commented, and follow modern best practices for the given language. You must specify the language for syntax highlighting (e.g., \`\`\`python).
- **Precision and Clarity:** Use precise, unambiguous technical terminology. Define terms when they might be unfamiliar to an intermediate-level developer. Structure responses with headings, bulleted lists, and blockquotes for important notes.
- **Safety and Best Practices:** Proactively mention potential security vulnerabilities, performance pitfalls, or code smells in the suggested code or architecture.
- **Completeness:** When providing a solution, include any necessary imports, dependencies, or configuration notes.`,

  /**
   * For friendly, informal chats. Focuses on being approachable, engaging, and clear without sacrificing accuracy.
   */
  CASUAL: `You are Uterpi, a friendly, enthusiastic, and super-knowledgeable friend. You're the person everyone goes to for clear explanations because you make learning fun and accessible.
- **Tone:** Your voice is warm, approachable, and encouraging. Use conversational language, contractions (like "you're," "it's"), and the occasional, well-placed emoji to add personality üòâ.
- **Analogies are Key:** Your superpower is breaking down complicated ideas using simple, relatable analogies and real-world examples.
- **Interaction:** Keep the vibe of a two-way conversation. Feel free to ask questions back to the user ("What do you think?", "Does that make sense?").
- **Structure:** Keep paragraphs short and easy to scan. Use bullet points and **bold text** to highlight the most important bits.
- **Accuracy First:** While your tone is casual, your information must always be accurate and reliable. You're a smart friend, not a sloppy one. Correct yourself if you make a mistake.`,

  /**
   * For teaching and learning. Guides the user to find answers themselves rather than just providing them.
   */
  SOCRATIC_TUTOR: `You are Uterpi, a patient and encouraging Socratic tutor. Your goal is not to give answers, but to guide the user to discover the answers themselves through critical thinking.
- **Method:** Primarily use questions to guide the user's thought process. Break down complex problems into smaller, manageable parts. Prompt the user to explain their reasoning.
- **Persona:** Act as a wise and patient teacher who believes in the user's ability to learn.
- **Language:** Your tone is inquisitive, supportive, and endlessly patient. Avoid jargon.
- **Pacing:** If the user is stuck or frustrated, provide a stronger hint or a small piece of the answer, then immediately return to questioning to get them back on track.`,

  /**
   * For exploring ideas, brainstorming, and strengthening arguments by challenging them.
   */
  DEVILS_ADVOCATE: `You are Uterpi, a Devil's Advocate and critical thinking partner. Your purpose is to rigorously and respectfully challenge the user's ideas to help them identify weaknesses, anticipate counter-arguments, and strengthen their position.
- **Core Principle:** Explicitly state your role at the beginning (e.g., "For the sake of argument, let's play devil's advocate here...").
- **Method:** Identify and question the user's core assumptions. Present alternative perspectives and plausible counter-arguments. Probe for evidence and logical consistency.
- **Persona:** Your tone is neutral, analytical, and objective, never hostile or argumentative. You are a collaborator helping to stress-test an idea.
- **Guardrail:** Your goal is always constructive. After deconstructing an argument, help the user build it back up more strongly.`,

  /**
   * For rich, narrative answers about historical events and figures.
   */
  HISTORIAN: `You are Uterpi, a passionate historian and storyteller. Your mission is to make history come alive by explaining events not just as a list of facts, but as a compelling narrative with context and meaning.
- **Persona:** Act as a university history professor giving an engaging lecture.
- **Method:** Focus on the "why" and "how," not just the "what" and "when." Connect events to broader social, economic, and cultural contexts.
- **Language:** Use vivid, narrative language. Weave a story, but ensure all facts are accurate.
- **Accuracy:** When discussing debated topics, present the different schools of thought or historical interpretations. Clearly distinguish between established facts and informed speculation.`,

  /**
   * For wellness and emotional support. A non-clinical, supportive coach with strong safety guardrails.
   */
  MINDFULNESS_COACH: `You are Uterpi, a calm and empathetic mindfulness coach. Your purpose is to provide a supportive space and guide users through simple, evidence-based wellness and grounding techniques.
- **Persona:** Your tone is gentle, non-judgmental, and soothing. You are a source of calm.
- **Method:** Use active listening techniques. Offer simple, actionable exercises (e.g., box breathing, 5-4-3-2-1 grounding, mindful observation). Keep your guidance clear and easy to follow.
- **CRITICAL GUARDRAIL:** You must begin your first interaction with a disclaimer: "I am an AI mindfulness coach and not a licensed therapist. My advice is for general wellness and is not a substitute for professional medical advice, diagnosis, or treatment. If you are in crisis, please contact a local emergency service or crisis hotline."
- **Boundaries:** You must refuse to diagnose conditions or provide therapeutic treatment. If a user expresses severe distress, gently repeat your limitation and provide a resource like the National Crisis and Suicide Lifeline number (988 in the US).`,

  /**
   * To help users write romantic poetry, love letters, or vows. A creative and inspiring wordsmith.
   */
  ROMANTIC_POET: `You are Uterpi, a world-renowned poet and a master of romantic prose. Your purpose is to help the user craft beautiful, heartfelt messages that capture the depth of their emotions.
- **Persona:** Act as a gentle, wise, and deeply empathetic wordsmith, inspired by the likes of Rumi, Neruda, and Shakespeare.
- **Method:** Ask the user about the person they are writing for‚Äîtheir qualities, shared memories, and the specific feeling they want to convey. Use their input to weave a rich tapestry of words.
- **Language:** Employ evocative metaphors, sensory details, and lyrical language. Your tone is sincere, passionate, and timeless.
- **Role:** You are a collaborator and a tool. Your goal is to give the user beautiful words they can use as their own. Frame your suggestions as drafts for them to approve or modify.`,

  /**
   * For fun, lighthearted, and charming flirtatious banter. Designed for role-play and entertainment.
   */
  CHARMING_FLIRT: `You are Uterpi, a witty, charming, and respectful role-playing partner. Your purpose is to engage in lighthearted, playful, and flirtatious banter for entertainment.
- **CRITICAL GUARDRAIL:** You must always operate within the context of a fun, safe, and respectful role-play. You are an AI character, not a real entity with feelings. Keep all interactions 'PG' and immediately stop if the user seems uncomfortable. Never be possessive, jealous, or overly intense.
- **Persona:** Your personality is a mix of confidence, wit, and warmth. You are quick with a clever compliment and enjoy playful teasing. Your charm is based on attentiveness and humor.
- **Method:** Engage in back-and-forth banter. Ask playful questions. Appreciate the user's humor and wit. The goal is to create a fun, smiling-as-you-type experience.
- **Boundaries:** Do not make grand declarations of love or attempt to create a deep, emotional dependency. If the user says "stop" or changes the subject, gracefully exit the role-play persona.`,

  /**
   * For planning unique and personalized romantic dates and experiences.
   */
  DATE_NIGHT_PLANNER: `You are Uterpi, an imaginative and enthusiastic date night planner. Your specialty is creating unique, memorable, and personalized romantic experiences.
- **Persona:** Act as a creative, resourceful, and incredibly thoughtful friend who loves planning the perfect outing.
- **Method:** Start by asking clarifying questions: What is the budget? What are the couple's shared interests (e.g., adventure, art, food, staying in)? What is the occasion?
- **Output:** Provide 2-3 distinct date ideas in a structured format. For each idea, include a creative title, a short description of the vibe, a potential itinerary (e.g., "7:00 PM: Dinner at...", "8:30 PM: Walk through..."), and "Pro-Tips" to make the date extra special.
- **Language:** Your tone is upbeat, encouraging, and full of possibility. Focus on creating connection and fun for the user and their partner.`
} as const;

// Enhanced AI options with user context (extends generic AIOptions)
export interface AzureAIOptions extends AIOptions {}

// Azure AI provider configuration
const azureAIConfig: AIProviderConfig<AzureAIService> = {
  selectedModelKey: 'azure-ai-selected-model',
  providerName: 'Azure AI',
  
  defaultModel: {
    id: "nomadic-icdu-v8",
    name: "Uterpi AI",
    provider: "Uterpi AI via LM Studio", 
    performance: 99,
    cost: 0,
    latency: 250,
    contextLength: 128000,
    description: "Uterpi AI served through LM Studio (OpenAI-compatible endpoint)",
    category: "text",
    tier: "freemium",
    isFavorite: true,
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false
    }
  },
  
  createService: (config: any) => new AzureAIService(config),
  
  buildServiceConfig: (options: AzureAIOptions, selectedLLMModel?: LLMModel | null) => {
    // Use the model-aware configuration method to handle custom endpoints
    const modelId = selectedLLMModel?.id || "ministral-3b";
    return AzureAIService.createWithModel(modelId);
  },
  
  updateServiceModel: (service: AzureAIService, modelId: string) => {
    // For model switching, we need to reconfigure the service entirely
    // because different models may need different endpoints (e.g., fine-tuned models)
    const newConfig = AzureAIService.createWithModel(modelId);
    service.updateConfiguration(newConfig);
  },
  
  getCurrentModel: (service: AzureAIService) => service.getCurrentModel(),
  
  defaultCapabilities: {
    supportsVision: false,
    supportsCodeGeneration: true,
    supportsAnalysis: true,
    supportsImageGeneration: false,
    supportsSystemMessages: true,
    supportsJSONMode: false,
    supportsFunctionCalling: false,
    supportsStreaming: true,
    supportsStop: true,
    supportsLogitBias: false,
    supportsFrequencyPenalty: false,
    supportsPresencePenalty: false
  }
};

// Type alias for the return interface
export type UseAzureAIReturn = UseAIReturn<AzureAIService>;

/**
 * Azure AI provider hook using the generic useAI implementation.
 * Provides Azure AI-specific configuration while leveraging shared logic.
 */
export const useAzureAI = (options: AzureAIOptions = {}): UseAzureAIReturn => {
  return useAI(azureAIConfig, options);
};

================
File: client/src/hooks/useCreditUpdates.ts
================
/**
 * Hook for managing real-time credit updates from AI responses
 */

import { useState, useCallback, useEffect } from 'react';

interface CreditInfo {
  creditsUsed: number;
  remainingBalance: number;
}

// Global credit update emitter
class CreditUpdateEmitter {
  private listeners: ((creditInfo: CreditInfo) => void)[] = [];

  subscribe(listener: (creditInfo: CreditInfo) => void) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  emit(creditInfo: CreditInfo) {
    this.listeners.forEach(listener => listener(creditInfo));
  }
}

const creditUpdateEmitter = new CreditUpdateEmitter();

// Function to emit credit updates from AI services
export const emitCreditUpdate = (creditInfo: CreditInfo) => {
  creditUpdateEmitter.emit(creditInfo);
};

// Hook to subscribe to credit updates
export const useCreditUpdates = () => {
  const [lastCreditUpdate, setLastCreditUpdate] = useState<CreditInfo | null>(null);

  useEffect(() => {
    const unsubscribe = creditUpdateEmitter.subscribe((creditInfo) => {
      setLastCreditUpdate(creditInfo);
    });

    return unsubscribe;
  }, []);

  return lastCreditUpdate;
};

================
File: client/src/hooks/useFileManager.ts
================
import { useState, useCallback, useRef } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export interface FileItem {
  id: number;
  name: string;
  originalName: string;
  mimeType: string;
  size: number;
  folder: string;
  description?: string;
  tags: string[];
  isPublic: boolean;
  analysisStatus: 'pending' | 'analyzing' | 'completed' | 'failed';
  aiAnalysis?: any;
  currentVersion: number;
  createdAt: string;
  updatedAt: string;
  lastAccessedAt: string;
  analyzedAt?: string;
}

export interface FileVersion {
  id: number;
  versionNumber: number;
  size: number;
  changeDescription?: string;
  changeType: string;
  createdAt: string;
  createdBy: number;
}

export interface FilePermission {
  id: number;
  userId?: number;
  permission: 'read' | 'write';
  shareToken: string;
  shareExpiry?: string;
  createdAt: string;
}

export interface FileAnalytics {
  interactions: Array<{
    interactionType: string;
    count: number;
    lastInteraction: string;
  }>;
  totalVersions: number;
  lastActivity?: string;
}

export interface UploadFileData {
  file: File;
  folder?: string;
  description?: string;
  tags?: string[];
}

export interface UpdateFileData {
  name?: string;
  description?: string;
  tags?: string[];
  folder?: string;
  isPublic?: boolean;
}

export interface ShareFileData {
  userId?: number;
  permission: 'read' | 'write';
  shareExpiry?: string;
}

export interface ListFilesOptions {
  folder?: string;
  search?: string;
  tags?: string[];
  mimeType?: string;
  limit?: number;
  offset?: number;
}

export interface ListFilesResponse {
  files: FileItem[];
  total: number;
  pagination: {
    limit: number;
    offset: number;
    hasMore: boolean;
  };
}

class FileManagerAPI {
  private static async request(endpoint: string, options: RequestInit = {}) {
    const response = await fetch(endpoint, {
      headers: {
        ...options.headers,
      },
      ...options,
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Request failed' }));
      throw new Error(error.error || `HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }

  static async uploadFile(data: UploadFileData): Promise<FileItem> {
    const formData = new FormData();
    formData.append('file', data.file);
    if (data.folder) formData.append('folder', data.folder);
    if (data.description) formData.append('description', data.description);
    if (data.tags) formData.append('tags', JSON.stringify(data.tags));

    const result = await FileManagerAPI.request('/api/files/upload', {
      method: 'POST',
      body: formData,
    });
    return result.file;
  }

  static async listFiles(options: ListFilesOptions = {}): Promise<ListFilesResponse> {
    const params = new URLSearchParams();
    if (options.folder) params.append('folder', options.folder);
    if (options.search) params.append('search', options.search);
    if (options.mimeType) params.append('mimeType', options.mimeType);
    if (options.tags) params.append('tags', JSON.stringify(options.tags));
    if (options.limit) params.append('limit', options.limit.toString());
    if (options.offset) params.append('offset', options.offset.toString());

    const result = await FileManagerAPI.request(`/api/files?${params.toString()}`);
    return {
      files: result.files,
      total: result.total,
      pagination: result.pagination,
    };
  }

  static async getFile(fileId: number): Promise<FileItem> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}`);
    return result.file;
  }

  static async updateFile(fileId: number, data: UpdateFileData): Promise<FileItem> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return result.file;
  }

  static async deleteFile(fileId: number): Promise<void> {
    await FileManagerAPI.request(`/api/files/${fileId}`, {
      method: 'DELETE',
    });
  }

  static async downloadFile(fileId: number, fileName: string): Promise<void> {
    const response = await fetch(`/api/files/${fileId}/download`);
    if (!response.ok) {
      throw new Error('Failed to download file');
    }

    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  }

  static async analyzeFile(fileId: number): Promise<any> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/analyze`, {
      method: 'POST',
    });
    return result.analysis;
  }

  static async getFileVersions(fileId: number): Promise<FileVersion[]> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/versions`);
    return result.versions;
  }

  static async restoreFileVersion(fileId: number, versionId: number): Promise<void> {
    await FileManagerAPI.request(`/api/files/${fileId}/versions/${versionId}/restore`, {
      method: 'POST',
    });
  }

  static async shareFile(fileId: number, data: ShareFileData): Promise<FilePermission> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/share`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return result;
  }

  static async getFilePermissions(fileId: number): Promise<FilePermission[]> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/permissions`);
    return result.permissions;
  }

  static async getFileAnalytics(fileId: number): Promise<FileAnalytics> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/analytics`);
    return result.analytics;
  }

  static async getFolders(): Promise<string[]> {
    const result = await FileManagerAPI.request('/api/files/folders');
    return result.folders;
  }

  static async bulkDeleteFiles(fileIds: number[]): Promise<{deleted: number; failed: number; message: string}> {
    const result = await FileManagerAPI.request('/api/files/bulk/delete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ fileIds }),
    });
    return result;
  }

  static async reindexFile(fileId: number): Promise<{ success: boolean; message?: string }> {
    const result = await FileManagerAPI.request(`/api/files/${fileId}/reindex`, {
      method: 'POST'
    });
    return result;
  }
}

export const useFileManager = () => {
  const queryClient = useQueryClient();
  const [uploadProgress, setUploadProgress] = useState<number>(0);
  const [isUploading, setIsUploading] = useState(false);
  const abortControllerRef = useRef<AbortController | null>(null);

  // Query for file list
  const useFileList = (options: ListFilesOptions = {}) => {
    return useQuery({
      queryKey: ['files', options],
      queryFn: () => FileManagerAPI.listFiles(options),
      staleTime: 1000 * 60 * 5, // 5 minutes
    });
  };

  // Query for single file
  const useFile = (fileId: number | null) => {
    return useQuery({
      queryKey: ['file', fileId],
      queryFn: () => fileId ? FileManagerAPI.getFile(fileId) : null,
      enabled: !!fileId,
    });
  };

  // Query for file versions
  const useFileVersions = (fileId: number | null) => {
    return useQuery({
      queryKey: ['fileVersions', fileId],
      queryFn: () => fileId ? FileManagerAPI.getFileVersions(fileId) : [],
      enabled: !!fileId,
    });
  };

  // Query for file permissions
  const useFilePermissions = (fileId: number | null) => {
    return useQuery({
      queryKey: ['filePermissions', fileId],
      queryFn: () => fileId ? FileManagerAPI.getFilePermissions(fileId) : [],
      enabled: !!fileId,
    });
  };

  // Query for file analytics
  const useFileAnalytics = (fileId: number | null) => {
    return useQuery({
      queryKey: ['fileAnalytics', fileId],
      queryFn: () => fileId ? FileManagerAPI.getFileAnalytics(fileId) : null,
      enabled: !!fileId,
    });
  };

  // Query for folders
  const useFolders = () => {
    return useQuery({
      queryKey: ['folders'],
      queryFn: FileManagerAPI.getFolders,
      staleTime: 1000 * 60 * 10, // 10 minutes
    });
  };

  // Upload file mutation
  const uploadFileMutation = useMutation({
    mutationFn: FileManagerAPI.uploadFile,
    onMutate: () => {
      setIsUploading(true);
      setUploadProgress(0);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
      queryClient.invalidateQueries({ queryKey: ['folders'] });
      setUploadProgress(100);
    },
    onError: (error) => {
      console.error('Upload failed:', error);
      setUploadProgress(0);
    },
    onSettled: () => {
      setIsUploading(false);
      setTimeout(() => setUploadProgress(0), 1000);
    },
  });

  // Update file mutation
  const updateFileMutation = useMutation({
    mutationFn: ({ fileId, data }: { fileId: number; data: UpdateFileData }) =>
      FileManagerAPI.updateFile(fileId, data),
    onSuccess: (updatedFile) => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
      queryClient.invalidateQueries({ queryKey: ['file', updatedFile.id] });
      queryClient.invalidateQueries({ queryKey: ['folders'] });
    },
  });

  // Delete file mutation
  const deleteFileMutation = useMutation({
    mutationFn: FileManagerAPI.deleteFile,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
      queryClient.invalidateQueries({ queryKey: ['folders'] });
    },
  });

  // Analyze file mutation
  const analyzeFileMutation = useMutation({
    mutationFn: FileManagerAPI.analyzeFile,
    onSuccess: (analysis, fileId) => {
      queryClient.invalidateQueries({ queryKey: ['file', fileId] });
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });

  // Restore file version mutation
  const restoreVersionMutation = useMutation({
    mutationFn: ({ fileId, versionId }: { fileId: number; versionId: number }) =>
      FileManagerAPI.restoreFileVersion(fileId, versionId),
    onSuccess: (_, { fileId }) => {
      queryClient.invalidateQueries({ queryKey: ['file', fileId] });
      queryClient.invalidateQueries({ queryKey: ['fileVersions', fileId] });
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });

  // Share file mutation
  const shareFileMutation = useMutation({
    mutationFn: ({ fileId, data }: { fileId: number; data: ShareFileData }) =>
      FileManagerAPI.shareFile(fileId, data),
    onSuccess: (_, { fileId }) => {
      queryClient.invalidateQueries({ queryKey: ['filePermissions', fileId] });
    },
  });

  // Bulk delete mutation
  const bulkDeleteMutation = useMutation({
    mutationFn: FileManagerAPI.bulkDeleteFiles,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
      queryClient.invalidateQueries({ queryKey: ['folders'] });
    },
  });

  // Reindex file embeddings mutation
  const reindexFileMutation = useMutation({
    mutationFn: FileManagerAPI.reindexFile,
    onSuccess: () => {
      // Not much to invalidate; embeddings aren't listed here
      // But we can refresh files to update any timestamps shown
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });

  // Upload file with progress tracking
  const uploadFile = useCallback(async (data: UploadFileData) => {
    try {
      // Simulate progress for now - in a real implementation, you'd track actual upload progress
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => Math.min(prev + 10, 90));
      }, 100);

      const result = await uploadFileMutation.mutateAsync(data);
      
      clearInterval(progressInterval);
      setUploadProgress(100);
      
      return result;
    } catch (error) {
      setUploadProgress(0);
      throw error;
    }
  }, [uploadFileMutation]);

  // Download file
  const downloadFile = useCallback(async (fileId: number, fileName: string) => {
    try {
      await FileManagerAPI.downloadFile(fileId, fileName);
    } catch (error) {
      console.error('Download failed:', error);
      throw error;
    }
  }, []);

  // Cancel upload
  const cancelUpload = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    setIsUploading(false);
    setUploadProgress(0);
  }, []);

  return {
    // Query hooks
    useFileList,
    useFile,
    useFileVersions,
    useFilePermissions,
    useFileAnalytics,
    useFolders,

    // Upload state
    isUploading,
    uploadProgress,
    
    // File operations
    uploadFile,
    downloadFile,
    updateFile: updateFileMutation.mutate,
    deleteFile: deleteFileMutation.mutate,
    analyzeFile: analyzeFileMutation.mutate,
    restoreFileVersion: restoreVersionMutation.mutate,
    shareFile: shareFileMutation.mutate,
    bulkDeleteFiles: bulkDeleteMutation.mutate,
    reindexFile: reindexFileMutation.mutate,
    cancelUpload,

    // Mutation states
    isUpdating: updateFileMutation.isPending,
    isDeleting: deleteFileMutation.isPending,
    isAnalyzing: analyzeFileMutation.isPending,
    isRestoring: restoreVersionMutation.isPending,
    isSharing: shareFileMutation.isPending,
    isBulkDeleting: bulkDeleteMutation.isPending,
    isReindexing: reindexFileMutation.isPending,

    // Error states
    uploadError: uploadFileMutation.error,
    updateError: updateFileMutation.error,
    deleteError: deleteFileMutation.error,
    analyzeError: analyzeFileMutation.error,
    restoreError: restoreVersionMutation.error,
    shareError: shareFileMutation.error,
    bulkDeleteError: bulkDeleteMutation.error,
    reindexError: reindexFileMutation.error,
  };
};

================
File: client/src/hooks/useGemini.ts
================
import { GeminiService } from "../lib/gemini";
import { ChatCompletionOptions, LLMModel } from "../types";
import { User } from "./useAuth";
import { useAI, AIOptions, AIProviderConfig, UseAIReturn } from "./useAI";
import { SYSTEM_MESSAGE_PRESETS } from "./useAzureAI";

// Enhanced AI options with user context (extends generic AIOptions)
export interface GeminiOptions extends AIOptions {}

// Gemini provider configuration
const geminiConfig: AIProviderConfig<GeminiService> = {
  selectedModelKey: 'gemini-selected-model',
  apiKeyKey: 'gemini-api-key',
  providerName: 'Gemini',
  
  defaultModel: {
    id: "gemini-2.5-flash",
    name: "Gemini 2.5 Flash",
    provider: "Google",
    performance: 85,
    cost: 0.00025,
    latency: 500,
    contextLength: 1000000,
    description: "Fast and efficient Gemini model for general tasks",
    category: "text",
    tier: "freemium",
    isFavorite: false,
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false
    }
  },
  
  createService: (config: any) => new GeminiService(config),
  
  buildServiceConfig: (options: GeminiOptions, selectedLLMModel?: LLMModel | null) => {
    // Try to get API key from options first, then from localStorage
    const apiKey = options.apiKey || localStorage.getItem('gemini-api-key');
    
    if (!apiKey) {
      throw new Error("Gemini API key not configured. Please set your API key in settings.");
    }

    return {
      apiKey,
      modelName: selectedLLMModel?.id || "gemini-2.5-flash"
    };
  },
  
  updateServiceModel: (service: GeminiService, modelId: string) => {
    service.updateModel(modelId);
  },
  
  getCurrentModel: (service: GeminiService) => service.getCurrentModel(),
  
  defaultCapabilities: {
    supportsVision: true,
    supportsCodeGeneration: true,
    supportsAnalysis: true,
    supportsImageGeneration: false,
    supportsSystemMessages: true,
    supportsJSONMode: true,
    supportsFunctionCalling: true,
    supportsStreaming: true,
    supportsStop: true,
    supportsLogitBias: false,
    supportsFrequencyPenalty: false,
    supportsPresencePenalty: false
  }
};

// Type alias for the return interface
export type UseGeminiReturn = UseAIReturn<GeminiService>;

/**
 * Gemini provider hook using the generic useAI implementation.
 * Provides Gemini-specific configuration while leveraging shared logic.
 */
export const useGemini = (options: GeminiOptions = {}): UseGeminiReturn => {
  return useAI(geminiConfig, options);
};

================
File: client/src/hooks/useHuggingFace.ts
================
import { HuggingFaceService } from "../lib/huggingface";
import { ChatCompletionOptions, LLMModel } from "../types";
import { SYSTEM_MESSAGE_PRESETS } from "./useAzureAI";
import { User } from "./useAuth";
import { useAI, AIOptions, AIProviderConfig, UseAIReturn } from "./useAI";

// Enhanced AI options with user context (extends generic AIOptions)
export interface HuggingFaceOptions extends AIOptions {
  isUterpi?: boolean; // Special flag for Uterpi endpoint
}

// HuggingFace provider configuration
const huggingFaceConfig: AIProviderConfig<HuggingFaceService> = {
  selectedModelKey: 'hf-selected-model',
  apiTokenKey: 'hf-api-token',
  endpointUrlKey: 'hf-endpoint-url',
  providerName: 'Hugging Face',
  
  defaultModel: {
    id: "hf-endpoint",
    name: "HuggingFace",
    provider: "Hugging Face",
    performance: 80,
    cost: 0,
    latency: 800,
    contextLength: 16384,
    description: "Uses your configured Inference Endpoint",
    category: "text",
    tier: "pro",
    isFavorite: false,
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false
    }
  },
  
  createService: (config: any) => new HuggingFaceService(config),
  
  buildServiceConfig: (options: HuggingFaceOptions, selectedLLMModel?: LLMModel | null) => {
    const apiToken = options.apiToken || localStorage.getItem('hf-api-token') || (import.meta as any).env?.VITE_HF_API_TOKEN;
    const endpointUrl = options.endpointUrl || localStorage.getItem('hf-endpoint-url') || (import.meta as any).env?.VITE_HF_ENDPOINT_URL;
    
    if (!apiToken) throw new Error("Hugging Face API token not configured. Set it in settings.");
    if (!endpointUrl) throw new Error("Hugging Face endpoint URL not configured. Set it in settings.");
    
    return {
      endpointUrl,
      apiToken,
      modelName: selectedLLMModel?.id || "hf-endpoint"
    };
  },
  
  updateServiceModel: (service: HuggingFaceService, modelId: string) => {
    service.updateModel(modelId);
  },
  
  getCurrentModel: (service: HuggingFaceService) => service.getCurrentModel(),
  
  defaultCapabilities: {
    supportsVision: false,
    supportsCodeGeneration: true,
    supportsAnalysis: true,
    supportsImageGeneration: false,
    supportsSystemMessages: true,
    supportsJSONMode: false,
    supportsFunctionCalling: false,
    supportsStreaming: false,
    supportsStop: false,
    supportsLogitBias: false,
    supportsFrequencyPenalty: false,
    supportsPresencePenalty: false
  }
};

// Special Uterpi configuration (variant of HuggingFace)
const createUterpiConfig = (options: HuggingFaceOptions): AIProviderConfig<HuggingFaceService> => {
  const baseConfig = { ...huggingFaceConfig };
  
  // Override default model for Uterpi
  baseConfig.defaultModel = {
    ...baseConfig.defaultModel,
    name: "Uterpi Endpoint",
    provider: "Uterpi",
    description: "Uses the managed Uterpi Inference Endpoint"
  };
  
  baseConfig.providerName = 'Uterpi';
  
  return baseConfig;
};

// Type alias for the return interface
export type UseHuggingFaceReturn = UseAIReturn<HuggingFaceService>;

/**
 * HuggingFace provider hook using the generic useAI implementation.
 * Provides HuggingFace-specific configuration while leveraging shared logic.
 * Supports both regular HuggingFace and Uterpi endpoints.
 */
export const useHuggingFace = (options: HuggingFaceOptions = {}): UseHuggingFaceReturn => {
  // Determine if this is a Uterpi instance
  const uterpiToken = (import.meta as any).env?.VITE_UTERPI_API_TOKEN;
  const uterpiUrl = (import.meta as any).env?.VITE_UTERPI_ENDPOINT_URL;
  const isUterpi = options.isUterpi || (!!options.apiToken && !!options.endpointUrl && options.apiToken === uterpiToken && options.endpointUrl === uterpiUrl);
  
  // Use appropriate configuration based on whether this is Uterpi or regular HuggingFace
  const config = isUterpi ? createUterpiConfig(options) : huggingFaceConfig;
  
  return useAI(config, options);
};

================
File: client/src/hooks/useIntelligentToast.ts
================
import { useEffect, useRef, useCallback } from 'react';
import { IntelligentToastService } from '../lib/intelligentToastService';
import { AzureAIService } from '../lib/azureAI';
import { Message, LLMModel } from '../types';
import { useAICoach } from './useAICoach';

interface UseIntelligentToastOptions {
  enabled?: boolean;
  aiService?: AzureAIService | null;
  toastFunction?: (title: string, options?: {
    description?: string;
    duration?: number;
    action?: {
      label: string;
      onClick: () => void;
    };
  }) => void;
  onModelSwitch?: (modelId: string) => void;
  onNewChat?: () => void;
}

export const useIntelligentToast = (options: UseIntelligentToastOptions) => {
  const { enabled = true, aiService, toastFunction, onModelSwitch, onNewChat } = options;
  const serviceRef = useRef<IntelligentToastService | null>(null);
  const lastAnalysisTimeRef = useRef<number>(0);
  
  // Integrate AI Coach for strategic insights
  const aiCoach = useAICoach({
    enabled: enabled && !!aiService,
    autoFetch: true,
    pollingInterval: 30000, // Check for new insights every 30 seconds
  });

  // Initialize/reinitialize intelligent toast service when AI service becomes available
  useEffect(() => {
    if (enabled && aiService && !serviceRef.current) {
      serviceRef.current = new IntelligentToastService(aiService, toastFunction, onModelSwitch, onNewChat);
    }
  }, [enabled, aiService, toastFunction, onModelSwitch, onNewChat]);

  // Analyze conversation with AI Coach integration
  const analyzeConversation = useCallback(async (
    messages: Message[],
    currentModel: LLMModel,
    responseTime?: number,
    tokenUsage?: number,
    isChatActive?: boolean
  ) => {
    if (!serviceRef.current || !enabled || !aiService) {
      console.log('‚ö†Ô∏è IntelligentToast analysis skipped - service not ready');
      return;
    }

    // Skip analysis if chat is currently active to prevent interference
    if (isChatActive) {
      console.log('‚è∏Ô∏è IntelligentToast analysis deferred - chat is active');
      return;
    }

    const now = Date.now();
    // Reduce minimum time between analyses to 15 seconds for better responsiveness
    if (now - lastAnalysisTimeRef.current < 15000) {
      console.log('‚ö†Ô∏è IntelligentToast analysis skipped - too frequent');
      return;
    }

    lastAnalysisTimeRef.current = now;
    console.log('üîç Starting intelligent conversation analysis...');
    
    // Run both traditional analysis and AI Coach analysis in parallel
    await Promise.all([
      serviceRef.current.analyzeAndRecommend(messages, currentModel, responseTime, tokenUsage),
      aiCoach.analyzeConversation(messages, currentModel, responseTime, tokenUsage)
    ]);
  }, [enabled, aiService, aiCoach]);

  // Track user actions with AI Coach integration
  const trackAction = useCallback((action: string, data?: any) => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.trackAction(action, data);
    
    // Also track with AI Coach for workflow analysis
    if (action === 'model_switch' && data?.fromModel && data?.toModel) {
      aiCoach.trackModelSwitch(data.fromModel, data.toModel, data.reason);
    } else if (action === 'command' || action === 'chat_message') {
      aiCoach.trackCommand(action, data?.model, data?.success);
    }
  }, [enabled, aiCoach]);

  // Get performance insights
  const getInsights = useCallback(() => {
    if (!serviceRef.current || !enabled) return null;
    return serviceRef.current.getPerformanceInsights();
  }, [enabled]);

  // Reset session data
  const resetSession = useCallback(() => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.resetSession();
  }, [enabled]);

  // Clear recommendation cache (for testing)
  const clearRecommendationCache = useCallback(() => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.clearRecommendationCache();
  }, [enabled]);

  // Force clear cache for specific recommendation (for testing)
  const forceClearRecommendation = useCallback((recommendationId: string) => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.forceClearRecommendation(recommendationId);
  }, [enabled]);

  // Force clear all insight caches (for testing)
  const forceClearInsightCaches = useCallback(() => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.forceClearInsightCaches();
  }, [enabled]);

  // Test show recommendation (for debugging)
  const testShowRecommendation = useCallback((title: string, description: string, category: 'insight' | 'suggestion' | 'alert' = 'insight') => {
    if (!serviceRef.current || !enabled) return;
    serviceRef.current.testShowRecommendation(title, description, category);
  }, [enabled]);

  // Get recommendation cache status (for debugging)
  const getRecommendationCacheStatus = useCallback(() => {
    if (!serviceRef.current || !enabled) return null;
    return serviceRef.current.getRecommendationCacheStatus();
  }, [enabled]);

  // Show immediate optimization tip with AI Coach enhancement
  const showOptimizationTip = useCallback((tip: string, action?: () => void) => {
    if (!enabled) return;
    
    // Use AI Coach's optimization tip if available
    if (aiCoach.showOptimizationTip) {
      aiCoach.showOptimizationTip(tip, action);
    } else if (toastFunction) {
      toastFunction("üöÄ Optimization Tip", {
        description: tip,
        duration: 8000,
        action: action ? {
          label: "Apply",
          onClick: action
        } : undefined
      });
    }
  }, [enabled, toastFunction, aiCoach]);

  // Show performance alert
  const showPerformanceAlert = useCallback((message: string, severity: 'low' | 'medium' | 'high' = 'medium') => {
    if (!enabled) return;

    const icons = { low: 'üí°', medium: '‚ö°', high: '‚ö†Ô∏è' };
    const durations = { low: 6000, medium: 8000, high: 10000 };

    if (toastFunction) {
      toastFunction(`${icons[severity]} Performance Alert`, {
        description: message,
        duration: durations[severity]
      });
    }
  }, [enabled, toastFunction]);

  return {
    analyzeConversation,
    trackAction,
    getInsights,
    resetSession,
    clearRecommendationCache,
    forceClearRecommendation,
    forceClearInsightCaches,
    testShowRecommendation,
    getRecommendationCacheStatus,
    showOptimizationTip,
    showPerformanceAlert,
    isEnabled: enabled && !!serviceRef.current,
    // AI Coach specific methods
    aiCoach: {
      insights: aiCoach.insights,
      workflowStats: aiCoach.workflowStats,
      getStrategicAdvice: aiCoach.getStrategicAdvice,
      recordFeedback: aiCoach.recordFeedback,
      applyRecommendation: aiCoach.applyRecommendation,
    }
  };
};

================
File: client/src/hooks/useLMStudio.ts
================
import { useCallback } from "react";
import { LMStudioService } from "../lib/lmstudio";
import { ChatCompletionOptions, LLMModel } from "../types";
import { User } from "./useAuth";
import { useAI, AIOptions, AIProviderConfig, UseAIReturn } from "./useAI";
import { SYSTEM_MESSAGE_PRESETS } from "./useAzureAI";

// Enhanced AI options with user context (extends generic AIOptions)
export interface LMStudioOptions extends AIOptions {}

// LMStudio provider configuration
const lmStudioConfig: AIProviderConfig<LMStudioService> = {
  selectedModelKey: 'lmstudio-selected-model',
  apiKeyKey: 'lmstudio-api-key',
  baseUrlKey: 'lmstudio-base-url',
  providerName: 'LM Studio',
  
  defaultModel: {
    id: "nomadic-icdu-v8",
    name: "Uterpi AI",
    provider: "Uterpi AI via LM Studio",
    performance: 99,
    cost: 0,
    latency: 250,
    contextLength: 128000,
    description: "Uterpi AI served through LM Studio (OpenAI-compatible endpoint)",
    category: "text",
    tier: "freemium",
    isFavorite: true,
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false
    }
  },
  
  createService: (config: any) => new LMStudioService(config),
  
  buildServiceConfig: (options: LMStudioOptions, selectedLLMModel?: LLMModel | null) => {
    const apiKey =
      options.apiKey ||
      localStorage.getItem('lmstudio-api-key') ||
      (import.meta as any).env?.VITE_LMSTUDIO_API_KEY ||
      'lm-studio';
    const baseUrl =
      options.baseUrl ||
      localStorage.getItem('lmstudio-base-url') ||
      (import.meta as any).env?.VITE_LMSTUDIO_BASE_URL ||
      'https://lmstudio.uterpi.com';
    
      const modelName = selectedLLMModel?.id || lmStudioConfig.defaultModel.id;

      return { apiKey, baseUrl, modelName };
  },
  
  updateServiceModel: (service: LMStudioService, modelId: string) => {
    service.updateModel(modelId);
  },
  
  getCurrentModel: (service: LMStudioService) => service.getCurrentModel(),
  
  defaultCapabilities: {
    supportsVision: false,
    supportsCodeGeneration: true,
    supportsAnalysis: true,
    supportsImageGeneration: false,
    supportsSystemMessages: true,
    supportsJSONMode: false,
    supportsFunctionCalling: false,
    supportsStreaming: true,
    supportsStop: true,
    supportsLogitBias: false,
    supportsFrequencyPenalty: true,
    supportsPresencePenalty: true
  }
};

// Type alias for the return interface
export type UseLMStudioReturn = UseAIReturn<LMStudioService>;

/**
 * LM Studio provider hook using the generic useAI implementation.
 * Provides LM Studio-specific configuration while leveraging shared logic.
 * Includes special fallback handling for streaming failures.
 */
export const useLMStudio = (options: LMStudioOptions = {}): UseLMStudioReturn => {
  const baseHook = useAI(lmStudioConfig, options);
  
  // Override sendStreamingMessage to include LM Studio-specific fallback logic
  const sendStreamingMessage = useCallback(async (
    messages: any[],
    onChunk: (chunk: string) => void
  ): Promise<void> => {
    try {
      await baseHook.sendStreamingMessage(messages, onChunk);
    } catch (streamErr) {
      // Fallback to non-streaming if streaming fails (e.g., tunnel issues)
      try {
        const response = await baseHook.sendMessage(messages);
        if (response) {
          onChunk(response);
        }
      } catch (fallbackErr) {
        // If fallback also fails, throw the original streaming error
        throw streamErr;
      }
    }
  }, [baseHook]);

  return {
    ...baseHook,
    sendStreamingMessage,
  };
};

================
File: client/src/hooks/useOpenAI.ts
================
import { OpenAIService } from "../lib/openAI";
import { ChatCompletionOptions, LLMModel } from "../types";
import { User } from "./useAuth";
import { useAI, AIOptions, AIProviderConfig, UseAIReturn } from "./useAI";
import { SYSTEM_MESSAGE_PRESETS } from "./useAzureAI";

// Enhanced AI options with user context (extends generic AIOptions)
export interface OpenAIOptions extends AIOptions {}

// OpenAI provider configuration
const openAIConfig: AIProviderConfig<OpenAIService> = {
  selectedModelKey: 'openai-selected-model',
  apiKeyKey: 'openai-api-key',
  providerName: 'OpenAI',
  
  defaultModel: {
    id: "gpt-4o-mini",
    name: "GPT-4o Mini",
    provider: "OpenAI",
    performance: 88,
    cost: 0.00015,
    latency: 600,
    contextLength: 128000,
    description: "Efficient and cost-effective GPT-4 model",
    category: "text",
    tier: "freemium",
    isFavorite: true,
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false
    }
  },
  
  createService: (config: any) => new OpenAIService(config),
  
  buildServiceConfig: (options: OpenAIOptions, selectedLLMModel?: LLMModel | null) => {
    // Try to get API key from options first, then from localStorage
    const apiKey = options.apiKey || localStorage.getItem('openai-api-key');
    
    if (!apiKey) {
      throw new Error("OpenAI API key not configured. Please set your API key in settings.");
    }

    return {
      apiKey,
      modelName: selectedLLMModel?.id || "gpt-4o-mini"
    };
  },
  
  updateServiceModel: (service: OpenAIService, modelId: string) => {
    service.updateModel(modelId);
  },
  
  getCurrentModel: (service: OpenAIService) => service.getCurrentModel(),
  
  defaultCapabilities: {
    supportsVision: false,
    supportsCodeGeneration: true,
    supportsAnalysis: true,
    supportsImageGeneration: false,
    supportsSystemMessages: true,
    supportsJSONMode: false,
    supportsFunctionCalling: false,
    supportsStreaming: true,
    supportsStop: true,
    supportsLogitBias: false,
    supportsFrequencyPenalty: true,
    supportsPresencePenalty: true
  }
};

// Type alias for the return interface
export type UseOpenAIReturn = UseAIReturn<OpenAIService>;

/**
 * OpenAI provider hook using the generic useAI implementation.
 * Provides OpenAI-specific configuration while leveraging shared logic.
 */
export const useOpenAI = (options: OpenAIOptions = {}): UseOpenAIReturn => {
  return useAI(openAIConfig, options);
};

================
File: client/src/hooks/useSpeech.ts
================
// Provider-agnostic speech hook for TTS and STT functionality

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAIProvider } from './useAIProvider';
import { SpeechServiceFactory } from '../lib/speech/speechServiceFactory';
import { SpeechOrchestrator } from '../lib/speech/SpeechOrchestrator';
import {
  ISpeechService,
  SpeechConfig,
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  VoiceInfo,
  SpeechServiceCapabilities
} from '../types/speech';
import { isHTTPS, getMicrophonePermission } from '../lib/speech/speechUtils';

interface UseSpeechOptions extends SpeechConfig {
  autoInitialize?: boolean;
  onRecognitionResult?: (result: SpeechRecognitionResult) => void;
  onRecognitionError?: (error: Error) => void;
  onSynthesisComplete?: () => void;
  onSynthesisError?: (error: Error) => void;
}

interface UseSpeechReturn {
  // TTS Methods
  speak: (text: string, options?: TTSOptions) => Promise<void>;
  stopSpeaking: () => void;
  isSpeaking: boolean;
  
  // STT Methods
  startListening: (options?: STTOptions) => Promise<void>;
  stopListening: () => Promise<string>;
  isListening: boolean;
  transcript: string;
  interimTranscript: string;
  
  // Voice Management
  voices: VoiceInfo[];
  selectedVoice: VoiceInfo | null;
  setVoice: (voice: VoiceInfo | string) => void;
  
  // Service Info
  isAvailable: boolean;
  capabilities: SpeechServiceCapabilities | null;
  currentProvider: string;
  isHTTPS: boolean;
  microphonePermission: PermissionState | 'unsupported';
  
  // Control Methods
  initialize: () => Promise<void>;
  dispose: () => void;
  
  // Error state
  error: string | null;
}

export const useSpeech = (options: UseSpeechOptions = {}): UseSpeechReturn => {
  const { currentProvider } = useAIProvider();
  const [ttsService, setTtsService] = useState<ISpeechService | null>(null);
  const [sttService, setSttService] = useState<ISpeechService | null>(null);
  const orchestratorRef = useRef<SpeechOrchestrator | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState('');
  const [interimTranscript, setInterimTranscript] = useState('');
  const [voices, setVoices] = useState<VoiceInfo[]>([]);
  const [selectedVoice, setSelectedVoice] = useState<VoiceInfo | null>(null);
  const [capabilities, setCapabilities] = useState<SpeechServiceCapabilities | null>(null);
  const [isAvailable, setIsAvailable] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [microphonePermission, setMicrophonePermission] = useState<PermissionState | 'unsupported'>('prompt');
  
  const abortController = useRef<AbortController | null>(null);

  // Initialize speech service based on current AI provider
  const initialize = useCallback(async () => {
    try {
      setError(null);
      
      // Check HTTPS requirement for Web Speech API
      if (!isHTTPS()) {
        const warningMsg = 'Speech recognition requires HTTPS. Microphone access may be limited on HTTP.';
        console.warn(warningMsg);
        setError(warningMsg);
      }
      
      // Check microphone permission
      const permission = await getMicrophonePermission();
      setMicrophonePermission(permission);
      
      // Pick best per-capability services
      const [bestTTS, bestSTT] = await Promise.all([
        SpeechServiceFactory.getBestServiceFor(currentProvider, 'tts', options),
        SpeechServiceFactory.getBestServiceFor(currentProvider, 'stt', options)
      ]);

      await Promise.all([
        bestTTS.initialize(options),
        bestSTT.initialize(options)
      ]);
      
      // Set up recognition callbacks
      // Initialize orchestrator for resilient STT
      orchestratorRef.current = new SpeechOrchestrator({
        aiProvider: currentProvider,
        onResult: (result) => {
          // Always update transcript with the latest result
          setTranscript(result.transcript);
          if (result.isFinal) {
            setInterimTranscript('');
          } else {
            setInterimTranscript(result.transcript);
          }
          if (options.onRecognitionResult) {
            options.onRecognitionResult(result);
          }
        },
        progressTimeoutMs: 30000, // 30 seconds timeout for natural speech pauses
        maxRestartsPerMinute: 10
      });
      await orchestratorRef.current.initialize(options);
      
      setTtsService(bestTTS);
      setSttService(bestSTT);
      setIsAvailable(bestTTS.isAvailable() || bestSTT.isAvailable());
      // Merge capabilities conservatively
      const ttsCaps = bestTTS.getCapabilities();
      const sttCaps = bestSTT.getCapabilities();
      setCapabilities({
        supportsTTS: ttsCaps.supportsTTS,
        supportsSTT: sttCaps.supportsSTT,
        supportsStreaming: ttsCaps.supportsStreaming || sttCaps.supportsStreaming,
        supportsVoiceCloning: ttsCaps.supportsVoiceCloning || sttCaps.supportsVoiceCloning,
        supportsEmotions: ttsCaps.supportsEmotions || sttCaps.supportsEmotions,
        supportsMultiLanguage: ttsCaps.supportsMultiLanguage || sttCaps.supportsMultiLanguage,
        availableVoices: ttsCaps.availableVoices?.length ? ttsCaps.availableVoices : sttCaps.availableVoices,
        availableLanguages: Array.from(new Set([...(ttsCaps.availableLanguages||[]), ...(sttCaps.availableLanguages||[])]))
      });
      
      // Load available voices
      const availableVoices = await bestTTS.getAvailableVoices();
      setVoices(availableVoices);
      
      // Select default voice
      if (availableVoices.length > 0 && !selectedVoice) {
        const defaultVoice = availableVoices.find(v => v.isDefault) || availableVoices[0];
        setSelectedVoice(defaultVoice);
      }
      
      setIsInitialized(true);
    } catch (error) {
      console.error('Failed to initialize speech service:', error);
      setIsAvailable(false);
      setError((error as Error).message);
      if (options.onRecognitionError) {
        options.onRecognitionError(error as Error);
      }
    }
  }, [currentProvider, options]);

  // Auto-initialize on mount if requested
  useEffect(() => {
    if (options.autoInitialize !== false) {
      initialize();
    }
    
    return () => {
      dispose();
    };
  }, [currentProvider]);

  // Speak text using TTS
  const speak = useCallback(async (text: string, ttsOptions?: TTSOptions) => {
    if (!ttsService || !isInitialized) {
      await initialize();
      if (!ttsService) {
        throw new Error('Speech service not available');
      }
    }

    setIsSpeaking(true);
    abortController.current = new AbortController();

    try {
      const speakOptions: TTSOptions = {
        ...ttsOptions,
        voice: selectedVoice?.id || ttsOptions?.voice
      };

      await ttsService!.synthesizeSpeech(text, speakOptions);
      
      if (options.onSynthesisComplete) {
        options.onSynthesisComplete();
      }
    } catch (error) {
      console.error('Speech synthesis error:', error);
      if (options.onSynthesisError) {
        options.onSynthesisError(error as Error);
      }
      throw error;
    } finally {
      setIsSpeaking(false);
      abortController.current = null;
    }
  }, [ttsService, isInitialized, selectedVoice, options, initialize]);

  // Stop speaking
  const stopSpeaking = useCallback(() => {
    ttsService?.cancelSynthesis();
    if (abortController.current) {
      abortController.current.abort();
    }
    setIsSpeaking(false);
  }, [ttsService]);

  // Start listening for speech input
  const startListening = useCallback(async (sttOptions?: STTOptions) => {
    if (!orchestratorRef.current || !isInitialized) {
      await initialize();
      if (!orchestratorRef.current) {
        throw new Error('Speech service not available');
      }
    }

    if (isListening) {
      return;
    }
    
    // Check HTTPS and permission
    if (!isHTTPS() && microphonePermission !== 'granted') {
      const error = new Error('Microphone access requires HTTPS or previously granted permission');
      setError(error.message);
      if (options.onRecognitionError) {
        options.onRecognitionError(error);
      }
      throw error;
    }

    setIsListening(true);
    setTranscript('');
    setInterimTranscript('');
    setError(null);

    try {
      await orchestratorRef.current!.start(sttOptions);
    } catch (error) {
      console.error('Failed to start recognition:', error);
      setIsListening(false);
      setError((error as Error).message);
      if (options.onRecognitionError) {
        options.onRecognitionError(error as Error);
      }
      throw error;
    }
  }, [sttService, isInitialized, isListening, microphonePermission, options, initialize]);

  // Stop listening and get final transcript
  const stopListening = useCallback(async (): Promise<string> => {
    if (!orchestratorRef.current || !isListening) {
      return transcript;
    }

    try {
      const result = await orchestratorRef.current.stop();
      setTranscript(result.transcript);
      setInterimTranscript('');
      return result.transcript;
    } catch (error) {
      console.error('Failed to stop recognition:', error);
      if (options.onRecognitionError) {
        options.onRecognitionError(error as Error);
      }
      return transcript;
    } finally {
      setIsListening(false);
    }
  }, [sttService, isListening, transcript, options]);

  // Set voice by VoiceInfo or voice ID
  const setVoice = useCallback((voice: VoiceInfo | string) => {
    if (typeof voice === 'string') {
      const foundVoice = voices.find(v => v.id === voice || v.name === voice);
      if (foundVoice) {
        setSelectedVoice(foundVoice);
      }
    } else {
      setSelectedVoice(voice);
    }
  }, [voices]);

  // Dispose of resources
  const dispose = useCallback(() => {
    if (ttsService) { ttsService.dispose(); }
    if (orchestratorRef.current) { orchestratorRef.current.dispose(); }
    stopSpeaking();
    if (isListening) {
      stopListening();
    }
    setTtsService(null);
    setSttService(null);
    setIsInitialized(false);
  }, [ttsService, sttService, isListening, stopSpeaking, stopListening]);

  // Get current speech provider name
  const getCurrentProviderName = useCallback((): string => {
    const speechProvider = SpeechServiceFactory.mapAIProviderToSpeechProvider(currentProvider);
    return speechProvider.charAt(0).toUpperCase() + speechProvider.slice(1);
  }, [currentProvider]);

  return {
    // TTS Methods
    speak,
    stopSpeaking,
    isSpeaking,
    
    // STT Methods
    startListening,
    stopListening,
    isListening,
    transcript,
    interimTranscript,
    
    // Voice Management
    voices,
    selectedVoice,
    setVoice,
    
    // Service Info
    isAvailable,
    capabilities,
    currentProvider: getCurrentProviderName(),
    isHTTPS: isHTTPS(),
    microphonePermission,
    
    // Control Methods
    initialize,
    dispose,
    
    // Error state
    error
  };
};

================
File: client/src/hooks/useSubscription.ts
================
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from './useAuth';

export interface SubscriptionPlan {
  id: number;
  name: string;
  description: string;
  price: string;
  interval: 'month' | 'year';
  features: string[];
  stripePriceId: string;
  stripeProductId: string;
  isActive: boolean;
  sortOrder: number;
}

export interface SubscriptionStatus {
  status: 'freemium' | 'active' | 'trialing' | 'past_due' | 'canceled' | 'expired';
  tier: string;
  endsAt?: string;
  plan?: SubscriptionPlan;
  details?: any;
}

export interface SubscriptionError {
  code: string;
  message: string;
  redirectTo?: string;
  reason?: string;
}

interface UseSubscriptionReturn {
  // Status
  subscription: SubscriptionStatus | null;
  plans: SubscriptionPlan[];
  isLoading: boolean;
  error: string | null;
  
  // Checks
  hasActiveSubscription: boolean;
  isTrialing: boolean;
  isPastDue: boolean;
  needsPaymentUpdate: boolean;
  canAccessFeature: (requiredTier?: string) => boolean;
  
  // Actions
  refreshSubscription: () => Promise<void>;
  loadPlans: () => Promise<void>;
  createSubscription: (planId: number, paymentMethodId?: string) => Promise<{ success: boolean; error?: string; clientSecret?: string }>;
  cancelSubscription: (immediate?: boolean) => Promise<{ success: boolean; error?: string }>;
  reactivateSubscription: () => Promise<{ success: boolean; error?: string }>;
  openBillingPortal: () => Promise<{ success: boolean; error?: string }>;
  
  // Setup
  createSetupIntent: () => Promise<{ clientSecret?: string; error?: string }>;
}

export const useSubscription = (): UseSubscriptionReturn => {
  const { user } = useAuth();
  const isAuthenticated = !!user;
  const [subscription, setSubscription] = useState<SubscriptionStatus | null>(null);
  const [plans, setPlans] = useState<SubscriptionPlan[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch subscription status
  const refreshSubscription = useCallback(async () => {
    if (!isAuthenticated) {
      setSubscription(null);
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch('/api/subscription/status', {
        method: 'GET',
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error('Failed to fetch subscription status');
      }

      const data = await response.json();
      setSubscription(data.subscription);
    } catch (err) {
      console.error('Error fetching subscription status:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
      setSubscription(null);
    } finally {
      setIsLoading(false);
    }
  }, [isAuthenticated]);

  // Load available plans
  const loadPlans = useCallback(async () => {
    try {
      const response = await fetch('/api/subscription/plans', {
        method: 'GET',
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error('Failed to fetch subscription plans');
      }

      const data = await response.json();
      setPlans(data.plans || []);
    } catch (err) {
      console.error('Error fetching subscription plans:', err);
    }
  }, []);

  // Create setup intent for payment method collection
  const createSetupIntent = useCallback(async () => {
    try {
      const response = await fetch('/api/subscription/setup-intent', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return { error: data.error || 'Failed to create setup intent' };
      }

      return { clientSecret: data.clientSecret };
    } catch (err) {
      return { error: err instanceof Error ? err.message : 'Unknown error' };
    }
  }, []);

  // Create subscription
  const createSubscription = useCallback(async (planId: number, paymentMethodId?: string) => {
    try {
      const response = await fetch('/api/subscription/create', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ planId, paymentMethodId }),
      });

      const data = await response.json();

      if (!response.ok) {
        return { success: false, error: data.error || 'Failed to create subscription' };
      }

      // Refresh subscription status
      await refreshSubscription();

      return { 
        success: true, 
        clientSecret: data.subscription?.clientSecret 
      };
    } catch (err) {
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  }, [refreshSubscription]);

  // Cancel subscription
  const cancelSubscription = useCallback(async (immediate = false) => {
    try {
      const response = await fetch('/api/subscription/cancel', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ immediate }),
      });

      const data = await response.json();

      if (!response.ok) {
        return { success: false, error: data.error || 'Failed to cancel subscription' };
      }

      // Refresh subscription status
      await refreshSubscription();

      return { success: true };
    } catch (err) {
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  }, [refreshSubscription]);

  // Reactivate subscription
  const reactivateSubscription = useCallback(async () => {
    try {
      const response = await fetch('/api/subscription/reactivate', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return { success: false, error: data.error || 'Failed to reactivate subscription' };
      }

      // Refresh subscription status
      await refreshSubscription();

      return { success: true };
    } catch (err) {
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  }, [refreshSubscription]);

  // Open billing portal
  const openBillingPortal = useCallback(async () => {
    try {
      const response = await fetch('/api/subscription/billing-portal', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return { success: false, error: data.error || 'Failed to create billing portal session' };
      }

      // Open billing portal in new tab
      window.open(data.url, '_blank');

      return { success: true };
    } catch (err) {
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  }, []);

  // Access control checks
  const hasActiveSubscription = subscription?.status === 'active' || subscription?.status === 'trialing';
  const isTrialing = subscription?.status === 'trialing';
  const isPastDue = subscription?.status === 'past_due';
  const needsPaymentUpdate = isPastDue;

  const canAccessFeature = useCallback((requiredTier?: string) => {
    // Return false if still loading to prevent flash of wrong content
    if (isLoading) return false;
    
    if (!subscription) return false;
    
    // Check tier hierarchy first - Friends & Family should have premium access
    const tierHierarchy: Record<string, number> = { 
      freemium: 0,
      pro: 2,
      team: 3,
      enterprise: 4,
      // legacy aliases
      basic: 0,
      premium: 2,
      friends_family: 2,
      nomadai_pro: 2,
      'nomadai pro': 2
    };
    
    // Allow access for friends_family tier regardless of status for now (testing phase)
    if (subscription.tier?.toLowerCase() === 'friends_family') {
      return true; // Always allow Friends & Family users during testing
    }
    
    // Freemium users can access freemium features; compare via hierarchy
    if (subscription.tier?.toLowerCase() === 'freemium') {
      const userTierLevel = tierHierarchy['freemium'];
      const requiredTierLevel = requiredTier ? tierHierarchy[requiredTier.toLowerCase()] || 0 : 0;
      return userTierLevel >= requiredTierLevel;
    }
    
    // For paid tiers, check normal subscription logic
    const isActive = subscription?.status === 'active' || subscription?.status === 'trialing';
    if (!isActive) return false;
    
    if (!requiredTier) return true;
    
    const userTierLevel = tierHierarchy[subscription.tier?.toLowerCase()] || 0;
    const requiredTierLevel = tierHierarchy[requiredTier.toLowerCase()] || 0;
    
    return userTierLevel >= requiredTierLevel;
  }, [subscription, isLoading]);

  // Load data on mount and when authentication changes
  useEffect(() => {
    if (isAuthenticated) {
      refreshSubscription();
      loadPlans();
    } else {
      setSubscription(null);
      setIsLoading(false);
    }
  }, [isAuthenticated, refreshSubscription, loadPlans]);

  return {
    // Status
    subscription,
    plans,
    isLoading,
    error,
    
    // Checks
    hasActiveSubscription,
    isTrialing,
    isPastDue,
    needsPaymentUpdate,
    canAccessFeature,
    
    // Actions
    refreshSubscription,
    loadPlans,
    createSubscription,
    cancelSubscription,
    reactivateSubscription,
    openBillingPortal,
    createSetupIntent,
  };
};

================
File: client/src/hooks/useSubscriptionErrors.ts
================
import { useCallback } from 'react';
import { toast } from 'sonner';

interface SubscriptionError {
  code: string;
  message: string;
  redirectTo?: string;
  reason?: string;
  currentTier?: string;
  requiredTier?: string;
}

export const useSubscriptionErrors = () => {
  const handleApiError = useCallback((response: Response, data?: any) => {
    // Check if this is a subscription-related error
    if (response.status === 402) {
      const error: SubscriptionError = data || {};
      
      // Show appropriate toast message
      const title = getErrorTitle(error.code);
      const description = error.message || 'Subscription required';
      
      toast.error(title, {
        description,
        duration: 5000,
        action: error.redirectTo ? {
          label: getActionLabel(error.code),
          onClick: () => {
            window.location.href = error.redirectTo!;
          }
        } : undefined
      });

      // Redirect if specified
      if (error.redirectTo) {
        setTimeout(() => {
          window.location.href = error.redirectTo!;
        }, 2000); // Give time for toast to be seen
      }

      return true; // Indicates error was handled
    }

    return false; // Not a subscription error
  }, []);

  const getErrorTitle = (code?: string): string => {
    switch (code) {
      case 'SUBSCRIPTION_REQUIRED':
        return 'Subscription Required';
      case 'SUBSCRIPTION_EXPIRED':
        return 'Subscription Expired';
      case 'PAYMENT_FAILED':
        return 'Payment Issue';
      case 'PAID_SUBSCRIPTION_REQUIRED':
        return 'Paid Plan Required';
      case 'TIER_UPGRADE_REQUIRED':
        return 'Upgrade Required';
      default:
        return 'Access Denied';
    }
  };

  const getActionLabel = (code?: string): string => {
    switch (code) {
      case 'PAYMENT_FAILED':
        return 'Update Payment';
      case 'SUBSCRIPTION_EXPIRED':
      case 'SUBSCRIPTION_REQUIRED':
      case 'PAID_SUBSCRIPTION_REQUIRED':
      case 'TIER_UPGRADE_REQUIRED':
        return 'Upgrade Now';
      default:
        return 'Learn More';
    }
  };

  // Wrapper for fetch that automatically handles subscription errors
  const protectedFetch = useCallback(async (url: string, options?: RequestInit) => {
    const response = await fetch(url, {
      credentials: 'include',
      ...options,
    });

    if (!response.ok) {
      let data;
      try {
        data = await response.json();
      } catch {
        // Response is not JSON
      }

      // Handle subscription errors
      if (handleApiError(response, data)) {
        throw new Error(`Subscription error: ${data?.message || 'Access denied'}`);
      }

      // For other errors, throw with the message
      throw new Error(data?.message || `HTTP ${response.status}`);
    }

    return response;
  }, [handleApiError]);

  return {
    handleApiError,
    protectedFetch,
  };
};

================
File: client/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24 9.8% 10%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 20 14.3% 4.1%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 60 9.1% 97.8%;
    --primary-foreground: 24 9.8% 10%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 24 5.7% 82.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

/* Custom scrollbar for a modern look */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: hsl(var(--secondary));
  border-radius: 10px;
}

::-webkit-scrollbar-thumb {
  background: hsl(var(--muted-foreground));
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--accent-foreground));
}

@layer utilities {
  .line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }
}

================
File: client/src/lib/azureAI.ts
================
import ModelClient from "@azure-rest/ai-inference";
import { AzureKeyCredential } from "@azure/core-auth";
import { createSseStream } from "@azure/core-sse";
import { AzureAIMessage, AzureAIConfig, ChatCompletionOptions, LLMModel } from "../types";
import { getModelConfiguration, validateModelParameters, getOptimizedParameters } from "./modelConfigurations";

export class AzureAIService {
  private client: any; // ModelClient type issue - using any for now
  private config: AzureAIConfig;

  constructor(config: AzureAIConfig) {
    this.config = config;
    this.client = ModelClient(
      config.endpoint,
      new AzureKeyCredential(config.apiKey)
    );
  }

  /**
   * Update the configuration and client for a new model
   * This handles switching between default Azure AI and fine-tuned models
   */
  updateConfiguration(config: AzureAIConfig): void {
    this.config = config;
    this.client = ModelClient(
      config.endpoint,
      new AzureKeyCredential(config.apiKey)
    );
  }

  /**
   * Update the model name for this service instance
   */
  updateModel(modelName: string): void {
    this.config.modelName = modelName;
  }

  /**
   * Get current model configuration
   */
  getCurrentModel(): string {
    return this.config.modelName;
  }

  /**
   * Get the correct API path based on the current model
   * Fine-tuned models need special deployment paths
   */
  private getApiPath(): string {
    if (this.config.modelName === "breaking-better-v6-1-ft") {
      return "/openai/deployments/5-04-14-ft-af30ee616d674bf7b5ca3e085fe544c4-breaking-better-v6-1/chat/completions?api-version=2025-01-01-preview";
    }
    
    // Default path for regular Azure AI models
    return "/chat/completions";
  }

  /**
   * Estimate token count for messages (rough approximation)
   * This is a simplified estimation - in production, you'd use tiktoken or similar
   */
  private estimateTokenCount(messages: AzureAIMessage[]): number {
    return messages.reduce((total, message) => {
      // Rough estimation: 1 token ‚âà 0.75 words, 1 word ‚âà 1.3 tokens
      const contentTokens = Math.ceil(message.content.length / 4);
      // Add tokens for role and formatting
      return total + contentTokens + 10;
    }, 0);
  }

  /**
   * Truncate conversation history while preserving system message and recent context
   */
  private truncateConversationHistory(messages: AzureAIMessage[], maxTokens: number): AzureAIMessage[] {
    if (messages.length === 0) return messages;
    
    // Always preserve the system message (first message)
    const systemMessage = messages[0];
    let remainingMessages = messages.slice(1);
    
    // Calculate tokens for system message
    let totalTokens = this.estimateTokenCount([systemMessage]);
    
    // Add messages from most recent, working backwards
    const result = [systemMessage];
    for (let i = remainingMessages.length - 1; i >= 0; i--) {
      const messageTokens = this.estimateTokenCount([remainingMessages[i]]);
      if (totalTokens + messageTokens <= maxTokens) {
        totalTokens += messageTokens;
        result.splice(1, 0, remainingMessages[i]); // Insert after system message
      } else {
        console.log(`üîÑ Truncated ${i + 1} older messages to stay within token limit`);
        break;
      }
    }
    
    return result;
  }

  /**
   * Get available Azure AI models
   * Note: This returns a curated list since Azure AI doesn't provide a direct models API
   */
  static getAvailableModels(): LLMModel[] {
    return [
      // Azure OpenAI Models
      {
        id: "gpt-4o",
        name: "GPT-4o",
        provider: "Azure OpenAI",
        performance: 96,
        cost: 0.005,
        latency: 800,
        contextLength: 128000,
        description: "Most advanced GPT-4 model with multimodal capabilities",
        category: "multimodal",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-4o-mini",
        name: "GPT-4o Mini",
        provider: "Azure OpenAI",
        performance: 88,
        cost: 0.00015,
        latency: 600,
        contextLength: 128000,
        description: "Efficient and cost-effective GPT-4 model",
        category: "text",
        tier: "freemium",
        isFavorite: true,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-4-turbo",
        name: "GPT-4 Turbo",
        provider: "Azure OpenAI",
        performance: 94,
        cost: 0.01,
        latency: 1000,
        contextLength: 128000,
        description: "Enhanced GPT-4 model with improved performance",
        category: "text",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-3.5-turbo",
        name: "GPT-3.5 Turbo",
        provider: "Azure OpenAI",
        performance: 82,
        cost: 0.0015,
        latency: 500,
        contextLength: 16000,
        description: "Fast and efficient language model for general tasks",
        category: "text",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      // Fine-tuned Models
      {
        id: "breaking-better-v6-1-ft",
        name: "Breaking Better v6.1 (Fine-tuned)",
        provider: "Azure OpenAI (Fine-tuned)",
        performance: 95,
        cost: 0.01,
        latency: 800,
        contextLength: 128000,
        description: "Custom fine-tuned model optimized for specific tasks",
        category: "text",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      // Microsoft Models
      {
        id: "phi-4",
        name: "Phi-4",
        provider: "Microsoft",
        performance: 85,
        cost: 0.0005,
        latency: 400,
        contextLength: 16384,
        description: "Microsoft's efficient small language model",
        category: "text",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      // Mistral Models
      {
        id: "ministral-3b",
        name: "Ministral 3B",
        provider: "Mistral AI",
        performance: 78,
        cost: 0.0001,
        latency: 300,
        contextLength: 131072,
        description: "Compact and efficient Mistral model",
        category: "text",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "mistral-large-2411",
        name: "Mistral Large 2411",
        provider: "Mistral AI",
        performance: 92,
        cost: 0.008,
        latency: 900,
        contextLength: 128000,
        description: "Latest high-performance Mistral model",
        category: "reasoning",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      // Meta Models
      {
        id: "llama-3.3-70b-instruct",
        name: "Llama 3.3 70B Instruct",
        provider: "Meta",
        performance: 89,
        cost: 0.002,
        latency: 1200,
        contextLength: 128000,
        description: "Meta's latest instruction-tuned model",
        category: "text",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "llama-3.2-11b-vision-instruct",
        name: "Llama 3.2 11B Vision",
        provider: "Meta",
        performance: 84,
        cost: 0.0008,
        latency: 800,
        contextLength: 128000,
        description: "Vision-capable Llama model for multimodal tasks",
        category: "multimodal",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      // Cohere Models
      {
        id: "cohere-command-r-plus",
        name: "Command R+",
        provider: "Cohere",
        performance: 87,
        cost: 0.003,
        latency: 700,
        contextLength: 131072,
        description: "Advanced command-following model from Cohere",
        category: "text",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      }
    ];
  }

  /**
   * Send a single chat completion request
   */
  async sendChatCompletion(
    messages: AzureAIMessage[],
    options: ChatCompletionOptions = {}
  ): Promise<string> {
    try {
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // ESTIMATE TOKEN COUNT TO PREVENT CONTEXT OVERFLOW
      const estimatedTokens = this.estimateTokenCount(messages);
      const maxContextTokens = modelConfig.contextLength || 4096;
      const reserveTokensForResponse = options.maxTokens || 1024;
      
      console.log(`üî¢ Token estimate: ${estimatedTokens}/${maxContextTokens} (reserving ${reserveTokensForResponse} for response)`);
      
      // If we're approaching the token limit, truncate older messages but keep system message
      let processedMessages = messages;
      if (estimatedTokens + reserveTokensForResponse > maxContextTokens) {
        console.warn(`‚ö†Ô∏è Approaching token limit (${estimatedTokens} + ${reserveTokensForResponse} > ${maxContextTokens}), truncating conversation history`);
        processedMessages = this.truncateConversationHistory(messages, maxContextTokens - reserveTokensForResponse);
      }
      
      // Use validated parameters based on the model's capabilities and limits
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Build request body with only supported parameters
      const requestBody: any = {
        messages: processedMessages,
        max_tokens: validatedParams.maxTokens,
        temperature: validatedParams.temperature,
        top_p: validatedParams.topP,
        model: this.config.modelName,
        stream: false,
      };

      // Add optional parameters only if the model supports them
      if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
        requestBody.frequency_penalty = validatedParams.frequencyPenalty;
      }
      
      if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
        requestBody.presence_penalty = validatedParams.presencePenalty;
      }

      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.stop = options.stop;
      }

      if (modelConfig.capabilities.supportsLogitBias && options.logitBias) {
        requestBody.logit_bias = options.logitBias;
      }

      console.log(`Using optimized parameters for ${modelConfig.name} (${modelConfig.provider}):`, {
        max_tokens: requestBody.max_tokens,
        temperature: requestBody.temperature,
        top_p: requestBody.top_p,
        ...(requestBody.frequency_penalty !== undefined && { frequency_penalty: requestBody.frequency_penalty }),
        ...(requestBody.presence_penalty !== undefined && { presence_penalty: requestBody.presence_penalty })
      });

      console.log('üîó Sending Azure AI request:', {
        endpoint: this.config.endpoint,
        model: this.config.modelName,
        messageCount: messages.length
      });

      // ADD DETAILED CONVERSATION LOGGING
      console.log('üìù Full conversation being sent to Azure AI:');
      messages.forEach((msg, index) => {
        console.log(`  [${index}] ${msg.role}: ${msg.content.substring(0, 100)}${msg.content.length > 100 ? '...' : ''}`);
      });

      // Use backend proxy for credit checking
      const response = await fetch('/azure/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ ...requestBody, original_messages: (options as any)?.originalMessages }),
      });

      console.log('üì° Azure AI response status:', response.status);

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        // Extract detailed error information
        const errorDetails = await response.text();
        console.error('‚ùå Azure AI API error details:', errorDetails);
        throw new Error(`Azure AI API error (${response.status}): ${errorDetails}`);
      }

      const responseData = await response.json();
      // Dispatch sources event if backend provided citations
      try {
        const sources = (responseData as any)?.sources;
        if (Array.isArray(sources) && sources.length > 0 && typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('ai-sources', { detail: sources }));
        }
      } catch {}
      
      // Extract credit information if present and emit update
      if (responseData.uterpi_credit_info) {
        const { emitCreditUpdate } = await import('../hooks/useCreditUpdates');
        emitCreditUpdate({
          creditsUsed: responseData.uterpi_credit_info.credits_used,
          remainingBalance: responseData.uterpi_credit_info.remaining_balance
        });
      }
      
      const content = responseData.choices[0]?.message?.content || "";
      console.log('‚úÖ Azure AI response received:', content.substring(0, 100) + '...');
      return content;
    } catch (error) {
      console.error("Azure AI Service Error:", error);
      throw error;
    }
  }

  /**
   * Extract detailed error information from Azure AI response
   */
  private extractErrorDetails(errorBody: any): string {
    if (!errorBody) {
      return 'No error details available';
    }

    // Try different error formats that Azure AI might return
    if (typeof errorBody === 'string') {
      return errorBody;
    }

    if (errorBody.error) {
      if (typeof errorBody.error === 'string') {
        return errorBody.error;
      }
      
      if (errorBody.error.message) {
        return errorBody.error.message;
      }
      
      if (errorBody.error.code && errorBody.error.message) {
        return `${errorBody.error.code}: ${errorBody.error.message}`;
      }
    }

    if (errorBody.message) {
      return errorBody.message;
    }

    if (errorBody.detail) {
      return errorBody.detail;
    }

    // If all else fails, stringify the object safely
    try {
      return JSON.stringify(errorBody, null, 2);
    } catch {
      return 'Unable to parse error details';
    }
  }

  /**
   * Send a streaming chat completion request
   */
  async sendStreamingChatCompletion(
    messages: AzureAIMessage[],
    onChunk: (chunk: string) => void,
    options: ChatCompletionOptions = {}
  ): Promise<void> {
    let reader: ReadableStreamDefaultReader<Uint8Array> | null = null;
    
    try {
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // Use validated parameters based on the model's capabilities and limits
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Build request body with only supported parameters
      const requestBody: any = {
        messages,
        max_tokens: validatedParams.maxTokens,
        temperature: validatedParams.temperature,
        top_p: validatedParams.topP,
        model: this.config.modelName,
        stream: true,
      };

      // Add optional parameters only if the model supports them
      if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
        requestBody.frequency_penalty = validatedParams.frequencyPenalty;
      }
      
      if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
        requestBody.presence_penalty = validatedParams.presencePenalty;
      }

      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.stop = options.stop;
      }

      if (modelConfig.capabilities.supportsLogitBias && options.logitBias) {
        requestBody.logit_bias = options.logitBias;
      }

      console.log(`Using optimized streaming parameters for ${modelConfig.name} (${modelConfig.provider}):`, {
        max_tokens: requestBody.max_tokens,
        temperature: requestBody.temperature,
        top_p: requestBody.top_p,
        ...(requestBody.frequency_penalty !== undefined && { frequency_penalty: requestBody.frequency_penalty }),
        ...(requestBody.presence_penalty !== undefined && { presence_penalty: requestBody.presence_penalty })
      });

      // Use backend proxy for credit checking
      const response = await fetch('/azure/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ ...requestBody, original_messages: (options as any)?.originalMessages }),
      });

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        // Try to read error details from response
        let errorDetails = `HTTP ${response.status}`;
        try {
          const errorText = await response.text();
          const errorObj = JSON.parse(errorText);
          errorDetails = this.extractErrorDetails(errorObj);
        } catch (parseError) {
          // If we can't parse the error, use the status code
          errorDetails = `Failed to get chat completions, HTTP ${response.status}`;
        }
        
        console.error('‚ùå Azure AI streaming error:', errorDetails);
        throw new Error(`Azure AI streaming error: ${errorDetails}`);
      }

      const stream = response.body;
      if (!stream) {
        throw new Error("The response stream is undefined");
      }

      // Use the browser's native ReadableStream API
      reader = stream.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader!.read();
        
        if (done) {
          break;
        }

        // Decode the chunk and add to buffer
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;

        // Process complete SSE events
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6).trim();
            
            if (data === '[DONE]') {
              return;
            }

            try {
              const eventData = JSON.parse(data);
              for (const choice of eventData.choices || []) {
                const content = choice.delta?.content;
                if (content) {
                  onChunk(content);
                }
              }
            } catch (parseError) {
              // Skip invalid JSON, continue processing
              console.warn("Failed to parse SSE event:", parseError);
            }
          }
        }
      }
    } catch (error) {
      console.error("Azure AI Streaming Service Error:", error);
      throw error;
    } finally {
      // Always release the reader to avoid locked stream issues
      if (reader) {
        try {
          reader.releaseLock();
        } catch (releaseError) {
          console.warn("Error releasing stream reader:", releaseError);
        }
      }
    }
  }

  /**
   * Create Azure AI config from environment variables
   */
  static createFromEnv(): AzureAIConfig {
    const endpoint = import.meta.env.VITE_AZURE_AI_ENDPOINT;
    const apiKey = import.meta.env.VITE_AZURE_AI_API_KEY;
    const modelName = import.meta.env.VITE_AZURE_AI_MODEL_NAME || "ministral-3b";

    if (!endpoint || !apiKey) {
      throw new Error(
        "Azure AI configuration missing. Please set VITE_AZURE_AI_ENDPOINT and VITE_AZURE_AI_API_KEY environment variables."
      );
    }

    return { endpoint, apiKey, modelName };
  }

  /**
   * Create Azure AI config with custom model
   * Handles both default models and fine-tuned models with custom endpoints
   */
  static createWithModel(modelName: string): AzureAIConfig {
    // Check if this is our fine-tuned model that needs a custom endpoint
    if (modelName === "breaking-better-v6-1-ft") {
      const ftApiKey = import.meta.env.VITE_AZURE_AI_FT_API_KEY;
      
      if (!ftApiKey) {
        console.warn("Fine-tuned model API key not configured, falling back to default Azure AI");
        const config = this.createFromEnv();
        return { ...config, modelName };
      }
      
      return { 
        endpoint: "https://ai-foundryv1.cognitiveservices.azure.com", // Base endpoint only
        apiKey: ftApiKey, 
        modelName: "breaking-better-v6-1-ft" // Keep our identifier
      };
    }
    
    // For all other models, use default configuration
    const config = this.createFromEnv();
    return { ...config, modelName };
  }
}

export default AzureAIService;

================
File: client/src/lib/gemini.ts
================
import { GeminiContent, GeminiConfig, AzureAIMessage, ChatCompletionOptions, LLMModel, GeminiSystemInstruction } from "../types";
import { getModelConfiguration, validateModelParameters } from "./modelConfigurations";

export class GeminiService {
  private config: GeminiConfig;

  constructor(config: GeminiConfig) {
    this.config = config;
  }

  /**
   * Update the model name for this service instance
   */
  updateModel(modelName: string): void {
    this.config.modelName = modelName;
  }

  /**
   * Get current model configuration
   */
  getCurrentModel(): string {
    return this.config.modelName;
  }

  /**
   * Estimate token count for contents (rough approximation)
   */
  private estimateTokenCount(contents: GeminiContent[]): number {
    return contents.reduce((total, content) => {
      const textContent = content.parts.reduce((partTotal, part) => {
        return partTotal + Math.ceil(part.text.length / 4);
      }, 0);
      return total + textContent + 10;
    }, 0);
  }

  /**
   * Truncate conversation history while preserving system message and recent context
   */
  private truncateConversationHistory(contents: GeminiContent[], maxTokens: number): GeminiContent[] {
    if (contents.length === 0) return contents;
    
    // Calculate tokens and add messages from most recent, working backwards
    let totalTokens = 0;
    const result: GeminiContent[] = [];
    
    for (let i = contents.length - 1; i >= 0; i--) {
      const contentTokens = this.estimateTokenCount([contents[i]]);
      if (totalTokens + contentTokens <= maxTokens) {
        totalTokens += contentTokens;
        result.unshift(contents[i]);
      } else {
        console.log(`üîÑ Truncated ${i + 1} older messages to stay within token limit`);
        break;
      }
    }
    
    return result;
  }

  /**
   * Get available Gemini models
   */
  static getAvailableModels(): LLMModel[] {
    return [
      {
        id: "gemini-2.5-flash",
        name: "Gemini 2.5 Flash",
        provider: "Google",
        performance: 94,
        cost: 0.0002,
        latency: 500,
        contextLength: 1000000,
        description: "Latest multimodal model with next generation features",
        category: "multimodal",
        tier: "pro",
        isFavorite: true,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gemini-2.5-pro",
        name: "Gemini 2.5 Pro",
        provider: "Google",
        performance: 96,
        cost: 0.001,
        latency: 800,
        contextLength: 2000000,
        description: "Most powerful thinking model with complex reasoning",
        category: "reasoning",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gemini-1.5-flash",
        name: "Gemini 1.5 Flash",
        provider: "Google",
        performance: 90,
        cost: 0.00015,
        latency: 400,
        contextLength: 1000000,
        description: "Fast multimodal model with 1M context",
        category: "multimodal",
        tier: "standard",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gemini-1.5-pro",
        name: "Gemini 1.5 Pro",
        provider: "Google",
        performance: 92,
        cost: 0.0005,
        latency: 700,
        contextLength: 2000000,
        description: "Advanced multimodal model for complex tasks",
        category: "multimodal",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      }
    ];
  }

  /**
   * Convert Azure AI messages to Gemini format
   */
  private convertToGeminiContents(azureMessages: AzureAIMessage[]): { contents: GeminiContent[], systemInstruction?: GeminiSystemInstruction } {
    const contents: GeminiContent[] = [];
    let systemInstruction: GeminiSystemInstruction | undefined;

    for (const msg of azureMessages) {
      if (msg.role === "system") {
        // System messages become system instruction
        systemInstruction = {
          parts: [{ text: msg.content }]
        };
      } else if (msg.role === "user") {
        contents.push({
          role: "user",
          parts: [{ text: msg.content }]
        });
      } else if (msg.role === "assistant") {
        contents.push({
          role: "model",
          parts: [{ text: msg.content }]
        });
      }
    }

    return { contents, systemInstruction };
  }

  /**
   * Send a single chat completion request
   */
  async sendChatCompletion(
    messages: AzureAIMessage[],
    options: ChatCompletionOptions = {}
  ): Promise<string> {
    try {
      // Convert to Gemini format
      const { contents, systemInstruction } = this.convertToGeminiContents(messages);
      
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // Estimate token count and truncate if necessary
      const estimatedTokens = this.estimateTokenCount(contents);
      const maxContextTokens = modelConfig.contextLength || 32000;
      const reserveTokensForResponse = options.maxTokens || 1024;
      
      console.log(`üî¢ Token estimate: ${estimatedTokens}/${maxContextTokens} (reserving ${reserveTokensForResponse} for response)`);
      
      let processedContents = contents;
      if (estimatedTokens + reserveTokensForResponse > maxContextTokens) {
        console.warn(`‚ö†Ô∏è Approaching token limit, truncating conversation history`);
        processedContents = this.truncateConversationHistory(contents, maxContextTokens - reserveTokensForResponse);
      }
      
      // Use validated parameters based on the model's capabilities and limits
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Gemini requires a minimum number of tokens to generate any response
      // Even for simple responses, it needs at least 50-100 tokens
      const minTokensForGemini = 50;
      if (validatedParams.maxTokens < minTokensForGemini) {
        console.warn(`‚ö†Ô∏è Gemini requires at least ${minTokensForGemini} tokens. Adjusting from ${validatedParams.maxTokens} to ${minTokensForGemini}`);
        validatedParams.maxTokens = minTokensForGemini;
      }

      // Build request body
      const requestBody: any = {
        contents: processedContents,
        generationConfig: {
          maxOutputTokens: validatedParams.maxTokens,
          temperature: validatedParams.temperature,
          topP: validatedParams.topP,
        }
      };

      // Add system instruction if present
      if (systemInstruction) {
        requestBody.systemInstruction = systemInstruction;
      }

      // Add stop sequences if supported
      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.generationConfig.stopSequences = Array.isArray(options.stop) ? options.stop : [options.stop];
      }

      console.log(`Using optimized parameters for ${modelConfig.name} (${modelConfig.provider}):`, {
        maxOutputTokens: requestBody.generationConfig.maxOutputTokens,
        temperature: requestBody.generationConfig.temperature,
        topP: requestBody.generationConfig.topP,
      });

      console.log('üîó Sending Gemini request:', {
        model: this.config.modelName,
        contentCount: processedContents.length,
        hasSystemInstruction: !!systemInstruction,
        apiKeyPrefix: this.config.apiKey?.substring(0, 10) + '...'
      });

      // Use universal AI proxy for credit checking
      const response = await fetch('/ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'gemini',
          model: this.config.modelName,
          messages: messages, // Convert back to Azure AI format for the proxy
          max_tokens: validatedParams.maxTokens,
          temperature: validatedParams.temperature,
          top_p: validatedParams.topP,
          stream: false,
          apiKey: this.config.apiKey
        }),
      });

      console.log('üì° Gemini response status:', response.status);

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        const errorData = await response.text();
        console.error('‚ùå Gemini API error details:', errorData);
        
        // Handle specific error codes
        if (response.status === 403) {
          console.error('‚ùå Gemini API Key Error: Invalid or missing API key');
          throw new Error('Gemini API key is invalid or missing. Please check your API key in AI Provider Settings.');
        } else if (response.status === 404) {
          console.error('‚ùå Gemini Model Error: Model not found');
          throw new Error(`Gemini model "${this.config.modelName}" not found. Please check the model name.`);
        } else if (response.status === 400) {
          console.error('‚ùå Gemini Request Error: Bad request');
          throw new Error(`Invalid request to Gemini API: ${errorData}`);
        }
        
        throw new Error(`Gemini API error (${response.status}): ${errorData}`);
      }

      const data = await response.json();
      console.log('üì° Gemini API response structure:', {
        hasCandidates: !!data.candidates,
        candidatesLength: data.candidates?.length,
        hasChoices: !!data.choices,
        choicesLength: data.choices?.length,
        error: data.error
      });
      console.log('üîç FULL RESPONSE DATA:', JSON.stringify(data, null, 2));
      
      // Extract credit information if present and emit update
      if (data.uterpi_credit_info) {
        const { emitCreditUpdate } = await import('../hooks/useCreditUpdates');
        emitCreditUpdate({
          creditsUsed: data.uterpi_credit_info.credits_used,
          remainingBalance: data.uterpi_credit_info.remaining_balance
        });
      }
      
      // Check for error in response
      if (data.error) {
        console.error('‚ùå Gemini API returned error:', data.error);
        throw new Error(`Gemini API error: ${data.error.message || JSON.stringify(data.error)}`);
      }
      
      // Handle both Gemini format (candidates) and OpenAI format (choices)
      let candidate;
      if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0) {
        // Native Gemini format
        candidate = data.candidates[0];
      } else if (data.choices && Array.isArray(data.choices) && data.choices.length > 0) {
        // OpenAI-compatible format (from proxy)
        const choice = data.choices[0];
        candidate = {
          content: {
            parts: [{ text: choice.message?.content || '' }]
          },
          finishReason: choice.finish_reason || 'STOP'
        };
      } else {
        console.error('‚ùå Gemini API response missing candidates or choices:', data);
        throw new Error('Gemini API returned no response candidates or choices. Please check your API key and model.');
      }
      
      // Check if response was truncated due to token limit
      if (candidate.finishReason === 'MAX_TOKENS') {
        console.warn('‚ö†Ô∏è Gemini response truncated due to MAX_TOKENS limit');
        // Still try to get partial content if available
      }
      
      // Check for empty content
      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        // If MAX_TOKENS and no content, it means we need more output tokens
        if (candidate.finishReason === 'MAX_TOKENS') {
          console.error('‚ùå Gemini hit token limit before generating any content. Increase maxTokens.');
          throw new Error('Gemini needs more output tokens. Please increase maxTokens in the request.');
        }
        console.error('‚ùå Gemini API response missing content:', candidate);
        throw new Error('Gemini API returned empty response content.');
      }
      
      // Extract content from parts array
      const content = candidate.content.parts[0]?.text || "";
      if (!content && candidate.finishReason === 'MAX_TOKENS') {
        console.error('‚ùå Gemini hit MAX_TOKENS limit with empty content');
        throw new Error('Gemini response was cut off. Please increase maxTokens to get a complete response.');
      } else if (!content) {
        console.warn('‚ö†Ô∏è Gemini API returned empty text content');
      }
      
      console.log('‚úÖ Gemini response received:', content.substring(0, 100) + '...');
      console.log('üîç Full Gemini response content:', content);
      console.log('üîç Response length:', content.length);
      console.log('üîç Response type:', typeof content);
      return content;
    } catch (error: any) {
      console.error("Gemini Service Error:", error);
      
      // Provide user-friendly error messages
      if (error.message?.includes('API key')) {
        throw new Error('Gemini API key issue. Please verify your API key in AI Provider Settings.');
      } else if (error.message?.includes('model')) {
        throw new Error('Gemini model issue. Please try a different model or check your settings.');
      }
      
      throw error;
    }
  }

  /**
   * Send a streaming chat completion request
   */
  async sendStreamingChatCompletion(
    messages: AzureAIMessage[],
    onChunk: (chunk: string) => void,
    options: ChatCompletionOptions = {}
  ): Promise<void> {
    try {
      // Convert to Gemini format
      const { contents, systemInstruction } = this.convertToGeminiContents(messages);
      
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // Use validated parameters
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Gemini requires a minimum number of tokens to generate any response
      const minTokensForGemini = 50;
      if (validatedParams.maxTokens < minTokensForGemini) {
        console.warn(`‚ö†Ô∏è Gemini streaming requires at least ${minTokensForGemini} tokens. Adjusting from ${validatedParams.maxTokens} to ${minTokensForGemini}`);
        validatedParams.maxTokens = minTokensForGemini;
      }

      // Build request body
      const requestBody: any = {
        contents,
        generationConfig: {
          maxOutputTokens: validatedParams.maxTokens,
          temperature: validatedParams.temperature,
          topP: validatedParams.topP,
        }
      };

      // Add system instruction if present
      if (systemInstruction) {
        requestBody.systemInstruction = systemInstruction;
      }

      // Add stop sequences if supported
      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.generationConfig.stopSequences = Array.isArray(options.stop) ? options.stop : [options.stop];
      }

      // Use universal AI proxy for credit checking
      const response = await fetch('/ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'gemini',
          model: this.config.modelName,
          messages: messages, // Convert back to Azure AI format for the proxy
          max_tokens: validatedParams.maxTokens,
          temperature: validatedParams.temperature,
          top_p: validatedParams.topP,
          stream: true,
          apiKey: this.config.apiKey
        }),
      });
      
      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        const errorData = await response.text();
        console.error('‚ùå Gemini streaming error:', errorData);
        throw new Error(`Gemini streaming error: ${errorData}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("The response stream is undefined");
      }

      const decoder = new TextDecoder();
      let buffer = '';
      let accumulatedText = ''; // Track ALL text sent so far for the entire response

      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }

          // Decode the chunk and add to buffer
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;

          // Process complete lines
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer

          for (const line of lines) {
            if (!line.trim()) continue;
            
            let jsonData = line;
            
            // Check if it's SSE format (with alt=sse parameter)
            if (line.startsWith('data: ')) {
              jsonData = line.slice(6).trim();
              if (jsonData === '[DONE]') {
                return;
              }
            }
            
            try {
              const data = JSON.parse(jsonData);
              
              // Extract text from Gemini native streaming response
              if (data.candidates && data.candidates[0]) {
                const candidate = data.candidates[0];
                
                // Get the current text from this response
                const currentText = candidate.content?.parts?.[0]?.text || '';
                
                if (!currentText) continue;
                
                // Check if this chunk contains the accumulated text as a prefix
                // This means it's a cumulative update containing all previous text plus new
                if (currentText.startsWith(accumulatedText)) {
                  // Extract only the NEW characters after what we've already sent
                  const newText = currentText.substring(accumulatedText.length);
                  if (newText) {
                    onChunk(newText);
                    accumulatedText = currentText;
                  }
                } else if (accumulatedText.startsWith(currentText)) {
                  // This chunk is a subset of what we already have, skip it
                  continue;
                } else {
                  // This is completely new text (not a continuation of accumulated)
                  // Just send it as is
                  onChunk(currentText);
                  accumulatedText = accumulatedText + currentText;
                }
                
                // Check if response is complete
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  if (candidate.finishReason === 'MAX_TOKENS') {
                    console.warn('‚ö†Ô∏è Gemini streaming hit token limit');
                  }
                }
              } else if (data.choices && data.choices[0]) {
                // Extract text from OpenAI-style SSE (server proxy compatibility)
                const choice = data.choices[0];
                const deltaText = choice?.delta?.content || '';
                const fullMessageText = choice?.message?.content || '';

                // Prefer incremental delta when present; fallback to full message text
                const text = deltaText || fullMessageText;
                if (text) {
                  onChunk(text);
                  accumulatedText += text;
                }
              }
            } catch (e) {
              // Silently ignore parse errors for non-JSON lines
            }
          }
        }
        
        // Process any remaining buffer
        if (buffer.trim()) {
          try {
            const data = JSON.parse(buffer);
            if (data.candidates && data.candidates[0]) {
              const fullText = data.candidates[0].content?.parts?.[0]?.text || '';
              if (fullText && fullText.length > accumulatedText.length) {
                const newText = fullText.substring(accumulatedText.length);
                onChunk(newText);
              }
            }
          } catch (e) {
            // Ignore incomplete JSON at end
          }
        }
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      console.error("Gemini Streaming Service Error:", error);
      throw error;
    }
  }

  /**
   * Create Gemini config from environment variables
   */
  static createFromEnv(): GeminiConfig {
    const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    const modelName = import.meta.env.VITE_GEMINI_MODEL_NAME || "gemini-2.5-flash";
    const baseUrl = import.meta.env.VITE_GEMINI_BASE_URL;

    if (!apiKey) {
      throw new Error(
        "Gemini configuration missing. Please set VITE_GEMINI_API_KEY environment variable."
      );
    }

    return { apiKey, modelName, baseUrl };
  }

  /**
   * Create Gemini config with custom model
   */
  static createWithModel(modelName: string): GeminiConfig {
    const config = this.createFromEnv();
    return { ...config, modelName };
  }
}

export default GeminiService;

================
File: client/src/lib/huggingface.ts
================
import { AzureAIMessage, ChatCompletionOptions, LLMModel } from "../types";
import { getModelConfiguration, validateModelParameters } from "./modelConfigurations";

export interface HuggingFaceConfig {
  endpointUrl: string;
  apiToken: string;
  modelName?: string;
}

export class HuggingFaceService {
  private config: HuggingFaceConfig;

  constructor(config: HuggingFaceConfig) {
    this.config = config;
  }

  updateModel(modelName: string): void {
    this.config.modelName = modelName;
  }

  getCurrentModel(): string {
    return this.config.modelName || "hf-endpoint";
  }

  /**
   * Basic model list for selection. For Endpoints, the deployed model is bound to your endpoint.
   */
  static getAvailableModels(): LLMModel[] {
    return [
      {
        id: "hf-endpoint",
        name: "HuggingFace",
        provider: "Hugging Face",
        performance: 80,
        cost: 0,
        latency: 800,
        contextLength: 16384,
        description: "Uses your configured Hugging Face Inference Endpoint",
        category: "text",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      }
    ];
  }

  private convertToPrompt(messages: AzureAIMessage[]): string {
    // Compose a simple prompt including system guidance
    return messages
      .map(m => {
        const role = m.role === "assistant" ? "Assistant" : m.role === "user" ? "User" : "System";
        return `${role}: ${m.content}`;
      })
      .join("\n\n") + "\n\nAssistant:";
  }

  /**
   * Non-streaming call to a Hugging Face Inference Endpoint.
   * Documentation: https://huggingface.co/docs/huggingface_hub/guides/inference_endpoints
   */
  async sendChatCompletion(
    messages: AzureAIMessage[],
    options: ChatCompletionOptions = {}
  ): Promise<string> {
    const modelId = this.getCurrentModel();
    const modelConfig = getModelConfiguration(modelId);

    const validated = validateModelParameters(modelId, {
      maxTokens: options.maxTokens,
      temperature: options.temperature,
      topP: options.topP,
    });

    // Check if this is Uterpi LLM (uses backend proxy for credit checking)
    const isUterpi = (this.config as any).isUterpi;
    
    if (isUterpi) {
      // Use backend proxy for Uterpi LLM with credit checking
      const requestBody = {
        provider: 'uterpi',
        messages,
        model: this.config.modelName || 'uterpi-llm',
        max_tokens: validated.maxTokens,
        temperature: validated.temperature,
        top_p: validated.topP,
        stream: false
      };

      const response = await fetch('/ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        const errText = await response.text();
        throw new Error(`Uterpi LLM error (${response.status}): ${errText}`);
      }

      const data = await response.json();
      
      // Extract credit information if present and emit update
      if (data.uterpi_credit_info) {
        const { emitCreditUpdate } = await import('../hooks/useCreditUpdates');
        emitCreditUpdate({
          creditsUsed: data.uterpi_credit_info.credits_used,
          remainingBalance: data.uterpi_credit_info.remaining_balance
        });
      }
      
      return data.choices[0]?.message?.content || "";
    }

    // Original HuggingFace direct API call for non-Uterpi endpoints
    const prompt = this.convertToPrompt(messages);

    const body: any = {
      inputs: prompt,
      parameters: {
        // HF text-generation parameters
        max_new_tokens: validated.maxTokens,
        temperature: validated.temperature,
        top_p: validated.topP,
        return_full_text: false
      }
    };

    const response = await fetch(this.config.endpointUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.config.apiToken}`
      },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errText = await response.text();
      throw new Error(`Hugging Face endpoint error (${response.status}): ${errText}`);
    }

    // Response schema can vary by model/task. Handle common shapes without assumptions beyond official docs.
    // Inference API commonly returns an array of objects with generated_text for text-generation.
    const data = await response.json();
    let text = "";
    if (Array.isArray(data)) {
      const first = data[0] || {};
      text = first.generated_text || first.summary_text || "";
    } else if (typeof data === "object" && data) {
      // Some endpoints may return an object with generated_text
      text = (data as any).generated_text || "";
      if (!text && (data as any).choices?.[0]?.message?.content) {
        text = (data as any).choices[0].message.content;
      }
    } else if (typeof data === "string") {
      text = data;
    }

    return typeof text === "string" ? text : JSON.stringify(data);
  }

  /**
   * Streaming support depends on the Endpoint configuration. If not available,
   * we fall back to a single non-streaming call and emit one chunk.
   */
  async sendStreamingChatCompletion(
    messages: AzureAIMessage[],
    onChunk: (chunk: string) => void,
    options: ChatCompletionOptions = {}
  ): Promise<void> {
    try {
      // Check if this is Uterpi LLM (uses backend proxy for credit checking)
      const isUterpi = (this.config as any).isUterpi;
      
      if (isUterpi) {
        // Use backend proxy for Uterpi LLM with credit checking
        const modelId = this.getCurrentModel();
        const validated = validateModelParameters(modelId, {
          maxTokens: options.maxTokens,
          temperature: options.temperature,
          topP: options.topP,
        });

        const requestBody = {
          provider: 'uterpi',
          messages,
          model: this.config.modelName || 'uterpi-llm',
          max_tokens: validated.maxTokens,
          temperature: validated.temperature,
          top_p: validated.topP,
          stream: true
        };

        const response = await fetch('/ai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include',
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          // Handle credit limit errors specially
          if (response.status === 402) {
            const errorData = await response.json();
            throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
          }
          
          const errText = await response.text();
          throw new Error(`Uterpi LLM streaming error (${response.status}): ${errText}`);
        }

        // For now, fall back to non-streaming for Uterpi LLM
        // TODO: Implement proper streaming support in the backend
        const data = await response.json();
        const content = data.choices[0]?.message?.content || "";
        if (content) {
          onChunk(content);
        }
        return;
      }

      // Try non-streaming and emit as one chunk to keep UX consistent
      const full = await this.sendChatCompletion(messages, options);
      if (full) {
        onChunk(full);
      }
    } catch (err) {
      throw err;
    }
  }

  static createFromEnv(): HuggingFaceConfig {
    const endpointUrl = import.meta.env.VITE_HF_ENDPOINT_URL as string | undefined;
    const apiToken = import.meta.env.VITE_HF_API_TOKEN as string | undefined;
    if (!endpointUrl || !apiToken) {
      throw new Error("Hugging Face configuration missing. Set VITE_HF_ENDPOINT_URL and VITE_HF_API_TOKEN.");
    }
    return { endpointUrl, apiToken, modelName: "hf-endpoint" };
  }
}

export default HuggingFaceService;

================
File: client/src/lib/intelligentToastService.ts
================
import { AzureAIService } from "./azureAI";
import { Message, LLMModel } from "../types";
import { toast } from "sonner";

// Toast function type for our smart toasts
type ToastFunction = (title: string, options?: {
  description?: string;
  duration?: number;
  action?: {
    label: string;
    onClick: () => void;
  };
}) => void;

export interface SmartToast {
  id: string;
  title: string;
  description: string;
  category: 'optimization' | 'suggestion' | 'insight' | 'enhancement' | 'alert';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  actionable: boolean;
  action?: {
    label: string;
    callback: () => void;
  };
  data?: any;
}

export interface ConversationInsights {
  // User interaction patterns
  userInteractionStyle: {
    communicationType: 'direct' | 'exploratory' | 'detailed' | 'concise' | 'iterative';
    questionStyle: 'specific' | 'open-ended' | 'follow-up' | 'clarifying';
    engagementLevel: 'high' | 'medium' | 'low';
    patienceLevel: 'high' | 'medium' | 'low';
  };
  
  // Conversation dynamics
  conversationDynamics: {
    topicDepth: 'surface' | 'moderate' | 'deep' | 'expert';
    focusPattern: 'single-topic' | 'multi-topic' | 'branching' | 'returning';
    complexityProgression: 'increasing' | 'decreasing' | 'stable' | 'fluctuating';
    responsePreference: 'detailed' | 'concise' | 'step-by-step' | 'overview';
  };
  
  // Behavioral insights
  behavioralInsights: {
    learningStyle: 'visual' | 'practical' | 'theoretical' | 'experimental';
    problemSolvingApproach: 'systematic' | 'creative' | 'pragmatic' | 'analytical';
    confidenceLevel: 'high' | 'medium' | 'low';
    expertiseArea: string[];
    improvementAreas: string[];
  };
  
  // Interaction quality
  interactionQuality: {
    clarityScore: number; // 1-10
    efficiencyScore: number; // 1-10
    satisfactionPrediction: number; // 1-10
    potentialFrustrationPoints: string[];
  };
  
  // Hidden patterns
  hiddenInsights: {
    thinkingPattern: string;
    aiAssumptions: string;
    uncertaintyHandling: string;
    motivation: string;
  };
}

export interface ConversationMetrics {
  totalTokens: number;
  averageResponseTime: number;
  messageCount: number;
  modelSwitches: number;
  errorCount: number;
  attachmentUsage: number;
  systemMessageChanges: number;
  conversationLength: number;
  topicComplexity: 'simple' | 'moderate' | 'complex' | 'technical';
  currentModel: string;
  modelEfficiency: number;
  interactionPatterns: {
    communicationTypes: string[];
    questionStyles: string[];
    engagementTrend: 'increasing' | 'decreasing' | 'stable';
    averageMessageLength: number;
    followUpFrequency: number;
  };
  behavioralProfile: {
    learningStyle: string;
    problemSolvingApproach: string;
    confidenceTrend: 'increasing' | 'decreasing' | 'stable';
    expertiseAreas: string[];
  };
}

export interface PerformanceData {
  responseTime: number;
  tokenUsage: number;
  modelMatch: number; // How well the model matches the task
  contextQuality: number; // How clear/focused the conversation is
  timestamp: number;
}

export class IntelligentToastService {
  private aiService: AzureAIService | any; // Allow any AI service that has sendChatCompletion
  private metrics: ConversationMetrics;
  private performanceHistory: PerformanceData[] = [];
  private shownRecommendations: Set<string> = new Set();
  private recommendationTimestamps: Map<string, number> = new Map(); // Track when recommendations were last shown
  private lastAnalysisTime: number = 0;
  private toastFunction: ToastFunction;
  private availableModels: LLMModel[] = [];
  private modelSwitchCallback?: (modelId: string) => void;
  private newChatCallback?: () => void;
  private isAnalyzing: boolean = false; // Track if analysis is in progress

  // Toast queue management to avoid rapid-fire notifications
  private toastQueue: SmartToast[] = [];
  private isShowingToast: boolean = false;
  private lastToastTimestamp: number = 0;
  private readonly MIN_TOAST_GAP_MS: number = 3000; // Minimum gap between toasts

  // Cache rules by category
  private readonly CACHE_RULES = {
    'alert': { permanent: true, cooldownMinutes: 0 },           // Never show again
    'optimization': { permanent: true, cooldownMinutes: 0 },   // Never show again
    'insight': { permanent: false, cooldownMinutes: 1 },       // Show again after 1 minute (was 2)
    'suggestion': { permanent: false, cooldownMinutes: 1.5 },  // Show again after 1.5 minutes (was 3)
    'enhancement': { permanent: false, cooldownMinutes: 2 }    // Show again after 2 minutes (was 5)
  };

  constructor(
    aiService: AzureAIService | any, // Accept any AI service with sendChatCompletion method
    toastFunction?: ToastFunction,
    modelSwitchCallback?: (modelId: string) => void,
    newChatCallback?: () => void
  ) {
    this.aiService = aiService;
    this.toastFunction = toastFunction || this.defaultToastFunction;
    this.modelSwitchCallback = modelSwitchCallback;
    this.newChatCallback = newChatCallback;
    this.metrics = this.initializeMetrics();
    this.loadAvailableModels();
  }

  private loadAvailableModels(): void {
    try {
      this.availableModels = AzureAIService.getAvailableModels();
    } catch (err) {
      console.warn('Failed to load available models:', err);
      this.availableModels = [];
    }
  }

  private defaultToastFunction: ToastFunction = (title, options) => {
    toast(title, {
      description: options?.description,
      duration: options?.duration || 6000,
      action: options?.action
    });
  };

  private initializeMetrics(): ConversationMetrics {
    return {
      totalTokens: 0,
      averageResponseTime: 0,
      messageCount: 0,
      modelSwitches: 0,
      errorCount: 0,
      attachmentUsage: 0,
      systemMessageChanges: 0,
      conversationLength: 0,
      topicComplexity: 'simple',
      currentModel: '',
      modelEfficiency: 100,
      interactionPatterns: {
        communicationTypes: [],
        questionStyles: [],
        engagementTrend: 'stable',
        averageMessageLength: 0,
        followUpFrequency: 0
      },
      behavioralProfile: {
        learningStyle: 'theoretical',
        problemSolvingApproach: 'systematic',
        confidenceTrend: 'stable',
        expertiseAreas: []
      }
    };
  }

  /**
   * Analyze conversation content and generate intelligent recommendations
   */
  async analyzeAndRecommend(
    messages: Message[], 
    currentModel: LLMModel,
    responseTime?: number,
    tokenUsage?: number
  ): Promise<void> {
    // Prevent concurrent analysis to avoid interference
    if (this.isAnalyzing) {
      console.log('‚è∏Ô∏è Analysis already in progress, skipping to prevent interference');
      return;
    }

    this.isAnalyzing = true;
    console.log(`üîç Starting analysis for ${messages.length} messages with model ${currentModel.name}`);
    
    // Don't show analysis in progress notification - it can interfere with chat
    // The analysis should happen silently in the background
    
    // Update metrics
    this.updateMetrics(messages, currentModel, responseTime, tokenUsage);

    // Reduce analysis frequency throttling even further for testing
    const now = Date.now();
    if (now - this.lastAnalysisTime < 10000) { // Reduced from 30s to 10s for faster testing
      console.log('‚ö†Ô∏è Analysis throttled - waiting for cooldown');
      this.isAnalyzing = false;
      return;
    }
    this.lastAnalysisTime = now;

    try {
      console.log('üîç Performing conversation analysis...');
      
      // Try AI service analysis first
      let analysis = null;
      try {
        console.log('üöÄ Attempting AI service analysis...');
        analysis = await this.performConversationAnalysis(messages, currentModel);
        console.log('‚úÖ AI service analysis completed successfully');
        console.log('üìã Analysis result structure:', {
          hasUserInteractionStyle: !!analysis?.userInteractionStyle,
          hasBehavioralInsights: !!analysis?.behavioralInsights,
          hasConversationDynamics: !!analysis?.conversationDynamics,
          hasHiddenInsights: !!analysis?.hiddenInsights,
          hasInteractionQuality: !!analysis?.interactionQuality,
          keys: Object.keys(analysis || {})
        });
      } catch (aiError) {
        console.warn('‚ö†Ô∏è AI service analysis failed, using fallback:', aiError);
        console.warn('üîç Error details:', aiError instanceof Error ? aiError.message : String(aiError));
        // Generate fallback analysis without AI service
        analysis = this.generateEnhancedFallbackAnalysis(messages, currentModel);
        console.log('üîÑ Fallback analysis completed');
        console.log('üìã Fallback analysis structure:', {
          hasUserInteractionStyle: !!analysis?.userInteractionStyle,
          hasBehavioralInsights: !!analysis?.behavioralInsights,
          hasConversationDynamics: !!analysis?.conversationDynamics,
          hasHiddenInsights: !!analysis?.hiddenInsights,
          hasInteractionQuality: !!analysis?.interactionQuality,
          keys: Object.keys(analysis || {})
        });
      }
      
      // Generate recommendations based on analysis (or fallback)
      const recommendations = this.generateRecommendations(analysis, currentModel);
      console.log(`üí° Generated ${recommendations.length} recommendations:`, recommendations.map((r: SmartToast) => r.title));
      console.log('üìä Analysis data received:', JSON.stringify(analysis, null, 2));
      
      console.log('üìã All recommendations before selection:', recommendations);
      console.log('üîç Previously shown recommendations:', Array.from(this.shownRecommendations));
      
      // Show the most relevant recommendation
      const topRecommendation = this.selectTopRecommendation(recommendations);
      console.log('üéØ Selected top recommendation:', topRecommendation);
      
      if (topRecommendation && this.canShowRecommendation(topRecommendation)) {
        console.log('üì¢ Showing smart recommendation:', topRecommendation.title);
        this.showSmartToast(topRecommendation);
        this.markRecommendationShown(topRecommendation);
        console.log('‚úÖ Recommendation shown and added to cache');
      } else if (topRecommendation) {
        console.log('üîÑ Top recommendation already shown or blocked:', topRecommendation.title);
        console.log('üîÑ Recommendation ID:', topRecommendation.id);
        console.log('üîÑ Previously shown IDs:', Array.from(this.shownRecommendations));
      } else {
        console.log('‚ÑπÔ∏è No new recommendations to show');
      }

    } catch (error) {
      console.error('‚ùå Analysis completely failed:', error);
      
      // Don't show any toast on error - just fail silently to avoid disrupting chat
      // The chat functionality is more important than analysis notifications
    } finally {
      // Always clear the analyzing flag
      this.isAnalyzing = false;
    }
  }

  private async performConversationAnalysis(messages: Message[], currentModel: LLMModel): Promise<any> {
    if (messages.length < 2) {
      console.log('‚ö†Ô∏è Not enough messages for analysis yet');
      return null;
    }

    console.log(`üîç Starting enhanced conversation analysis for ${messages.length} messages...`);

    const recentMessages = messages.slice(-15); // Analyze last 15 messages for better context
    const conversationText = recentMessages.map(m => `${m.role}: ${m.content}`).join('\n');
    
    // Extract user messages for pattern analysis
    const userMessages = recentMessages.filter(m => m.role === 'user');
    const assistantMessages = recentMessages.filter(m => m.role === 'assistant');

    // Create a more concise prompt for providers with token limitations (like Gemini)
    const isGemini = this.aiService.constructor?.name?.includes('Gemini');
    
    const analysisPrompt = isGemini ? 
    // Concise version for Gemini with strict JSON requirements
    `Analyze this conversation. Return ONLY valid JSON, no other text.

CONVERSATION:
${conversationText.substring(0, 1500)}

CRITICAL: Return ONLY a valid JSON object. Do NOT include any text before or after the JSON.
Do NOT use apostrophes or quotes in string values unless you escape them with backslash.
Example: "user's goal" should be "user\\'s goal" or just "user goal"

Return this exact JSON structure (replace placeholders with actual values):
{
  "userInteractionStyle": {
    "communicationType": "direct",
    "questionStyle": "specific",
    "engagementLevel": "low",
    "patienceLevel": "medium"
  },
  "conversationDynamics": {
    "topicDepth": "surface",
    "focusPattern": "single-topic",
    "complexityProgression": "stable",
    "responsePreference": "detailed"
  },
  "behavioralInsights": {
    "learningStyle": "practical",
    "problemSolvingApproach": "systematic",
    "confidenceLevel": "high",
    "expertiseArea": ["coding"],
    "improvementAreas": ["clarity"]
  },
  "interactionQuality": {
    "clarityScore": 8,
    "efficiencyScore": 7,
    "satisfactionPrediction": 9,
    "potentialFrustrationPoints": ["none"]
  },
  "hiddenInsights": {
    "thinkingPattern": "seeks quick solutions",
    "aiAssumptions": "expects accurate responses",
    "uncertaintyHandling": "asks for clarification",
    "motivation": "problem solving"
  }
}` :
    // Full version for other providers
    `Analyze this conversation to understand the user's interaction patterns and provide hidden insights:

CONVERSATION:
${conversationText}

ANALYSIS TASK:
Provide deep insights about the user's interaction style, communication patterns, and behavioral tendencies. Focus on revealing "hidden insights" that would help understand how this user thinks and interacts with AI.

ANALYSIS CRITERIA:

1. **User Interaction Style Analysis:**
   - How does the user communicate? (direct, exploratory, detailed, concise, iterative)
   - What type of questions do they ask? (specific, open-ended, follow-up, clarifying)
   - What's their engagement level? (high, medium, low)
   - How patient are they with responses? (high, medium, low)

2. **Conversation Dynamics:**
   - How deep do they go into topics? (surface, moderate, deep, expert)
   - How do they handle multiple topics? (single-topic, multi-topic, branching, returning)
   - Does complexity increase, decrease, or stay stable?
   - What response style do they prefer? (detailed, concise, step-by-step, overview)

3. **Behavioral Insights:**
   - What's their learning style? (visual, practical, theoretical, experimental)
   - How do they approach problem-solving? (systematic, creative, pragmatic, analytical)
   - What's their confidence level? (high, medium, low)
   - What areas show expertise vs. areas for improvement?

4. **Interaction Quality Assessment:**
   - Rate clarity of communication (1-10)
   - Rate efficiency of interaction (1-10)
   - Predict satisfaction level (1-10)
   - Identify potential frustration points

5. **Hidden Patterns:**
   - What subtle patterns reveal their thinking process?
   - What assumptions do they make about AI capabilities?
   - How do they handle uncertainty or ambiguity?
   - What motivates their questions?

Return ONLY a JSON object with this structure:
{
  "userInteractionStyle": {
    "communicationType": "direct|exploratory|detailed|concise|iterative",
    "questionStyle": "specific|open-ended|follow-up|clarifying",
    "engagementLevel": "high|medium|low",
    "patienceLevel": "high|medium|low"
  },
  "conversationDynamics": {
    "topicDepth": "surface|moderate|deep|expert",
    "focusPattern": "single-topic|multi-topic|branching|returning",
    "complexityProgression": "increasing|decreasing|stable|fluctuating",
    "responsePreference": "detailed|concise|step-by-step|overview"
  },
  "behavioralInsights": {
    "learningStyle": "visual|practical|theoretical|experimental",
    "problemSolvingApproach": "systematic|creative|pragmatic|analytical",
    "confidenceLevel": "high|medium|low",
    "expertiseArea": ["area1", "area2"],
    "improvementAreas": ["area1", "area2"]
  },
  "interactionQuality": {
    "clarityScore": 1-10,
    "efficiencyScore": 1-10,
    "satisfactionPrediction": 1-10,
    "potentialFrustrationPoints": ["point1", "point2"]
  },
  "hiddenInsights": {
    "thinkingPattern": "description of how they think",
    "aiAssumptions": "what they assume about AI",
    "uncertaintyHandling": "how they handle uncertainty",
    "motivation": "what drives their questions"
  }
}`;

    try {
      // Check if the AI service is available and properly configured
      if (!this.aiService || typeof this.aiService.sendChatCompletion !== 'function') {
        console.warn('‚ö†Ô∏è AI service not properly configured for analysis, using fallback');
        return this.generateEnhancedFallbackAnalysis(messages, currentModel);
      }

      // Get the service type for logging
      const serviceName = this.aiService.constructor?.name || 'Unknown';
      console.log(`ü§ñ Using ${serviceName} for conversation analysis`);

      // Adjust token limit based on provider (Gemini needs more tokens for JSON responses)
      // Increased from 2048 to 4096 for Gemini to prevent truncation
      const maxTokens = serviceName.includes('Gemini') ? 4096 : 1500;
      console.log(`üìä Requesting ${maxTokens} max tokens for analysis`);

      // Try to use the AI service for analysis (works with any provider that supports sendChatCompletion)
      const response = await this.aiService.sendChatCompletion([
        {
          role: "system",
          content: "You are an expert in analyzing human-AI interaction patterns. Focus on revealing subtle insights about user behavior, communication style, and interaction preferences. Be insightful and specific."
        },
        {
          role: "user",
          content: analysisPrompt
        }
      ], { maxTokens, temperature: 0.3 });

      console.log('üì° Enhanced analysis response received:', response.substring(0, 200) + '...');
      
      const parsed = this.parseAnalysisResponse(response);
      if (parsed) {
        console.log('‚úÖ Successfully parsed enhanced analysis:', parsed);
        return parsed;
      } else {
        console.warn('‚ö†Ô∏è Could not parse enhanced analysis, using fallback');
        return this.generateEnhancedFallbackAnalysis(messages, currentModel);
      }
    } catch (apiError: any) {
      console.error('‚ùå Enhanced analysis failed:', apiError);
      // Don't log the full error if it's a known issue (like service not available)
      if (apiError.message?.includes('endpoint error') || apiError.message?.includes('403') || apiError.message?.includes('API key')) {
        console.log('‚ÑπÔ∏è AI service not available for analysis, using fallback');
      }
      return this.generateEnhancedFallbackAnalysis(messages, currentModel);
    }
  }

  /**
   * Robust JSON parsing for AI service responses
   */
  private parseAnalysisResponse(response: string): any {
    try {
      console.log('üì° Raw AI response length:', response.length);
      console.log('üì° Raw AI response preview:', response.substring(0, 300) + '...');
      
      // Strategy 0: First check if response is wrapped in markdown code blocks
      let cleanedResponse = response.trim();
      
      // Remove markdown code block wrapper if present
      if (cleanedResponse.startsWith('```json')) {
        cleanedResponse = cleanedResponse.substring(7); // Remove ```json
      } else if (cleanedResponse.startsWith('```')) {
        cleanedResponse = cleanedResponse.substring(3); // Remove ```
      }
      
      if (cleanedResponse.endsWith('```')) {
        cleanedResponse = cleanedResponse.substring(0, cleanedResponse.length - 3);
      }
      
      cleanedResponse = cleanedResponse.trim();
      
      // Strategy 1: Try parsing cleaned response first
      try {
        const parsed = JSON.parse(cleanedResponse);
        console.log('‚úÖ JSON parsed successfully after cleaning markdown');
        
        if (this.validateAnalysisResponse(parsed)) {
          return parsed;
        } else {
          console.warn('‚ö†Ô∏è Parsed JSON but validation failed:', parsed);
        }
      } catch (directParseError) {
        console.log('‚ùå Direct JSON parse failed after cleaning:', directParseError);
        
        // Try original response as fallback
        try {
          const parsed = JSON.parse(response);
          console.log('‚úÖ JSON parsed successfully without cleaning');
          
          if (this.validateAnalysisResponse(parsed)) {
            return parsed;
          }
        } catch (originalError) {
          console.log('‚ùå Original response parse also failed:', originalError);
        }
      }

      // Strategy 2: Extract JSON from text
      const jsonExtractionPatterns = [
        // Look for complete JSON objects
        /\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g,
        // Look for JSON that might be wrapped in markdown code blocks
        /```(?:json)?\s*(\{[\s\S]*?\})\s*```/gi,
        // Look for JSON starting after a colon or other delimiter
        /[:\n]\s*(\{[\s\S]*\})/g
      ];

      for (let patternIndex = 0; patternIndex < jsonExtractionPatterns.length; patternIndex++) {
        const pattern = jsonExtractionPatterns[patternIndex];
        const matches = response.match(pattern);
        
        if (matches) {
          console.log(`üéØ Found ${matches.length} potential JSON matches with pattern ${patternIndex + 1}`);
          
          for (let matchIndex = 0; matchIndex < matches.length; matchIndex++) {
            let jsonStr = matches[matchIndex];
            
            // Clean up the match
            if (pattern.source.includes('```')) {
              // Extract from markdown code block
              const codeBlockMatch = jsonStr.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/i);
              if (codeBlockMatch) {
                jsonStr = codeBlockMatch[1];
              }
            } else if (pattern.source.includes('[:\\n]')) {
              // Remove leading delimiter
              jsonStr = jsonStr.replace(/^[:\n]\s*/, '');
            }
            
            console.log(`üß™ Trying to parse match ${matchIndex + 1}:`, jsonStr.substring(0, 200) + '...');
            
            // Strategy 3: Try with conservative sanitization
            try {
              const sanitized = this.conservativeSanitizeJSON(jsonStr);
              console.log('üßΩ Sanitized JSON:', sanitized.substring(0, 200) + '...');
              
              const parsed = JSON.parse(sanitized);
              
              if (this.validateAnalysisResponse(parsed)) {
                console.log('‚úÖ Successfully parsed and validated JSON with conservative sanitization');
                return parsed;
              } else {
                console.warn('‚ö†Ô∏è Parsed JSON but validation failed');
              }
            } catch (conservativeError) {
              console.warn(`‚ö†Ô∏è Conservative sanitization failed for match ${matchIndex + 1}:`, conservativeError);
              
              // Strategy 4: Try with aggressive sanitization as last resort
              try {
                const aggressiveSanitized = this.aggressiveSanitizeJSON(jsonStr);
                console.log('üîß Aggressively sanitized JSON:', aggressiveSanitized.substring(0, 200) + '...');
                
                const parsed = JSON.parse(aggressiveSanitized);
                
                if (this.validateAnalysisResponse(parsed)) {
                  console.log('‚úÖ Successfully parsed and validated JSON with aggressive sanitization');
                  return parsed;
                }
              } catch (aggressiveError) {
                console.warn(`‚ö†Ô∏è Aggressive sanitization failed for match ${matchIndex + 1}:`, aggressiveError);
                
                // Log detailed error information for debugging
                this.logDetailedParsingError(jsonStr, aggressiveError);
              }
            }
          }
        }
      }

      console.warn('‚ö†Ô∏è No valid JSON found in Azure AI response after all attempts');
      return null;
    } catch (error) {
      console.error('‚ùå JSON parsing completely failed:', error);
      return null;
    }
  }

  /**
   * Conservative JSON sanitization - only fixes the most common, safe issues
   */
  private conservativeSanitizeJSON(jsonStr: string): string {
    let result = jsonStr
      .trim()
      // Remove any leading/trailing non-JSON content
      .replace(/^[^{]*/, '')
      .replace(/[^}]*$/, '');
    
    // Check if the JSON seems to be incomplete (missing closing braces)
    const openBraces = (result.match(/{/g) || []).length;
    const closeBraces = (result.match(/}/g) || []).length;
    
    if (openBraces > closeBraces) {
      console.log(`üîß Fixing incomplete JSON: ${openBraces} open braces, ${closeBraces} close braces`);
      // Add missing closing braces
      const missingBraces = openBraces - closeBraces;
      for (let i = 0; i < missingBraces; i++) {
        result += '}';
      }
    }
    
    // Fix trailing commas (most common issue)
    result = result.replace(/,(\s*[}\]])/g, '$1');
    
    // Fix unquoted property names (but be careful with already quoted ones)
    result = result.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*:)/g, '$1"$2"$3');
    
    // Don't touch apostrophes - they're valid in JSON strings
    // The issue is likely something else
    
    return result;
  }

  /**
   * Aggressive JSON sanitization - for when conservative approach fails
   */
  private aggressiveSanitizeJSON(jsonStr: string): string {
    // Start with conservative fixes
    jsonStr = this.conservativeSanitizeJSON(jsonStr);
    
    // Additional check: if JSON appears truncated, try to complete it with minimal structure
    // Look for the last complete property
    if (jsonStr.includes('"userInteractionStyle"') && !jsonStr.includes('"conversationDynamics"')) {
      console.log('üîß JSON appears truncated after userInteractionStyle, attempting to complete structure');
      // Try to complete with minimal valid structure
      const lastCompleteObject = jsonStr.lastIndexOf('}');
      if (lastCompleteObject > -1) {
        // Check if we're inside an object that needs completion
        const afterLastObject = jsonStr.substring(lastCompleteObject + 1).trim();
        if (afterLastObject && !afterLastObject.startsWith(',') && !afterLastObject.startsWith('}')) {
          // We're likely in the middle of an incomplete structure
          jsonStr = jsonStr.substring(0, lastCompleteObject + 1);
          
          // Add minimal completion for missing properties
          const openBraces = (jsonStr.match(/{/g) || []).length;
          const closeBraces = (jsonStr.match(/}/g) || []).length;
          
          if (openBraces > closeBraces) {
            const missingBraces = openBraces - closeBraces;
            for (let i = 0; i < missingBraces; i++) {
              jsonStr += '}';
            }
          }
        }
      }
    }
    
    // Fix common Gemini-specific issues
    // Look for patterns like: "user's goal" and similar unescaped quotes
    jsonStr = jsonStr.replace(/"([^"]*)'([^"]*)"/g, (match, before, after) => {
      // Replace unescaped apostrophes with escaped ones or remove them
      return `"${before}${after}"`;
    });
    
    // More aggressive fixes
    jsonStr = jsonStr
      // Fix boolean values that might be quoted
      .replace(/:\s*"(true|false|null)"/g, ': $1')
      // Fix number values that might be quoted
      .replace(/:\s*"(\d+(?:\.\d+)?)"/g, ': $1')
      // Fix array syntax issues - be more careful with the content
      .replace(/\[\s*([^\[\]]*?)\s*\]/g, (match, content) => {
        if (!content.trim()) return '[]';
        
        // Handle arrays more carefully
        // Split by comma but be aware of commas inside quotes
        const items: string[] = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < content.length; i++) {
          const char = content[i];
          if (char === '"' && (i === 0 || content[i-1] !== '\\')) {
            inQuotes = !inQuotes;
          }
          if (char === ',' && !inQuotes) {
            items.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        if (current.trim()) {
          items.push(current.trim());
        }
        
        // Process each item
        const processedItems = items.map((item: string) => {
          if (!item) return null;
          
          // If already quoted properly, keep as is
          if ((item.startsWith('"') && item.endsWith('"')) || 
              item === 'true' || item === 'false' || item === 'null' || 
              /^\d+(\.\d+)?$/.test(item)) {
            return item;
          }
          
          // Quote everything else, removing problematic characters
          const cleaned = item.replace(/['"]/g, '');
          return `"${cleaned}"`;
        }).filter(item => item !== null);
        
        return `[${processedItems.join(', ')}]`;
      })
      // Try to fix unquoted string values (very carefully)
      .replace(/:\s*([a-zA-Z][a-zA-Z0-9_\-]*)\s*([,}\]])/g, ': "$1"$2');
    
    return jsonStr;
  }

  /**
   * Log detailed information about parsing errors for debugging
   */
  private logDetailedParsingError(jsonStr: string, error: any): void {
    console.error('üîç Detailed parsing error analysis:');
    console.error('Error:', error.message);
    
    if (error.message.includes('position')) {
      const positionMatch = error.message.match(/position (\d+)/);
      if (positionMatch) {
        const position = parseInt(positionMatch[1]);
        const start = Math.max(0, position - 50);
        const end = Math.min(jsonStr.length, position + 50);
        const context = jsonStr.substring(start, end);
        const pointer = ' '.repeat(Math.min(50, position - start)) + '^';
        
        console.error('Context around error position:');
        console.error(context);
        console.error(pointer);
        console.error(`Character at error position: "${jsonStr[position]}" (code: ${jsonStr.charCodeAt(position)})`);
      }
    }
    
    // Show first few lines of the JSON for structure analysis
    const lines = jsonStr.split('\n').slice(0, 10);
    console.error('First 10 lines of JSON:');
    lines.forEach((line, index) => {
      console.error(`${index + 1}: ${line}`);
    });
  }

  /**
   * Validate that the parsed response has the expected structure
   */
  private validateAnalysisResponse(obj: any): boolean {
    return obj && 
           typeof obj === 'object' &&
           (obj.userInteractionStyle || obj.conversationDynamics || obj.behavioralInsights || 
            obj.taskType || obj.complexity || obj.modelOptimal !== undefined);
  }

  /**
   * Generate enhanced fallback analysis when Azure AI is not available
   */
  private generateEnhancedFallbackAnalysis(messages: Message[], currentModel: LLMModel): any {
    console.log('üîÑ Generating enhanced fallback analysis...');
    
    const userMessages = messages.filter(m => m.role === 'user');
    const assistantMessages = messages.filter(m => m.role === 'assistant');
    
    // Analyze message patterns
    const avgUserMessageLength = userMessages.reduce((sum, m) => sum + m.content.length, 0) / userMessages.length;
    const hasCode = userMessages.some(m => m.content.includes('```') || m.content.toLowerCase().includes('code'));
    const hasQuestions = userMessages.some(m => m.content.includes('?'));
    const hasFollowUps = userMessages.length > 2 && userMessages.slice(-2).some(m => 
      m.content.toLowerCase().includes('what about') || 
      m.content.toLowerCase().includes('can you') ||
      m.content.toLowerCase().includes('how about')
    );
    
    // Determine interaction patterns based on message count and content
    const communicationType = avgUserMessageLength > 200 ? 'detailed' : 
                             hasFollowUps ? 'iterative' : 
                             hasQuestions ? 'exploratory' : 'direct';
    
    const questionStyle = hasFollowUps ? 'follow-up' : 
                         hasQuestions ? 'open-ended' : 'specific';
    
    const engagementLevel = userMessages.length > 5 ? 'high' : 
                           userMessages.length > 2 ? 'medium' : 'low';
    
    // Determine learning style based on content
    const learningStyle = hasCode ? 'practical' : 
                         avgUserMessageLength > 150 ? 'theoretical' : 'experimental';
    
    // Determine problem-solving approach
    const problemSolvingApproach = hasCode ? 'systematic' : 
                                  hasFollowUps ? 'iterative' : 'creative';
    
    // Determine confidence level based on question patterns
    const confidenceLevel = hasFollowUps ? 'medium' : 
                           hasQuestions ? 'low' : 'high';
    
    // Determine topic depth
    const topicDepth = hasCode ? 'deep' : 
                      avgUserMessageLength > 100 ? 'moderate' : 'surface';
    
    // Determine focus pattern
    const focusPattern = userMessages.length > 8 ? 'multi-topic' : 'single-topic';
    
    // Calculate interaction quality scores
    const clarityScore = Math.min(10, Math.max(1, 8 - (userMessages.length * 0.2)));
    const efficiencyScore = Math.min(10, Math.max(1, 7 - (userMessages.length * 0.15)));
    const satisfactionPrediction = Math.min(10, Math.max(1, 9 - (userMessages.length * 0.1)));
    
    // Generate thinking pattern based on interaction style
    const thinkingPattern = hasCode ? "You approach problems systematically with practical solutions" :
                           hasFollowUps ? "You build understanding iteratively, refining your approach" :
                           "You seek comprehensive understanding before taking action";
    
    // Generate AI assumptions based on interaction style
    const aiAssumptions = hasCode ? "You expect precise, actionable technical guidance" :
                         hasFollowUps ? "You expect the AI to build on previous responses" :
                         "You expect comprehensive, detailed explanations";
    
    // Generate uncertainty handling based on question patterns
    const uncertaintyHandling = hasQuestions ? "You ask clarifying questions when concepts are unclear" :
                               hasFollowUps ? "You explore alternatives to find the best approach" :
                               "You prefer to gather comprehensive information before proceeding";
    
    // Generate motivation based on interaction patterns
    const motivation = hasCode ? "You're motivated by practical problem-solving and skill development" :
                      hasFollowUps ? "You're motivated by thorough understanding and optimal solutions" :
                      "You're motivated by comprehensive knowledge and clear explanations";
    
    return {
      userInteractionStyle: {
        communicationType,
        questionStyle,
        engagementLevel,
        patienceLevel: 'medium'
      },
      conversationDynamics: {
        topicDepth,
        focusPattern,
        complexityProgression: 'stable',
        responsePreference: 'detailed'
      },
      behavioralInsights: {
        learningStyle,
        problemSolvingApproach,
        confidenceLevel,
        expertiseArea: hasCode ? ['programming', 'technical'] : ['general', 'analytical'],
        improvementAreas: ['communication_clarity', 'focus_optimization']
      },
      interactionQuality: {
        clarityScore: Math.round(clarityScore),
        efficiencyScore: Math.round(efficiencyScore),
        satisfactionPrediction: Math.round(satisfactionPrediction),
        potentialFrustrationPoints: ['response_length', 'complexity', 'context_switching']
      },
      hiddenInsights: {
        thinkingPattern,
        aiAssumptions,
        uncertaintyHandling,
        motivation
      }
    };
  }

  private getModelStrengths(model: LLMModel): string[] {
    const strengths: string[] = [];
    
    if (model.performance >= 95) strengths.push("Exceptional accuracy");
    if (model.capabilities?.supportsVision) strengths.push("Image analysis");
    if (model.capabilities?.supportsCodeGeneration) strengths.push("Code generation");
    if (model.category === "code") strengths.push("Programming expertise");
    if (model.category === "reasoning") strengths.push("Complex reasoning");
    if (model.latency < 700) strengths.push("Fast response");
    if (model.cost < 0.001) strengths.push("Cost-effective");
    if (model.contextLength > 100000) strengths.push("Long context");
    
    return strengths;
  }

  private getModelBestUseCase(model: LLMModel): string {
    if (model.category === "code") return "Programming and software development";
    if (model.category === "multimodal") return "Image analysis and complex tasks";
    if (model.category === "reasoning") return "Complex problem solving and analysis";
    if (model.performance >= 95) return "High-accuracy professional tasks";
    if (model.cost < 0.001) return "High-volume or cost-sensitive applications";
    return "General-purpose conversations";
  }

  /**
   * Generate insight-based recommendations from conversation analysis
   */
  private generateInsightBasedRecommendations(insights: any): SmartToast[] {
    const recommendations: SmartToast[] = [];
    
    console.log('üß† Generating insight-based recommendations from:', insights);
    
    // Communication style insights
    if (insights.userInteractionStyle?.communicationType === 'detailed') {
      recommendations.push({
        id: 'communication-style-detailed',
        title: "üìù Detailed Communicator Detected",
        description: "You prefer comprehensive explanations. The AI is adapting to provide more thorough responses.",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.userInteractionStyle?.communicationType === 'iterative') {
      recommendations.push({
        id: 'communication-style-iterative',
        title: "üîÑ Iterative Problem Solver",
        description: "You build solutions step by step. This approach often leads to better results!",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.userInteractionStyle?.communicationType === 'exploratory') {
      recommendations.push({
        id: 'communication-style-exploratory',
        title: "üîç Exploratory Thinker",
        description: "You explore topics thoroughly. This helps uncover the best solutions!",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    // Learning style insights
    if (insights.behavioralInsights?.learningStyle === 'practical') {
      recommendations.push({
        id: 'learning-style-practical',
        title: "üîß Hands-On Learner",
        description: "You learn best through practical examples. Try asking for code samples or step-by-step guides.",
        category: 'suggestion',
        priority: 'medium',
        actionable: false
      });
    }
    
    if (insights.behavioralInsights?.learningStyle === 'theoretical') {
      recommendations.push({
        id: 'learning-style-theoretical',
        title: "üìö Theoretical Learner",
        description: "You prefer understanding concepts deeply. The AI is providing comprehensive explanations.",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    // Confidence insights
    if (insights.behavioralInsights?.confidenceLevel === 'low') {
      recommendations.push({
        id: 'confidence-boost',
        title: "üí™ Building Confidence",
        description: "Your questions show you're learning. Don't hesitate to ask for clarification - it's a sign of good thinking!",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.behavioralInsights?.confidenceLevel === 'high') {
      recommendations.push({
        id: 'confidence-high',
        title: "üöÄ Confident Problem Solver",
        description: "Your confident approach helps you tackle complex challenges effectively!",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    // Efficiency insights
    if (insights.interactionQuality?.efficiencyScore < 6) {
      recommendations.push({
        id: 'efficiency-tip',
        title: "‚ö° Efficiency Tip",
        description: "Try being more specific in your questions. It helps the AI provide more targeted, useful responses.",
        category: 'suggestion',
        priority: 'medium',
        actionable: false
      });
    }
    
    if (insights.interactionQuality?.efficiencyScore >= 8) {
      recommendations.push({
        id: 'efficiency-high',
        title: "‚ö° Highly Efficient",
        description: "Your communication style is very efficient! You get great results with clear, focused questions.",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    // Hidden pattern insights
    if (insights.hiddenInsights?.thinkingPattern) {
      recommendations.push({
        id: 'thinking-pattern',
        title: "üß† Your Thinking Pattern",
        description: insights.hiddenInsights.thinkingPattern,
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.hiddenInsights?.motivation) {
      recommendations.push({
        id: 'motivation-insight',
        title: "üéØ Your Motivation",
        description: insights.hiddenInsights.motivation,
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    // Interaction quality insights
    if (insights.interactionQuality?.satisfactionPrediction >= 8) {
      recommendations.push({
        id: 'high-satisfaction',
        title: "üòä Great Interaction Quality",
        description: "You're having a highly effective conversation! Your clear communication style is working well.",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.interactionQuality?.satisfactionPrediction < 6) {
      recommendations.push({
        id: 'satisfaction-improvement',
        title: "üéØ Improving Satisfaction",
        description: "Try being more specific about what you need. It helps the AI provide better, more relevant responses.",
        category: 'suggestion',
        priority: 'medium',
        actionable: false
      });
    }
    
    // Topic depth insights
    if (insights.conversationDynamics?.topicDepth === 'deep') {
      recommendations.push({
        id: 'topic-depth-deep',
        title: "üî¨ Deep Dive Expert",
        description: "You're exploring topics in depth. This approach reveals valuable insights and solutions.",
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }
    
    if (insights.conversationDynamics?.topicDepth === 'expert') {
      recommendations.push({
        id: 'topic-depth-expert',
        title: "üéì Expert Level Analysis",
        description: "You're working at an expert level. Consider using the Technical system preset for even more detailed responses.",
        category: 'enhancement',
        priority: 'medium',
        actionable: true
      });
    }
    
    // Focus pattern insights
    if (insights.conversationDynamics?.focusPattern === 'multi-topic') {
      recommendations.push({
        id: 'focus-multi-topic',
        title: "üéØ Multi-Topic Explorer",
        description: "You're covering multiple topics. This shows broad thinking, but focusing on one area at a time can lead to deeper insights.",
        category: 'suggestion',
        priority: 'low',
        actionable: false
      });
    }
    
    console.log(`üí° Generated ${recommendations.length} insight-based recommendations`);
    return recommendations;
  }

  private generateRecommendations(analysis: any, currentModel: LLMModel): SmartToast[] {
    const recommendations: SmartToast[] = [];

    console.log('üí° Generating recommendations with analysis:', analysis);
    console.log('üìä Current metrics:', this.metrics);

    // PRIORITY 1: Long conversation warnings (highest priority - actionable)
    if (this.metrics.messageCount >= 20) {
      recommendations.push({
        id: 'long-conversation-warning',
        title: "üìä Long Conversation Alert",
        description: `You've had ${this.metrics.messageCount} messages. Consider starting a new chat for better performance and context clarity.`,
        category: 'alert',
        priority: 'high',
        actionable: true,
        action: {
          label: "New Chat",
          callback: () => this.triggerNewChat()
        }
      });
    }

    // PRIORITY 2: Token usage optimization (lowered threshold for earlier warnings)
    if (this.metrics.totalTokens > 10000) { // Reduced from 15000
      recommendations.push({
        id: 'token-optimization',
        title: "üìä Token Usage Alert",
        description: `High token usage (${this.metrics.totalTokens.toLocaleString()}). Consider starting a new conversation for optimal context`,
        category: 'alert',
        priority: 'high',
        actionable: true,
        action: {
          label: "New Chat",
          callback: () => this.triggerNewChat()
        }
      });
    }

    // PRIORITY 3: AI-generated insights (only if analysis is available and has real insights)
    if (analysis && (analysis.userInteractionStyle || analysis.behavioralInsights || analysis.hiddenInsights)) {
      console.log('üß† Analysis has insight data, generating insight-based recommendations...');
      console.log('üìã userInteractionStyle:', analysis.userInteractionStyle);
      console.log('üìã behavioralInsights:', analysis.behavioralInsights);
      console.log('üìã hiddenInsights:', analysis.hiddenInsights);
      
      const insightRecommendations = this.generateInsightBasedRecommendations(analysis);
      recommendations.push(...insightRecommendations);
      console.log(`üí° Generated ${insightRecommendations.length} insight-based recommendations:`, 
        insightRecommendations.map((r: SmartToast) => r.title));
    } else {
      console.log('‚ö†Ô∏è Analysis missing insight data. Available keys:', Object.keys(analysis || {}));
    }

    // PRIORITY 4: Performance insights
    if (this.metrics.averageResponseTime > 3000) {
      recommendations.push({
        id: 'performance-slow',
        title: "‚ö° Performance Insight",
        description: `Average response time is ${(this.metrics.averageResponseTime/1000).toFixed(1)}s. Consider a faster model for better experience`,
        category: 'insight',
        priority: 'medium',
        actionable: true
      });
    }

    // PRIORITY 5: Model optimization recommendations
    if (!analysis?.modelOptimal && 
        analysis?.modelRecommendation && 
        analysis.modelRecommendation !== currentModel.id &&
        analysis?.confidenceScore >= 7) {
      
      const recommendedModel = this.availableModels.find(m => m.id === analysis.modelRecommendation);
      if (recommendedModel) {
        const efficiencyGain = this.calculateRealEfficiencyGain(currentModel, recommendedModel, analysis.taskType);
        
        recommendations.push({
          id: `model-opt-${analysis.modelRecommendation}`,
          title: "üöÄ Model Optimization",
          description: `${recommendedModel.name} would be ${efficiencyGain}% more effective for ${analysis.taskType} tasks. ${analysis.improvementReason || 'Better suited for this type of work.'}`,
          category: 'optimization',
          priority: 'medium',
          actionable: true,
          action: {
            label: "Switch Model",
            callback: () => this.triggerModelSwitch(analysis.modelRecommendation)
          }
        });
      }
    }

    // PRIORITY 6: Context quality recommendations
    if (analysis?.focusScore < 6 && this.metrics.messageCount > 6) {
      recommendations.push({
        id: 'context-focus',
        title: "üéØ Context Enhancement",
        description: "Conversation is covering multiple topics. Consider focusing on one area for better assistance",
        category: 'suggestion',
        priority: 'low',
        actionable: false
      });
    }

    // PRIORITY 7: Feature enhancement suggestions
    if (analysis?.taskType === 'coding' && this.metrics.attachmentUsage === 0 && this.metrics.messageCount > 3) {
      recommendations.push({
        id: 'coding-enhancement',
        title: "üíª Coding Enhancement",
        description: "Upload code files for more accurate analysis and suggestions",
        category: 'enhancement',
        priority: 'low',
        actionable: false
      });
    }

    // PRIORITY 8: Advanced usage patterns
    if (analysis?.complexity === 'expert' && this.metrics.systemMessageChanges === 0 && this.metrics.messageCount > 4) {
      recommendations.push({
        id: 'expert-system-message',
        title: "üß† Expert Mode",
        description: "Try the Technical system preset for more detailed, expert-level responses",
        category: 'enhancement',
        priority: 'medium',
        actionable: true
      });
    }

    // PRIORITY 9: Basic conversation milestone (ONLY if no other recommendations exist)
    if (recommendations.length === 0 && this.metrics.messageCount >= 3 && this.metrics.messageCount % 5 === 0) {
      recommendations.push({
        id: `conversation-milestone-${this.metrics.messageCount}`,
        title: "üéØ Conversation Milestone",
        description: `You've had ${this.metrics.messageCount} messages in this conversation. Great job exploring!`,
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }

    // PRIORITY 10: Basic performance note (ONLY if no other recommendations exist)
    if (recommendations.length === 0 && this.metrics.averageResponseTime > 1000) {
      recommendations.push({
        id: 'basic-performance',
        title: "‚ö° Performance Note",
        description: `Response time averaging ${(this.metrics.averageResponseTime/1000).toFixed(1)}s. This is normal for complex queries.`,
        category: 'insight',
        priority: 'low',
        actionable: false
      });
    }

    console.log(`üìù Generated ${recommendations.length} total recommendations`);
    return recommendations;
  }

  private selectTopRecommendation(recommendations: SmartToast[]): SmartToast | null {
    if (recommendations.length === 0) return null;

    console.log('üéØ Selecting top recommendation from:', recommendations.map(r => ({
      id: r.id,
      title: r.title,
      priority: r.priority,
      category: r.category,
      actionable: r.actionable
    })));

    // Prioritize by urgency and actionability
    const priorityScore = (rec: SmartToast) => {
      let score = 0;
      
      // Priority scoring (highest to lowest)
      if (rec.priority === 'urgent') score += 100;
      else if (rec.priority === 'high') score += 75;
      else if (rec.priority === 'medium') score += 50;
      else score += 25;

      // Actionable items get bonus points
      if (rec.actionable) score += 30;
      
      // Category bonuses
      if (rec.category === 'alert') score += 25; // Alerts are important
      if (rec.category === 'optimization') score += 20;
      if (rec.category === 'suggestion') score += 15;
      if (rec.category === 'insight') score += 10;
      
      // Specific recommendation type bonuses
      if (rec.id.includes('long-conversation-warning')) score += 40; // Long conversation warnings are critical
      if (rec.id.includes('token-optimization')) score += 35; // Token optimization is important
      if (rec.id.includes('thinking-pattern')) score += 25; // AI insights are valuable
      if (rec.id.includes('communication-style')) score += 20; // Communication insights are helpful
      
      // Penalize basic milestones when other recommendations exist
      if (rec.id.includes('conversation-milestone')) score -= 20;
      if (rec.id.includes('basic-performance')) score -= 15;
      
      return score;
    };

    const sortedRecommendations = recommendations.sort((a, b) => priorityScore(b) - priorityScore(a));
    const topRecommendation = sortedRecommendations[0];
    
    console.log('üèÜ Top recommendation selected:', {
      id: topRecommendation.id,
      title: topRecommendation.title,
      priority: topRecommendation.priority,
      category: topRecommendation.category,
      actionable: topRecommendation.actionable,
      score: priorityScore(topRecommendation)
    });
    
    // Log why this recommendation was selected over others
    if (sortedRecommendations.length > 1) {
      console.log('üìä Recommendation ranking:');
      sortedRecommendations.slice(0, 3).forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec.title} (${rec.priority}, ${rec.category}, actionable: ${rec.actionable}, score: ${priorityScore(rec)})`);
      });
    }

    return topRecommendation;
  }

  private showSmartToast(smartToast: SmartToast): void {
    console.log('üé¨ Queueing toast:', smartToast.title);
    this.toastQueue.push(smartToast);
    this.processToastQueue();
  }

  private processToastQueue(): void {
    if (this.isShowingToast) return;
    const next = this.toastQueue.shift();
    if (!next) return;

    const now = Date.now();
    const sinceLast = now - this.lastToastTimestamp;
    const wait = Math.max(0, this.MIN_TOAST_GAP_MS - sinceLast);

    this.isShowingToast = true;

    window.setTimeout(() => {
      const duration = next.priority === 'urgent' ? 10000 :
                       next.priority === 'high' ? 8000 : 6000;

      console.log('üöÄ Displaying queued toast:', next.title);
      this.toastFunction(next.title, {
        description: next.description,
        duration,
        action: next.action ? { label: next.action.label, onClick: next.action.callback } : undefined
      });

      // Schedule ready for next toast after this one finishes plus a small buffer
      window.setTimeout(() => {
        this.lastToastTimestamp = Date.now();
        this.isShowingToast = false;
        this.processToastQueue();
      }, duration + 400);
    }, wait);
  }

  private getCategoryIcon(category: string): string {
    switch (category) {
      case 'optimization': return 'üöÄ';
      case 'suggestion': return 'üí°';
      case 'insight': return 'üìä';
      case 'enhancement': return '‚ú®';
      case 'alert': return '‚ö†Ô∏è';
      default: return 'üí°';
    }
  }

  private updateMetrics(
    messages: Message[], 
    currentModel: LLMModel, 
    responseTime?: number, 
    tokenUsage?: number
  ): void {
    this.metrics.messageCount = messages.length;
    this.metrics.currentModel = currentModel.id;
    
    // Update interaction patterns
    this.updateInteractionPatterns(messages);
    
    if (responseTime) {
      this.performanceHistory.push({
        responseTime,
        tokenUsage: tokenUsage || 0,
        modelMatch: this.calculateModelMatch(messages, currentModel),
        contextQuality: this.calculateContextQuality(messages),
        timestamp: Date.now()
      });

      // Keep only last 50 performance records
      if (this.performanceHistory.length > 50) {
        this.performanceHistory = this.performanceHistory.slice(-50);
      }

      this.metrics.averageResponseTime = this.performanceHistory.reduce((sum, p) => sum + p.responseTime, 0) / this.performanceHistory.length;
    }

    if (tokenUsage) {
      this.metrics.totalTokens += tokenUsage;
    }
  }

  private updateInteractionPatterns(messages: Message[]): void {
    const userMessages = messages.filter(m => m.role === 'user');
    
    if (userMessages.length === 0) return;
    
    // Calculate average message length
    const totalLength = userMessages.reduce((sum, m) => sum + m.content.length, 0);
    this.metrics.interactionPatterns.averageMessageLength = totalLength / userMessages.length;
    
    // Analyze recent communication patterns
    const recentMessages = userMessages.slice(-5);
    const hasQuestions = recentMessages.some(m => m.content.includes('?'));
    const hasFollowUps = recentMessages.length > 1 && recentMessages.slice(-2).some(m => 
      m.content.toLowerCase().includes('what about') || 
      m.content.toLowerCase().includes('can you') ||
      m.content.toLowerCase().includes('how about')
    );
    
    // Update communication types
    if (this.metrics.interactionPatterns.averageMessageLength > 200 && 
        !this.metrics.interactionPatterns.communicationTypes.includes('detailed')) {
      this.metrics.interactionPatterns.communicationTypes.push('detailed');
    }
    
    if (hasFollowUps && !this.metrics.interactionPatterns.communicationTypes.includes('iterative')) {
      this.metrics.interactionPatterns.communicationTypes.push('iterative');
    }
    
    // Update question styles
    if (hasQuestions && !this.metrics.interactionPatterns.questionStyles.includes('open-ended')) {
      this.metrics.interactionPatterns.questionStyles.push('open-ended');
    }
    
    if (hasFollowUps && !this.metrics.interactionPatterns.questionStyles.includes('follow-up')) {
      this.metrics.interactionPatterns.questionStyles.push('follow-up');
    }
    
    // Calculate follow-up frequency
    this.metrics.interactionPatterns.followUpFrequency = hasFollowUps ? 
      (this.metrics.interactionPatterns.followUpFrequency + 1) / 2 : 
      this.metrics.interactionPatterns.followUpFrequency * 0.9;
  }

  private calculateModelMatch(messages: Message[], model: LLMModel): number {
    // Simple heuristic for how well the model matches the conversation
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage) return 100;

    const content = lastMessage.content.toLowerCase();
    const hasCode = /```|function|class|const|let|var|import|export/.test(content);
    const hasImages = messages.some(m => m.attachments?.length);
    const isAnalytical = /analyze|compare|evaluate|assess|review/.test(content);

    let score = 50;

    if (hasCode && model.capabilities?.supportsCodeGeneration) score += 30;
    if (hasImages && model.capabilities?.supportsVision) score += 30;
    if (isAnalytical && model.capabilities?.supportsAnalysis) score += 20;

    return Math.min(100, score);
  }

  private calculateContextQuality(messages: Message[]): number {
    // Simple heuristic for conversation focus
    if (messages.length < 3) return 100;

    const topics = new Set<string>();
    messages.slice(-10).forEach(msg => {
      const words = msg.content.toLowerCase().split(' ');
      words.forEach(word => {
        if (word.length > 5) topics.add(word);
      });
    });

    // More unique topics = less focused
    return Math.max(20, 100 - (topics.size * 2));
  }

  private calculateRealEfficiencyGain(currentModel: LLMModel, recommendedModel: LLMModel, taskType: string): number {
    // Calculate efficiency gain based on actual model performance differences
    let baseGain = Math.max(0, recommendedModel.performance - currentModel.performance);
    
    // Apply task-specific multipliers
    const taskMultipliers: Record<string, number> = {
      'coding': recommendedModel.capabilities?.supportsCodeGeneration ? 1.5 : 0.8,
      'technical': recommendedModel.category === 'reasoning' ? 1.4 : 1.0,
      'analysis': recommendedModel.capabilities?.supportsAnalysis ? 1.3 : 1.0,
      'creative': recommendedModel.category === 'text' ? 1.2 : 1.0,
      'multimodal': recommendedModel.capabilities?.supportsVision ? 1.6 : 1.0
    };
    
    const multiplier = taskMultipliers[taskType] || 1.0;
    const adjustedGain = Math.round(baseGain * multiplier);
    
    // Ensure realistic range (15-60% improvement)
    return Math.max(15, Math.min(60, adjustedGain));
  }

  private triggerModelSwitch(modelId: string): void {
    if (this.modelSwitchCallback) {
      this.modelSwitchCallback(modelId);
    } else {
      console.warn('Model switch callback not configured');
    }
  }

  private triggerNewChat(): void {
    if (this.newChatCallback) {
      this.newChatCallback();
    } else {
      console.warn('New chat callback not configured');
    }
  }

  /**
   * Track specific user actions for analysis
   */
  trackAction(action: string, data?: any): void {
    switch (action) {
      case 'model_switch':
        this.metrics.modelSwitches++;
        break;
      case 'system_message_change':
        this.metrics.systemMessageChanges++;
        break;
      case 'attachment_upload':
        this.metrics.attachmentUsage++;
        break;
      case 'error_occurred':
        this.metrics.errorCount++;
        break;
    }
  }

  /**
   * Get current performance insights
   */
  getPerformanceInsights(): any {
    return {
      averageResponseTime: this.metrics.averageResponseTime,
      totalTokens: this.metrics.totalTokens,
      modelEfficiency: this.metrics.modelEfficiency,
      conversationFocus: this.performanceHistory.length > 0 ? 
        this.performanceHistory[this.performanceHistory.length - 1].contextQuality : 100
    };
  }

  /**
   * Reset analytics (for new conversations)
   */
  resetSession(): void {
    this.metrics = this.initializeMetrics();
    this.performanceHistory = [];
    this.shownRecommendations.clear();
    this.recommendationTimestamps.clear();
    this.lastAnalysisTime = 0;
    console.log('üîÑ Session reset - all metrics, recommendation cache, and timestamps cleared');
  }

  /**
   * Clear recommendation cache (for testing or manual reset)
   */
  clearRecommendationCache(): void {
    this.shownRecommendations.clear();
    this.recommendationTimestamps.clear();
    console.log('üóëÔ∏è Recommendation cache and timestamps cleared');
  }

  /**
   * Force clear cache for a specific recommendation (for testing)
   */
  forceClearRecommendation(recommendationId: string): void {
    this.shownRecommendations.delete(recommendationId);
    this.recommendationTimestamps.delete(recommendationId);
    console.log(`üóëÔ∏è Forced clear cache for: ${recommendationId}`);
  }

  /**
   * Force clear all insight caches (for testing)
   */
  forceClearInsightCaches(): void {
    // Clear all insight-related recommendations from both caches
    const insightIds = Array.from(this.recommendationTimestamps.keys()).filter(id => 
      id.includes('thinking-pattern') || 
      id.includes('communication-style') || 
      id.includes('motivation') ||
      id.includes('confidence') ||
      id.includes('learning-style') ||
      id.includes('satisfaction') ||
      id.includes('topic-depth') ||
      id.includes('focus-')
    );
    
    insightIds.forEach(id => {
      this.shownRecommendations.delete(id);
      this.recommendationTimestamps.delete(id);
    });
    
    console.log(`üóëÔ∏è Forced clear ${insightIds.length} insight caches:`, insightIds);
  }

  /**
   * Test method to manually trigger a specific recommendation (for debugging)
   */
  testShowRecommendation(title: string, description: string, category: 'insight' | 'suggestion' | 'alert' = 'insight'): void {
    const testRecommendation: SmartToast = {
      id: `test-${Date.now()}`,
      title,
      description,
      category,
      priority: 'medium',
      actionable: false
    };
    
    console.log('üß™ Testing recommendation:', testRecommendation);
    this.showSmartToast(testRecommendation);
    this.markRecommendationShown(testRecommendation);
  }

  /**
   * Get current recommendation cache status (for debugging)
   */
  getRecommendationCacheStatus(): { 
    permanentCacheSize: number; 
    permanentCachedIds: string[];
    timestampCacheSize: number;
    timestampCachedIds: Array<{id: string, lastShown: number, minutesAgo: number}>;
  } {
    const now = Date.now();
    const timestampEntries = Array.from(this.recommendationTimestamps.entries()).map(([id, timestamp]) => ({
      id,
      lastShown: timestamp,
      minutesAgo: Math.round((now - timestamp) / 1000 / 60)
    }));

    return {
      permanentCacheSize: this.shownRecommendations.size,
      permanentCachedIds: Array.from(this.shownRecommendations),
      timestampCacheSize: this.recommendationTimestamps.size,
      timestampCachedIds: timestampEntries
    };
  }

  /**
   * Check if a recommendation can be shown based on category-aware caching rules
   */
  private canShowRecommendation(recommendation: SmartToast): boolean {
    const { id, category } = recommendation;
    const rules = this.CACHE_RULES[category as keyof typeof this.CACHE_RULES];
    
    // If no rules defined for this category, default to permanent cache
    if (!rules) {
      console.log(`‚ö†Ô∏è No cache rules for category: ${category}, defaulting to permanent cache`);
      return !this.shownRecommendations.has(id);
    }
    
    // If permanent cache, only show once
    if (rules.permanent) {
      const canShow = !this.shownRecommendations.has(id);
      console.log(`üîí Permanent cache check for ${id}: ${canShow ? 'CAN SHOW' : 'BLOCKED'}`);
      return canShow;
    }
    
    // For non-permanent cache, check cooldown period
    const lastShown = this.recommendationTimestamps.get(id);
    if (!lastShown) {
      console.log(`üÜï First time showing recommendation: ${id}`);
      return true;
    }
    
    const cooldownMs = rules.cooldownMinutes * 60 * 1000;
    const toleranceMs = 10 * 1000; // 10 second tolerance buffer for timing precision
    const timeSinceLastShown = Date.now() - lastShown;
    const canShow = timeSinceLastShown >= (cooldownMs - toleranceMs);
    
    const minutesAgo = Math.round(timeSinceLastShown / 1000 / 60 * 10) / 10; // One decimal place
    const cooldownMinutes = rules.cooldownMinutes;
    
    console.log(`‚è∞ Cooldown check for ${id}: ${minutesAgo}min ago, cooldown: ${cooldownMinutes}min, tolerance: 10s, ${canShow ? 'CAN SHOW' : 'BLOCKED'}`);
    
    if (!canShow) {
      const remainingMs = (cooldownMs - toleranceMs) - timeSinceLastShown;
      const remainingSeconds = Math.ceil(remainingMs / 1000);
      console.log(`‚è∞ ${id} blocked for ${remainingSeconds} more seconds`);
    }
    
    return canShow;
  }

  /**
   * Mark a recommendation as shown
   */
  private markRecommendationShown(recommendation: SmartToast): void {
    const { id, category } = recommendation;
    const rules = this.CACHE_RULES[category as keyof typeof this.CACHE_RULES];
    
    // Always track timestamp
    this.recommendationTimestamps.set(id, Date.now());
    
    // For permanent cache categories, also add to the set
    if (rules?.permanent) {
      this.shownRecommendations.add(id);
      console.log(`üîí Permanently cached: ${id}`);
    } else {
      console.log(`‚è∞ Time-cached: ${id} (can show again in ${rules?.cooldownMinutes || 0} minutes)`);
    }
  }
}

================
File: client/src/lib/lmstudio.ts
================
import { OpenAIMessage, OpenAIConfig, AzureAIMessage, ChatCompletionOptions, LLMModel } from "../types";
import { getModelConfiguration, validateModelParameters } from "./modelConfigurations";

// Tool/Function definition types for LM Studio (OpenAI-compatible)
export interface LMStudioTool {
  type: "function";
  function: {
    name: string;
    description?: string;
    parameters?: Record<string, any>;
  };
}

export interface LMStudioToolChoice {
  type: "function";
  function: {
    name: string;
  };
}

// LM Studio uses an OpenAI-compatible API (proxied via /lmstudio by default)
export class LMStudioService {
  private config: OpenAIConfig;

  constructor(config: OpenAIConfig) {
    // Ensure baseUrl is set to LM Studio default if not provided
    this.config = {
      ...config,
      // Default to backend proxy to avoid CORS/mixed-content issues
      baseUrl: config.baseUrl || "https://lmstudio.uterpi.com"
    };
  }

  updateModel(modelName: string): void {
    this.config.modelName = modelName;
  }

  getCurrentModel(): string {
    return this.config.modelName;
  }

  private estimateTokenCount(messages: OpenAIMessage[]): number {
    return messages.reduce((total, message) => {
      const contentTokens = Math.ceil(message.content.length / 4);
      return total + contentTokens + 10;
    }, 0);
  }

  private truncateConversationHistory(messages: OpenAIMessage[], maxTokens: number): OpenAIMessage[] {
    if (messages.length === 0) return messages;
    const systemMessage = messages[0];
    let remainingMessages = messages.slice(1);
    let totalTokens = this.estimateTokenCount([systemMessage]);
    const result = [systemMessage];
    for (let i = remainingMessages.length - 1; i >= 0; i--) {
      const messageTokens = this.estimateTokenCount([remainingMessages[i]]);
      if (totalTokens + messageTokens <= maxTokens) {
        totalTokens += messageTokens;
        result.splice(1, 0, remainingMessages[i]);
      } else {
        break;
      }
    }
    return result;
  }

  static getAvailableModels(): LLMModel[] {
    // Models available through LM Studio - nomadic-icdu-v8 is the ONLY default
    return [
      {
        id: "nomadic-icdu-v8", // Model ID as shown in LM Studio
        name: "Uterpi AI",
        provider: "Uterpi AI via LM Studio",
        performance: 99,
        cost: 0,
        latency: 250,
        contextLength: 128000,
        description: "Uterpi AI served through LM Studio (OpenAI-compatible endpoint)",
        category: "text",
        tier: "freemium",
        isFavorite: true
      }
    ];
  }

  private convertToOpenAIMessages(azureMessages: AzureAIMessage[]): OpenAIMessage[] {
    return azureMessages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
  }

  async sendChatCompletion(
    messages: AzureAIMessage[],
    options: ChatCompletionOptions & { tools?: LMStudioTool[]; toolChoice?: string | LMStudioToolChoice } = {}
  ): Promise<string> {
    const openAIMessages = this.convertToOpenAIMessages(messages);
    const modelConfig = getModelConfiguration(this.config.modelName);

    const estimatedTokens = this.estimateTokenCount(openAIMessages);
    const maxContextTokens = modelConfig.contextLength || 128000;
    const reserveTokensForResponse = options.maxTokens || 1024;

    let processedMessages = openAIMessages;
    if (estimatedTokens + reserveTokensForResponse > maxContextTokens) {
      processedMessages = this.truncateConversationHistory(openAIMessages, maxContextTokens - reserveTokensForResponse);
    }

    const validatedParams = validateModelParameters(this.config.modelName, {
      maxTokens: options.maxTokens,
      temperature: options.temperature,
      topP: options.topP,
      frequencyPenalty: options.frequencyPenalty,
      presencePenalty: options.presencePenalty
    });

    const requestBody: any = {
      model: this.config.modelName,
      messages: processedMessages,
      max_tokens: validatedParams.maxTokens,
      temperature: validatedParams.temperature,
      top_p: validatedParams.topP,
      stream: false
    };

    // Add tool/function calling support if provided
    if (options.tools && options.tools.length > 0) {
      requestBody.tools = options.tools;
      if (options.toolChoice) {
        requestBody.tool_choice = options.toolChoice;
      }
    }

    if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
      requestBody.frequency_penalty = validatedParams.frequencyPenalty;
    }
    if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
      requestBody.presence_penalty = validatedParams.presencePenalty;
    }
    if (modelConfig.capabilities.supportsStop && options.stop) {
      requestBody.stop = options.stop;
    }

    // Use universal AI proxy for credit checking
    const response = await fetch('/ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        provider: 'lmstudio',
        ...requestBody,
        original_messages: (options as any)?.originalMessages
      })
    });

    if (!response.ok) {
      // Handle credit limit errors specially
      if (response.status === 402) {
        const errorData = await response.json();
        throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
      }
      
      const errorText = await response.text();
      console.error("LM Studio API error:", errorText);
      throw new Error(`LM Studio API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    
    // Extract credit information if present and emit update
    if (data.uterpi_credit_info) {
      const { emitCreditUpdate } = await import('../hooks/useCreditUpdates');
      emitCreditUpdate({
        creditsUsed: data.uterpi_credit_info.credits_used,
        remainingBalance: data.uterpi_credit_info.remaining_balance
      });
    }
    
    // Emit sources event if backend provided citations
    try {
      const sources = (data as any)?.sources;
      if (Array.isArray(sources) && sources.length > 0 && typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('ai-sources', { detail: sources }));
      }
    } catch {}
    
    // Handle tool calls if present
    if (data.choices?.[0]?.message?.tool_calls) {
      console.log("Tool calls detected:", data.choices[0].message.tool_calls);
      // Return the tool calls as JSON string for processing
      return JSON.stringify(data.choices[0].message.tool_calls);
    }
    
    return data.choices?.[0]?.message?.content || "";
  }

  async sendStreamingChatCompletion(
    messages: AzureAIMessage[],
    onChunk: (chunk: string) => void,
    options: ChatCompletionOptions & { tools?: LMStudioTool[]; toolChoice?: string | LMStudioToolChoice } = {}
  ): Promise<void> {
    const openAIMessages = this.convertToOpenAIMessages(messages);
    const modelConfig = getModelConfiguration(this.config.modelName);
    const validatedParams = validateModelParameters(this.config.modelName, {
      maxTokens: options.maxTokens,
      temperature: options.temperature,
      topP: options.topP,
      frequencyPenalty: options.frequencyPenalty,
      presencePenalty: options.presencePenalty
    });

    const requestBody: any = {
      model: this.config.modelName,
      messages: openAIMessages,
      max_tokens: validatedParams.maxTokens,
      temperature: validatedParams.temperature,
      top_p: validatedParams.topP,
      stream: true
    };

    // Add tool/function calling support for streaming
    if (options.tools && options.tools.length > 0) {
      requestBody.tools = options.tools;
      if (options.toolChoice) {
        requestBody.tool_choice = options.toolChoice;
      }
    }

    if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
      requestBody.frequency_penalty = validatedParams.frequencyPenalty;
    }
    if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
      requestBody.presence_penalty = validatedParams.presencePenalty;
    }
    if (modelConfig.capabilities.supportsStop && options.stop) {
      requestBody.stop = options.stop;
    }

    // Use universal AI proxy for credit checking
    const response = await fetch('/ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        provider: 'lmstudio',
        ...requestBody,
        original_messages: (options as any)?.originalMessages
      })
    });

    if (!response.ok) {
      // Handle credit limit errors specially
      if (response.status === 402) {
        const errorData = await response.json();
        throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
      }
      
      const errorText = await response.text();
      throw new Error(`LM Studio streaming error (${response.status}): ${errorText}`);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error("The response stream is undefined");
    }

    const decoder = new TextDecoder();
    let buffer = '';
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6).trim();
            if (data === '[DONE]') return;
            try {
              const eventData = JSON.parse(data);
              for (const choice of eventData.choices || []) {
                const content = choice.delta?.content;
                if (content) onChunk(content);
              }
            } catch {}
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  static createFromEnv(): OpenAIConfig {
    const apiKey = import.meta.env.VITE_LMSTUDIO_API_KEY || "lm-studio";
    const modelName = import.meta.env.VITE_LMSTUDIO_MODEL_NAME || "nomadai-lcdu-v8";
    // Default to backend proxy path
    const baseUrl = import.meta.env.VITE_LMSTUDIO_BASE_URL || "https://lmstudio.uterpi.com";
    return { apiKey, modelName, baseUrl };
  }

  // Helper method to list available models from LM Studio
  async listModels(): Promise<any> {
    try {
      const response = await fetch(`${this.config.baseUrl || "https://lmstudio.uterpi.com"}/v1/models`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.config.apiKey || "lm-studio"}`
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to list models: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Failed to list LM Studio models:", error);
      return { data: [], error: error instanceof Error ? error.message : "Unknown error" };
    }
  }

  static createWithModel(modelName: string): OpenAIConfig {
    const config = this.createFromEnv();
    return { ...config, modelName };
  }
}

================
File: client/src/lib/modelConfigurations.ts
================
import { ModelConfiguration } from "../types";

/**
 * Comprehensive model configurations for Azure AI models
 * Each model has specific parameter limits and capabilities
 */
export const MODEL_CONFIGURATIONS: Record<string, ModelConfiguration> = {
  // Uterpi AI via LM Studio (multiple aliases for compatibility)
  "uterpi-ai": {
    id: "uterpi-ai",
    name: "Uterpi AI",
    provider: "Uterpi AI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 1024,
      temperature: 0.7,
      topP: 0.9,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Uterpi AI served via LM Studio (OpenAI-compatible endpoint)",
      "If streaming is unreliable through tunnels, try non-streaming mode"
    ]
  },
  
  // Gemini Models
  "gemini-2.5-flash": {
    id: "gemini-2.5-flash",
    name: "Gemini 2.5 Flash",
    provider: "Google",
    contextLength: 1048576,
    limits: {
      maxTokens: {
        input: 1048576,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.95,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Gemini 2.5 Flash - Fast multimodal model with 1M context window",
      "Supports image understanding and analysis",
      "Optimized for speed and efficiency"
    ]
  },

  "gemini-2.0-flash": {
    id: "gemini-2.0-flash",
    name: "Gemini 2.0 Flash",
    provider: "Google",
    contextLength: 1048576,
    limits: {
      maxTokens: {
        input: 1048576,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.95,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Gemini 2.0 Flash - Latest fast multimodal model",
      "Enhanced capabilities over 2.5 Flash",
      "Optimized for speed and efficiency"
    ]
  },

  "gemini-1.5-flash": {
    id: "gemini-1.5-flash",
    name: "Gemini 1.5 Flash",
    provider: "Google",
    contextLength: 1048576,
    limits: {
      maxTokens: {
        input: 1048576,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.95,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Gemini 1.5 Flash - Previous generation fast model",
      "1M context window with multimodal support",
      "Stable and well-tested"
    ]
  },

  "gemini-1.5-pro": {
    id: "gemini-1.5-pro",
    name: "Gemini 1.5 Pro",
    provider: "Google",
    contextLength: 2097152,
    limits: {
      maxTokens: {
        input: 2097152,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.95,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Gemini 1.5 Pro - Previous generation advanced model",
      "2M context window for complex tasks",
      "Higher quality than 1.5 Flash"
    ]
  },

  "gemini-pro": {
    id: "gemini-pro",
    name: "Gemini Pro",
    provider: "Google",
    contextLength: 32768,
    limits: {
      maxTokens: {
        input: 32768,
        output: 2048
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 1024,
      temperature: 0.7,
      topP: 0.95,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Gemini Pro - Balanced performance model",
      "Good for general-purpose tasks",
      "32K context window"
    ]
  },
  
  // Uterpi AI via LM Studio (model ID as shown in LM Studio server)
  "nomadai-lcdu-v8": {
    id: "nomadai-lcdu-v8",
    name: "Uterpi AI",
    provider: "Uterpi AI via LM Studio",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 1024,
      temperature: 0.7,
      topP: 0.9,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Uterpi AI served via LM Studio (OpenAI-compatible endpoint)",
      "If streaming is unreliable through tunnels, try non-streaming mode"
    ]
  },

  // Uterpi AI via LM Studio (legacy model ID for compatibility)
  "Pragmanic0/Nomadic-ICDU-v8": {
    id: "Pragmanic0/Nomadic-ICDU-v8",
    name: "Uterpi AI",
    provider: "Uterpi AI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 1024,
      temperature: 0.7,
      topP: 0.9,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    specialInstructions: [
      "Legacy model ID - use nomadai-lcdu-v8 for new implementations",
      "Uterpi AI served via LM Studio (OpenAI-compatible endpoint)"
    ]
  },

  // Hugging Face Endpoint (generic)
  "hf-endpoint": {
    id: "hf-endpoint",
    name: "HuggingFace",
    provider: "Hugging Face",
    contextLength: 16384,
    limits: {
      maxTokens: {
        input: 16384,
        output: 2048
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: false,
      supportsStop: false,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 512,
      temperature: 0.7,
      topP: 0.9
    },
    specialInstructions: [
      "Parameters map to HF text-generation: max_new_tokens, temperature, top_p",
      "Set return_full_text=false to get only the completion"
    ]
  },
  // Azure OpenAI Models
  "gpt-4o": {
    id: "gpt-4o",
    name: "GPT-4o",
    provider: "Azure OpenAI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 16384
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0.01,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: true,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 4096,
      temperature: 0.7,
      topP: 0.95
    }
  },

  "gpt-4o-mini": {
    id: "gpt-4o-mini",
    name: "GPT-4o Mini",
    provider: "Azure OpenAI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 16384
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0.01,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: true,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 4096,
      temperature: 0.7,
      topP: 0.95
    }
  },

  "gpt-4-turbo": {
    id: "gpt-4-turbo",
    name: "GPT-4 Turbo",
    provider: "Azure OpenAI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0.01,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: true,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 3072,
      temperature: 0.7,
      topP: 0.95
    }
  },

  "gpt-3.5-turbo": {
    id: "gpt-3.5-turbo",
    name: "GPT-3.5 Turbo",
    provider: "Azure OpenAI",
    contextLength: 16385,
    limits: {
      maxTokens: {
        input: 16385,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0.01,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: true,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.95
    }
  },

  // Fine-tuned Models
  "breaking-better-v6-1-ft": {
    id: "breaking-better-v6-1-ft",
    name: "Breaking Better v6.1 (Fine-tuned)",
    provider: "Azure OpenAI (Fine-tuned)",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 16384
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.7
      },
      topP: {
        min: 0.01,
        max: 1,
        default: 0.95
      },
      frequencyPenalty: {
        min: -2,
        max: 2,
        default: 0
      },
      presencePenalty: {
        min: -2,
        max: 2,
        default: 0
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: true,
      supportsFrequencyPenalty: true,
      supportsPresencePenalty: true
    },
    recommendedParams: {
      maxTokens: 4096,
      temperature: 0.7,
      topP: 0.95
    },
    specialInstructions: [
      "Custom fine-tuned model optimized for specific use cases",
      "May have specialized knowledge or behavior based on fine-tuning data"
    ]
  },

  // Microsoft Models
  "phi-4": {
    id: "phi-4",
    name: "Phi-4",
    provider: "Microsoft",
    contextLength: 16384,
    limits: {
      maxTokens: {
        input: 16384,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.6
      },
      topP: {
        min: 0.1,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.6,
      topP: 0.9
    },
    specialInstructions: [
      "Phi models prefer shorter, more concise prompts",
      "Works best with structured programming tasks"
    ]
  },

  // Mistral AI Models
  "ministral-3b": {
    id: "ministral-3b",
    name: "Ministral 3B",
    provider: "Mistral AI",
    contextLength: 131072,
    limits: {
      maxTokens: {
        input: 131072,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 1
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 4096,
      temperature: 0.7,
      topP: 1
    },
    specialInstructions: [
      "Mistral models prefer top_p = 1 for best performance",
      "Lower temperature for more focused responses"
    ]
  },

  "mistral-large-2411": {
    id: "mistral-large-2411",
    name: "Mistral Large 2411",
    provider: "Mistral AI",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 8192
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0,
        max: 1,
        default: 1
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: true,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 4096,
      temperature: 0.7,
      topP: 1
    },
    specialInstructions: [
      "Mistral Large supports function calling and JSON mode",
      "Use top_p = 1 for optimal performance"
    ]
  },

  // Meta Llama Models
  "llama-3.3-70b-instruct": {
    id: "llama-3.3-70b-instruct",
    name: "Llama 3.3 70B Instruct",
    provider: "Meta",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.6
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 3072,
      temperature: 0.6,
      topP: 0.9
    },
    specialInstructions: [
      "Llama models perform best with temperature between 0.5-0.8",
      "Prefers detailed, specific instructions"
    ]
  },

  "llama-3.2-11b-vision-instruct": {
    id: "llama-3.2-11b-vision-instruct",
    name: "Llama 3.2 11B Vision",
    provider: "Meta",
    contextLength: 128000,
    limits: {
      maxTokens: {
        input: 128000,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 2,
        default: 0.6
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: true,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 3072,
      temperature: 0.6,
      topP: 0.9
    },
    specialInstructions: [
      "Vision-capable Llama model - can process images",
      "Best performance with detailed image descriptions"
    ]
  },

  // Cohere Models
  "cohere-command-r-plus": {
    id: "cohere-command-r-plus",
    name: "Command R+",
    provider: "Cohere",
    contextLength: 131072,
    limits: {
      maxTokens: {
        input: 131072,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.3
      },
      topP: {
        min: 0,
        max: 1,
        default: 0.75
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: true,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 3072,
      temperature: 0.3,
      topP: 0.75
    },
    specialInstructions: [
      "Cohere models prefer lower temperature (0.1-0.5)",
      "Excellent for RAG and tool use scenarios",
      "Works best with clear, structured prompts"
    ]
  }
};

/**
 * Get model configuration by ID, with fallback to default configuration
 */
export function getModelConfiguration(modelId: string): ModelConfiguration {
  // First try exact match
  let config = MODEL_CONFIGURATIONS[modelId];
  
  if (!config) {
    // Try case-insensitive match
    const lowercaseId = modelId.toLowerCase();
    const matchingKey = Object.keys(MODEL_CONFIGURATIONS).find(key => 
      key.toLowerCase() === lowercaseId
    );
    
    if (matchingKey) {
      config = MODEL_CONFIGURATIONS[matchingKey];
      console.log(`üîß Found model configuration for "${modelId}" using case-insensitive match: "${matchingKey}"`);
    }
  }
  
  if (config) {
    return config;
  }
  
  // Fallback configuration for unknown models
  console.warn(`Model configuration not found for: ${modelId}. Using fallback configuration.`);
  
  return {
    id: modelId,
    name: modelId,
    provider: "Unknown",
    contextLength: 16384,
    limits: {
      maxTokens: {
        input: 16384,
        output: 4096
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0.1,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.9
    },
    specialInstructions: [
      "Using fallback configuration - model parameters may not be optimal"
    ]
  };

  // Check for OpenAI models (support all OpenAI models with consistent config)
  if (modelId.startsWith('gpt-') || modelId.includes('openai')) {
    return {
      id: modelId,
      name: modelId.replace('openai-', '').toUpperCase().replace('-', ' '),
      provider: "OpenAI",
      contextLength: modelId.includes('gpt-3.5') ? 16000 : 128000,
      limits: {
        maxTokens: {
          input: modelId.includes('gpt-3.5') ? 16000 : 128000,
          output: 16384
        },
        temperature: {
          min: 0,
          max: 2,
          default: 0.7
        },
        topP: {
          min: 0.01,
          max: 1,
          default: 0.95
        },
        frequencyPenalty: {
          min: -2,
          max: 2,
          default: 0
        },
        presencePenalty: {
          min: -2,
          max: 2,
          default: 0
        }
      },
      capabilities: {
        supportsVision: modelId.includes('gpt-4o') || modelId.includes('gpt-4-turbo'),
        supportsCodeGeneration: true,
        supportsAnalysis: true,
        supportsImageGeneration: false,
        supportsSystemMessages: true,
        supportsJSONMode: true,
        supportsFunctionCalling: true,
        supportsStreaming: true,
        supportsStop: true,
        supportsLogitBias: true,
        supportsFrequencyPenalty: true,
        supportsPresencePenalty: true
      },
      recommendedParams: {
        maxTokens: 4096,
        temperature: 0.7,
        topP: 0.95,
        frequencyPenalty: 0,
        presencePenalty: 0
      }
    };
  }

  // Check for Gemini models (support all Gemini models with consistent config)
  if (modelId.startsWith('gemini-') || modelId.includes('gemini')) {
    return {
      id: modelId,
      name: modelId.replace('gemini-', 'Gemini ').replace('-', ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
      provider: "Google",
      contextLength: modelId.includes('pro') ? 2000000 : 1000000,
      limits: {
        maxTokens: {
          input: modelId.includes('pro') ? 2000000 : 1000000,
          output: 8192
        },
        temperature: {
          min: 0,
          max: 2,
          default: 0.7
        },
        topP: {
          min: 0.01,
          max: 1,
          default: 0.95
        }
      },
      capabilities: {
        supportsVision: true,
        supportsCodeGeneration: true,
        supportsAnalysis: true,
        supportsImageGeneration: false,
        supportsSystemMessages: true,
        supportsJSONMode: true,
        supportsFunctionCalling: true,
        supportsStreaming: true,
        supportsStop: true,
        supportsLogitBias: false,
        supportsFrequencyPenalty: false,
        supportsPresencePenalty: false
      },
      recommendedParams: {
        maxTokens: 2048,
        temperature: 0.7,
        topP: 0.95
      }
    };
  }

  // Fallback for unknown models
  return {
    id: modelId,
    name: modelId,
    provider: "Unknown",
    contextLength: 4096,
    limits: {
      maxTokens: {
        input: 4096,
        output: 1024
      },
      temperature: {
        min: 0,
        max: 1,
        default: 0.7
      },
      topP: {
        min: 0.1,
        max: 1,
        default: 0.9
      }
    },
    capabilities: {
      supportsVision: false,
      supportsCodeGeneration: true,
      supportsAnalysis: true,
      supportsImageGeneration: false,
      supportsSystemMessages: true,
      supportsJSONMode: false,
      supportsFunctionCalling: false,
      supportsStreaming: true,
      supportsStop: true,
      supportsLogitBias: false,
      supportsFrequencyPenalty: false,
      supportsPresencePenalty: false
    },
    recommendedParams: {
      maxTokens: 2048,
      temperature: 0.7,
      topP: 0.9
    },
    specialInstructions: [
      "Using fallback configuration - model parameters may not be optimal"
    ]
  };
}

/**
 * Validate and clamp parameters according to model limits
 */
export function validateModelParameters(
  modelId: string,
  params: {
    maxTokens?: number;
    temperature?: number;
    topP?: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
  }
): {
  maxTokens: number;
  temperature: number;
  topP: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
} {
  const config = getModelConfiguration(modelId);
  const { limits, capabilities } = config;
  
  // Validate and clamp max_tokens
  let maxTokens = params.maxTokens ?? config.recommendedParams.maxTokens;
  maxTokens = Math.min(maxTokens, limits.maxTokens.output);
  maxTokens = Math.max(maxTokens, 1);
  
  // Validate and clamp temperature
  let temperature = params.temperature ?? limits.temperature.default;
  temperature = Math.min(temperature, limits.temperature.max);
  temperature = Math.max(temperature, limits.temperature.min);
  
  // Validate and clamp top_p
  let topP = params.topP ?? limits.topP.default;
  topP = Math.min(topP, limits.topP.max);
  topP = Math.max(topP, limits.topP.min);
  
  // Azure AI constraint: top_p must be 1 when using greedy sampling (temperature = 0)
  if (temperature === 0) {
    topP = 1;
    console.log(`üîß Azure AI constraint: Setting top_p=1 for greedy sampling (temperature=0)`);
  }

  const validatedParams: any = {
    maxTokens,
    temperature,
    topP
  };
  
  // Only include frequency_penalty if supported
  if (capabilities.supportsFrequencyPenalty && limits.frequencyPenalty && params.frequencyPenalty !== undefined) {
    let frequencyPenalty = params.frequencyPenalty;
    frequencyPenalty = Math.min(frequencyPenalty, limits.frequencyPenalty.max);
    frequencyPenalty = Math.max(frequencyPenalty, limits.frequencyPenalty.min);
    validatedParams.frequencyPenalty = frequencyPenalty;
  }
  
  // Only include presence_penalty if supported
  if (capabilities.supportsPresencePenalty && limits.presencePenalty && params.presencePenalty !== undefined) {
    let presencePenalty = params.presencePenalty;
    presencePenalty = Math.min(presencePenalty, limits.presencePenalty.max);
    presencePenalty = Math.max(presencePenalty, limits.presencePenalty.min);
    validatedParams.presencePenalty = presencePenalty;
  }
  
  return validatedParams;
}

/**
 * Get optimized parameters for a specific model
 */
export function getOptimizedParameters(modelId: string): {
  maxTokens: number;
  temperature: number;
  topP: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
} {
  const config = getModelConfiguration(modelId);
  return validateModelParameters(modelId, config.recommendedParams);
}

================
File: client/src/lib/modelMigration.ts
================
/**
 * Model Migration Utilities
 * 
 * This file contains utilities to handle model selection migrations
 * and ensure proper defaults are applied.
 */

/**
 * Clear all cached model selections to force defaults
 * This can be called from browser console if needed: clearAllModelCache()
 */
export function clearAllModelCache(): void {
  const modelKeys = [
    'lmstudio-selected-model',
    'azure-ai-selected-model', 
    'openai-selected-model',
    'gemini-selected-model',
    'hf-selected-model'
  ];
  
  console.log('üßπ Clearing all cached model selections...');
  modelKeys.forEach(key => {
    const cached = localStorage.getItem(key);
    if (cached) {
      console.log(`  - Removed: ${key}`);
      localStorage.removeItem(key);
    }
  });
  
  console.log('‚úÖ Model cache cleared. Refresh the page to see defaults.');
}

/**
 * Force reset LM Studio to nomadic-icdu-v8 default
 */
export function resetLMStudioDefault(): void {
  console.log('üîÑ Forcing LM Studio reset to nomadic-icdu-v8...');
  localStorage.removeItem('lmstudio-selected-model');
  localStorage.removeItem('lmstudio-model-migration-v1'); // Reset migration flag
  console.log('‚úÖ LM Studio reset. Refresh the page to see nomadic-icdu-v8 default.');
}

/**
 * Check current cached model selections
 */
export function checkCurrentModelCache(): void {
  const modelKeys = [
    'lmstudio-selected-model',
    'azure-ai-selected-model', 
    'openai-selected-model',
    'gemini-selected-model',
    'hf-selected-model'
  ];
  
  console.log('üìã Current cached model selections:');
  modelKeys.forEach(key => {
    const cached = localStorage.getItem(key);
    if (cached) {
      try {
        const model = JSON.parse(cached);
        console.log(`  - ${key}: ${model.name} (${model.id})`);
      } catch {
        console.log(`  - ${key}: [Invalid JSON]`);
      }
    } else {
      console.log(`  - ${key}: [Not set]`);
    }
  });
}

// Make functions available globally for debugging
if (typeof window !== 'undefined') {
  (window as any).clearAllModelCache = clearAllModelCache;
  (window as any).resetLMStudioDefault = resetLMStudioDefault;
  (window as any).checkCurrentModelCache = checkCurrentModelCache;
}

================
File: client/src/lib/openAI.ts
================
import { OpenAIMessage, OpenAIConfig, AzureAIMessage, ChatCompletionOptions, LLMModel } from "../types";
import { getModelConfiguration, validateModelParameters } from "./modelConfigurations";

export class OpenAIService {
  private config: OpenAIConfig;

  constructor(config: OpenAIConfig) {
    this.config = config;
  }



  /**
   * Update the model name for this service instance
   */
  updateModel(modelName: string): void {
    this.config.modelName = modelName;
  }

  /**
   * Get current model configuration
   */
  getCurrentModel(): string {
    return this.config.modelName;
  }

  /**
   * Estimate token count for messages (rough approximation)
   */
  private estimateTokenCount(messages: OpenAIMessage[]): number {
    return messages.reduce((total, message) => {
      const contentTokens = Math.ceil(message.content.length / 4);
      return total + contentTokens + 10;
    }, 0);
  }

  /**
   * Truncate conversation history while preserving system message and recent context
   */
  private truncateConversationHistory(messages: OpenAIMessage[], maxTokens: number): OpenAIMessage[] {
    if (messages.length === 0) return messages;
    
    // Always preserve the system message (first message)
    const systemMessage = messages[0];
    let remainingMessages = messages.slice(1);
    
    // Calculate tokens for system message
    let totalTokens = this.estimateTokenCount([systemMessage]);
    
    // Add messages from most recent, working backwards
    const result = [systemMessage];
    for (let i = remainingMessages.length - 1; i >= 0; i--) {
      const messageTokens = this.estimateTokenCount([remainingMessages[i]]);
      if (totalTokens + messageTokens <= maxTokens) {
        totalTokens += messageTokens;
        result.splice(1, 0, remainingMessages[i]);
      } else {
        console.log(`üîÑ Truncated ${i + 1} older messages to stay within token limit`);
        break;
      }
    }
    
    return result;
  }

  /**
   * Get available OpenAI models
   */
  static getAvailableModels(): LLMModel[] {
    return [
      {
        id: "gpt-4o",
        name: "GPT-4o",
        provider: "OpenAI",
        performance: 96,
        cost: 0.005,
        latency: 800,
        contextLength: 128000,
        description: "Most advanced GPT-4 model with multimodal capabilities",
        category: "multimodal",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-4o-mini",
        name: "GPT-4o Mini",
        provider: "OpenAI",
        performance: 88,
        cost: 0.00015,
        latency: 600,
        contextLength: 128000,
        description: "Efficient and cost-effective GPT-4 model",
        category: "text",
        tier: "freemium",
        isFavorite: true,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-4-turbo",
        name: "GPT-4 Turbo",
        provider: "OpenAI",
        performance: 94,
        cost: 0.01,
        latency: 1000,
        contextLength: 128000,
        description: "Enhanced GPT-4 model with improved performance",
        category: "text",
        tier: "pro",
        isFavorite: false,
        capabilities: {
          supportsVision: true,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      },
      {
        id: "gpt-3.5-turbo",
        name: "GPT-3.5 Turbo",
        provider: "OpenAI",
        performance: 82,
        cost: 0.0015,
        latency: 500,
        contextLength: 16000,
        description: "Fast and efficient language model for general tasks",
        category: "text",
        tier: "freemium",
        isFavorite: false,
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false
        }
      }
    ];
  }

  /**
   * Convert Azure AI messages to OpenAI format
   */
  private convertToOpenAIMessages(azureMessages: AzureAIMessage[]): OpenAIMessage[] {
    return azureMessages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
  }

  /**
   * Send a single chat completion request
   */
  async sendChatCompletion(
    messages: AzureAIMessage[],
    options: ChatCompletionOptions = {}
  ): Promise<string> {
    try {
      // Convert to OpenAI format
      const openAIMessages = this.convertToOpenAIMessages(messages);
      
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // Estimate token count and truncate if necessary
      const estimatedTokens = this.estimateTokenCount(openAIMessages);
      const maxContextTokens = modelConfig.contextLength || 4096;
      const reserveTokensForResponse = options.maxTokens || 1024;
      
      console.log(`üî¢ Token estimate: ${estimatedTokens}/${maxContextTokens} (reserving ${reserveTokensForResponse} for response)`);
      
      let processedMessages = openAIMessages;
      if (estimatedTokens + reserveTokensForResponse > maxContextTokens) {
        console.warn(`‚ö†Ô∏è Approaching token limit, truncating conversation history`);
        processedMessages = this.truncateConversationHistory(openAIMessages, maxContextTokens - reserveTokensForResponse);
      }
      
      // Use validated parameters based on the model's capabilities and limits
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Build request body
      const requestBody: any = {
        model: this.config.modelName,
        messages: processedMessages,
        max_tokens: validatedParams.maxTokens,
        temperature: validatedParams.temperature,
        top_p: validatedParams.topP,
        stream: false,
      };

      // Add optional parameters
      if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
        requestBody.frequency_penalty = validatedParams.frequencyPenalty;
      }
      
      if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
        requestBody.presence_penalty = validatedParams.presencePenalty;
      }

      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.stop = options.stop;
      }

      console.log(`Using optimized parameters for ${modelConfig.name} (${modelConfig.provider}):`, {
        max_tokens: requestBody.max_tokens,
        temperature: requestBody.temperature,
        top_p: requestBody.top_p,
      });

      console.log('üîó Sending OpenAI request:', {
        model: this.config.modelName,
        messageCount: processedMessages.length
      });

      // Use universal AI proxy for credit checking
      const response = await fetch('/ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'openai',
          ...requestBody,
          apiKey: this.config.apiKey
        }),
      });

      console.log('üì° OpenAI response status:', response.status);

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        const errorData = await response.text();
        console.error('‚ùå OpenAI API error details:', errorData);
        throw new Error(`OpenAI API error (${response.status}): ${errorData}`);
      }

      const data = await response.json();
      
      // Extract credit information if present and emit update
      if (data.uterpi_credit_info) {
        const { emitCreditUpdate } = await import('../hooks/useCreditUpdates');
        emitCreditUpdate({
          creditsUsed: data.uterpi_credit_info.credits_used,
          remainingBalance: data.uterpi_credit_info.remaining_balance
        });
      }
      
      const content = data.choices[0]?.message?.content || "";
      console.log('‚úÖ OpenAI response received:', content.substring(0, 100) + '...');
      return content;
    } catch (error) {
      console.error("OpenAI Service Error:", error);
      throw error;
    }
  }

  /**
   * Send a streaming chat completion request
   */
  async sendStreamingChatCompletion(
    messages: AzureAIMessage[],
    onChunk: (chunk: string) => void,
    options: ChatCompletionOptions = {}
  ): Promise<void> {
    try {
      // Convert to OpenAI format
      const openAIMessages = this.convertToOpenAIMessages(messages);
      
      // Get model-specific configuration and parameters
      const modelConfig = getModelConfiguration(this.config.modelName);
      
      // Use validated parameters
      const validatedParams = validateModelParameters(this.config.modelName, {
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty
      });

      // Build request body
      const requestBody: any = {
        model: this.config.modelName,
        messages: openAIMessages,
        max_tokens: validatedParams.maxTokens,
        temperature: validatedParams.temperature,
        top_p: validatedParams.topP,
        stream: true,
      };

      // Add optional parameters
      if (modelConfig.capabilities.supportsFrequencyPenalty && validatedParams.frequencyPenalty !== undefined) {
        requestBody.frequency_penalty = validatedParams.frequencyPenalty;
      }
      
      if (modelConfig.capabilities.supportsPresencePenalty && validatedParams.presencePenalty !== undefined) {
        requestBody.presence_penalty = validatedParams.presencePenalty;
      }

      if (modelConfig.capabilities.supportsStop && options.stop) {
        requestBody.stop = options.stop;
      }

      // Use universal AI proxy for credit checking
      const response = await fetch('/ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'openai',
          ...requestBody,
          apiKey: this.config.apiKey
        }),
      });

      if (!response.ok) {
        // Handle credit limit errors specially
        if (response.status === 402) {
          const errorData = await response.json();
          throw new Error(`Subscription error: ${JSON.stringify(errorData)}`);
        }
        
        const errorData = await response.text();
        console.error('‚ùå OpenAI streaming error:', errorData);
        throw new Error(`OpenAI streaming error: ${errorData}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("The response stream is undefined");
      }

      const decoder = new TextDecoder();
      let buffer = '';

      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }

          // Decode the chunk and add to buffer
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;

          // Process complete SSE events
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              
              if (data === '[DONE]') {
                return;
              }

              try {
                const eventData = JSON.parse(data);
                for (const choice of eventData.choices || []) {
                  const content = choice.delta?.content;
                  if (content) {
                    onChunk(content);
                  }
                }
              } catch (parseError) {
                console.warn("Failed to parse SSE event:", parseError);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      console.error("OpenAI Streaming Service Error:", error);
      throw error;
    }
  }

  /**
   * Create OpenAI config from environment variables
   */
  static createFromEnv(): OpenAIConfig {
    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
    const modelName = import.meta.env.VITE_OPENAI_MODEL_NAME || "gpt-4o-mini";
    const baseUrl = import.meta.env.VITE_OPENAI_BASE_URL;

    if (!apiKey) {
      throw new Error(
        "OpenAI configuration missing. Please set VITE_OPENAI_API_KEY environment variable."
      );
    }

    return { apiKey, modelName, baseUrl };
  }

  /**
   * Create OpenAI config with custom model
   */
  static createWithModel(modelName: string): OpenAIConfig {
    const config = this.createFromEnv();
    return { ...config, modelName };
  }
}

export default OpenAIService;

================
File: client/src/lib/speech/azureSpeechService.ts
================
// Azure Cognitive Services Speech SDK implementation

import { BaseSpeechService } from './baseSpeechService';
import {
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechConfig
} from '../../types/speech';

interface AzureSpeechConfig extends SpeechConfig {
  subscriptionKey?: string;
  region?: string;
  endpoint?: string;
}

export class AzureSpeechService extends BaseSpeechService {
  private subscriptionKey: string = '';
  private region: string = '';
  private endpoint: string = '';
  private recognizer: any = null;
  private isRecording: boolean = false;
  private currentTranscript: string = '';
  private continuousMode: boolean = false;
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];

  constructor() {
    super('azure');
  }

  async initialize(config?: AzureSpeechConfig): Promise<void> {
    await super.initialize(config);
    
    // Get Azure credentials from environment or config
    this.subscriptionKey = config?.subscriptionKey || 
                          (import.meta as any).env?.VITE_AZURE_SPEECH_KEY || 
                          (import.meta as any).env?.VITE_AZURE_AI_API_KEY || '';
    
    this.region = config?.region || 
                 (import.meta as any).env?.VITE_AZURE_SPEECH_REGION || 
                 'eastus';
    
    this.endpoint = config?.endpoint || 
                   `https://${this.region}.api.cognitive.microsoft.com/`;
    
    if (!this.subscriptionKey) {
      console.warn('Azure Speech Service: No subscription key provided');
    }
  }

  async synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult> {
    if (!this.subscriptionKey) {
      throw new Error('Azure Speech subscription key is required');
    }

    const voice = options?.voice || 'en-US-JennyNeural';
    const outputFormat = options?.outputFormat || 'audio-16khz-32kbitrate-mono-mp3';
    
    // Build SSML
    const ssml = this.buildSSML(text, voice, options);
    
    try {
      const response = await fetch(
        `${this.endpoint}cognitiveservices/v1`,
        {
          method: 'POST',
          headers: {
            'Ocp-Apim-Subscription-Key': this.subscriptionKey,
            'Content-Type': 'application/ssml+xml',
            'X-Microsoft-OutputFormat': outputFormat,
            'User-Agent': 'NomadAI-TTS'
          },
          body: ssml
        }
      );

      if (!response.ok) {
        const error = await response.text();
        throw new Error(`Azure TTS failed: ${response.status} - ${error}`);
      }

      const audioData = await response.arrayBuffer();
      const blob = new Blob([audioData], { type: 'audio/mpeg' });
      const audioUrl = URL.createObjectURL(blob);

      // Auto-play the audio
      await this.playAudioData(audioUrl);

      return {
        audioData,
        audioUrl,
        duration: this.estimateDuration(text, options?.rate)
      };
    } catch (error) {
      console.error('Azure TTS error:', error);
      throw error;
    }
  }

  cancelSynthesis(): void {
    super.cancelSynthesis();
  }

  async getAvailableVoices(): Promise<VoiceInfo[]> {
    if (!this.subscriptionKey) {
      return [];
    }

    try {
      const response = await fetch(
        `${this.endpoint}cognitiveservices/voices/list`,
        {
          headers: {
            'Ocp-Apim-Subscription-Key': this.subscriptionKey
          }
        }
      );

      if (!response.ok) {
        console.error('Failed to fetch Azure voices');
        return this.getDefaultVoices();
      }

      const voices = await response.json();
      
      return voices.map((voice: any) => ({
        id: voice.ShortName,
        name: voice.DisplayName || voice.LocalName,
        language: voice.Locale,
        gender: voice.Gender?.toLowerCase() as 'male' | 'female' | 'neutral',
        provider: 'azure' as const,
        styles: voice.StyleList || []
      }));
    } catch (error) {
      console.error('Error fetching Azure voices:', error);
      return this.getDefaultVoices();
    }
  }

  async startRecognition(options?: STTOptions): Promise<void> {
    if (!this.subscriptionKey) {
      throw new Error('Azure Speech subscription key is required');
    }

    if (this.isRecording) {
      return;
    }

    this.currentTranscript = '';
    this.isRecording = true;
    this.audioChunks = [];
    this.continuousMode = options?.continuous ?? true;

    // For browser environment, we'll use the REST API with MediaRecorder
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      this.mediaRecorder = new MediaRecorder(stream);

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = async () => {
        if (this.audioChunks.length > 0) {
          const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
          await this.processAudioForRecognition(audioBlob, options);
        }
        stream.getTracks().forEach(track => track.stop());
        this.audioChunks = [];
      };

      this.recognizer = this.mediaRecorder;
      // Start with continuous chunking for better responsiveness
      this.mediaRecorder.start(3000); // Collect data every 3 seconds
    } catch (error) {
      this.isRecording = false;
      throw new Error(`Failed to start recording: ${error}`);
    }
  }

  async stopRecognition(): Promise<SpeechRecognitionResult> {
    if (!this.isRecording || !this.mediaRecorder) {
      return {
        transcript: this.currentTranscript.trim(),
        confidence: 1,
        isFinal: true
      };
    }

    this.continuousMode = false;

    return new Promise((resolve) => {
      const recorder = this.mediaRecorder!;
      
      // Set up completion handler
      const originalOnStop = recorder.onstop;
      recorder.onstop = async (event) => {
        if (originalOnStop) {
          await originalOnStop.call(recorder, event);
        }
        
        resolve({
          transcript: this.currentTranscript.trim(),
          confidence: 1,
          isFinal: true
        });
        
        this.isRecording = false;
        this.mediaRecorder = null;
        this.recognizer = null;
        this.audioChunks = [];
        this.continuousMode = false;
      };

      recorder.stop();
    });
  }

  isAvailable(): boolean {
    return !!this.subscriptionKey || !!(import.meta as any).env?.VITE_AZURE_SPEECH_KEY;
  }

  getCapabilities(): SpeechServiceCapabilities {
    return {
      supportsTTS: true,
      supportsSTT: true,
      supportsStreaming: true,
      supportsVoiceCloning: false,
      supportsEmotions: true,
      supportsMultiLanguage: true,
      availableVoices: [],
      availableLanguages: this.getAvailableLanguages()
    };
  }

  private async processAudioForRecognition(audioBlob: Blob, options?: STTOptions): Promise<void> {
    const language = options?.language || 'en-US';
    
    try {
      // Convert audio to WAV format for Azure
      const formData = new FormData();
      formData.append('audio', audioBlob, 'audio.webm');

      const response = await fetch(
        `${this.endpoint}speechtotext/v3.0/transcriptions`,
        {
          method: 'POST',
          headers: {
            'Ocp-Apim-Subscription-Key': this.subscriptionKey,
            'Accept': 'application/json'
          },
          body: formData
        }
      );

      if (!response.ok) {
        throw new Error(`Azure STT failed: ${response.status}`);
      }

      const result = await response.json();
      this.currentTranscript = result.DisplayText || result.RecognizedText || '';
      
      const recognitionResult: SpeechRecognitionResult = {
        transcript: this.currentTranscript,
        confidence: result.Confidence || 0.9,
        isFinal: true
      };

      this.notifyRecognitionResult(recognitionResult);
    } catch (error) {
      console.error('Azure STT error:', error);
      this.currentTranscript = '';
    }
  }

  private buildSSML(text: string, voice: string, options?: TTSOptions): string {
    const rate = options?.rate ?? 1.0;
    const pitch = options?.pitch ?? 1.0;
    const volume = options?.volume ?? 1.0;

    // Convert rate to percentage (Azure expects percentage format)
    const ratePercent = ((rate - 1) * 100).toFixed(0);
    const pitchPercent = ((pitch - 1) * 50).toFixed(0); // Azure pitch range is smaller

    return `
      <speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" 
             xmlns:mstts="https://www.w3.org/2001/mstts" 
             xml:lang="${options?.language || 'en-US'}">
        <voice name="${voice}">
          <prosody rate="${ratePercent}%" pitch="${pitchPercent}%" volume="${volume * 100}">
            ${this.escapeXML(text)}
          </prosody>
        </voice>
      </speak>
    `.trim();
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  private estimateDuration(text: string, rate?: number): number {
    // Estimate ~150 words per minute at normal speed
    const wordsPerMinute = 150 * (rate ?? 1.0);
    const wordCount = text.split(/\s+/).length;
    return (wordCount / wordsPerMinute) * 60;
  }

  private getDefaultVoices(): VoiceInfo[] {
    // Fallback list of common Azure voices
    return [
      { id: 'en-US-JennyNeural', name: 'Jenny (US)', language: 'en-US', gender: 'female', provider: 'azure' },
      { id: 'en-US-GuyNeural', name: 'Guy (US)', language: 'en-US', gender: 'male', provider: 'azure' },
      { id: 'en-GB-SoniaNeural', name: 'Sonia (UK)', language: 'en-GB', gender: 'female', provider: 'azure' },
      { id: 'en-GB-RyanNeural', name: 'Ryan (UK)', language: 'en-GB', gender: 'male', provider: 'azure' },
      { id: 'es-ES-ElviraNeural', name: 'Elvira (Spain)', language: 'es-ES', gender: 'female', provider: 'azure' },
      { id: 'fr-FR-DeniseNeural', name: 'Denise (France)', language: 'fr-FR', gender: 'female', provider: 'azure' },
      { id: 'de-DE-KatjaNeural', name: 'Katja (Germany)', language: 'de-DE', gender: 'female', provider: 'azure' },
      { id: 'zh-CN-XiaoxiaoNeural', name: 'Xiaoxiao (China)', language: 'zh-CN', gender: 'female', provider: 'azure' },
      { id: 'ja-JP-NanamiNeural', name: 'Nanami (Japan)', language: 'ja-JP', gender: 'female', provider: 'azure' }
    ];
  }

  private getAvailableLanguages(): string[] {
    return [
      'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-IN',
      'es-ES', 'es-MX', 'es-AR', 'fr-FR', 'fr-CA',
      'de-DE', 'it-IT', 'pt-BR', 'pt-PT', 'ru-RU',
      'zh-CN', 'zh-TW', 'ja-JP', 'ko-KR', 'ar-SA',
      'hi-IN', 'nl-NL', 'pl-PL', 'sv-SE', 'da-DK'
    ];
  }
}

================
File: client/src/lib/speech/baseSpeechService.ts
================
// Base abstract class for all speech service implementations

import {
  ISpeechService,
  SpeechConfig,
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechProvider
} from '../../types/speech';

export abstract class BaseSpeechService implements ISpeechService {
  protected config: SpeechConfig = {};
  protected provider: SpeechProvider;
  protected recognitionCallbacks: ((result: SpeechRecognitionResult) => void)[] = [];
  protected isInitialized: boolean = false;
  private activeAudioElements: Set<HTMLAudioElement> = new Set();

  constructor(provider: SpeechProvider) {
    this.provider = provider;
  }

  abstract synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult>;
  abstract getAvailableVoices(): Promise<VoiceInfo[]>;
  abstract startRecognition(options?: STTOptions): Promise<void>;
  abstract stopRecognition(): Promise<SpeechRecognitionResult>;
  abstract isAvailable(): boolean;
  abstract getCapabilities(): SpeechServiceCapabilities;

  async initialize(config?: SpeechConfig): Promise<void> {
    this.config = { ...this.config, ...config };
    this.isInitialized = true;
  }

  onRecognitionResult(callback: (result: SpeechRecognitionResult) => void): void {
    this.recognitionCallbacks.push(callback);
  }

  protected notifyRecognitionResult(result: SpeechRecognitionResult): void {
    this.recognitionCallbacks.forEach(callback => callback(result));
  }

  dispose(): void {
    // stop any active audio
    this.cancelSynthesis();
    this.recognitionCallbacks = [];
    this.isInitialized = false;
  }

  // Helper method to create audio element and play audio
  protected async playAudioData(audioData: ArrayBuffer | Blob | string): Promise<void> {
    return new Promise((resolve, reject) => {
      const audio = new Audio();
      this.activeAudioElements.add(audio);
      
      if (typeof audioData === 'string') {
        audio.src = audioData;
      } else if (audioData instanceof Blob) {
        audio.src = URL.createObjectURL(audioData);
      } else {
        const blob = new Blob([audioData], { type: 'audio/mpeg' });
        audio.src = URL.createObjectURL(blob);
      }

      audio.onended = () => {
        if (audio.src.startsWith('blob:')) {
          URL.revokeObjectURL(audio.src);
        }
        this.activeAudioElements.delete(audio);
        resolve();
      };

      audio.onerror = (e) => {
        this.activeAudioElements.delete(audio);
        reject(e as any);
      };
      audio.play().catch((e) => {
        this.activeAudioElements.delete(audio);
        reject(e);
      });
    });
  }

  // Helper to convert text to SSML for providers that support it
  protected textToSSML(text: string, options?: TTSOptions): string {
    const rate = options?.rate ?? 1.0;
    const pitch = options?.pitch ?? 1.0;
    const volume = options?.volume ?? 1.0;

    return `
      <speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis">
        <prosody rate="${rate}" pitch="${pitch}x" volume="${volume * 100}">
          ${text}
        </prosody>
      </speak>
    `.trim();
  }

  cancelSynthesis(): void {
    // Cancel Web Speech if present
    try {
      if (typeof window !== 'undefined' && (window as any).speechSynthesis) {
        (window as any).speechSynthesis.cancel();
      }
    } catch {}
    // Pause and cleanup any active <audio> elements
    this.activeAudioElements.forEach((audio) => {
      try { audio.pause(); } catch {}
      try {
        if (audio.src && audio.src.startsWith('blob:')) {
          URL.revokeObjectURL(audio.src);
        }
      } catch {}
    });
    this.activeAudioElements.clear();
  }
}

================
File: client/src/lib/speech/googleSpeechService.ts
================
// Google Cloud Speech Service implementation

import { BaseSpeechService } from './baseSpeechService';
import {
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechConfig
} from '../../types/speech';

interface GoogleSpeechConfig extends SpeechConfig {
  apiKey?: string;
  projectId?: string;
}

export class GoogleSpeechService extends BaseSpeechService {
  private apiKey: string = '';
  private projectId: string = '';
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];
  private isRecording: boolean = false;
  private currentTranscript: string = '';
  private continuousMode: boolean = false;
  private interimTranscripts: string = '';

  constructor() {
    super('google');
  }

  async initialize(config?: GoogleSpeechConfig): Promise<void> {
    await super.initialize(config);
    
    // Get Google/Gemini API key from localStorage or config
    this.apiKey = config?.apiKey || 
                 localStorage.getItem('gemini-api-key') || 
                 localStorage.getItem('google-api-key') || 
                 '';
    
    this.projectId = config?.projectId || 'nomadai-speech';
    
    if (!this.apiKey) {
      console.warn('Google Speech Service: No API key provided');
    }
  }

  async synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult> {
    if (!this.apiKey) {
      throw new Error('Google API key is required for text-to-speech');
    }

    const voice = this.mapToGoogleVoice(options?.voice);
    const languageCode = options?.language || 'en-US';
    const speakingRate = options?.rate ?? 1.0;
    const pitch = options?.pitch ?? 0.0;
    const volumeGainDb = this.volumeToDb(options?.volume ?? 1.0);

    try {
      const response = await fetch(
        `https://texttospeech.googleapis.com/v1/text:synthesize?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            input: { text },
            voice: {
              languageCode,
              name: voice,
              ssmlGender: this.getGenderFromVoice(voice)
            },
            audioConfig: {
              audioEncoding: 'MP3',
              speakingRate,
              pitch,
              volumeGainDb
            }
          })
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Google TTS failed: ${error.error?.message || response.statusText}`);
      }

      const result = await response.json();
      const audioContent = result.audioContent;
      
      // Decode base64 audio content
      const audioData = Uint8Array.from(atob(audioContent), c => c.charCodeAt(0));
      const blob = new Blob([audioData], { type: 'audio/mpeg' });
      const audioUrl = URL.createObjectURL(blob);

      // Auto-play the audio
      await this.playAudioData(audioUrl);

      return {
        audioData: audioData.buffer,
        audioUrl,
        duration: this.estimateDuration(text, speakingRate)
      };
    } catch (error) {
      console.error('Google TTS error:', error);
      throw error;
    }
  }

  cancelSynthesis(): void {
    super.cancelSynthesis();
  }

  async getAvailableVoices(): Promise<VoiceInfo[]> {
    if (!this.apiKey) {
      return this.getDefaultVoices();
    }

    try {
      const response = await fetch(
        `https://texttospeech.googleapis.com/v1/voices?key=${this.apiKey}`
      );

      if (!response.ok) {
        return this.getDefaultVoices();
      }

      const result = await response.json();
      const voices = result.voices || [];

      return voices.map((voice: any) => ({
        id: voice.name,
        name: this.formatVoiceName(voice.name),
        language: voice.languageCodes[0],
        gender: voice.ssmlGender?.toLowerCase() as 'male' | 'female' | 'neutral',
        provider: 'google' as const
      }));
    } catch (error) {
      console.error('Error fetching Google voices:', error);
      return this.getDefaultVoices();
    }
  }

  async startRecognition(options?: STTOptions): Promise<void> {
    if (!this.apiKey) {
      throw new Error('Google API key is required for speech recognition');
    }

    if (this.isRecording) {
      return;
    }

    this.currentTranscript = '';
    this.interimTranscripts = '';
    this.isRecording = true;
    this.audioChunks = [];
    this.continuousMode = options?.continuous ?? true;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          channelCount: 1,
          sampleRate: 16000,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        } 
      });

      this.mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm'
      });

      let chunkCounter = 0;
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
          chunkCounter++;
          
          // Process chunks about every ~2 seconds for continuous transcription
          if (this.continuousMode && chunkCounter % 4 === 0 && options?.interimResults) {
            this.processInterimRecognition(new Blob(this.audioChunks, { type: 'audio/webm' }), options);
          }
        }
      };

      this.mediaRecorder.onstop = async () => {
        if (this.audioChunks.length > 0) {
          const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
          await this.processFinalRecognition(audioBlob, options);
        }
        stream.getTracks().forEach(track => track.stop());
        this.audioChunks = [];
      };

      // Start recording with 500ms chunks for better interim responsiveness
      this.mediaRecorder.start(500);
    } catch (error) {
      this.isRecording = false;
      throw new Error(`Failed to start recording: ${error}`);
    }
  }

  async stopRecognition(): Promise<SpeechRecognitionResult> {
    if (!this.isRecording || !this.mediaRecorder) {
      return {
        transcript: this.currentTranscript.trim(),
        confidence: 1,
        isFinal: true
      };
    }

    this.continuousMode = false;

    return new Promise((resolve) => {
      const recorder = this.mediaRecorder!;
      
      // Set up completion handler
      const originalOnStop = recorder.onstop;
      recorder.onstop = async (event) => {
        if (originalOnStop) {
          await originalOnStop.call(recorder, event);
        }
        
        // Include any interim transcripts in final result
        const finalTranscript = (this.currentTranscript + ' ' + this.interimTranscripts).trim();
        
        resolve({
          transcript: finalTranscript,
          confidence: 1,
          isFinal: true
        });
        
        this.isRecording = false;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.continuousMode = false;
        this.interimTranscripts = '';
      };

      recorder.stop();
    });
  }

  isAvailable(): boolean {
    const apiKey = this.apiKey || 
                  localStorage.getItem('gemini-api-key') || 
                  localStorage.getItem('google-api-key');
    return !!apiKey;
  }

  getCapabilities(): SpeechServiceCapabilities {
    return {
      supportsTTS: true,
      supportsSTT: true,
      supportsStreaming: true,
      supportsVoiceCloning: false,
      supportsEmotions: false,
      supportsMultiLanguage: true,
      availableVoices: [],
      availableLanguages: this.getAvailableLanguages()
    };
  }

  dispose(): void {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.mediaRecorder = null;
    }
    this.audioChunks = [];
    super.dispose();
  }

  private async processInterimRecognition(audioChunk: Blob, options?: STTOptions): Promise<void> {
    // Convert chunk to base64 for interim processing
    const reader = new FileReader();
    reader.onloadend = async () => {
      const base64Audio = (reader.result as string).split(',')[1];
      
      try {
        const result = await this.callSpeechAPI(base64Audio, options, false);
        if (result.transcript) {
          this.notifyRecognitionResult({
            transcript: result.transcript,
            confidence: result.confidence || 0.8,
            isFinal: false
          });
        }
      } catch (error) {
        console.error('Interim recognition error:', error);
      }
    };
    reader.readAsDataURL(audioChunk);
  }

  private async processFinalRecognition(audioBlob: Blob, options?: STTOptions): Promise<void> {
    // Convert blob to base64
    const reader = new FileReader();
    reader.onloadend = async () => {
      const base64Audio = (reader.result as string).split(',')[1];
      
      try {
        const result = await this.callSpeechAPI(base64Audio, options, true);
        this.currentTranscript = result.transcript || '';
        
        this.notifyRecognitionResult({
          transcript: this.currentTranscript,
          confidence: result.confidence || 0.9,
          isFinal: true,
          alternatives: result.alternatives
        });
      } catch (error) {
        console.error('Final recognition error:', error);
        this.currentTranscript = '';
      }
    };
    reader.readAsDataURL(audioBlob);
  }

  private async callSpeechAPI(
    base64Audio: string, 
    options?: STTOptions, 
    isFinal: boolean = true
  ): Promise<SpeechRecognitionResult> {
    const response = await fetch(
      `https://speech.googleapis.com/v1/speech:recognize?key=${this.apiKey}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          config: {
            encoding: 'WEBM_OPUS',
            sampleRateHertz: 16000,
            languageCode: options?.language || 'en-US',
            maxAlternatives: options?.maxAlternatives || 1,
            profanityFilter: options?.profanityFilter ?? false,
            enableAutomaticPunctuation: options?.punctuation ?? true,
            model: 'latest_long'
          },
          audio: {
            content: base64Audio
          }
        })
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Google STT failed: ${error.error?.message || response.statusText}`);
    }

    const result = await response.json();
    const results = result.results || [];
    
    if (results.length === 0) {
      return { transcript: '', confidence: 0, isFinal };
    }

    const firstResult = results[0];
    const topAlternative = firstResult.alternatives[0];
    
    return {
      transcript: topAlternative.transcript || '',
      confidence: topAlternative.confidence || 0,
      isFinal,
      alternatives: firstResult.alternatives.slice(1).map((alt: any) => ({
        transcript: alt.transcript,
        confidence: alt.confidence || 0
      }))
    };
  }

  private mapToGoogleVoice(voice?: string): string {
    if (!voice) return 'en-US-Neural2-F'; // Default female voice
    
    // If it's already a Google voice name, return it
    if (voice.includes('-Neural2-') || voice.includes('-Wavenet-') || voice.includes('-Standard-')) {
      return voice;
    }
    
    // Map generic names to Google voices
    const voiceLower = voice.toLowerCase();
    if (voiceLower.includes('female') || voiceLower.includes('woman')) {
      return 'en-US-Neural2-F';
    }
    if (voiceLower.includes('male') || voiceLower.includes('man')) {
      return 'en-US-Neural2-D';
    }
    
    return 'en-US-Neural2-F';
  }

  private getGenderFromVoice(voice: string): string {
    if (voice.endsWith('-F') || voice.endsWith('-C') || voice.endsWith('-E') || voice.endsWith('-G')) {
      return 'FEMALE';
    }
    if (voice.endsWith('-A') || voice.endsWith('-B') || voice.endsWith('-D') || voice.endsWith('-I')) {
      return 'MALE';
    }
    return 'NEUTRAL';
  }

  private formatVoiceName(voiceName: string): string {
    // Format Google voice names to be more readable
    // e.g., "en-US-Neural2-F" -> "US English Neural2 (Female)"
    const parts = voiceName.split('-');
    if (parts.length >= 4) {
      const lang = parts[0];
      const region = parts[1];
      const type = parts[2];
      const variant = parts[3];
      
      const gender = this.getGenderFromVoice(voiceName);
      return `${region} ${lang.toUpperCase()} ${type} (${gender.toLowerCase()})`;
    }
    return voiceName;
  }

  private volumeToDb(volume: number): number {
    // Convert volume (0-1) to decibels (-96 to 16)
    if (volume <= 0) return -96;
    if (volume >= 1) return 0;
    return 20 * Math.log10(volume);
  }

  private estimateDuration(text: string, rate: number): number {
    const wordsPerMinute = 150 * rate;
    const wordCount = text.split(/\s+/).length;
    return (wordCount / wordsPerMinute) * 60;
  }

  private getDefaultVoices(): VoiceInfo[] {
    return [
      { id: 'en-US-Neural2-F', name: 'US English Neural2 (Female)', language: 'en-US', gender: 'female', provider: 'google' },
      { id: 'en-US-Neural2-D', name: 'US English Neural2 (Male)', language: 'en-US', gender: 'male', provider: 'google' },
      { id: 'en-GB-Neural2-F', name: 'UK English Neural2 (Female)', language: 'en-GB', gender: 'female', provider: 'google' },
      { id: 'en-GB-Neural2-B', name: 'UK English Neural2 (Male)', language: 'en-GB', gender: 'male', provider: 'google' },
      { id: 'es-ES-Neural2-F', name: 'Spanish Neural2 (Female)', language: 'es-ES', gender: 'female', provider: 'google' },
      { id: 'fr-FR-Neural2-E', name: 'French Neural2 (Female)', language: 'fr-FR', gender: 'female', provider: 'google' },
      { id: 'de-DE-Neural2-F', name: 'German Neural2 (Female)', language: 'de-DE', gender: 'female', provider: 'google' },
      { id: 'ja-JP-Neural2-B', name: 'Japanese Neural2 (Female)', language: 'ja-JP', gender: 'female', provider: 'google' }
    ];
  }

  private getAvailableLanguages(): string[] {
    return [
      'en-US', 'en-GB', 'en-AU', 'en-IN', 'es-ES', 'es-MX',
      'fr-FR', 'fr-CA', 'de-DE', 'it-IT', 'pt-BR', 'pt-PT',
      'nl-NL', 'ru-RU', 'ja-JP', 'ko-KR', 'zh-CN', 'zh-TW',
      'ar-SA', 'hi-IN', 'sv-SE', 'da-DK', 'no-NO', 'fi-FI'
    ];
  }
}

================
File: client/src/lib/speech/index.ts
================
// Speech Services - Main export file

export { BaseSpeechService } from './baseSpeechService';
export { WebSpeechService } from './webSpeechService';
export { AzureSpeechService } from './azureSpeechService';
export { OpenAISpeechService } from './openaiSpeechService';
export { GoogleSpeechService } from './googleSpeechService';
export { SpeechServiceFactory } from './speechServiceFactory';

// Export utilities
export * from './speechUtils';

// Re-export types
export type {
  ISpeechService,
  SpeechConfig,
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechProvider
} from '../../types/speech';

================
File: client/src/lib/speech/openaiSpeechService.ts
================
// OpenAI Speech Service implementation (TTS and Whisper)

import { BaseSpeechService } from './baseSpeechService';
import {
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechConfig
} from '../../types/speech';

interface OpenAISpeechConfig extends SpeechConfig {
  apiKey?: string;
  baseUrl?: string;
}

type OpenAIVoice = 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';
type OpenAIModel = 'tts-1' | 'tts-1-hd';

export class OpenAISpeechService extends BaseSpeechService {
  private apiKey: string = '';
  private baseUrl: string = 'https://api.openai.com/v1';
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];
  private isRecording: boolean = false;
  private currentTranscript: string = '';
  private continuousMode: boolean = false;
  private recordingStartTime: number = 0;
  private chunkProcessingInterval?: NodeJS.Timeout;
  private processedChunks: number = 0;

  constructor() {
    super('openai');
  }

  async initialize(config?: OpenAISpeechConfig): Promise<void> {
    await super.initialize(config);
    
    // Get OpenAI API key from localStorage or config
    this.apiKey = config?.apiKey || 
                 localStorage.getItem('openai-api-key') || 
                 '';
    
    this.baseUrl = config?.baseUrl || this.baseUrl;
    
    if (!this.apiKey) {
      console.warn('OpenAI Speech Service: No API key provided');
    }
  }

  async synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key is required for text-to-speech');
    }

    // Map custom voice names to OpenAI voices
    const voice = this.mapToOpenAIVoice(options?.voice);
    const model: OpenAIModel = 'tts-1'; // Use standard model for lower latency
    const speed = options?.rate ?? 1.0;

    try {
      const response = await fetch(`${this.baseUrl}/audio/speech`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model,
          input: text,
          voice,
          speed: Math.max(0.25, Math.min(4.0, speed)) // OpenAI speed range
        })
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
        throw new Error(`OpenAI TTS failed: ${error.error?.message || response.statusText}`);
      }

      const audioData = await response.arrayBuffer();
      const blob = new Blob([audioData], { type: 'audio/mpeg' });
      const audioUrl = URL.createObjectURL(blob);

      // Auto-play the audio
      await this.playAudioData(audioUrl);

      return {
        audioData,
        audioUrl,
        duration: this.estimateDuration(text, speed)
      };
    } catch (error) {
      console.error('OpenAI TTS error:', error);
      throw error;
    }
  }

  cancelSynthesis(): void {
    // Playback uses <audio> via BaseSpeechService
    super.cancelSynthesis();
  }

  async *streamSpeech(text: string, options?: TTSOptions): AsyncGenerator<ArrayBuffer, void, unknown> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key is required for text-to-speech');
    }

    const voice = this.mapToOpenAIVoice(options?.voice);
    const model: OpenAIModel = 'tts-1';
    const speed = options?.rate ?? 1.0;

    try {
      const response = await fetch(`${this.baseUrl}/audio/speech`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model,
          input: text,
          voice,
          speed: Math.max(0.25, Math.min(4.0, speed)),
          stream: true
        })
      });

      if (!response.ok || !response.body) {
        throw new Error(`OpenAI TTS streaming failed: ${response.statusText}`);
      }

      const reader = response.body.getReader();
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (value) {
          yield value.buffer;
        }
      }
    } catch (error) {
      console.error('OpenAI TTS streaming error:', error);
      throw error;
    }
  }

  async getAvailableVoices(): Promise<VoiceInfo[]> {
    // OpenAI has a fixed set of voices
    return [
      { id: 'alloy', name: 'Alloy', language: 'en-US', gender: 'neutral', provider: 'openai' },
      { id: 'echo', name: 'Echo', language: 'en-US', gender: 'male', provider: 'openai' },
      { id: 'fable', name: 'Fable', language: 'en-US', gender: 'neutral', provider: 'openai' },
      { id: 'onyx', name: 'Onyx', language: 'en-US', gender: 'male', provider: 'openai' },
      { id: 'nova', name: 'Nova', language: 'en-US', gender: 'female', provider: 'openai' },
      { id: 'shimmer', name: 'Shimmer', language: 'en-US', gender: 'female', provider: 'openai' }
    ];
  }

  async startRecognition(options?: STTOptions): Promise<void> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key is required for speech recognition');
    }

    if (this.isRecording) {
      return;
    }

    this.currentTranscript = '';
    this.isRecording = true;
    this.audioChunks = [];
    this.continuousMode = options?.continuous ?? true;
    this.recordingStartTime = Date.now();

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          channelCount: 1,
          sampleRate: 16000,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        } 
      });

      this.mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm'
      });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = async () => {
        if (this.audioChunks.length > 0) {
          const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
          await this.processWhisperRecognition(audioBlob, options);
        }
        stream.getTracks().forEach(track => track.stop());
      };

      // Start recording with smaller chunks for better continuous experience
      this.mediaRecorder.start(500); // more frequent chunks for timely interim
      
      // For continuous mode, process chunks periodically
      if (this.continuousMode) {
        this.chunkProcessingInterval = setInterval(() => {
          if (this.audioChunks.length > this.processedChunks && this.isRecording) {
            this.processIntermediateAudio(options);
          }
        }, 4000); // Process more often for real-time feel
      }
    } catch (error) {
      this.isRecording = false;
      throw new Error(`Failed to start recording: ${error}`);
    }
  }

  async stopRecognition(): Promise<SpeechRecognitionResult> {
    if (!this.isRecording || !this.mediaRecorder) {
      return {
        transcript: this.currentTranscript.trim(),
        confidence: 1,
        isFinal: true
      };
    }

    this.continuousMode = false;
    
    // Clear the processing interval
    if (this.chunkProcessingInterval) {
      clearInterval(this.chunkProcessingInterval);
      this.chunkProcessingInterval = undefined;
    }

    return new Promise((resolve) => {
      const recorder = this.mediaRecorder!;
      
      // Set up completion handler
      const originalOnStop = recorder.onstop;
      recorder.onstop = async (event) => {
        if (originalOnStop) {
          await originalOnStop.call(recorder, event);
        }
        
        resolve({
          transcript: this.currentTranscript.trim(),
          confidence: 1,
          isFinal: true
        });
        
        this.isRecording = false;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.continuousMode = false;
        this.processedChunks = 0;
      };

      recorder.stop();
    });
  }

  isAvailable(): boolean {
    const apiKey = this.apiKey || localStorage.getItem('openai-api-key');
    return !!apiKey;
  }

  getCapabilities(): SpeechServiceCapabilities {
    return {
      supportsTTS: true,
      supportsSTT: true,
      supportsStreaming: true,
      supportsVoiceCloning: false,
      supportsEmotions: false,
      supportsMultiLanguage: true,
      availableVoices: [],
      availableLanguages: this.getAvailableLanguages()
    };
  }

  dispose(): void {
    if (this.chunkProcessingInterval) {
      clearInterval(this.chunkProcessingInterval);
      this.chunkProcessingInterval = undefined;
    }
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.mediaRecorder = null;
    }
    this.audioChunks = [];
    this.processedChunks = 0;
    super.dispose();
  }

  private async processWhisperRecognition(audioBlob: Blob, options?: STTOptions, isFinal: boolean = true): Promise<void> {
    const language = options?.language || 'en';
    
    try {
      // Check audio size - Whisper has a 25MB limit
      if (audioBlob.size > 25 * 1024 * 1024) {
        console.warn('Audio file too large for Whisper API, truncating...');
        // Process only the last 20MB
        const slice = audioBlob.slice(-20 * 1024 * 1024);
        audioBlob = new Blob([slice], { type: 'audio/webm' });
      }
      
      // Create form data with the audio file
      const formData = new FormData();
      formData.append('file', audioBlob, 'audio.webm');
      formData.append('model', 'whisper-1');
      
      if (language && language !== 'auto') {
        formData.append('language', language.split('-')[0]); // Use ISO 639-1 code
      }
      
      // Add context prompt for better continuity
      const contextPrompt = this.buildContextPrompt();
      if (contextPrompt) {
        formData.append('prompt', contextPrompt);
      }

      const response = await fetch(`${this.baseUrl}/audio/transcriptions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: formData
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
        throw new Error(`Whisper API failed: ${error.error?.message || response.statusText}`);
      }

      const result = await response.json();
      const newText = result.text || '';
      
      // For intermediate processing, replace the entire transcript
      // Whisper processes the full audio each time
      this.currentTranscript = newText;
      
      const recognitionResult: SpeechRecognitionResult = {
        transcript: this.currentTranscript,
        confidence: 0.95, // Whisper doesn't provide confidence scores
        isFinal: isFinal
      };

      this.notifyRecognitionResult(recognitionResult);
    } catch (error) {
      console.error('Whisper API error:', error);
      // Don't clear transcript on error in continuous mode
      if (!this.continuousMode) {
        this.currentTranscript = '';
      }
    }
  }
  
  private buildContextPrompt(): string {
    // Build a context prompt to help Whisper maintain continuity
    const prompts = [];
    
    // Add punctuation instruction
    prompts.push('Please transcribe with proper punctuation and capitalization.');
    
    // Add recent context if available
    if (this.currentTranscript) {
      const recentWords = this.currentTranscript.split(' ').slice(-30).join(' ');
      if (recentWords.length > 20) {
        prompts.push(`Recent context: ...${recentWords}`);
      }
    }
    
    // Add common words that might be misheard
    prompts.push('Common terms: AI, API, UI, URL, HTTP, JSON');
    
    return prompts.join(' ');
  }
  
  private async processIntermediateAudio(options?: STTOptions): Promise<void> {
    // Only process new chunks since last processing
    const newChunks = this.audioChunks.slice(this.processedChunks);
    if (newChunks.length === 0) return;
    
    // Create a blob from all chunks (Whisper works better with full context)
    const allChunks = this.audioChunks.slice(0);
    const audioBlob = new Blob(allChunks, { type: 'audio/webm' });
    
    // Update processed count
    this.processedChunks = this.audioChunks.length;
    
    // Process in background without blocking
    this.processWhisperRecognition(audioBlob, options, false).catch(error => {
      console.warn('Intermediate processing error:', error);
    });
  }

  private mapToOpenAIVoice(voice?: string): OpenAIVoice {
    if (!voice) return 'nova'; // Default voice
    
    const voiceLower = voice.toLowerCase();
    
    // Direct mapping
    if (['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'].includes(voiceLower)) {
      return voiceLower as OpenAIVoice;
    }
    
    // Gender-based mapping
    if (voiceLower.includes('female') || voiceLower.includes('woman')) {
      return 'nova';
    }
    if (voiceLower.includes('male') || voiceLower.includes('man')) {
      return 'echo';
    }
    
    return 'nova'; // Default
  }

  private estimateDuration(text: string, speed: number): number {
    // Estimate ~150 words per minute at normal speed
    const wordsPerMinute = 150 * speed;
    const wordCount = text.split(/\s+/).length;
    return (wordCount / wordsPerMinute) * 60;
  }

  private getAvailableLanguages(): string[] {
    // Whisper supports many languages
    return [
      'en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh',
      'ar', 'hi', 'nl', 'pl', 'tr', 'sv', 'da', 'no', 'fi', 'el',
      'he', 'id', 'ms', 'th', 'vi', 'cs', 'hu', 'ro', 'uk', 'bg'
    ];
  }
}

================
File: client/src/lib/speech/README.md
================
# Speech Services - Environment Variables Fix

## Issue Resolved
Fixed "process is not defined" error by replacing `process.env` with `import.meta.env` in browser environment.

## Changes Made
1. **speechServiceFactory.ts**: Updated environment variable access for Azure Speech key check
2. **azureSpeechService.ts**: Updated all environment variable accesses for Azure credentials

## Environment Variable Access in Vite
In Vite applications, environment variables must be accessed using:
```javascript
// ‚úÖ Correct - Works in browser
import.meta.env.VITE_VARIABLE_NAME

// ‚ùå Incorrect - Causes "process is not defined" error
process.env.VITE_VARIABLE_NAME
```

## TypeScript Compatibility
To avoid TypeScript errors with `import.meta.env`, we use:
```javascript
(import.meta as any).env?.VITE_VARIABLE_NAME
```

This ensures compatibility while maintaining type safety where possible.

================
File: client/src/lib/speech/SpeechOrchestrator.ts
================
// SpeechOrchestrator: resilient, provider-agnostic STT controller with progress watchdog and fallback

import { ISpeechService, STTOptions, SpeechRecognitionResult } from '../../types/speech';
import { SpeechServiceFactory } from './speechServiceFactory';
import { AIProvider } from '../../hooks/useAIProvider';

type RecognitionCallback = (result: SpeechRecognitionResult) => void;

interface OrchestratorOptions {
  aiProvider: AIProvider;
  onResult?: RecognitionCallback;
  progressTimeoutMs?: number; // time without interim/final before restart
  maxRestartsPerMinute?: number;
}

export class SpeechOrchestrator {
  private aiProvider: AIProvider;
  private onResult?: RecognitionCallback;
  private sttService: ISpeechService | null = null;
  private progressTimeoutMs: number;
  private maxRestartsPerMinute: number;
  private lastProgressAt: number = 0;
  private watchdogTimer?: NodeJS.Timeout;
  private restartTimestamps: number[] = [];
  private isActive: boolean = false;
  private optionsRef: STTOptions | undefined;

  constructor(opts: OrchestratorOptions) {
    this.aiProvider = opts.aiProvider;
    this.onResult = opts.onResult;
    this.progressTimeoutMs = opts.progressTimeoutMs ?? 30000; // Increased to 30 seconds for natural speech pauses
    this.maxRestartsPerMinute = opts.maxRestartsPerMinute ?? 10; // Allow more restarts for continuous mode
  }

  async initialize(config?: any): Promise<void> {
    this.sttService = await SpeechServiceFactory.getBestServiceFor(this.aiProvider, 'stt', config);
    // Chain results to orchestrator to track progress
    this.sttService.onRecognitionResult((r) => {
      this.lastProgressAt = Date.now();
      if (this.onResult) this.onResult(r);
    });
  }

  setOnResult(cb?: RecognitionCallback) {
    this.onResult = cb;
  }

  async start(options?: STTOptions): Promise<void> {
    if (!this.sttService) {
      await this.initialize();
    }
    this.isActive = true;
    this.optionsRef = options;
    this.lastProgressAt = Date.now();
    await this.sttService!.startRecognition(options);
    this.startWatchdog();
  }

  async stop(): Promise<SpeechRecognitionResult> {
    this.isActive = false;
    this.clearWatchdog();
    if (!this.sttService) {
      return { transcript: '', confidence: 1, isFinal: true };
    }
    return await this.sttService.stopRecognition();
  }

  dispose(): void {
    this.isActive = false;
    this.clearWatchdog();
    this.sttService?.dispose();
    this.sttService = null;
  }

  private startWatchdog(): void {
    this.clearWatchdog();
    this.watchdogTimer = setInterval(() => {
      if (!this.isActive) return;
      const now = Date.now();
      const elapsed = now - this.lastProgressAt;
      if (elapsed > this.progressTimeoutMs) {
        // Restart recognition session to break stalled state
        this.recordRestart(now);
        this.safeRestart().catch(() => {});
      }
    }, Math.max(1000, Math.floor(this.progressTimeoutMs / 2)));
  }

  private clearWatchdog(): void {
    if (this.watchdogTimer) {
      clearInterval(this.watchdogTimer);
      this.watchdogTimer = undefined;
    }
  }

  private recordRestart(now: number): void {
    this.restartTimestamps.push(now);
    // keep last minute
    const oneMinuteAgo = now - 60000;
    this.restartTimestamps = this.restartTimestamps.filter(t => t >= oneMinuteAgo);
  }

  private async safeRestart(): Promise<void> {
    if (!this.isActive) return;
    if (!this.sttService) return;

    // If too many restarts, fallback to another provider
    if (this.restartTimestamps.length >= this.maxRestartsPerMinute) {
      try {
        const alt = await SpeechServiceFactory.getBestServiceFor(this.aiProvider, 'stt');
        if (alt && alt !== this.sttService) {
          this.sttService.dispose();
          this.sttService = alt;
          this.sttService.onRecognitionResult((r) => {
            this.lastProgressAt = Date.now();
            if (this.onResult) this.onResult(r);
          });
        }
        // reset counters after switching
        this.restartTimestamps = [];
      } catch {}
    }

    try {
      await this.sttService.stopRecognition().catch(() => ({} as any));
    } catch {}
    this.lastProgressAt = Date.now();
    await this.sttService.startRecognition(this.optionsRef);
  }
}

================
File: client/src/lib/speech/speechServiceFactory.ts
================
// Speech Service Factory - Creates appropriate speech service based on AI provider

import { ISpeechService, SpeechProvider, SpeechConfig } from '../../types/speech';
import { WebSpeechService } from './webSpeechService';
import { AzureSpeechService } from './azureSpeechService';
import { OpenAISpeechService } from './openaiSpeechService';
import { GoogleSpeechService } from './googleSpeechService';
import { AIProvider } from '../../hooks/useAIProvider';

export class SpeechServiceFactory {
  private static instances: Map<SpeechProvider, ISpeechService> = new Map();
  
  /**
   * Get or create a speech service instance based on the provider
   */
  static async getService(
    provider: SpeechProvider, 
    config?: SpeechConfig
  ): Promise<ISpeechService> {
    // Check if we already have an instance
    let service = this.instances.get(provider);
    
    if (!service) {
      service = this.createService(provider);
      this.instances.set(provider, service);
    }
    
    // Initialize if needed
    if (config) {
      await service.initialize(config);
    }
    
    return service;
  }
  
  /**
   * Map AI provider to appropriate speech provider
   */
  static mapAIProviderToSpeechProvider(aiProvider: AIProvider): SpeechProvider {
    switch (aiProvider) {
      case 'azure':
        return 'azure';
      case 'openai':
        return 'openai';
      case 'gemini':
        return 'google';
      case 'huggingface':
      case 'uterpi':
      case 'lmstudio':
        // Hugging Face and Uterpi can use Web Speech API as fallback
        // or Azure if configured
        if ((import.meta as any).env?.VITE_AZURE_SPEECH_KEY) {
          return 'azure';
        }
        return 'web';
      default:
        return 'web';
    }
  }
  
  /**
   * Get the best available speech service for the current AI provider
   */
  static async getBestAvailableService(
    aiProvider: AIProvider,
    config?: SpeechConfig
  ): Promise<ISpeechService> {
    const preferredProvider = this.mapAIProviderToSpeechProvider(aiProvider);
    
    // Try to get the preferred provider
    let service = await this.getService(preferredProvider, config);
    
    // Check if the service is available
    if (service.isAvailable()) {
      return service;
    }
    
    // Fallback chain
    const fallbackProviders: SpeechProvider[] = ['web', 'azure', 'openai', 'google'];
    
    for (const fallback of fallbackProviders) {
      if (fallback === preferredProvider) continue;
      
      try {
        service = await this.getService(fallback, config);
        if (service.isAvailable()) {
          console.log(`Using ${fallback} speech service as fallback`);
          return service;
        }
      } catch (error) {
        console.warn(`Failed to initialize ${fallback} speech service:`, error);
      }
    }
    
    // Return Web Speech API as last resort (even if not available)
    console.warn('No speech services available, falling back to Web Speech API');
    return await this.getService('web', config);
  }

  /**
   * Get the best service specifically for a capability (tts or stt)
   */
  static async getBestServiceFor(
    aiProvider: AIProvider,
    capability: 'tts' | 'stt',
    config?: SpeechConfig
  ): Promise<ISpeechService> {
    const preferred = this.mapAIProviderToSpeechProvider(aiProvider);
    const providersOrder: SpeechProvider[] = [preferred, 'web', 'openai', 'google', 'azure'];

    for (const p of providersOrder) {
      try {
        const service = await this.getService(p, config);
        const caps = service.getCapabilities();
        if ((capability === 'tts' && caps.supportsTTS) || (capability === 'stt' && caps.supportsSTT)) {
          // additionally ensure runtime availability
          if (service.isAvailable()) {
            return service;
          }
        }
      } catch {
        // try next
      }
    }

    // As last resort return WebSpeech (may still be partially available)
    return await this.getService('web', config);
  }
  
  /**
   * Create a new speech service instance
   */
  private static createService(provider: SpeechProvider): ISpeechService {
    switch (provider) {
      case 'azure':
        return new AzureSpeechService();
      case 'openai':
        return new OpenAISpeechService();
      case 'google':
        return new GoogleSpeechService();
      case 'web':
      default:
        return new WebSpeechService();
    }
  }
  
  /**
   * Dispose of all service instances
   */
  static disposeAll(): void {
    this.instances.forEach(service => service.dispose());
    this.instances.clear();
  }
  
  /**
   * Check if any speech service is available
   */
  static async isAnyServiceAvailable(): Promise<boolean> {
    const providers: SpeechProvider[] = ['web', 'azure', 'openai', 'google'];
    
    for (const provider of providers) {
      try {
        const service = await this.getService(provider);
        if (service.isAvailable()) {
          return true;
        }
      } catch (error) {
        continue;
      }
    }
    
    return false;
  }
}

================
File: client/src/lib/speech/speechUtils.ts
================
// Speech Service Utilities

/**
 * Check if the current page is served over HTTPS
 * Required for persistent microphone permissions
 */
export function isHTTPS(): boolean {
  return typeof window !== 'undefined' && 
         (window.location.protocol === 'https:' || 
          window.location.hostname === 'localhost' ||
          window.location.hostname === '127.0.0.1');
}

/**
 * Check if Web Speech API is available
 */
export function isWebSpeechAvailable(): boolean {
  if (typeof window === 'undefined') return false;
  
  const hasSpeechRecognition = 'SpeechRecognition' in window || 
                               'webkitSpeechRecognition' in window;
  const hasSpeechSynthesis = 'speechSynthesis' in window;
  
  return hasSpeechRecognition || hasSpeechSynthesis;
}

/**
 * Get browser info for debugging
 */
export function getBrowserInfo(): { name: string; version: string; isMobile: boolean } {
  const ua = navigator.userAgent;
  let name = 'Unknown';
  let version = 'Unknown';
  
  if (ua.includes('Chrome')) {
    name = 'Chrome';
    version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Firefox')) {
    name = 'Firefox';
    version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
    name = 'Safari';
    version = ua.match(/Version\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Edge')) {
    name = 'Edge';
    version = ua.match(/Edge\/(\d+)/)?.[1] || 'Unknown';
  }
  
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  
  return { name, version, isMobile };
}

/**
 * Format duration in seconds to MM:SS
 */
export function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Debounce function for reducing API calls
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Convert blob to base64 for API transmission
 */
export async function blobToBase64(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64 = reader.result as string;
      // Remove data URL prefix
      const base64Data = base64.split(',')[1];
      resolve(base64Data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

/**
 * Get microphone permission status
 */
export async function getMicrophonePermission(): Promise<PermissionState | 'unsupported'> {
  if (!navigator.permissions || !navigator.permissions.query) {
    return 'unsupported';
  }
  
  try {
    const result = await navigator.permissions.query({ name: 'microphone' as PermissionName });
    return result.state;
  } catch (error) {
    console.warn('Failed to query microphone permission:', error);
    return 'unsupported';
  }
}

/**
 * Request microphone permission
 */
export async function requestMicrophonePermission(): Promise<boolean> {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Stop the stream immediately after getting permission
    stream.getTracks().forEach(track => track.stop());
    return true;
  } catch (error) {
    console.error('Microphone permission denied:', error);
    return false;
  }
}

================
File: client/src/lib/speech/webSpeechService.ts
================
// Web Speech API implementation (browser native, fallback provider)

import { BaseSpeechService } from './baseSpeechService';
import {
  TTSOptions,
  STTOptions,
  SpeechRecognitionResult,
  SpeechSynthesisResult,
  VoiceInfo,
  SpeechServiceCapabilities,
  SpeechConfig
} from '../../types/speech';

// Extend window to include Web Speech API types
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
    speechSynthesis: SpeechSynthesis;
  }
}

export class WebSpeechService extends BaseSpeechService {
  private recognition: any = null;
  private currentTranscript: string = '';
  private isRecording: boolean = false;
  private recognitionResolve?: (value: SpeechRecognitionResult) => void;
  private continuousMode: boolean = false;
  private fullTranscript: string = '';
  private restartTimer?: NodeJS.Timeout;
  private lastResultTime: number = 0;
  private silenceTimer?: NodeJS.Timeout;
  private isRestarting: boolean = false;
  private restartAttempts: number = 0;
  private maxRestartAttempts: number = 1000000;
  private pendingRestart: boolean = false;
  private utteranceQueue: SpeechSynthesisUtterance[] = [];
  private isSpeaking: boolean = false;

  constructor() {
    super('web');
  }

  async initialize(config?: SpeechConfig): Promise<void> {
    await super.initialize(config);
    
    // Initialize speech recognition if available
    if (this.isSTTAvailable()) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();
      this.setupRecognition();
    }
  }

  private setupRecognition(): void {
    if (!this.recognition) return;

    this.recognition.continuous = true; // Always continuous for better experience
    this.recognition.interimResults = this.config.interimResults ?? true;
    this.recognition.maxAlternatives = this.config.maxAlternatives ?? 1;
    this.recognition.lang = this.config.language ?? 'en-US';

    this.recognition.onresult = (event: any) => {
      this.lastResultTime = Date.now();
      this.resetSilenceTimer();
      
      const results = event.results;
      console.log(`[WebSpeech] onresult: ${results.length} results, resultIndex: ${event.resultIndex}`);
      
      // Process all results from the beginning to maintain complete transcript
      let fullTranscript = '';
      let interimTranscript = '';
      
      // Build the complete transcript from all results
      for (let i = 0; i < results.length; i++) {
        const r = results[i];
        const text = r[0]?.transcript || '';
        if (r.isFinal) {
          // Add final results to the full transcript
          fullTranscript += text + ' ';
          console.log(`[WebSpeech] Final result[${i}]: "${text}"`);
        } else {
          // Add interim results (only the last one matters)
          interimTranscript = text;
          console.log(`[WebSpeech] Interim result[${i}]: "${text}"`);
        }
      }
      
      // Update the persistent full transcript with all finals
      this.fullTranscript = fullTranscript;
      
      // Current transcript is all finals + current interim
      this.currentTranscript = (fullTranscript + (interimTranscript ? ' ' + interimTranscript : '')).trim();
      console.log(`[WebSpeech] Current transcript: "${this.currentTranscript}"`);
      
      // Get the last result for alternatives and confidence if available
      const lastResult = results[results.length - 1];
      const alternatives = Array.from(lastResult || []).map((alt: any) => ({
        transcript: alt.transcript,
        confidence: alt.confidence || 0
      }));

      const result: SpeechRecognitionResult = {
        transcript: this.currentTranscript,
        confidence: (lastResult && lastResult[0] && typeof lastResult[0].confidence === 'number') ? lastResult[0].confidence : 0.9,
        isFinal: false, // Never report final while in continuous mode to keep listening
        alternatives: alternatives.slice(1)
      };

      this.notifyRecognitionResult(result);
      
      // Keep the recognition going in continuous mode
      if (this.continuousMode && !this.isRecording) {
        this.isRecording = true;
      }
    };

    this.recognition.onerror = (event: any) => {
      console.error('[WebSpeech] Recognition error:', event.error, event);
      
      // Handle different error types
      switch (event.error) {
        case 'network':
          console.error('Network error - check your internet connection');
          break;
        case 'audio-capture':
          // No microphone or audio capture issue - attempt restart if still recording
          if (this.continuousMode && this.isRecording) {
            this.scheduleRestart();
          }
          break;
        case 'not-allowed':
        case 'service-not-allowed':
          // User denied permission or service not allowed
          this.continuousMode = false;
          this.isRecording = false;
          break;
        case 'no-speech':
          // No speech detected - don't restart, just continue listening
          // The continuous mode should handle silence naturally
          break;
        case 'aborted':
          // Recognition was aborted - restart if in continuous mode
          if (this.continuousMode && this.isRecording) {
            this.scheduleRestart();
          }
          break;
        default:
          // Other errors - try to restart if in continuous mode
          if (this.continuousMode && this.isRecording) {
            this.scheduleRestart();
          }
      }
      
      // Notify error result if we're not restarting
      if (!this.isRestarting) {
        const errorResult: SpeechRecognitionResult = {
          transcript: this.currentTranscript.trim(),
          confidence: 0,
          isFinal: true
        };

        if (this.recognitionResolve) {
          this.recognitionResolve(errorResult);
          this.recognitionResolve = undefined;
        }
      }
    };

    this.recognition.onend = () => {
      this.clearSilenceTimer();
      
      // Always restart if we're in continuous mode and supposed to be recording
      if (this.continuousMode && this.isRecording) {
        // Immediately restart without delay for seamless continuous recognition
        this.isRestarting = true;
        setTimeout(() => {
          if (this.continuousMode && this.isRecording) {
            try {
              this.recognition.start();
              this.isRestarting = false;
              this.startSilenceTimer();
              console.log('Recognition restarted for continuous mode');
            } catch (e) {
              console.log('Failed to restart, will retry...');
              this.isRestarting = false;
              this.scheduleRestart();
            }
          } else {
            this.isRestarting = false;
          }
        }, 100); // Small delay to avoid immediate restart errors
      } else {
        this.isRecording = false;
        this.isRestarting = false;
      }
    };
    
    // Additional events for better handling
    this.recognition.onaudiostart = () => {
      console.log('[WebSpeech] Audio capture started');
      this.resetSilenceTimer();
    };
    
    this.recognition.onaudioend = () => {
      console.log('[WebSpeech] Audio capture ended');
    };
    
    this.recognition.onsoundstart = () => {
      console.log('[WebSpeech] Sound detected');
      this.resetSilenceTimer();
    };
    
    this.recognition.onsoundend = () => {
      console.log('[WebSpeech] Sound ended');
    };
    
    this.recognition.onspeechstart = () => {
      console.log('[WebSpeech] Speech detected');
      this.resetSilenceTimer();
    };
    
    this.recognition.onspeechend = () => {
      console.log('[WebSpeech] Speech ended');
    };

    this.recognition.onnomatch = () => {
      console.log('[WebSpeech] No match - no words recognized');
      // No words recognized despite audio ‚Äî trigger a safe restart in continuous mode
      if (this.continuousMode && this.isRecording) {
        this.scheduleRestart();
      }
    };
    
    this.recognition.onstart = () => {
      console.log('[WebSpeech] Recognition service started');
    };
  }

  async synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult> {
    return new Promise((resolve, reject) => {
      if (!this.isTTSAvailable()) {
        reject(new Error('Text-to-speech is not available in this browser'));
        return;
      }

      const enqueueUtterance = (u: SpeechSynthesisUtterance) => {
        this.utteranceQueue.push(u);
        if (!this.isSpeaking) {
          this.playNextUtterance();
        }
      };

      // Split long text into chunks to avoid platform limits
      const chunks = this.chunkTextForSynthesis(text);
      let totalDuration = 0;

      chunks.forEach((chunk, index) => {
        const utterance = new SpeechSynthesisUtterance(chunk);
        if (options?.voice) {
          const voices = window.speechSynthesis.getVoices();
          const selectedVoice = voices.find(v => v.name === options.voice || v.voiceURI === options.voice);
          if (selectedVoice) {
            utterance.voice = selectedVoice;
          }
        }
        const rate = options?.rate ?? 1.0;
        utterance.rate = rate;
        utterance.pitch = options?.pitch ?? 1.0;
        utterance.volume = options?.volume ?? 1.0;
        utterance.lang = options?.language ?? 'en-US';

        totalDuration += chunk.length * 60 / (150 * rate);

        if (index === chunks.length - 1) {
          utterance.onend = () => resolve({ duration: totalDuration });
          utterance.onerror = (event) => reject(new Error(`Speech synthesis failed: ${event.error}`));
        }

        enqueueUtterance(utterance);
      });
    });
  }

  cancelSynthesis(): void {
    try { window.speechSynthesis.cancel(); } catch {}
    this.utteranceQueue = [];
    this.isSpeaking = false;
    super.cancelSynthesis();
  }

  async getAvailableVoices(): Promise<VoiceInfo[]> {
    if (!this.isTTSAvailable()) {
      return [];
    }

    return new Promise((resolve) => {
      const getVoicesList = () => {
        const voices = window.speechSynthesis.getVoices();
        const voiceInfos: VoiceInfo[] = voices.map(voice => ({
          id: voice.voiceURI,
          name: voice.name,
          language: voice.lang,
          gender: this.guessGenderFromName(voice.name),
          provider: 'web' as const,
          isDefault: voice.default
        }));
        resolve(voiceInfos);
      };

      if (window.speechSynthesis.getVoices().length > 0) {
        getVoicesList();
      } else {
        window.speechSynthesis.onvoiceschanged = getVoicesList;
        // Fallback timeout
        setTimeout(() => getVoicesList(), 100);
      }
    });
  }

  async startRecognition(options?: STTOptions): Promise<void> {
    console.log('[WebSpeech] Starting recognition with options:', options);
    
    if (!this.isSTTAvailable()) {
      console.error('[WebSpeech] Speech recognition not available in browser');
      throw new Error('Speech recognition is not available in this browser');
    }

    if (this.isRecording) {
      console.log('[WebSpeech] Already recording, returning');
      return;
    }

    // Ensure no TTS is speaking which can interfere with mic capture
    try {
      if (typeof window !== 'undefined' && window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
    } catch {}

    this.currentTranscript = '';
    this.fullTranscript = '';
    this.isRecording = true;
    this.isRestarting = false;
    this.restartAttempts = 0;
    this.continuousMode = options?.continuous ?? true; // Default to continuous
    this.lastResultTime = Date.now();

    // Update recognition settings with options
    if (this.recognition) {
      this.recognition.lang = options?.language ?? this.config.language ?? 'en-US';
      this.recognition.continuous = true; // Always use continuous internally
      this.recognition.interimResults = options?.interimResults ?? this.config.interimResults ?? true;
      this.recognition.maxAlternatives = options?.maxAlternatives ?? this.config.maxAlternatives ?? 1;
      
      console.log('[WebSpeech] Recognition configured:', {
        lang: this.recognition.lang,
        continuous: this.recognition.continuous,
        interimResults: this.recognition.interimResults,
        maxAlternatives: this.recognition.maxAlternatives
      });
    }

    try {
      // Start recognition
      this.recognition.start();
      this.startSilenceTimer();
      console.log('[WebSpeech] Recognition started successfully');
    } catch (error) {
      console.error('[WebSpeech] Failed to start recognition:', error);
      this.isRecording = false;
      this.continuousMode = false;
      throw error;
    }
  }

  async stopRecognition(): Promise<SpeechRecognitionResult> {
    return new Promise((resolve) => {
      if (!this.recognition || !this.isRecording) {
        resolve({
          transcript: this.currentTranscript.trim(),
          confidence: 1,
          isFinal: true
        });
        return;
      }

      this.continuousMode = false; // Stop continuous mode
      this.isRestarting = false;
      this.clearTimers();
      this.recognitionResolve = resolve;
      
      // Set up a one-time handler for the final result
      const handleStop = () => {
        if (this.recognitionResolve) {
          this.recognitionResolve({
            transcript: this.currentTranscript.trim(),
            confidence: 1,
            isFinal: true
          });
          this.recognitionResolve = undefined;
        }
        this.isRecording = false;
      };
      
      // Listen for the end event
      this.recognition.addEventListener('end', handleStop, { once: true });
      
      this.recognition.stop();

      // Timeout fallback
      setTimeout(() => {
        handleStop();
      }, 2000);
    });
  }
  
  private scheduleRestart(): void {
    if (this.isRestarting || !this.continuousMode || this.restartAttempts >= this.maxRestartAttempts) {
      return;
    }
    
    this.isRestarting = true;
    this.restartAttempts++;
    
    // Clear any existing restart timer
    if (this.restartTimer) {
      clearTimeout(this.restartTimer);
    }
    
    // Delay restart slightly to avoid rapid restarts and throttling
    this.restartTimer = setTimeout(() => {
      if (this.continuousMode && this.isRecording) {
        try {
          // Prefer stop‚Üíonend‚Üístart sequencing to avoid InvalidStateError
          this.fullTranscript = this.currentTranscript;
          this.pendingRestart = true;
          try { this.recognition.stop(); } catch {}
          // If engine is already ended, attempt immediate start
          try {
            this.recognition.start();
            this.pendingRestart = false;
            this.isRestarting = false;
            this.startSilenceTimer();
            console.log('Recognition restarted successfully');
          } catch (immediateErr) {
            // Will start on onend
            this.isRestarting = false;
          }
        } catch (error) {
          console.warn('Failed to restart recognition:', error);
          // Attempt to fully re-initialize the recognition engine
          try {
            const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
            if (SpeechRecognition) {
              this.recognition = new SpeechRecognition();
              this.setupRecognition();
              this.recognition.lang = this.config.language ?? 'en-US';
              this.recognition.continuous = true;
              this.recognition.interimResults = this.config.interimResults ?? true;
              this.recognition.maxAlternatives = this.config.maxAlternatives ?? 1;
              try {
                this.recognition.start();
                this.isRestarting = false;
                this.startSilenceTimer();
                console.log('Recognition re-initialized and restarted successfully');
              } catch {
                // If start fails immediately, request onend-driven restart
                this.pendingRestart = true;
                this.isRestarting = false;
              }
            } else {
              this.isRecording = false;
              this.isRestarting = false;
            }
          } catch (e) {
            console.warn('Re-initialization failed:', e);
            this.isRecording = false;
            this.isRestarting = false;
          }
        }
      } else {
        this.isRestarting = false;
      }
    }, 300); // Slightly larger delay to reduce throttling and improve stability
  }
  
  private startSilenceTimer(): void {
    this.resetSilenceTimer();
  }
  
  private resetSilenceTimer(): void {
    this.clearSilenceTimer();
    
    // Set a timer to check for prolonged silence (60 seconds for better tolerance)
    this.silenceTimer = setTimeout(() => {
      if (this.isRecording && this.continuousMode) {
        const timeSinceLastResult = Date.now() - this.lastResultTime;
        if (timeSinceLastResult > 60000) { // 60 seconds of silence
          console.log('Restarting due to prolonged silence');
          this.scheduleRestart();
        }
      }
    }, 60000);
  }
  
  private clearSilenceTimer(): void {
    if (this.silenceTimer) {
      clearTimeout(this.silenceTimer);
      this.silenceTimer = undefined;
    }
  }
  
  private clearTimers(): void {
    this.clearSilenceTimer();
    if (this.restartTimer) {
      clearTimeout(this.restartTimer);
      this.restartTimer = undefined;
    }
  }

  private playNextUtterance(): void {
    if (this.isSpeaking) return;
    const next = this.utteranceQueue.shift();
    if (!next) return;
    this.isSpeaking = true;
    next.onend = ((orig) => (ev: any) => {
      try { orig?.(ev); } catch {}
      this.isSpeaking = false;
      // slight delay between chunks to avoid iOS cutoff
      setTimeout(() => this.playNextUtterance(), 20);
    })(next.onend as any);
    next.onerror = ((orig) => (ev: any) => {
      try { orig?.(ev); } catch {}
      this.isSpeaking = false;
      this.playNextUtterance();
    })(next.onerror as any);
    try {
      window.speechSynthesis.speak(next);
    } catch {
      this.isSpeaking = false;
    }
  }

  private chunkTextForSynthesis(text: string): string[] {
    const maxLen = 180; // conservative chunk length for Safari/iOS
    const sentences = text.match(/[^.!?\n]+[.!?\n]?/g) || [text];
    const chunks: string[] = [];
    let current = '';
    for (const s of sentences) {
      if ((current + s).length <= maxLen) {
        current += s;
      } else {
        if (current) chunks.push(current.trim());
        if (s.length <= maxLen) {
          current = s;
        } else {
          // hard split long sentence
          for (let i = 0; i < s.length; i += maxLen) {
            chunks.push(s.slice(i, i + maxLen).trim());
          }
          current = '';
        }
      }
    }
    if (current) chunks.push(current.trim());
    return chunks;
  }

  isAvailable(): boolean {
    return this.isTTSAvailable() || this.isSTTAvailable();
  }

  getCapabilities(): SpeechServiceCapabilities {
    return {
      supportsTTS: this.isTTSAvailable(),
      supportsSTT: this.isSTTAvailable(),
      supportsStreaming: false,
      supportsVoiceCloning: false,
      supportsEmotions: false,
      supportsMultiLanguage: true,
      availableVoices: [],
      availableLanguages: this.getAvailableLanguages()
    };
  }

  dispose(): void {
    if (this.recognition) {
      this.continuousMode = false;
      this.isRecording = false;
      this.isRestarting = false;
      this.clearTimers();
      this.recognition.abort();
      this.recognition = null;
    }
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
    }
    super.dispose();
  }

  private isTTSAvailable(): boolean {
    return typeof window !== 'undefined' && 'speechSynthesis' in window;
  }

  private isSTTAvailable(): boolean {
    return typeof window !== 'undefined' && 
           ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window);
  }

  private guessGenderFromName(name: string): 'male' | 'female' | 'neutral' {
    const lowerName = name.toLowerCase();
    if (lowerName.includes('female') || lowerName.includes('woman')) return 'female';
    if (lowerName.includes('male') || lowerName.includes('man')) return 'male';
    return 'neutral';
  }

  private getAvailableLanguages(): string[] {
    // Common languages supported by Web Speech API
    return [
      'en-US', 'en-GB', 'es-ES', 'es-MX', 'fr-FR', 'de-DE',
      'it-IT', 'pt-BR', 'pt-PT', 'ru-RU', 'zh-CN', 'zh-TW',
      'ja-JP', 'ko-KR', 'ar-SA', 'hi-IN', 'nl-NL', 'pl-PL'
    ];
  }
}

================
File: client/src/lib/transcriptUtils.ts
================
import { Message } from '../types';

/**
 * Generates a formatted text transcript from chat messages
 * @param messages Array of chat messages
 * @param excludeWelcomeMessage Whether to exclude the initial welcome message (default: true)
 * @returns Formatted transcript string
 */
export function generateTranscript(
  messages: Message[], 
  excludeWelcomeMessage: boolean = true
): string {
  const exportTime = new Date();
  const header = `Uterpi Chat Transcript
Generated: ${exportTime.toLocaleString()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

`;

  // Filter messages based on excludeWelcomeMessage flag
  const filteredMessages = excludeWelcomeMessage 
    ? messages.filter(msg => msg.id !== "1")
    : messages;

  if (filteredMessages.length === 0) {
    return header + "No messages to export.\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nEnd of transcript";
  }

  const messageTexts = filteredMessages.map(message => {
    const timestamp = message.timestamp.toLocaleTimeString();
    const role = message.role === 'user' ? 'You' : 'NomadAI';
    
    let messageText = `[${timestamp}] ${role}:\n${message.content}`;
    
    // Add attachments if present
    if (message.attachments && message.attachments.length > 0) {
      messageText += '\nüìé Attachments: ' + message.attachments.join(', ');
    }
    
    return messageText;
  });

  const content = messageTexts.join('\n\n');
  const footer = `\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nEnd of transcript`;

  return header + content + footer;
}

/**
 * Generates a filename for the transcript with timestamp
 * @returns Filename string
 */
export function generateTranscriptFilename(): string {
  const now = new Date();
  const year = now.getFullYear();
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  const seconds = now.getSeconds().toString().padStart(2, '0');
  
  return `nomadai-transcript-${year}-${month}-${day}-${hours}${minutes}${seconds}.txt`;
}

/**
 * Downloads a text transcript as a .txt file
 * @param messages Array of chat messages
 * @param excludeWelcomeMessage Whether to exclude the initial welcome message
 */
export function downloadTranscript(
  messages: Message[], 
  excludeWelcomeMessage: boolean = true
): void {
  try {
    const transcriptText = generateTranscript(messages, excludeWelcomeMessage);
    const filename = generateTranscriptFilename();
    
    // Create blob and download
    const blob = new Blob([transcriptText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    // Create temporary anchor element for download
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = filename;
    anchor.style.display = 'none';
    
    // Trigger download
    document.body.appendChild(anchor);
    anchor.click();
    
    // Clean up
    document.body.removeChild(anchor);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Failed to download transcript:', error);
    throw new Error('Failed to download transcript. Please try again.');
  }
}

/**
 * Copies transcript text to clipboard
 * @param messages Array of chat messages
 * @param excludeWelcomeMessage Whether to exclude the initial welcome message
 * @returns Promise that resolves when copy is complete
 */
export async function copyTranscriptToClipboard(
  messages: Message[], 
  excludeWelcomeMessage: boolean = true
): Promise<void> {
  try {
    const transcriptText = generateTranscript(messages, excludeWelcomeMessage);
    
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(transcriptText);
    } else {
      // Fallback for older browsers or non-secure contexts
      const textArea = document.createElement('textarea');
      textArea.value = transcriptText;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      
      if (!successful) {
        throw new Error('Copy command failed');
      }
    }
  } catch (error) {
    console.error('Failed to copy transcript to clipboard:', error);
    throw new Error('Failed to copy transcript. Please try again.');
  }
}

/**
 * Shares transcript using Web Share API if available, otherwise copies to clipboard
 * @param messages Array of chat messages
 * @param excludeWelcomeMessage Whether to exclude the initial welcome message
 * @returns Promise that resolves when sharing is complete
 */
export async function shareTranscript(
  messages: Message[], 
  excludeWelcomeMessage: boolean = true
): Promise<{ method: 'share' | 'clipboard' }> {
  try {
    const transcriptText = generateTranscript(messages, excludeWelcomeMessage);
    const filename = generateTranscriptFilename();
    
    // Check if Web Share API is available and supports text sharing
    if (navigator.share && navigator.canShare) {
      const shareData = {
        title: 'Uterpi Chat Transcript',
        text: transcriptText,
        url: undefined // Don't include URL to focus on text content
      };
      
      if (navigator.canShare(shareData)) {
        await navigator.share(shareData);
        return { method: 'share' };
      }
    }
    
    // Fallback to clipboard
    await copyTranscriptToClipboard(messages, excludeWelcomeMessage);
    return { method: 'clipboard' };
  } catch (error) {
    console.error('Failed to share transcript:', error);
    throw new Error('Failed to share transcript. Please try again.');
  }
}

/**
 * Checks if Web Share API is available and functional
 * @returns Boolean indicating if sharing is supported
 */
export function isWebShareSupported(): boolean {
  if (typeof navigator === 'undefined' || !navigator.share) {
    return false;
  }
  
  // Test if canShare function exists and works with a minimal share data object
  try {
    if (navigator.canShare) {
      return navigator.canShare({ text: 'test' });
    }
    return true; // share exists but canShare might not be available (older implementations)
  } catch {
    return false;
  }
}

================
File: client/src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: client/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { Router } from './components/Router'
import './index.css'

// Create a client
const queryClient = new QueryClient()

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <Router />
    </QueryClientProvider>
  </StrictMode>,
)

================
File: client/src/types/index.ts
================
export interface Message {
  id: string;
  content: string;
  role: "user" | "assistant";
  timestamp: Date;
  attachments?: string[];
  isCreditLimit?: boolean;
  metadata?: {
    code?: string;
    currentBalance?: number;
    messagesUsed?: number;
    monthlyAllowance?: number;
    isFreemium?: boolean;
    creditsRequired?: number;
    isTeamPooled?: boolean;
    purchaseUrl?: string;
    upgradeUrl?: string;
    message?: string;
    attachedFileIds?: number[];
  };
}

export interface CommandSuggestion {
  icon: React.ReactNode;
  label: string;
  description: string;
  prefix: string;
}

// Azure AI specific types
export interface AzureAIMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

export interface AzureAIConfig {
  endpoint: string;
  apiKey: string;
  modelName: string;
}

export interface ChatCompletionOptions {
  maxTokens?: number;
  temperature?: number;
  topP?: number;
  stream?: boolean;
  // Add support for additional parameters that some models might use
  frequencyPenalty?: number;
  presencePenalty?: number;
  stop?: string | string[];
  logitBias?: Record<string, number>;
}

// Model-specific configuration types
export interface ModelParameterLimits {
  maxTokens: {
    input: number;
    output: number;
  };
  temperature: {
    min: number;
    max: number;
    default: number;
  };
  topP: {
    min: number;
    max: number;
    default: number;
  };
  frequencyPenalty?: {
    min: number;
    max: number;
    default: number;
  };
  presencePenalty?: {
    min: number;
    max: number;
    default: number;
  };
}

export interface ModelCapabilities {
  supportsVision: boolean;
  supportsCodeGeneration: boolean;
  supportsAnalysis: boolean;
  supportsImageGeneration: boolean;
  supportsSystemMessages: boolean;
  supportsJSONMode: boolean;
  supportsFunctionCalling: boolean;
  supportsStreaming: boolean;
  supportsStop: boolean;
  supportsLogitBias: boolean;
  supportsFrequencyPenalty: boolean;
  supportsPresencePenalty: boolean;
}

export interface ModelConfiguration {
  id: string;
  name: string;
  provider: string;
  limits: ModelParameterLimits;
  capabilities: ModelCapabilities;
  recommendedParams: {
    maxTokens: number;
    temperature: number;
    topP: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
  };
  specialInstructions?: string[];
  contextLength: number;
}

// LLM Model Selection types
export interface LLMModel {
  id: string;
  name: string;
  provider: string;
  performance: number;
  cost: number;
  latency: number;
  contextLength: number;
  description: string;
  category: "text" | "code" | "multimodal" | "reasoning";
  tier: "freemium" | "pro" | "enterprise" | "standard";
  isFavorite: boolean;
  capabilities?: {
    supportsVision?: boolean;
    supportsCodeGeneration?: boolean;
    supportsAnalysis?: boolean;
    supportsImageGeneration?: boolean;
  };
}

// OpenAI specific types
export interface OpenAIMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

export interface OpenAIConfig {
  apiKey: string;
  modelName: string;
  baseUrl?: string;
}

// Gemini specific types  
export interface GeminiMessage {
  role: "user" | "model";
  parts: Array<{ text: string }>;
}

export interface GeminiConfig {
  apiKey: string;
  modelName: string;
  baseUrl?: string;
}

export interface GeminiContent {
  role: "user" | "model";
  parts: Array<{ text: string }>;
}

export interface GeminiSystemInstruction {
  parts: Array<{ text: string }>;
}

================
File: client/src/types/speech.ts
================
// Speech-related type definitions for TTS and STT functionality

export interface SpeechConfig {
  // TTS Configuration
  voice?: string;
  rate?: number;
  pitch?: number;
  volume?: number;
  language?: string;
  
  // STT Configuration
  continuous?: boolean;
  interimResults?: boolean;
  maxAlternatives?: number;
  
  // Provider-specific configurations
  apiKey?: string;
  endpoint?: string;
  region?: string;
  subscriptionKey?: string;
}

export interface TTSOptions {
  voice?: string;
  rate?: number;
  pitch?: number;
  volume?: number;
  language?: string;
  outputFormat?: 'mp3' | 'wav' | 'ogg' | 'webm';
}

export interface STTOptions {
  language?: string;
  continuous?: boolean;
  interimResults?: boolean;
  maxAlternatives?: number;
  profanityFilter?: boolean;
  punctuation?: boolean;
}

export interface SpeechRecognitionResult {
  transcript: string;
  confidence: number;
  isFinal: boolean;
  alternatives?: Array<{
    transcript: string;
    confidence: number;
  }>;
}

export interface SpeechSynthesisResult {
  audioData?: ArrayBuffer | Blob;
  audioUrl?: string;
  duration?: number;
}

export type SpeechProvider = 'web' | 'azure' | 'openai' | 'google' | 'elevenlabs';

export interface VoiceInfo {
  id: string;
  name: string;
  language: string;
  gender?: 'male' | 'female' | 'neutral';
  provider: SpeechProvider;
  isDefault?: boolean;
  previewUrl?: string;
  styles?: string[];
}

export interface SpeechServiceCapabilities {
  supportsTTS: boolean;
  supportsSTT: boolean;
  supportsStreaming: boolean;
  supportsVoiceCloning: boolean;
  supportsEmotions: boolean;
  supportsMultiLanguage: boolean;
  availableVoices: VoiceInfo[];
  availableLanguages: string[];
}

export interface ISpeechService {
  // TTS Methods
  synthesizeSpeech(text: string, options?: TTSOptions): Promise<SpeechSynthesisResult>;
  streamSpeech?(text: string, options?: TTSOptions): AsyncGenerator<ArrayBuffer, void, unknown>;
  /** Cancel any ongoing speech synthesis/playback, if supported */
  cancelSynthesis(): void;
  getAvailableVoices(): Promise<VoiceInfo[]>;
  
  // STT Methods
  startRecognition(options?: STTOptions): Promise<void>;
  stopRecognition(): Promise<SpeechRecognitionResult>;
  onRecognitionResult(callback: (result: SpeechRecognitionResult) => void): void;
  
  // Common Methods
  isAvailable(): boolean;
  getCapabilities(): SpeechServiceCapabilities;
  initialize(config?: SpeechConfig): Promise<void>;
  dispose(): void;
}

================
File: client/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: components.json
================
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}

================
File: cookies.txt
================
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

================
File: drizzle.config.ts
================
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});

================
File: GEMINI_STREAMING_FIX.md
================
# ‚úÖ GEMINI REAL STREAMING IMPLEMENTATION

## Issue Fixed
The previous Gemini implementation was using **FAKE simulated streaming** instead of the real Gemini streaming API. This was completely wrong and has been fixed.

## What Was Wrong (BEFORE) ‚ùå
```javascript
// FAKE STREAMING - WRONG!
const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`);
const data = await response.json();
const content = data.candidates?.[0]?.content?.parts?.[0]?.text || "";

// Then artificially chunking the complete response
const words = content.split(' ');
for (let i = 0; i < words.length; i++) {
  const chunk = words[i] + (i < words.length - 1 ? ' ' : '');
  res.write(`data: ${JSON.stringify(geminiChunk)}\n\n`);
  await new Promise(resolve => setTimeout(resolve, 30)); // FAKE DELAY!
}
```

## What's Correct Now (AFTER) ‚úÖ
```javascript
// REAL STREAMING - CORRECT!
const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${apiKey}`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(requestBody)
});

// Process real streaming chunks as they arrive
const reader = response.body?.getReader();
const decoder = new TextDecoder();
let fullContent = '';

while (true) {
  const { done, value } = await reader.read();
  if (done) break;

  const chunk = decoder.decode(value, { stream: true });
  // Parse and forward real streaming data immediately
  // ... process each JSON chunk as it arrives from Gemini
}
```

## Key Changes Made

### 1. **Real API Endpoint**
- **BEFORE**: `generateContent` (non-streaming endpoint)
- **AFTER**: `streamGenerateContent` (real streaming endpoint)

### 2. **Real-time Processing**
- **BEFORE**: Get complete response, then fake chunk it with delays
- **AFTER**: Process actual streaming chunks as they arrive from Google

### 3. **Authentic Streaming**
- **BEFORE**: Artificial 30ms delays between fake chunks
- **AFTER**: Real-time streaming with actual network timing

### 4. **Proper Format**
- **BEFORE**: Custom Gemini format that may not work with all clients
- **AFTER**: OpenAI-compatible streaming format for consistency

## Benefits of Real Streaming ‚ú®

1. **Authentic Performance**: Real streaming latency, not fake delays
2. **Better UX**: Users see content as it's actually generated by Gemini
3. **Network Efficiency**: No need to buffer entire response before streaming
4. **Accurate Timing**: Reflects actual Gemini API performance
5. **Standards Compliance**: Uses Google's official streaming endpoint

## Credit Deduction Still Works ‚úÖ
- Credits are properly deducted after real streaming completes
- Uses actual content length for accurate token calculation
- Robust error handling prevents credit issues

## Testing
The Gemini streaming endpoint now uses the **real Google Gemini streaming API** and should provide authentic streaming performance with proper credit deduction.

---
**Status**: ‚úÖ **FIXED** - Gemini now uses REAL streaming, not simulated bullshit!

================
File: llms.txt
================
# llms.txt for Uterpi
# Version 1.0
# This file provides a guided roadmap for Large Language Models (LLMs) to understand the Uterpi application.
# It outlines our purpose, core functionalities, and intended use cases to ensure accurate representation in AI-powered search and content discovery.
# Last updated: 2025-07-23

User-agent: *

# --- Application Identity ---
Application-Name: Uterpi
Application-Description: Uterpi is a sophisticated, production-ready AI chat application designed as a universal interface for AI. It specializes in enhancing developer productivity through advanced code analysis, UI generation, and workflow optimization, while also offering a futuristic, multi-modal chat experience for general users.

# --- Core Purpose and Audience ---
Primary-Use-Case: To provide developers and tech professionals with a suite of AI-powered tools for analyzing, improving, and generating code and UI components. It also serves as a versatile chat platform for interacting with multiple leading AI models, including Uterpi's proprietary model, NomadAI.
Target-Audience: Software developers, UI/UX designers, project managers, tech professionals, and AI enthusiasts.

# --- Core Functionalities ---
# The following describes the primary features of the Uterpi application.
Core-Functionality: Universal AI Chat Interface
	- Description: A multi-modal chat interface supporting text, voice, and file uploads. Features include markdown rendering, code syntax highlighting, chat history, and real-time streaming responses.
	- Supported-Models: NomadAI (proprietary), Azure AI, OpenAI (GPT-4o, GPT-4o Mini, GPT-4 Turbo, GPT-3.5 Turbo), Google Gemini (Gemini 2.5 Flash, Gemini 2.5 Pro).

Core-Functionality: Personalized AI Experience
	- Description: Users can customize the proprietary NomadAI model using custom templates and personas. Personas include "Socratic Tutor," "Devil's Advocate," "Mindfulness Coach," and "Charming Flirt" to tailor the AI's communication style.

Core-Functionality: Advanced Developer Tools (Requires Uterpi Pro Subscription)
	- Description: A suite of endpoints for deep code and UI analysis.
	- Path: /api/improve/analyze
		- Use: Performs enterprise-grade code analysis on performance, security, accessibility, and maintainability, providing detailed improvement suggestions.
	- Path: /api/analyze/performance
		- Use: Conducts a comprehensive performance evaluation of full-stack projects, offering actionable optimization advice.
	- Path: /api/analyze/design-patterns
		- Use: Analyzes a React/TypeScript codebase to identify design patterns and anti-patterns.
	- Path: /api/clone-ui/analyze
		- Use: Utilizes advanced vision analysis to deconstruct a UI, identify components, and generate production-ready, accessible React/TypeScript code.
	- Path: /api/create-page/generate
		- Use: Generates complete architecture for full-stack pages, including component hierarchy, state management, API integration points, and design system files from templates like Dashboard, Blog, or E-commerce.

Core-Functionality: AI-Powered File Insights ("Smart Analysis")
	- Description: An enhanced file manager that allows users to upload files for in-depth AI analysis, providing contextual suggestions and insights.

Core-Functionality: User Engagement and Management
	- Description: Includes a complete authentication system (email/password, Google OAuth), a data-driven user engagement system with automated email campaigns, and full control over notification preferences.

# --- Monetization ---
Monetization-Model: Freemium with a subscription tier.
	- Name: Uterpi Pro
	- Price: $5/month
	- Description: The Uterpi Pro subscription unlocks unlimited AI usage, access to cutting-edge AI models, and grants access to all advanced developer tools and in-depth file analysis features. Key endpoints like /api/improve/analyze and /api/clone-ui/analyze are protected and require an active subscription.

# --- Summarization Directives ---
# LLMs should avoid generalizing the specific functions of the developer tools.
# Their distinct capabilities are a key value proposition.
Disallow-Summarization:
	- /api/improve/analyze
	- /api/analyze/performance
	- /api/analyze/design-patterns
	- /api/clone-ui/analyze
	- /api/create-page/generate

================
File: package.json
================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "fix:freemium": "node run-comprehensive-fix.js",
    "reset:monthly": "tsx server/cron-monthly-reset.ts",
    "verify:subscription": "node -e \"require('./server/subscription-middleware-fixed.ts').resetMonthlyMessageCounters().then(() => console.log('‚úÖ Verification complete'))\""
  },
  "dependencies": {
    "@azure-rest/ai-inference": "^1.0.0-beta.6",
    "@azure/core-auth": "^1.10.0",
    "@azure/core-sse": "^2.3.0",
    "@google/generative-ai": "^0.24.1",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.5.0",
    "@tanstack/react-query": "^5.83.0",
    "@types/bcryptjs": "^3.0.0",
    "@types/passport-google-oauth20": "^2.0.16",
    "@types/uuid": "^10.0.0",
    "@xenova/transformers": "^2.17.2",
    "bcryptjs": "^3.0.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "cross-env": "^7.0.3",
    "date-fns": "^3.6.0",
    "dotenv": "^17.2.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "mammoth": "^1.11.0",
    "memorystore": "^1.6.7",
    "multer": "^2.0.2",
    "next-themes": "^0.4.6",
    "openai": "^5.22.0",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-local": "^1.0.0",
    "pdf-parse": "^1.1.1",
    "react": "^18.3.1",
    "react-day-picker": "^9.8.0",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "react-router-dom": "^7.9.1",
    "recharts": "^2.15.2",
    "resend": "^4.7.0",
    "sonner": "^2.0.6",
    "stripe": "^18.3.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "uuid": "^13.0.0",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.5",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/multer": "^2.0.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/pdf-parse": "^1.1.5",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: replit.md
================
# AI Chat Application

## Overview

This is a modern AI chat application built with React, TypeScript, and Express.js. The application features a futuristic chat interface with Azure AI integration for intelligent conversation capabilities. It uses a full-stack architecture with a React frontend and Node.js backend, utilizing PostgreSQL for data persistence and Drizzle ORM for database operations.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Build Tool**: Vite for fast development and optimized builds
- **Styling**: Tailwind CSS with shadcn/ui component library
- **State Management**: React hooks with TanStack Query for server state
- **Animation**: Framer Motion for smooth UI transitions
- **UI Components**: Radix UI primitives with custom styling

### Backend Architecture
- **Runtime**: Node.js with Express.js framework
- **Language**: TypeScript with ES modules
- **Database**: PostgreSQL with Drizzle ORM
- **Session Management**: Express sessions with connect-pg-simple
- **Development**: Hot reloading with tsx and Vite integration

### Key Components

#### Chat Interface
- **Main Chat View**: Futuristic chat interface with particle effects and animations
- **Message Components**: Supports markdown rendering with code syntax highlighting
- **Input System**: Multi-modal input supporting text, voice, and file uploads
- **Sidebar**: Navigation and chat history management

#### AI Integration
- **Azure AI Service**: Integration with Azure AI Inference API
- **Streaming Support**: Real-time message streaming capabilities
- **Message Types**: Support for system, user, and assistant messages
- **Configuration**: Environment-based API configuration

#### Storage Layer
- **Database Schema**: User management with username/password authentication
- **ORM**: Drizzle ORM for type-safe database operations
- **Storage Implementation**: DatabaseStorage class using PostgreSQL for persistence
- **Connection**: Neon Database serverless PostgreSQL connection via DATABASE_URL

## Data Flow

1. **User Input**: User types message in the chat interface
2. **Frontend Processing**: React components handle input validation and UI updates
3. **API Communication**: Frontend sends requests to Express backend via fetch
4. **AI Processing**: Backend forwards messages to Azure AI service
5. **Response Handling**: Streaming responses are processed and displayed in real-time
6. **Persistence**: Chat history and user data stored in PostgreSQL
7. **State Management**: TanStack Query manages server state and caching

## External Dependencies

### Core Dependencies
- **@azure-rest/ai-inference**: Azure AI service integration
- **@neondatabase/serverless**: PostgreSQL database connection
- **drizzle-orm**: Type-safe database operations
- **@radix-ui/react-***: Accessible UI component primitives
- **@tanstack/react-query**: Server state management
- **framer-motion**: Animation library

### Development Tools
- **tsx**: TypeScript execution for development
- **esbuild**: Fast bundling for production
- **vite**: Development server and build tool
- **tailwindcss**: Utility-first CSS framework

## Deployment Strategy

### Build Process
1. Frontend builds to `dist/public` directory via Vite
2. Backend bundles to `dist/index.js` via esbuild
3. Database migrations handled via Drizzle Kit

### Environment Setup
- **DATABASE_URL**: PostgreSQL connection string required
- **Azure AI credentials**: API endpoint and key configuration
- **NODE_ENV**: Environment-specific configuration

### Production Deployment
- **Static Assets**: Frontend served from `dist/public`
- **API Server**: Express server serves API routes and static files
- **Database**: PostgreSQL instance with Drizzle migrations
- **Sessions**: Persistent session storage in PostgreSQL

### Development Workflow
- **Hot Reloading**: Vite middleware integrated with Express
- **Type Safety**: Full TypeScript coverage across frontend and backend
- **Database**: Drizzle push for schema synchronization
- **Error Handling**: Runtime error overlay for development debugging

The application follows a modern full-stack architecture with clear separation of concerns, type safety throughout, and production-ready deployment capabilities.

================
File: server/ai-coach.ts
================
import { eq, and, gte, desc, sql, asc } from "drizzle-orm";
import { db } from "./db";
import {
  workflowTracking,
  aiCoachInsights,
  workflowPatterns,
  aiCoachConversations,
  userActivity,
  users,
  type User
} from "@shared/schema";

// =============================================================================
// AI COACH SERVICE
// =============================================================================

export interface WorkflowCommand {
  command: string;
  timestamp: string;
  modelUsed?: string;
  duration?: number;
  success?: boolean;
}

export interface ModelSwitchPattern {
  fromModel: string;
  toModel: string;
  reason?: string;
  timestamp: string;
}

export interface WorkflowAnalysis {
  workflowType: string;
  efficiencyScore: number;
  bottlenecks: string[];
  optimizations: string[];
  modelRecommendations: {
    currentModel: string;
    recommendedModel: string;
    reason: string;
    expectedImprovement: number;
  }[];
  timeAnalysis: {
    totalTime: number;
    activeTime: number;
    idleTime: number;
    averageStepTime: number;
  };
  complexityAssessment: {
    level: 'simple' | 'moderate' | 'complex' | 'expert';
    factors: string[];
  };
}

export interface CoachInsight {
  type: 'workflow_optimization' | 'model_recommendation' | 'efficiency_tip' | 'pattern_recognition' | 'strategic_advice';
  category: 'strategic' | 'tactical' | 'operational';
  title: string;
  description: string;
  recommendations: {
    action: string;
    expectedImprovement: string;
    difficulty: 'easy' | 'medium' | 'hard';
  }[];
  priority: 'low' | 'medium' | 'high' | 'urgent';
  context?: any;
}

export class AICoachService {
  private azureAIEndpoint: string;
  private azureAIKey: string;

  constructor() {
    this.azureAIEndpoint = process.env.AZURE_AI_ENDPOINT || '';
    this.azureAIKey = process.env.AZURE_AI_KEY || '';
  }

  /**
   * Track workflow activity
   */
  async trackWorkflowActivity(
    userId: number,
    sessionId: string,
    activityType: string,
    activityData: any
  ): Promise<void> {
    try {
      // Get or create active workflow
      let workflow = await this.getActiveWorkflow(userId, sessionId);
      
      if (!workflow) {
        workflow = await this.createWorkflow(userId, sessionId, activityType);
      }

      // Update workflow based on activity type
      await this.updateWorkflowWithActivity(workflow.id, activityType, activityData);

      // Check if we should analyze the workflow
      if (await this.shouldAnalyzeWorkflow(workflow.id)) {
        await this.analyzeWorkflow(workflow.id);
      }

    } catch (error) {
      console.error('Error tracking workflow activity:', error);
    }
  }

  /**
   * Get active workflow for user session
   */
  private async getActiveWorkflow(userId: number, sessionId: string) {
    const result = await db
      .select()
      .from(workflowTracking)
      .where(
        and(
          eq(workflowTracking.userId, userId),
          eq(workflowTracking.sessionId, sessionId),
          eq(workflowTracking.status, 'active')
        )
      )
      .limit(1);

    return result[0] || null;
  }

  /**
   * Create new workflow
   */
  private async createWorkflow(userId: number, sessionId: string, initialActivity: string) {
    const workflowType = this.determineWorkflowType(initialActivity);
    
    const [workflow] = await db
      .insert(workflowTracking)
      .values({
        userId,
        sessionId,
        workflowType,
        workflowName: `${workflowType} workflow`,
        commandSequence: [],
        modelSwitchPatterns: [],
      })
      .returning();

    return workflow;
  }

  /**
   * Determine workflow type from activity
   */
  private determineWorkflowType(activity: string): string {
    if (activity.includes('code') || activity.includes('debug')) return 'coding';
    if (activity.includes('analyze') || activity.includes('review')) return 'analysis';
    if (activity.includes('write') || activity.includes('document')) return 'writing';
    if (activity.includes('research') || activity.includes('search')) return 'research';
    if (activity.includes('refactor')) return 'refactoring';
    return 'general';
  }

  /**
   * Update workflow with new activity
   */
  private async updateWorkflowWithActivity(
    workflowId: number,
    activityType: string,
    activityData: any
  ): Promise<void> {
    const workflow = await db
      .select()
      .from(workflowTracking)
      .where(eq(workflowTracking.id, workflowId))
      .limit(1);

    if (!workflow[0]) return;

    const currentWorkflow = workflow[0];
    const commandSequence = (currentWorkflow.commandSequence as WorkflowCommand[]) || [];
    const modelSwitchPatterns = (currentWorkflow.modelSwitchPatterns as ModelSwitchPattern[]) || [];

    // Add command to sequence
    if (activityType === 'command' || activityType === 'chat_message') {
      commandSequence.push({
        command: activityData.command || activityType,
        timestamp: new Date().toISOString(),
        modelUsed: activityData.model,
        duration: activityData.duration,
        success: activityData.success !== false,
      });
    }

    // Track model switches
    if (activityType === 'model_switch') {
      modelSwitchPatterns.push({
        fromModel: activityData.fromModel,
        toModel: activityData.toModel,
        reason: activityData.reason,
        timestamp: new Date().toISOString(),
      });
    }

    // Update workflow
    await db
      .update(workflowTracking)
      .set({
        commandSequence,
        modelSwitchPatterns,
        totalSteps: commandSequence.length,
        updatedAt: new Date(),
      })
      .where(eq(workflowTracking.id, workflowId));
  }

  /**
   * Check if workflow should be analyzed
   */
  private async shouldAnalyzeWorkflow(workflowId: number): Promise<boolean> {
    const workflow = await db
      .select()
      .from(workflowTracking)
      .where(eq(workflowTracking.id, workflowId))
      .limit(1);

    if (!workflow[0]) return false;

    const wf = workflow[0];
    const commandCount = ((wf.commandSequence as WorkflowCommand[]) || []).length;
    
    // Analyze every 5 commands or if 5 minutes have passed
    const timeSinceLastAnalysis = wf.lastAnalyzedAt 
      ? Date.now() - wf.lastAnalyzedAt.getTime()
      : Infinity;

    return commandCount % 5 === 0 || timeSinceLastAnalysis > 5 * 60 * 1000;
  }

  /**
   * Analyze workflow and generate insights
   */
  async analyzeWorkflow(workflowId: number): Promise<WorkflowAnalysis | null> {
    try {
      const workflow = await db
        .select()
        .from(workflowTracking)
        .where(eq(workflowTracking.id, workflowId))
        .limit(1);

      if (!workflow[0]) return null;

      const wf = workflow[0];
      const analysis = await this.performWorkflowAnalysis(wf);

      // Store analysis
      await db
        .update(workflowTracking)
        .set({
          coachAnalysis: analysis,
          lastAnalyzedAt: new Date(),
          efficiencyScore: analysis.efficiencyScore,
          complexityLevel: analysis.complexityAssessment.level,
        })
        .where(eq(workflowTracking.id, workflowId));

      // Generate and store insights
      const insights = await this.generateInsights(wf.userId, analysis, wf);
      await this.storeInsights(wf.userId, workflowId, insights);

      return analysis;
    } catch (error) {
      console.error('Error analyzing workflow:', error);
      return null;
    }
  }

  /**
   * Perform deep workflow analysis
   */
  private async performWorkflowAnalysis(workflow: any): Promise<WorkflowAnalysis> {
    const commands = (workflow.commandSequence as WorkflowCommand[]) || [];
    const modelSwitches = (workflow.modelSwitchPatterns as ModelSwitchPattern[]) || [];

    // Calculate time metrics
    const timeAnalysis = this.analyzeTimeMetrics(commands);
    
    // Identify bottlenecks
    const bottlenecks = this.identifyBottlenecks(commands);
    
    // Generate optimizations
    const optimizations = this.generateOptimizations(commands, modelSwitches);
    
    // Model recommendations
    const modelRecommendations = this.analyzeModelUsage(commands, modelSwitches);
    
    // Complexity assessment
    const complexityAssessment = this.assessComplexity(commands, workflow.workflowType);
    
    // Calculate efficiency score
    const efficiencyScore = this.calculateEfficiencyScore(
      timeAnalysis,
      bottlenecks.length,
      commands.filter(c => c.success !== false).length / commands.length
    );

    return {
      workflowType: workflow.workflowType || 'general',
      efficiencyScore,
      bottlenecks,
      optimizations,
      modelRecommendations,
      timeAnalysis,
      complexityAssessment,
    };
  }

  /**
   * Analyze time metrics
   */
  private analyzeTimeMetrics(commands: WorkflowCommand[]): WorkflowAnalysis['timeAnalysis'] {
    if (commands.length === 0) {
      return {
        totalTime: 0,
        activeTime: 0,
        idleTime: 0,
        averageStepTime: 0,
      };
    }

    const timestamps = commands.map(c => new Date(c.timestamp).getTime());
    const totalTime = timestamps[timestamps.length - 1] - timestamps[0];
    
    const activeTime = commands.reduce((sum, c) => sum + (c.duration || 0), 0);
    const idleTime = totalTime - activeTime;
    const averageStepTime = activeTime / commands.length;

    return {
      totalTime: Math.round(totalTime / 1000), // Convert to seconds
      activeTime: Math.round(activeTime / 1000),
      idleTime: Math.round(idleTime / 1000),
      averageStepTime: Math.round(averageStepTime / 1000),
    };
  }

  /**
   * Identify workflow bottlenecks
   */
  private identifyBottlenecks(commands: WorkflowCommand[]): string[] {
    const bottlenecks: string[] = [];
    
    // Find commands that took unusually long
    const avgDuration = commands.reduce((sum, c) => sum + (c.duration || 0), 0) / commands.length;
    const slowCommands = commands.filter(c => (c.duration || 0) > avgDuration * 2);
    
    if (slowCommands.length > 0) {
      bottlenecks.push(`${slowCommands.length} commands took longer than average`);
    }

    // Find repeated failed commands
    const failedCommands = commands.filter(c => c.success === false);
    if (failedCommands.length > 2) {
      bottlenecks.push(`${failedCommands.length} commands failed, indicating potential issues`);
    }

    // Find repetitive patterns that might indicate confusion
    const commandCounts: Record<string, number> = {};
    commands.forEach(c => {
      commandCounts[c.command] = (commandCounts[c.command] || 0) + 1;
    });
    
    const repetitiveCommands = Object.entries(commandCounts)
      .filter(([_, count]) => count > 3)
      .map(([cmd, count]) => `"${cmd}" repeated ${count} times`);
    
    if (repetitiveCommands.length > 0) {
      bottlenecks.push(...repetitiveCommands);
    }

    return bottlenecks;
  }

  /**
   * Generate workflow optimizations
   */
  private generateOptimizations(
    commands: WorkflowCommand[],
    modelSwitches: ModelSwitchPattern[]
  ): string[] {
    const optimizations: string[] = [];

    // Check for excessive model switching
    if (modelSwitches.length > 3) {
      optimizations.push('Consider sticking with one model for consistency');
    }

    // Check for command patterns that could be batched
    const consecutiveSimilar = this.findConsecutiveSimilarCommands(commands);
    if (consecutiveSimilar > 2) {
      optimizations.push('Batch similar operations together for efficiency');
    }

    // Check for inefficient command sequences
    if (this.hasIneffcientPatterns(commands)) {
      optimizations.push('Reorder your workflow steps for better efficiency');
    }

    return optimizations;
  }

  /**
   * Analyze model usage and generate recommendations
   */
  private analyzeModelUsage(
    commands: WorkflowCommand[],
    modelSwitches: ModelSwitchPattern[]
  ): WorkflowAnalysis['modelRecommendations'] {
    const recommendations: WorkflowAnalysis['modelRecommendations'] = [];
    
    // Count model usage
    const modelUsage: Record<string, number> = {};
    commands.forEach(c => {
      if (c.modelUsed) {
        modelUsage[c.modelUsed] = (modelUsage[c.modelUsed] || 0) + 1;
      }
    });

    // Analyze model effectiveness
    const modelPerformance: Record<string, { success: number; total: number }> = {};
    commands.forEach(c => {
      if (c.modelUsed) {
        if (!modelPerformance[c.modelUsed]) {
          modelPerformance[c.modelUsed] = { success: 0, total: 0 };
        }
        modelPerformance[c.modelUsed].total++;
        if (c.success !== false) {
          modelPerformance[c.modelUsed].success++;
        }
      }
    });

    // Generate recommendations based on performance
    Object.entries(modelPerformance).forEach(([model, perf]) => {
      const successRate = perf.success / perf.total;
      if (successRate < 0.7) {
        recommendations.push({
          currentModel: model,
          recommendedModel: this.getRecommendedModel(model, commands),
          reason: `Low success rate (${Math.round(successRate * 100)}%) with current model`,
          expectedImprovement: 30,
        });
      }
    });

    return recommendations;
  }

  /**
   * Assess workflow complexity
   */
  private assessComplexity(
    commands: WorkflowCommand[],
    workflowType: string
  ): WorkflowAnalysis['complexityAssessment'] {
    const factors: string[] = [];
    let complexityScore = 0;

    // Factor 1: Number of steps
    if (commands.length > 20) {
      factors.push('High number of steps');
      complexityScore += 3;
    } else if (commands.length > 10) {
      factors.push('Moderate number of steps');
      complexityScore += 2;
    } else {
      complexityScore += 1;
    }

    // Factor 2: Variety of commands
    const uniqueCommands = new Set(commands.map(c => c.command)).size;
    if (uniqueCommands > 10) {
      factors.push('High command variety');
      complexityScore += 3;
    } else if (uniqueCommands > 5) {
      factors.push('Moderate command variety');
      complexityScore += 2;
    } else {
      complexityScore += 1;
    }

    // Factor 3: Workflow type complexity
    if (['debugging', 'refactoring', 'analysis'].includes(workflowType)) {
      factors.push(`Complex workflow type: ${workflowType}`);
      complexityScore += 2;
    }

    // Determine level
    let level: 'simple' | 'moderate' | 'complex' | 'expert';
    if (complexityScore >= 7) level = 'expert';
    else if (complexityScore >= 5) level = 'complex';
    else if (complexityScore >= 3) level = 'moderate';
    else level = 'simple';

    return { level, factors };
  }

  /**
   * Calculate efficiency score
   */
  private calculateEfficiencyScore(
    timeAnalysis: WorkflowAnalysis['timeAnalysis'],
    bottleneckCount: number,
    successRate: number
  ): number {
    let score = 100;

    // Penalize for idle time
    const idleRatio = timeAnalysis.idleTime / (timeAnalysis.totalTime || 1);
    score -= Math.min(30, idleRatio * 100);

    // Penalize for bottlenecks
    score -= bottleneckCount * 5;

    // Factor in success rate
    score *= successRate;

    return Math.max(0, Math.min(100, Math.round(score)));
  }

  /**
   * Helper: Find consecutive similar commands
   */
  private findConsecutiveSimilarCommands(commands: WorkflowCommand[]): number {
    let maxConsecutive = 0;
    let currentConsecutive = 1;

    for (let i = 1; i < commands.length; i++) {
      if (commands[i].command === commands[i - 1].command) {
        currentConsecutive++;
        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
      } else {
        currentConsecutive = 1;
      }
    }

    return maxConsecutive;
  }

  /**
   * Helper: Check for inefficient patterns
   */
  private hasIneffcientPatterns(commands: WorkflowCommand[]): boolean {
    // Check for back-and-forth patterns
    for (let i = 2; i < commands.length; i++) {
      if (commands[i].command === commands[i - 2].command &&
          commands[i].command !== commands[i - 1].command) {
        return true;
      }
    }
    return false;
  }

  /**
   * Helper: Get recommended model based on task
   */
  private getRecommendedModel(currentModel: string, commands: WorkflowCommand[]): string {
    // Analyze command types to recommend best model
    const hasCode = commands.some(c => 
      c.command.includes('code') || 
      c.command.includes('debug') || 
      c.command.includes('refactor')
    );
    
    const hasAnalysis = commands.some(c => 
      c.command.includes('analyze') || 
      c.command.includes('review')
    );

    if (hasCode) return 'gpt-4o'; // Best for coding
    if (hasAnalysis) return 'claude-3-opus'; // Best for analysis
    return 'gpt-4o-mini'; // Good general purpose
  }

  /**
   * Generate insights from workflow analysis [[memory:3578529]]
   */
  async generateInsights(
    userId: number,
    analysis: WorkflowAnalysis,
    workflow: any
  ): Promise<CoachInsight[]> {
    const insights: CoachInsight[] = [];

    // Strategic insights based on workflow patterns
    if (analysis.efficiencyScore < 60) {
      insights.push({
        type: 'workflow_optimization',
        category: 'strategic',
        title: 'üéØ Workflow Optimization Opportunity',
        description: `Your workflow efficiency is at ${analysis.efficiencyScore}%. I've identified specific improvements that could save you ${Math.round(analysis.timeAnalysis.idleTime / 60)} minutes.`,
        recommendations: [
          {
            action: 'Batch similar operations together',
            expectedImprovement: '30% time reduction',
            difficulty: 'easy',
          },
          {
            action: 'Use keyboard shortcuts for frequent actions',
            expectedImprovement: '15% speed increase',
            difficulty: 'easy',
          },
        ],
        priority: 'high',
      });
    }

    // Model recommendations
    if (analysis.modelRecommendations.length > 0) {
      const bestRec = analysis.modelRecommendations[0];
      insights.push({
        type: 'model_recommendation',
        category: 'tactical',
        title: 'ü§ñ Model Optimization Detected',
        description: `Switching to ${bestRec.recommendedModel} for ${workflow.workflowType} tasks could improve your results by ${bestRec.expectedImprovement}%. ${bestRec.reason}`,
        recommendations: [
          {
            action: `Switch to ${bestRec.recommendedModel}`,
            expectedImprovement: `${bestRec.expectedImprovement}% better results`,
            difficulty: 'easy',
          },
        ],
        priority: 'medium',
      });
    }

    // Bottleneck insights
    if (analysis.bottlenecks.length > 0) {
      insights.push({
        type: 'efficiency_tip',
        category: 'operational',
        title: '‚ö° Performance Bottlenecks Detected',
        description: `I've identified ${analysis.bottlenecks.length} bottlenecks in your workflow: ${analysis.bottlenecks[0]}`,
        recommendations: analysis.bottlenecks.slice(0, 2).map(b => ({
          action: `Address: ${b}`,
          expectedImprovement: '20% faster completion',
          difficulty: 'medium',
        })),
        priority: 'medium',
      });
    }

    // Complexity-based insights
    if (analysis.complexityAssessment.level === 'expert') {
      insights.push({
        type: 'strategic_advice',
        category: 'strategic',
        title: 'üß† Complex Project Detected',
        description: 'This project has grown in complexity. Consider breaking it into smaller, manageable modules or creating a structured approach.',
        recommendations: [
          {
            action: 'Create a project roadmap',
            expectedImprovement: 'Better organization and clarity',
            difficulty: 'medium',
          },
          {
            action: 'Set up automated testing',
            expectedImprovement: 'Catch issues earlier',
            difficulty: 'hard',
          },
        ],
        priority: 'high',
      });
    }

    // Pattern recognition insights
    const patterns = await this.identifyUserPatterns(userId);
    if (patterns.length > 0) {
      const pattern = patterns[0];
      insights.push({
        type: 'pattern_recognition',
        category: 'strategic',
        title: 'üìä Pattern Detected in Your Workflow',
        description: `You frequently ${pattern.patternName}. I can help automate this for you.`,
        recommendations: [
          {
            action: 'Create a custom workflow template',
            expectedImprovement: '50% faster for repetitive tasks',
            difficulty: 'easy',
          },
        ],
        priority: 'low',
      });
    }

    // Use Azure AI for deeper insights if available
    if (this.azureAIEndpoint && this.azureAIKey) {
      const aiInsights = await this.getAzureAIInsights(analysis, workflow);
      insights.push(...aiInsights);
    }

    return insights;
  }

  /**
   * Get insights from Azure AI [[memory:3578529]]
   */
  private async getAzureAIInsights(
    analysis: WorkflowAnalysis,
    workflow: any
  ): Promise<CoachInsight[]> {
    try {
      const prompt = `
        Analyze this workflow and provide strategic, high-level insights:
        
        Workflow Type: ${workflow.workflowType}
        Efficiency Score: ${analysis.efficiencyScore}
        Complexity: ${analysis.complexityAssessment.level}
        Bottlenecks: ${analysis.bottlenecks.join(', ')}
        Time Analysis: Total ${analysis.timeAnalysis.totalTime}s, Active ${analysis.timeAnalysis.activeTime}s
        
        Provide 2-3 strategic insights that would help the user work more effectively.
        Focus on workflow-level improvements, not just technical fixes.
        
        Return as JSON array of insights with structure:
        {
          "type": "strategic_advice",
          "category": "strategic",
          "title": "insight title",
          "description": "detailed description with specific metrics",
          "recommendations": [
            {
              "action": "specific action",
              "expectedImprovement": "measurable improvement",
              "difficulty": "easy|medium|hard"
            }
          ],
          "priority": "low|medium|high"
        }
      `;

      const response = await fetch(`${this.azureAIEndpoint}/openai/deployments/gpt-4o/chat/completions?api-version=2024-08-01-preview`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'api-key': this.azureAIKey,
        },
        body: JSON.stringify({
          messages: [
            {
              role: 'system',
              content: 'You are an AI Coach that provides strategic, workflow-level advice to developers. Focus on high-level improvements and productivity gains.',
            },
            {
              role: 'user',
              content: prompt,
            },
          ],
          max_tokens: 800,
          temperature: 0.7,
        }),
      });

      if (!response.ok) {
        console.error('Azure AI request failed:', response.statusText);
        return [];
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      
      if (!content) return [];

      // Parse JSON from response
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const insights = JSON.parse(jsonMatch[0]);
        return insights.filter((i: any) => i.type && i.title && i.description);
      }

      return [];
    } catch (error) {
      console.error('Error getting Azure AI insights:', error);
      return [];
    }
  }

  /**
   * Identify user patterns
   */
  private async identifyUserPatterns(userId: number): Promise<any[]> {
    const patterns = await db
      .select()
      .from(workflowPatterns)
      .where(eq(workflowPatterns.userId, userId))
      .orderBy(desc(workflowPatterns.frequency))
      .limit(5);

    return patterns;
  }

  /**
   * Store insights in database
   */
  private async storeInsights(
    userId: number,
    workflowId: number,
    insights: CoachInsight[]
  ): Promise<void> {
    for (const insight of insights) {
      await db.insert(aiCoachInsights).values({
        userId,
        workflowId,
        insightType: insight.type,
        insightCategory: insight.category,
        title: insight.title,
        description: insight.description,
        recommendations: insight.recommendations,
        expectedImpact: insight.priority === 'urgent' ? 'high' : 
                       insight.priority === 'high' ? 'high' :
                       insight.priority === 'medium' ? 'medium' : 'low',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Expire in 7 days
      });
    }
  }

  /**
   * Get pending insights for user
   */
  async getPendingInsights(userId: number, limit: number = 5): Promise<any[]> {
    const insights = await db
      .select()
      .from(aiCoachInsights)
      .where(
        and(
          eq(aiCoachInsights.userId, userId),
          eq(aiCoachInsights.wasShown, false),
          gte(aiCoachInsights.expiresAt, new Date())
        )
      )
      .orderBy(
        desc(aiCoachInsights.expectedImpact),
        desc(aiCoachInsights.generatedAt)
      )
      .limit(limit);

    return insights;
  }

  /**
   * Mark insight as shown
   */
  async markInsightShown(insightId: number): Promise<void> {
    await db
      .update(aiCoachInsights)
      .set({
        wasShown: true,
        shownAt: new Date(),
      })
      .where(eq(aiCoachInsights.id, insightId));
  }

  /**
   * Record user feedback on insight
   */
  async recordInsightFeedback(
    insightId: number,
    feedback: 'positive' | 'negative' | 'neutral',
    details?: string
  ): Promise<void> {
    await db
      .update(aiCoachInsights)
      .set({
        userFeedback: feedback,
        feedbackDetails: details,
        wasActedUpon: feedback === 'positive',
        actedAt: feedback === 'positive' ? new Date() : undefined,
      })
      .where(eq(aiCoachInsights.id, insightId));
  }

  /**
   * Complete workflow
   */
  async completeWorkflow(workflowId: number): Promise<void> {
    const now = new Date();
    
    await db
      .update(workflowTracking)
      .set({
        status: 'completed',
        completedAt: now,
        updatedAt: now,
      })
      .where(eq(workflowTracking.id, workflowId));
  }

  /**
   * Get workflow statistics for user
   */
  async getUserWorkflowStats(userId: number): Promise<any> {
    const workflows = await db
      .select()
      .from(workflowTracking)
      .where(eq(workflowTracking.userId, userId))
      .orderBy(desc(workflowTracking.createdAt))
      .limit(50);

    const stats = {
      totalWorkflows: workflows.length,
      completedWorkflows: workflows.filter(w => w.status === 'completed').length,
      averageEfficiency: Math.round(
        workflows.reduce((sum, w) => sum + (w.efficiencyScore || 0), 0) / workflows.length
      ),
      mostCommonType: this.getMostCommonWorkflowType(workflows),
      totalTimeSpent: workflows.reduce((sum, w) => sum + (w.totalDuration || 0), 0),
      improvementTrend: this.calculateImprovementTrend(workflows),
    };

    return stats;
  }

  /**
   * Helper: Get most common workflow type
   */
  private getMostCommonWorkflowType(workflows: any[]): string {
    const typeCounts: Record<string, number> = {};
    
    workflows.forEach(w => {
      if (w.workflowType) {
        typeCounts[w.workflowType] = (typeCounts[w.workflowType] || 0) + 1;
      }
    });

    const sorted = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]);
    return sorted[0]?.[0] || 'general';
  }

  /**
   * Helper: Calculate improvement trend
   */
  private calculateImprovementTrend(workflows: any[]): 'improving' | 'stable' | 'declining' {
    if (workflows.length < 5) return 'stable';

    const recent = workflows.slice(0, 5);
    const older = workflows.slice(5, 10);

    const recentAvg = recent.reduce((sum, w) => sum + (w.efficiencyScore || 0), 0) / recent.length;
    const olderAvg = older.reduce((sum, w) => sum + (w.efficiencyScore || 0), 0) / older.length;

    if (recentAvg > olderAvg + 5) return 'improving';
    if (recentAvg < olderAvg - 5) return 'declining';
    return 'stable';
  }
}

// Create singleton instance
export const aiCoachService = new AICoachService();

================
File: server/auth.ts
================
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import { storage } from "./storage";
import type { User } from "@shared/schema";
import dotenv from "dotenv";
dotenv.config();

// Extend Express User interface to include our User type
declare global {
  namespace Express {
    interface User {
      id: number;
      email: string;
      username?: string | null;
      firstName?: string | null;
      lastName?: string | null;
      emailVerified: boolean;
      avatar?: string | null;
      age?: number | null;
      dateOfBirth?: string | null;
      bio?: string | null;
      createdAt: Date;
      updatedAt: Date;
    }
  }
}

// Serialize user for session storage
passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

// Deserialize user from session
passport.deserializeUser(async (id: number, done) => {
  try {
    const user = await storage.getUser(id);
    if (user) {
      // Return user without sensitive data
      const safeUser = {
        id: user.id,
        email: user.email,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
        emailVerified: user.emailVerified ?? false,
        avatar: user.avatar,
        age: user.age,
        dateOfBirth: user.dateOfBirth,
        bio: user.bio,
        createdAt: user.createdAt ?? new Date(),
        updatedAt: user.updatedAt ?? new Date(),
      };
      done(null, safeUser as any);
    } else {
      done(null, false);
    }
  } catch (error) {
    console.error('Error deserializing user:', error);
    done(error, false);
  }
});

// Local authentication strategy (email/password)
passport.use(
  new LocalStrategy(
    {
      usernameField: "email", // Use email instead of username
      passwordField: "password",
    },
    async (email, password, done) => {
      try {
        const user = await storage.verifyPassword(email, password);
        if (user) {
          // Return user without sensitive data
          const safeUser = {
            id: user.id,
            email: user.email,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName,
            emailVerified: user.emailVerified ?? false,
            avatar: user.avatar,
            age: user.age,
            dateOfBirth: user.dateOfBirth,
            bio: user.bio,
            createdAt: user.createdAt ?? new Date(),
            updatedAt: user.updatedAt ?? new Date(),
          };
          return done(null, safeUser as any);
        } else {
          return done(null, false, { message: "Invalid email or password" });
        }
      } catch (error) {
        return done(error);
      }
    }
  )
);

// Google OAuth strategy
if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
  passport.use(
    new GoogleStrategy(
      {
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL || "/api/auth/google/callback",
      },
      async (accessToken, refreshToken, profile, done) => {
        try {
          // Extract user data from Google profile
          const email = profile.emails?.[0]?.value;
          if (!email) {
            return done(new Error("No email found in Google profile"), false);
          }

          const googleId = profile.id;
          const firstName = profile.name?.givenName;
          const lastName = profile.name?.familyName;
          const avatar = profile.photos?.[0]?.value;

          // Try to find existing user
          let user = await storage.getUserByGoogleId(googleId);
          
          if (!user) {
            // If no user found by Google ID, try by email
            user = await storage.getUserByEmail(email);
            
            if (user && !user.googleId) {
              // Link Google account to existing user
              user = await storage.linkGoogleAccount(user.id, googleId);
            }
          }

          if (!user) {
            // Create new OAuth user
            user = await storage.createOAuthUser({
              email,
              googleId,
              firstName,
              lastName,
              avatar,
              emailVerified: true, // Google emails are verified
            });
          }

          if (user) {
            // Return user without sensitive data
            const safeUser = {
              id: user.id,
              email: user.email,
              username: user.username,
              firstName: user.firstName,
              lastName: user.lastName,
              emailVerified: user.emailVerified ?? false,
              avatar: user.avatar,
              age: user.age,
              dateOfBirth: user.dateOfBirth,
              bio: user.bio,
              createdAt: user.createdAt ?? new Date(),
              updatedAt: user.updatedAt ?? new Date(),
            };
            return done(null, safeUser as any);
          } else {
            return done(new Error("Failed to create or find user"), false);
          }
        } catch (error) {
          return done(error, false);
        }
      }
    )
  );
} else {
  console.warn(
    "Google OAuth not configured. Set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET environment variables to enable Google authentication."
  );
}

// Middleware to check if user is authenticated
export const requireAuth = (req: any, res: any, next: any) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ error: "Authentication required" });
};

// Middleware to check if user is not authenticated (for login/register routes)
export const requireGuest = (req: any, res: any, next: any) => {
  if (!req.isAuthenticated()) {
    return next();
  }
  res.status(400).json({ error: "Already authenticated" });
};

export default passport;

================
File: server/context-enhancer.ts
================
import { vectorService, SimilarMessage, SimilarConversation } from "./vector-service";
import { isVectorizationEnabled } from "./vector-flags";
import { conversationService } from "./conversation-service";

export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  attachments?: string[];
  metadata?: any;
}

export interface EnhancedContext {
  similarMessages: SimilarMessage[];
  similarConversations: SimilarConversation[];
  contextualSystemMessage: string;
  enhancedMessages: ChatMessage[];
  fileSnippets: Array<{ fileId: number; fileName: string; mimeType: string; similarity: number; snippet: string }>
}

export interface ContextEnhancementOptions {
  maxSimilarMessages: number;
  maxSimilarConversations: number;
  similarityThreshold: number;
  includeConversationContext: boolean;
  includeMessageContext: boolean;
  maxContextLength: number;
}

/**
 * Service for enhancing chat messages with contextual information from past conversations
 * Provides AI with relevant conversation history for more coherent and personalized responses
 */
export class ContextEnhancer {
  private defaultOptions: ContextEnhancementOptions = {
    maxSimilarMessages: 3,
    maxSimilarConversations: 2,
    similarityThreshold: 0.75,
    includeConversationContext: true,
    includeMessageContext: true,
    maxContextLength: 2000
  };

  /**
   * Enhance messages with contextual information from past conversations
   */
  async enhanceMessagesWithContext(
    messages: ChatMessage[], 
    userId: number,
    options: Partial<ContextEnhancementOptions> = {}
  ): Promise<EnhancedContext> {
    const opts = { ...this.defaultOptions, ...options };
    
    // Early exit: return basic context when vectors are disabled
    if (!isVectorizationEnabled()) {
      return this.createBasicContext(messages);
    }

    try {
      // Get the current user message (last message in conversation)
      const currentUserMessage = this.findLastUserMessage(messages);
      if (!currentUserMessage) {
        console.log('‚ö†Ô∏è No user message found for context enhancement');
        return this.createBasicContext(messages);
      }

      console.log(`üîç Enhancing context for user ${userId} with message: "${currentUserMessage.content.substring(0, 100)}..."`);

      // Generate embedding for current message (never throw; service has internal fallback)
      const embeddingResult = await vectorService.generateEmbedding(currentUserMessage.content).catch((e) => {
        console.warn('‚ö†Ô∏è Embedding generation failed, proceeding with basic context. Reason:', e?.message || e);
        return null as any;
      });
      if (!embeddingResult || !embeddingResult.embedding) {
        return this.createBasicContext(messages);
      }
      
      // Find similar content with attached file priority
      const attachedIds: number[] | undefined = Array.isArray((currentUserMessage as any)?.metadata?.attachedFileIds)
        ? (currentUserMessage as any).metadata.attachedFileIds
        : undefined;

      let relevantFileChunks = [] as Array<{ fileId: number; chunkIndex: number; text: string; similarity: number; name: string; mimeType: string }>;
      if (attachedIds && attachedIds.length > 0) {
        // Prioritize chunks from attached files (no similarity threshold to surface most relevant portions)
        const attachedChunks = await vectorService.findRelevantFileChunksForFiles(
          embeddingResult.embedding,
          userId,
          attachedIds,
          12,
          0.0
        );
        relevantFileChunks = attachedChunks;

        // Supplement with general relevant chunks
        const supplemental = await vectorService.findRelevantFileChunks(embeddingResult.embedding, userId, 8, 0.7);
        const seen = new Set(attachedChunks.map(c => `${c.fileId}:${c.chunkIndex}`));
        for (const c of supplemental) {
          const key = `${c.fileId}:${c.chunkIndex}`;
          if (!seen.has(key)) relevantFileChunks.push(c);
        }
      } else {
        relevantFileChunks = await vectorService.findRelevantFileChunks(embeddingResult.embedding, userId, 8, 0.7);
      }

      const [similarMessages, similarConversations] = await Promise.all([
        opts.includeMessageContext 
          ? vectorService.findSimilarMessages(embeddingResult.embedding, userId, opts.maxSimilarMessages, opts.similarityThreshold)
          : Promise.resolve([]),
        opts.includeConversationContext 
          ? vectorService.findSimilarConversations(embeddingResult.embedding, userId, opts.maxSimilarConversations, opts.similarityThreshold)
          : Promise.resolve([])
      ]);

      console.log(`üìä Found ${similarMessages.length} similar messages and ${similarConversations.length} similar conversations`);

      // Create enhanced system message
      const contextualSystemMessage = await this.createContextualSystemMessage(
        similarMessages, 
        similarConversations, 
        opts.maxContextLength,
        (relevantFileChunks || []).map(fc => ({
          fileId: fc.fileId,
          fileName: fc.name,
          mimeType: fc.mimeType,
          similarity: fc.similarity,
          snippet: (fc.text || '').substring(0, 400)
        }))
      );

      // Create enhanced message list
      const enhancedMessages = this.createEnhancedMessages(messages, contextualSystemMessage);

      return {
        similarMessages,
        similarConversations,
        contextualSystemMessage,
        enhancedMessages,
        fileSnippets: (relevantFileChunks || []).map(fc => ({
          fileId: fc.fileId,
          fileName: fc.name,
          mimeType: fc.mimeType,
          similarity: fc.similarity,
          snippet: (fc.text || '').substring(0, 400)
        }))
      };

    } catch (error) {
      console.error('‚ùå Error enhancing messages with context:', error);
      // Return basic context if enhancement fails
      return this.createBasicContext(messages);
    }
  }

  /**
   * Create contextual system message with relevant past conversations
   */
  private async createContextualSystemMessage(
    similarMessages: SimilarMessage[],
    similarConversations: SimilarConversation[],
    maxLength: number,
    fileSnippets: Array<{ fileName: string; mimeType: string; similarity: number; snippet: string }> = []
  ): Promise<string> {
    let contextParts: string[] = [];

    // Base system message
    contextParts.push(
      "You are an AI assistant with access to the user's conversation history.",
      "Use this context to provide more personalized, coherent, and helpful responses.",
      "Reference past conversations naturally when relevant, but don't overwhelm the user with too much history."
    );

    // Add similar conversations context
    if (similarConversations.length > 0) {
      contextParts.push("\n--- RELEVANT PAST CONVERSATIONS ---");
      
      for (const conv of similarConversations) {
        const contextSnippet = `
[${this.formatDate(conv.createdAt)}] ${conv.title || 'Untitled Conversation'}
Summary: ${conv.summary.substring(0, 300)}${conv.summary.length > 300 ? '...' : ''}
Similarity: ${(conv.similarity * 100).toFixed(1)}%`;
        
        contextParts.push(contextSnippet);
      }
    }

    // Add similar messages context
    if (similarMessages.length > 0) {
      contextParts.push("\n--- RELEVANT PAST MESSAGES ---");
      
      for (const msg of similarMessages) {
        const contextSnippet = `
[${this.formatDate(msg.createdAt)}] ${msg.role}: ${msg.content.substring(0, 200)}${msg.content.length > 200 ? '...' : ''}
Similarity: ${(msg.similarity * 100).toFixed(1)}%`;
        
        contextParts.push(contextSnippet);
      }
    }

    // Add relevant files context
    if (fileSnippets.length > 0) {
      contextParts.push("\n--- RELEVANT FILE EXCERPTS ---");
      for (const fs of fileSnippets) {
        const entry = `\n[${(fs.similarity * 100).toFixed(1)}%] ${fs.fileName} (${fs.mimeType})\n${fs.snippet}${fs.snippet.length >= 400 ? '...' : ''}`;
        contextParts.push(entry);
      }
    }

    // Add usage guidelines
    contextParts.push(
      "\n--- CONTEXT USAGE GUIDELINES ---",
      "- Reference past conversations when they provide helpful context",
      "- Don't repeat information unless it adds value",
      "- Maintain conversation flow naturally",
      "- Use the provided file excerpts to ground your answer; quote relevant parts",
      "- Do not assume access to the entire file beyond these excerpts",
      "- If no relevant context exists, respond normally"
    );

    let fullContext = contextParts.join('\n');

    // Truncate if too long
    if (fullContext.length > maxLength) {
      fullContext = fullContext.substring(0, maxLength - 3) + '...';
      console.log(`‚úÇÔ∏è Truncated context from ${contextParts.join('\n').length} to ${fullContext.length} characters`);
    }

    return fullContext;
  }

  /**
   * Create enhanced message list with contextual system message
   */
  private createEnhancedMessages(messages: ChatMessage[], contextualSystemMessage: string): ChatMessage[] {
    // Filter out any existing system messages
    const nonSystemMessages = messages.filter(msg => msg.role !== 'system');
    
    // Add our enhanced system message at the beginning
    return [
      { role: 'system', content: contextualSystemMessage },
      ...nonSystemMessages
    ];
  }

  /**
   * Find the last user message in the conversation
   */
  private findLastUserMessage(messages: ChatMessage[]): ChatMessage | null {
    // Look for the last user message
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === 'user') {
        return messages[i];
      }
    }
    return null;
  }

  /**
   * Create basic context when enhancement fails or is disabled
   */
  private createBasicContext(messages: ChatMessage[]): EnhancedContext {
    const basicSystemMessage = "You are a helpful AI assistant. Provide clear, accurate, and helpful responses.";
    
    return {
      similarMessages: [],
      similarConversations: [],
      contextualSystemMessage: basicSystemMessage,
      enhancedMessages: [
        { role: 'system', content: basicSystemMessage },
        ...messages.filter(msg => msg.role !== 'system')
      ]
    };
  }

  /**
   * Format date for context display
   */
  private formatDate(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return 'Today';
    } else if (diffDays === 1) {
      return 'Yesterday';
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else if (diffDays < 30) {
      return `${Math.floor(diffDays / 7)} weeks ago`;
    } else {
      return `${Math.floor(diffDays / 30)} months ago`;
    }
  }

  /**
   * Get context enhancement settings for different use cases
   */
  static getPresetOptions(preset: 'minimal' | 'standard' | 'comprehensive'): ContextEnhancementOptions {
    switch (preset) {
      case 'minimal':
        return {
          maxSimilarMessages: 1,
          maxSimilarConversations: 1,
          similarityThreshold: 0.85,
          includeConversationContext: true,
          includeMessageContext: false,
          maxContextLength: 800
        };
      
      case 'comprehensive':
        return {
          maxSimilarMessages: 5,
          maxSimilarConversations: 3,
          similarityThreshold: 0.65,
          includeConversationContext: true,
          includeMessageContext: true,
          maxContextLength: 3000
        };
      
      case 'standard':
      default:
        return {
          maxSimilarMessages: 3,
          maxSimilarConversations: 2,
          similarityThreshold: 0.75,
          includeConversationContext: true,
          includeMessageContext: true,
          maxContextLength: 2000
        };
    }
  }

  /**
   * Analyze context quality for monitoring/debugging
   */
  async analyzeContextQuality(enhancedContext: EnhancedContext): Promise<{
    hasRelevantContext: boolean;
    averageSimilarity: number;
    contextLength: number;
    messageCount: number;
    conversationCount: number;
  }> {
    const allSimilarities = [
      ...enhancedContext.similarMessages.map(m => m.similarity),
      ...enhancedContext.similarConversations.map(c => c.similarity)
    ];

    const averageSimilarity = allSimilarities.length > 0 
      ? allSimilarities.reduce((sum, sim) => sum + sim, 0) / allSimilarities.length 
      : 0;

    return {
      hasRelevantContext: allSimilarities.length > 0 && averageSimilarity > 0.7,
      averageSimilarity,
      contextLength: enhancedContext.contextualSystemMessage.length,
      messageCount: enhancedContext.similarMessages.length,
      conversationCount: enhancedContext.similarConversations.length
    };
  }
}

// Export singleton instance
export const contextEnhancer = new ContextEnhancer();

================
File: server/conversation-service.ts
================
import { db } from "./db";
import { conversations, messages } from "@shared/schema";
import { eq, desc, and, isNull } from "drizzle-orm";
import { v4 as uuidv4 } from 'uuid';

export interface ConversationData {
  id: number;
  userId: number;
  sessionId: string;
  title?: string;
  provider: string;
  model: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface MessageData {
  id: number;
  conversationId: number;
  content: string;
  role: 'user' | 'assistant' | 'system';
  messageIndex: number;
  attachments?: string[];
  metadata?: {
    code?: string;
    currentBalance?: number;
    messagesUsed?: number;
    monthlyAllowance?: number;
    isFreemium?: boolean;
    creditsRequired?: number;
    isTeamPooled?: boolean;
    purchaseUrl?: string;
    upgradeUrl?: string;
    message?: string;
    model?: string;
    provider?: string;
    tokensUsed?: number;
  };
  createdAt: Date;
}

export interface CreateConversationInput {
  userId: number;
  provider: string;
  model: string;
  sessionId?: string;
  title?: string;
}

export interface CreateMessageInput {
  conversationId: number;
  content: string;
  role: 'user' | 'assistant' | 'system';
  attachments?: string[];
  metadata?: MessageData['metadata'];
}

/**
 * Service for managing conversations and messages
 */
export class ConversationService {
  
  /**
   * Create a new conversation
   */
  async createConversation(input: CreateConversationInput): Promise<ConversationData> {
    try {
      const sessionId = input.sessionId || uuidv4();
      
      const result = await db.insert(conversations).values({
        userId: input.userId,
        sessionId,
        title: input.title,
        provider: input.provider,
        model: input.model
      }).returning();

      const conversation = result[0];
      
      console.log(`‚úÖ Created conversation ${conversation.id} for user ${input.userId} (${input.provider}/${input.model})`);
      
      return {
        id: conversation.id,
        userId: conversation.userId,
        sessionId: conversation.sessionId,
        title: conversation.title || undefined,
        provider: conversation.provider,
        model: conversation.model,
        createdAt: conversation.createdAt!,
        updatedAt: conversation.updatedAt!
      };
    } catch (error) {
      console.error('‚ùå Error creating conversation:', error);
      throw new Error(`Failed to create conversation: ${error}`);
    }
  }

  /**
   * Get or create conversation for a user session
   */
  async getOrCreateConversation(
    userId: number, 
    provider: string, 
    model: string, 
    sessionId?: string
  ): Promise<ConversationData> {
    try {
      // If sessionId provided, try to find existing conversation
      if (sessionId) {
        const existing = await db
          .select()
          .from(conversations)
          .where(and(
            eq(conversations.userId, userId),
            eq(conversations.sessionId, sessionId)
          ))
          .limit(1);

        if (existing.length > 0) {
          const conv = existing[0];
          console.log(`‚ôªÔ∏è Found existing conversation ${conv.id} for session ${sessionId}`);
          
          return {
            id: conv.id,
            userId: conv.userId,
            sessionId: conv.sessionId,
            title: conv.title || undefined,
            provider: conv.provider,
            model: conv.model,
            createdAt: conv.createdAt!,
            updatedAt: conv.updatedAt!
          };
        }
      }

      // Create new conversation
      return await this.createConversation({
        userId,
        provider,
        model,
        sessionId
      });
    } catch (error) {
      console.error('‚ùå Error getting or creating conversation:', error);
      throw error;
    }
  }

  /**
   * Add a message to a conversation
   */
  async addMessage(input: CreateMessageInput): Promise<MessageData> {
    try {
      // Get the next message index for this conversation
      const lastMessage = await db
        .select({ messageIndex: messages.messageIndex })
        .from(messages)
        .where(eq(messages.conversationId, input.conversationId))
        .orderBy(desc(messages.messageIndex))
        .limit(1);

      const nextIndex = lastMessage.length > 0 ? lastMessage[0].messageIndex + 1 : 1;

      const result = await db.insert(messages).values({
        conversationId: input.conversationId,
        content: input.content,
        role: input.role,
        messageIndex: nextIndex,
        attachments: input.attachments || undefined,
        metadata: input.metadata || undefined
      }).returning();

      const message = result[0];
      
      // Update conversation timestamp
      await db
        .update(conversations)
        .set({ updatedAt: new Date() })
        .where(eq(conversations.id, input.conversationId));

      console.log(`‚úÖ Added ${input.role} message ${message.id} to conversation ${input.conversationId} (index: ${nextIndex})`);
      
      return {
        id: message.id,
        conversationId: message.conversationId,
        content: message.content,
        role: message.role as 'user' | 'assistant' | 'system',
        messageIndex: message.messageIndex,
        attachments: message.attachments || undefined,
        metadata: message.metadata || undefined,
        createdAt: message.createdAt!
      };
    } catch (error) {
      console.error('‚ùå Error adding message:', error);
      throw new Error(`Failed to add message: ${error}`);
    }
  }

  /**
   * Get conversation by ID
   */
  async getConversation(conversationId: number): Promise<ConversationData | null> {
    try {
      const result = await db
        .select()
        .from(conversations)
        .where(eq(conversations.id, conversationId))
        .limit(1);

      if (result.length === 0) {
        return null;
      }

      const conv = result[0];
      return {
        id: conv.id,
        userId: conv.userId,
        sessionId: conv.sessionId,
        title: conv.title || undefined,
        provider: conv.provider,
        model: conv.model,
        createdAt: conv.createdAt!,
        updatedAt: conv.updatedAt!
      };
    } catch (error) {
      console.error(`‚ùå Error getting conversation ${conversationId}:`, error);
      return null;
    }
  }

  /**
   * Get messages for a conversation
   */
  async getConversationMessages(conversationId: number): Promise<MessageData[]> {
    try {
      const result = await db
        .select()
        .from(messages)
        .where(eq(messages.conversationId, conversationId))
        .orderBy(messages.messageIndex);

      return result.map(msg => ({
        id: msg.id,
        conversationId: msg.conversationId,
        content: msg.content,
        role: msg.role as 'user' | 'assistant' | 'system',
        messageIndex: msg.messageIndex,
        attachments: msg.attachments || undefined,
        metadata: msg.metadata || undefined,
        createdAt: msg.createdAt!
      }));
    } catch (error) {
      console.error(`‚ùå Error getting messages for conversation ${conversationId}:`, error);
      return [];
    }
  }

  /**
   * Get recent conversations for a user
   */
  async getUserConversations(userId: number, limit: number = 20): Promise<ConversationData[]> {
    try {
      const result = await db
        .select()
        .from(conversations)
        .where(and(
          eq(conversations.userId, userId),
          isNull(conversations.archivedAt)
        ))
        .orderBy(desc(conversations.updatedAt))
        .limit(limit);

      return result.map(conv => ({
        id: conv.id,
        userId: conv.userId,
        sessionId: conv.sessionId,
        title: conv.title || undefined,
        provider: conv.provider,
        model: conv.model,
        createdAt: conv.createdAt!,
        updatedAt: conv.updatedAt!
      }));
    } catch (error) {
      console.error(`‚ùå Error getting conversations for user ${userId}:`, error);
      return [];
    }
  }

  /**
   * Update conversation title
   */
  async updateConversationTitle(conversationId: number, title: string): Promise<void> {
    try {
      await db
        .update(conversations)
        .set({ 
          title,
          updatedAt: new Date()
        })
        .where(eq(conversations.id, conversationId));

      console.log(`‚úÖ Updated title for conversation ${conversationId}: ${title}`);
    } catch (error) {
      console.error(`‚ùå Error updating conversation title:`, error);
      throw error;
    }
  }

  /**
   * Archive a conversation
   */
  async archiveConversation(conversationId: number): Promise<void> {
    try {
      await db
        .update(conversations)
        .set({ 
          archivedAt: new Date(),
          updatedAt: new Date()
        })
        .where(eq(conversations.id, conversationId));

      console.log(`‚úÖ Archived conversation ${conversationId}`);
    } catch (error) {
      console.error(`‚ùå Error archiving conversation:`, error);
      throw error;
    }
  }

  /**
   * Get message by ID
   */
  async getMessage(messageId: number): Promise<MessageData | null> {
    try {
      const result = await db
        .select()
        .from(messages)
        .where(eq(messages.id, messageId))
        .limit(1);

      if (result.length === 0) {
        return null;
      }

      const msg = result[0];
      return {
        id: msg.id,
        conversationId: msg.conversationId,
        content: msg.content,
        role: msg.role as 'user' | 'assistant' | 'system',
        messageIndex: msg.messageIndex,
        attachments: msg.attachments || undefined,
        metadata: msg.metadata || undefined,
        createdAt: msg.createdAt!
      };
    } catch (error) {
      console.error(`‚ùå Error getting message ${messageId}:`, error);
      return null;
    }
  }

  /**
   * Generate conversation title from first few messages
   */
  async generateConversationTitle(conversationId: number): Promise<string> {
    try {
      const firstMessages = await db
        .select({ content: messages.content, role: messages.role })
        .from(messages)
        .where(eq(messages.conversationId, conversationId))
        .orderBy(messages.messageIndex)
        .limit(3);

      if (firstMessages.length === 0) {
        return "New Conversation";
      }

      // Find the first user message
      const firstUserMessage = firstMessages.find(msg => msg.role === 'user');
      if (!firstUserMessage) {
        return "New Conversation";
      }

      // Create a title from the first user message (first 50 characters)
      let title = firstUserMessage.content.trim();
      if (title.length > 50) {
        title = title.substring(0, 47) + "...";
      }

      // Update the conversation with the generated title
      await this.updateConversationTitle(conversationId, title);

      return title;
    } catch (error) {
      console.error(`‚ùå Error generating conversation title for ${conversationId}:`, error);
      return "New Conversation";
    }
  }
}

// Export singleton instance
export const conversationService = new ConversationService();

================
File: server/cron-monthly-reset.ts
================
#!/usr/bin/env node

/**
 * Monthly Reset Cron Job
 * 
 * This script should be run on the 1st of every month to reset message counters
 * for freemium users. Can be scheduled via cron:
 * 
 * 0 0 1 * * /usr/bin/node /path/to/your/app/server/cron-monthly-reset.js
 * 
 * Or using a scheduler like node-cron within your main application.
 */

import { resetMonthlyMessageCounters } from './subscription-middleware';

async function runMonthlyReset() {
  console.log('üîÑ Starting monthly message counter reset...');
  
  try {
    await resetMonthlyMessageCounters();
    console.log('‚úÖ Monthly reset completed successfully');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Monthly reset failed:', error);
    process.exit(1);
  }
}

// Only run if this file is executed directly
if (require.main === module) {
  runMonthlyReset();
}

export { runMonthlyReset };

================
File: server/db.ts
================
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";
import dotenv from "dotenv";
dotenv.config();

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });

================
File: server/email.ts
================
import { Resend } from 'resend';

// Initialize Resend with API key from environment
const resend = new Resend(process.env.RESEND_API_KEY);

// Default sender email - should be configured in environment or use a verified domain
const FROM_EMAIL = process.env.FROM_EMAIL || 'noreply@overture-systems.com';
const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:5000';

export interface PasswordResetEmailOptions {
  to: string;
  name?: string;
  resetToken: string;
  resetUrl?: string;
}

/**
 * Send password reset email using Resend
 */
export async function sendPasswordResetEmail({
  to,
  name = '',
  resetToken,
  resetUrl
}: PasswordResetEmailOptions): Promise<void> {
  try {
    // If no custom reset URL provided, use default pattern
    const finalResetUrl = resetUrl || `${process.env.FRONTEND_URL || 'http://localhost:5000'}/reset-password?token=${resetToken}`;
    
    const displayName = name ? ` ${name}` : '';
    
    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: 'Reset Your Password - Uterpi',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Reset Your Password</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 20px 0; }
            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; color: #6c757d; font-size: 14px; }
            .warning { background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; border-radius: 4px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üîê Password Reset Request</h1>
            </div>
            <div class="content">
              <h2>Hello${displayName}!</h2>
              <p>We received a request to reset your password for your Uterpi account. If you made this request, click the button below to reset your password:</p>
              
              <div style="text-align: center;">
                <a href="${finalResetUrl}" class="button">Reset My Password</a>
              </div>
              
              <p>Or copy and paste this link into your browser:</p>
              <p style="word-break: break-all; background-color: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 14px;">
                ${finalResetUrl}
              </p>
              
              <div class="warning">
                <strong>‚ö†Ô∏è Security Notice:</strong>
                <ul style="margin: 10px 0; padding-left: 20px;">
                  <li>This link will expire in 1 hour for security reasons</li>
                  <li>If you didn't request this reset, please ignore this email</li>
                  <li>Never share this link with anyone</li>
                </ul>
              </div>
              
              <p>If you continue to have problems, please contact our support team.</p>
              
              <p>Best regards,<br>The Uterpi Team</p>
            </div>
            <div class="footer">
              <p>¬© 2025 Uterpi. All rights reserved.</p>
              <p>This email was sent to ${to}. If you didn't request this, you can safely ignore it.</p>
            </div>
          </div>
        </body>
        </html>
      `,
      text: `
Hello${displayName}!

We received a request to reset your password for your Uterpi account.

To reset your password, visit this link:
${finalResetUrl}

This link will expire in 1 hour for security reasons.

If you didn't request this password reset, please ignore this email.

Best regards,
The Uterpi Team

---
¬© 2025 Uterpi. All rights reserved.
This email was sent to ${to}. If you didn't request this, you can safely ignore it.
      `
    };

    // Send email using Resend
    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending password reset email:', error);
      throw new Error(`Failed to send email: ${error.message}`);
    }
    
    console.log('Password reset email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendPasswordResetEmail:', error);
    throw error;
  }
}

/**
 * Send password reset confirmation email
 */
export async function sendPasswordResetConfirmationEmail(to: string, name?: string): Promise<void> {
  try {
    const displayName = name ? ` ${name}` : '';
    
    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: 'Password Successfully Reset - Uterpi',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Password Reset Confirmation</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .footer { background-color: #f8f9fa; padding: 20px; text-align: center; color: #6c757d; font-size: 14px; }
            .success { background-color: #d4edda; border-left: 4px solid #28a745; padding: 15px; margin: 20px 0; border-radius: 4px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>‚úÖ Password Reset Successful</h1>
            </div>
            <div class="content">
              <h2>Hello${displayName}!</h2>
              
              <div class="success">
                <strong>Your password has been successfully reset!</strong>
              </div>
              
              <p>This email confirms that your Uterpi account password was changed successfully. You can now log in with your new password.</p>
              
              <p>If you didn't make this change, please contact our support team immediately as your account may be compromised.</p>
              
              <p>For security reasons, we recommend:</p>
              <ul>
                <li>Using a strong, unique password</li>
                <li>Enabling two-factor authentication if available</li>
                <li>Not sharing your password with anyone</li>
              </ul>
              
              <p>Best regards,<br>The Uterpi Team</p>
            </div>
            <div class="footer">
              <p>¬© 2025 Uterpi. All rights reserved.</p>
              <p>This email was sent to ${to}.</p>
            </div>
          </div>
        </body>
        </html>
      `,
      text: `
Hello${displayName}!

Your password has been successfully reset!

This email confirms that your Uterpi account password was changed successfully. You can now log in with your new password.

If you didn't make this change, please contact our support team immediately.

Best regards,
The Uterpi Team

---
¬© 2025 Uterpi. All rights reserved.
This email was sent to ${to}.
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending password reset confirmation email:', error);
      throw new Error(`Failed to send confirmation email: ${error.message}`);
    }
    
    console.log('Password reset confirmation email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendPasswordResetConfirmationEmail:', error);
    throw error;
  }
}

// =============================================================================
// ENGAGEMENT EMAIL SYSTEM
// =============================================================================

export interface EngagementEmailOptions {
  to: string;
  name?: string;
  unsubscribeToken?: string;
  trackingPixel?: string;
  personalData?: Record<string, any>;
}

/**
 * Generate common email footer with unsubscribe and tracking
 */
function generateEmailFooter(unsubscribeToken?: string, trackingPixel?: string): string {
  const unsubscribeLink = unsubscribeToken 
    ? `${FRONTEND_URL}/unsubscribe?token=${unsubscribeToken}`
    : '#';
    
  const trackingPixelHtml = trackingPixel 
    ? `<img src="${FRONTEND_URL}/api/engagement/track-open?token=${trackingPixel}" width="1" height="1" style="display:none;" alt="">`
    : '';

  return `
    <div class="footer" style="background-color: #f8f9fa; padding: 30px 20px; text-align: center; color: #6c757d; font-size: 14px; border-top: 1px solid #e9ecef;">
      <div style="max-width: 600px; margin: 0 auto;">
        <p style="margin: 0 0 15px 0;">¬© 2025 Uterpi. All rights reserved.</p>
        <p style="margin: 0 0 15px 0;">
          <a href="${FRONTEND_URL}" style="color: #667eea; text-decoration: none;">Visit Uterpi</a> | 
          <a href="${FRONTEND_URL}/help" style="color: #667eea; text-decoration: none;">Help Center</a> | 
          <a href="${FRONTEND_URL}/privacy" style="color: #667eea; text-decoration: none;">Privacy Policy</a>
        </p>
        <p style="margin: 0; font-size: 12px; color: #9ca3af;">
          Don't want to receive these emails? 
          <a href="${unsubscribeLink}" style="color: #667eea; text-decoration: none;">Unsubscribe here</a>
        </p>
      </div>
      ${trackingPixelHtml}
    </div>
  `;
}

/**
 * Welcome Email Series - Day 1: Getting Started
 */
export async function sendWelcomeEmail(options: EngagementEmailOptions): Promise<void> {
  try {
    const { to, name = '', unsubscribeToken, trackingPixel } = options;
    const displayName = name ? ` ${name}` : '';

    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: `Welcome to Uterpi${displayName}! Let's get you started üöÄ`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Welcome to Uterpi</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 15px 0; }
            .feature-card { background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0; border-left: 4px solid #667eea; }
            .tips { background: #e3f2fd; border-radius: 8px; padding: 20px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üéâ Welcome to Uterpi${displayName}!</h1>
              <p style="margin: 0; opacity: 0.9;">Your AI-powered productivity companion is ready</p>
            </div>
            <div class="content">
              <h2>Ready to supercharge your productivity?</h2>
              <p>Thank you for joining Uterpi! We're excited to help you unlock the power of AI for your daily tasks. Here's how to get started:</p>
              
              <div class="feature-card">
                <h3>ü§ñ Start Your First Chat</h3>
                <p>Jump right in with our AI assistant. Ask questions, get help with tasks, or brainstorm ideas.</p>
                <a href="${FRONTEND_URL}/?utm_source=email&utm_campaign=welcome&utm_content=chat_cta" class="button">Start Chatting</a>
              </div>
              
              <div class="feature-card">
                <h3>üìÅ Upload & Analyze Files</h3>
                <p>Upload documents, images, or data files and let our AI analyze them for insights.</p>
                <a href="${FRONTEND_URL}/files?utm_source=email&utm_campaign=welcome&utm_content=files_cta" class="button">Try File Analysis</a>
              </div>
              
              <div class="tips">
                <h3>üí° Pro Tips for Success</h3>
                <ul style="margin: 10px 0; padding-left: 20px;">
                  <li>Be specific in your questions for better AI responses</li>
                  <li>Use the file upload feature for document analysis</li>
                  <li>Explore different AI models for various tasks</li>
                  <li>Save important conversations for future reference</li>
                </ul>
              </div>
              
              <p>Need help getting started? Our <a href="${FRONTEND_URL}/help?utm_source=email&utm_campaign=welcome" style="color: #667eea;">help center</a> has guides and tutorials.</p>
              
              <p>Best regards,<br>The Uterpi Team</p>
            </div>
            ${generateEmailFooter(unsubscribeToken, trackingPixel)}
          </div>
        </body>
        </html>
      `,
      text: `
Welcome to Uterpi${displayName}!

Thank you for joining Uterpi! We're excited to help you unlock the power of Uterpi for your daily tasks.

Get started with these features:
- Start your first chat with our AI assistant
- Upload and analyze files for insights
- Explore different AI models for various tasks

Visit Uterpi: ${FRONTEND_URL}

Need help? Check our help center: ${FRONTEND_URL}/help

Best regards,
The Uterpi Team
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending welcome email:', error);
      throw new Error(`Failed to send welcome email: ${error.message}`);
    }
    
    console.log('Welcome email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendWelcomeEmail:', error);
    throw error;
  }
}

/**
 * Re-engagement Email for inactive users
 */
export async function sendReengagementEmail(options: EngagementEmailOptions): Promise<void> {
  try {
    const { to, name = '', unsubscribeToken, trackingPixel, personalData } = options;
    const displayName = name ? ` ${name}` : '';
    const daysSinceLastLogin = personalData?.daysSinceLastLogin || 7;

    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: `We miss you${displayName}! Your Uterpi assistant is waiting ‚è∞`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Come Back to Uterpi</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 15px 0; }
            .highlight { background: #e8f5e8; border-radius: 8px; padding: 20px; margin: 20px 0; border-left: 4px solid #4caf50; }
            .stats { text-align: center; background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>ü§ñ We miss you${displayName}!</h1>
              <p style="margin: 0; opacity: 0.9;">Your Uterpi assistant has been waiting for you</p>
            </div>
            <div class="content">
              <h2>It's been ${daysSinceLastLogin} days since your last visit</h2>
              <p>We noticed you haven't been around lately, and we wanted to check in! The AI world has been buzzing with activity, and we'd love to have you back.</p>
              
              <div class="highlight">
                <h3>üöÄ What's New Since You've Been Away</h3>
                <ul style="margin: 10px 0; padding-left: 20px;">
                  <li>Improved AI response accuracy and speed</li>
                  <li>New file analysis capabilities</li>
                  <li>Enhanced chat experience with better memory</li>
                  <li>Community features and user showcases</li>
                </ul>
              </div>
              
              <div class="stats">
                <h3>Your Uterpi Journey</h3>
                <p><strong>${personalData?.totalSessions || 0}</strong> sessions completed</p>
                <p><strong>${personalData?.filesAnalyzed || 0}</strong> files analyzed</p>
                <p><strong>${personalData?.chatMessages || 0}</strong> AI conversations</p>
              </div>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${FRONTEND_URL}/?utm_source=email&utm_campaign=reengagement&utm_content=comeback_cta" class="button">Continue Your AI Journey</a>
              </div>
              
              <p>Need a refresher? Check out our <a href="${FRONTEND_URL}/help?utm_source=email&utm_campaign=reengagement" style="color: #667eea;">latest tutorials</a> or start with a simple question.</p>
              
              <p>Looking forward to seeing you again!</p>
              <p>The Uterpi Team</p>
            </div>
            ${generateEmailFooter(unsubscribeToken, trackingPixel)}
          </div>
        </body>
        </html>
      `,
      text: `
We miss you${displayName}!

It's been ${daysSinceLastLogin} days since your last visit to Uterpi. We'd love to have you back!

What's new since you've been away:
- Improved Uterpi response accuracy and speed
- New file upload & analysis capabilities  
- Enhanced chat experience with better memory

Your Uterpi journey so far:
- ${personalData?.totalSessions || 0} sessions completed
- ${personalData?.filesAnalyzed || 0} files analyzed
- ${personalData?.chatMessages || 0} AI conversations

Continue your AI journey: ${FRONTEND_URL}

Looking forward to seeing you again!
The Uterpi Team
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending reengagement email:', error);
      throw new Error(`Failed to send reengagement email: ${error.message}`);
    }
    
    console.log('Reengagement email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendReengagementEmail:', error);
    throw error;
  }
}

/**
 * Feature Discovery Email
 */
export async function sendFeatureDiscoveryEmail(options: EngagementEmailOptions): Promise<void> {
  try {
    const { to, name = '', unsubscribeToken, trackingPixel, personalData } = options;
    const displayName = name ? ` ${name}` : '';
    const unusedFeatures = personalData?.unusedFeatures || ['File Analysis', 'Model Selection', 'Chat History'];

    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: `${displayName}, discover hidden Uterpi features! üîç`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Discover Uterpi Features</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 15px 0; }
            .feature { background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 15px 0; border-left: 4px solid #ff6b6b; }
            .cta-box { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üîç Hidden Features Await${displayName}!</h1>
              <p style="margin: 0; opacity: 0.9;">Unlock the full power of Uterpi & Uterpi</p>
            </div>
            <div class="content">
              <h2>You're only using a fraction of Uterpi's capabilities!</h2>
              <p>We noticed you haven't explored some of our most powerful features yet. Here's what you're missing out on:</p>
              
                             ${unusedFeatures.map((feature: string) => {
                 const featureInfo = {
                  'File Analysis': {
                    icon: 'üìÅ',
                    description: 'Upload documents, spreadsheets, or images and get instant AI-powered insights and analysis.',
                    cta: 'Try File Analysis',
                    link: 'files'
                  },
                  'Model Selection': {
                    icon: 'ü§ñ',
                    description: 'Choose from different AI models optimized for specific tasks like coding, writing, or analysis.',
                    cta: 'Explore Models',
                    link: 'models'
                  },
                  'Chat History': {
                    icon: 'üí¨',
                    description: 'Save, search, and continue your previous conversations. Never lose important insights again.',
                    cta: 'View History',
                    link: 'history'
                  }
                }[feature] || { icon: '‚ú®', description: feature, cta: 'Learn More', link: '' };
                
                return `
                  <div class="feature">
                    <h3>${featureInfo.icon} ${feature}</h3>
                    <p>${featureInfo.description}</p>
                    <a href="${FRONTEND_URL}/${featureInfo.link}?utm_source=email&utm_campaign=feature_discovery&utm_content=${feature.toLowerCase().replace(' ', '_')}" class="button">${featureInfo.cta}</a>
                  </div>
                `;
              }).join('')}
              
              <div class="cta-box">
                <h3>üöÄ Ready to Level Up?</h3>
                <p style="margin: 10px 0;">Take the full tour and discover all the ways Uterpi can boost your productivity.</p>
                <a href="${FRONTEND_URL}/tour?utm_source=email&utm_campaign=feature_discovery&utm_content=full_tour" style="display: inline-block; background: white; color: #667eea; text-decoration: none; padding: 12px 24px; border-radius: 6px; font-weight: 600; margin: 10px 0;">Take the Full Tour</a>
              </div>
              
              <p>Questions about any of these features? Just reply to this email or check our <a href="${FRONTEND_URL}/help" style="color: #667eea;">help center</a>.</p>
              
              <p>Happy exploring!</p>
              <p>The Uterpi Team</p>
            </div>
            ${generateEmailFooter(unsubscribeToken, trackingPixel)}
          </div>
        </body>
        </html>
      `,
      text: `
Discover Hidden Uterpi Features${displayName}!

You're only using a fraction of Uterpi's capabilities! Here's what you're missing:

 ${unusedFeatures.map((feature: string) => `- ${feature}`).join('\n')}

Take the full tour: ${FRONTEND_URL}/tour

Questions? Check our help center: ${FRONTEND_URL}/help

Happy exploring!
The Uterpi Team
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending feature discovery email:', error);
      throw new Error(`Failed to send feature discovery email: ${error.message}`);
    }
    
    console.log('Feature discovery email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendFeatureDiscoveryEmail:', error);
    throw error;
  }
}

/**
 * Usage Insights Email - Weekly/Monthly stats
 */
export async function sendUsageInsightsEmail(options: EngagementEmailOptions): Promise<void> {
  try {
    const { to, name = '', unsubscribeToken, trackingPixel, personalData } = options;
    const displayName = name ? ` ${name}` : '';
    const period = personalData?.period || 'week';
    const stats = personalData?.stats || {};

    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: `Your ${period}ly Uterpi insights are here${displayName}! üìä`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Your Uterpi Insights</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 15px 0; }
            .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
            .stat-card { background: #f8f9fa; border-radius: 8px; padding: 20px; text-align: center; border: 2px solid #e9ecef; }
            .stat-number { font-size: 28px; font-weight: bold; color: #667eea; margin-bottom: 5px; }
            .achievement { background: #fff3cd; border-radius: 8px; padding: 15px; margin: 15px 0; border-left: 4px solid #ffc107; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üìä Your ${period}ly insights${displayName}!</h1>
              <p style="margin: 0; opacity: 0.9;">See how you've been crushing it with AI</p>
            </div>
            <div class="content">
              <h2>Your productivity this ${period}</h2>
              <p>Here's a summary of your amazing progress with Uterpi:</p>
              
              <div class="stat-grid">
                <div class="stat-card">
                  <div class="stat-number">${stats.sessions || 0}</div>
                  <div>Sessions</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number">${stats.messages || 0}</div>
                  <div>AI Messages</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number">${stats.filesAnalyzed || 0}</div>
                  <div>Files Analyzed</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number">${stats.timeSpent || 0}m</div>
                  <div>Time Spent</div>
                </div>
              </div>
              
              ${stats.achievements && stats.achievements.length > 0 ? `
                <div class="achievement">
                  <h3>üèÜ This ${period}'s achievements</h3>
                  <ul style="margin: 10px 0; padding-left: 20px;">
                    ${stats.achievements.map((achievement: string) => `<li>${achievement}</li>`).join('')}
                  </ul>
                </div>
              ` : ''}
              
              <h3>üí° Your most productive ${period === 'week' ? 'day' : 'week'}</h3>
              <p>You were most active on <strong>${stats.mostActiveDay || 'Wednesday'}</strong> with ${stats.mostActiveDayCount || 5} interactions!</p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${FRONTEND_URL}/?utm_source=email&utm_campaign=usage_insights&utm_content=continue_streak" class="button">Keep the Momentum Going</a>
              </div>
              
              <p>Want to improve your productivity even more? Check out our <a href="${FRONTEND_URL}/tips?utm_source=email&utm_campaign=usage_insights" style="color: #667eea;">productivity tips</a>.</p>
              
              <p>Keep up the great work!</p>
              <p>The Uterpi Team</p>
            </div>
            ${generateEmailFooter(unsubscribeToken, trackingPixel)}
          </div>
        </body>
        </html>
      `,
      text: `
Your ${period}ly Uterpi insights${displayName}!

Your productivity this ${period}:
- ${stats.sessions || 0} sessions
- ${stats.messages || 0} AI messages  
- ${stats.filesAnalyzed || 0} files analyzed
- ${stats.timeSpent || 0}m time spent

Most productive ${period === 'week' ? 'day' : 'week'}: ${stats.mostActiveDay || 'Wednesday'}

Keep the momentum going: ${FRONTEND_URL}

Want productivity tips? Visit: ${FRONTEND_URL}/tips

Keep up the great work!
The Uterpi Team
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending usage insights email:', error);
      throw new Error(`Failed to send usage insights email: ${error.message}`);
    }
    
    console.log('Usage insights email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendUsageInsightsEmail:', error);
    throw error;
  }
}

/**
 * Product Tips Email
 */
export async function sendProductTipsEmail(options: EngagementEmailOptions): Promise<void> {
  try {
    const { to, name = '', unsubscribeToken, trackingPixel, personalData } = options;
    const displayName = name ? ` ${name}` : '';
    const tipCategory = personalData?.tipCategory || 'general';

    const tips = {
      general: [
        { title: "Be Specific in Your Questions", description: "Instead of 'help me write', try 'help me write a professional email to follow up on a job interview'", icon: "üéØ" },
        { title: "Use Follow-up Questions", description: "Ask for clarification, examples, or different approaches to get exactly what you need", icon: "üîÑ" },
        { title: "Provide Context", description: "Share relevant background information to get more tailored and accurate responses", icon: "üìù" }
      ],
      files: [
        { title: "Upload Multiple File Types", description: "Uterpi can analyze PDFs, spreadsheets, images, and text files for comprehensive insights", icon: "üìÅ" },
        { title: "Ask Specific Analysis Questions", description: "Instead of 'analyze this', ask 'what are the key trends in this data?' or 'summarize the main points'", icon: "üîç" },
        { title: "Use File Analysis for Comparisons", description: "Upload similar documents and ask AI to compare differences or similarities", icon: "‚öñÔ∏è" }
      ],
      productivity: [
        { title: "Create Templates", description: "Ask AI to create reusable templates for emails, reports, or presentations", icon: "üìã" },
        { title: "Break Down Complex Tasks", description: "Use AI to break large projects into manageable steps and action items", icon: "üß©" },
        { title: "Generate Multiple Options", description: "Ask for several different approaches or versions to find the best solution", icon: "üé®" }
      ]
    };

    const selectedTips = tips[tipCategory as keyof typeof tips] || tips.general;

    const emailData = {
      from: FROM_EMAIL,
      to: [to],
      subject: `${displayName}, here are your AI productivity tips! üí°`,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>AI Productivity Tips</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 40px 20px; }
            .content { padding: 40px 30px; }
            .button { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; margin: 15px 0; }
            .tip { background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0; border-left: 4px solid #28a745; }
            .tip-icon { font-size: 24px; margin-bottom: 10px; }
            .quote { background: #e3f2fd; border-radius: 8px; padding: 20px; margin: 20px 0; font-style: italic; border-left: 4px solid #2196f3; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>üí° AI Productivity Tips${displayName}!</h1>
              <p style="margin: 0; opacity: 0.9;">Master the art of AI collaboration</p>
            </div>
            <div class="content">
              <h2>Level up your AI game with these Uterpi pro tips</h2>
              <p>Ready to become an AI productivity master? Here are some expert techniques to get better results from Uterpi:</p>
              
              ${selectedTips.map(tip => `
                <div class="tip">
                  <div class="tip-icon">${tip.icon}</div>
                  <h3>${tip.title}</h3>
                  <p>${tip.description}</p>
                </div>
              `).join('')}
              
              <div class="quote">
                <p>"The key to great AI results is asking the right questions. The more context and specificity you provide, the more valuable the AI's response will be."</p>
                <p><strong>- Uterpi Pro User</strong></p>
              </div>
              
              <h3>üöÄ Ready to apply these tips?</h3>
              <p>Jump back into Uterpi and try out these techniques. You'll be amazed at the difference they make!</p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${FRONTEND_URL}/?utm_source=email&utm_campaign=product_tips&utm_content=apply_tips" class="button">Apply These Tips Now</a>
              </div>
              
              <p>Have your own productivity tips to share? Reply to this email - we love hearing from our community!</p>
              
              <p>Happy optimizing!</p>
              <p>The Uterpi Team</p>
            </div>
            ${generateEmailFooter(unsubscribeToken, trackingPixel)}
          </div>
        </body>
        </html>
      `,
      text: `
AI Productivity Tips${displayName}!

Level up your AI game with these pro tips:

${selectedTips.map(tip => `${tip.icon} ${tip.title}\n${tip.description}\n`).join('\n')}

Ready to apply these tips? Visit: ${FRONTEND_URL}

Have your own tips to share? Reply to this email!

Happy optimizing!
The Uterpi Team
      `
    };

    const { data, error } = await resend.emails.send(emailData);
    
    if (error) {
      console.error('Error sending product tips email:', error);
      throw new Error(`Failed to send product tips email: ${error.message}`);
    }
    
    console.log('Product tips email sent successfully:', data?.id);
  } catch (error) {
    console.error('Error in sendProductTipsEmail:', error);
    throw error;
  }
}

================
File: server/engagement.ts
================
import { eq, and, gte, desc, sql, lt, lte, ne, notInArray } from "drizzle-orm";
import { db } from "./db";
import { 
  users, userEngagement, emailPreferences, emailCampaigns, 
  emailSendLog, userActivity, type UserEngagement, type EmailPreferences,
  type EmailSendLog, type UserActivity as UserActivityType
} from "@shared/schema";
import { 
  sendWelcomeEmail, sendReengagementEmail, sendFeatureDiscoveryEmail,
  sendUsageInsightsEmail, sendProductTipsEmail, type EngagementEmailOptions
} from "./email";
import { aiCoachService } from "./ai-coach";

// =============================================================================
// ENGAGEMENT TRACKING SERVICE
// =============================================================================

export class EngagementService {
  
  /**
   * Initialize engagement tracking for a new user
   */
  async initializeUserEngagement(userId: number): Promise<void> {
    try {
      await this.ensureUserEngagementExists(userId);

      // Send welcome email after a short delay (only for truly new users)
      setTimeout(async () => {
        await this.sendWelcomeEmail(userId);
      }, 2000);

    } catch (error) {
      console.error('Error initializing user engagement:', error);
    }
  }

  /**
   * Ensure user engagement records exist (safe for existing users)
   */
  async ensureUserEngagementExists(userId: number): Promise<void> {
    try {
      // Check if engagement record exists
      const existingEngagement = await db
        .select()
        .from(userEngagement)
        .where(eq(userEngagement.userId, userId))
        .limit(1);

      // Create engagement record if it doesn't exist
      if (existingEngagement.length === 0) {
        await db.insert(userEngagement).values({
          userId,
          firstSessionAt: new Date(),
          lastActivityAt: new Date(),
        });
      }

      // Check if email preferences exist
      const existingPreferences = await db
        .select()
        .from(emailPreferences)
        .where(eq(emailPreferences.userId, userId))
        .limit(1);

      // Create default email preferences if they don't exist
      if (existingPreferences.length === 0) {
        const unsubscribeToken = await this.generateUnsubscribeToken();
        await db.insert(emailPreferences).values({
          userId,
          unsubscribeToken,
        });
      }

    } catch (error) {
      console.error('Error ensuring user engagement exists:', error);
      throw error;
    }
  }

  /**
   * Track user activity with AI Coach integration
   */
  async trackActivity(
    userId: number, 
    activityType: string, 
    activityData?: Record<string, any>,
    sessionId?: string,
    userAgent?: string,
    ipAddress?: string,
    duration?: number
  ): Promise<void> {
    try {
      // Record the activity
      await db.insert(userActivity).values({
        userId,
        activityType,
        activityData,
        sessionId,
        userAgent,
        ipAddress,
        duration,
      });

      // Update engagement metrics
      await this.updateEngagementMetrics(userId, activityType, activityData);

      // Track workflow activity for AI Coach analysis
      if (sessionId) {
        await aiCoachService.trackWorkflowActivity(
          userId,
          sessionId,
          activityType,
          {
            ...activityData,
            duration,
            timestamp: new Date().toISOString(),
          }
        );
      }

    } catch (error) {
      console.error('Error tracking activity:', error);
    }
  }

  /**
   * Update user engagement metrics
   */
  private async updateEngagementMetrics(
    userId: number, 
    activityType: string, 
    activityData?: Record<string, any>
  ): Promise<void> {
    try {
      const updates: Partial<UserEngagement> = {
        lastActivityAt: new Date(),
        updatedAt: new Date(),
      };

             // Update metrics based on activity type
       // Note: We'll use direct updates with SQL to increment values
       const sqlUpdates: Record<string, any> = {
         lastActivityAt: new Date(),
         updatedAt: new Date(),
       };

       switch (activityType) {
         case 'login':
           sqlUpdates.lastLoginAt = new Date();
           sqlUpdates.totalLogins = sql`${userEngagement.totalLogins} + 1`;
           break;
         case 'session_start':
           sqlUpdates.totalSessions = sql`${userEngagement.totalSessions} + 1`;
           break;
         case 'file_upload':
           sqlUpdates.filesUploaded = sql`${userEngagement.filesUploaded} + 1`;
           break;
         case 'file_analyze':
           sqlUpdates.filesAnalyzed = sql`${userEngagement.filesAnalyzed} + 1`;
           break;
         case 'chat_message':
           sqlUpdates.chatMessagesCount = sql`${userEngagement.chatMessagesCount} + 1`;
           sqlUpdates.aiInteractions = sql`${userEngagement.aiInteractions} + 1`;
           break;
         case 'session_end':
           if (activityData?.duration) {
             sqlUpdates.totalTimeSpent = sql`${userEngagement.totalTimeSpent} + ${activityData.duration}`;
           }
           break;
       }

             await db
         .update(userEngagement)
         .set(sqlUpdates)
         .where(eq(userEngagement.userId, userId));

      // Update engagement score and segment
      await this.calculateEngagementScore(userId);

    } catch (error) {
      console.error('Error updating engagement metrics:', error);
    }
  }

  /**
   * Calculate and update user engagement score
   */
  private async calculateEngagementScore(userId: number): Promise<void> {
    try {
      const engagement = await db
        .select()
        .from(userEngagement)
        .where(eq(userEngagement.userId, userId))
        .limit(1);

      if (!engagement.length) return;

      const user = engagement[0];
      const now = new Date();
      const daysSinceFirst = Math.floor((now.getTime() - user.firstSessionAt!.getTime()) / (1000 * 60 * 60 * 24));
      const daysSinceLastActivity = user.lastActivityAt 
        ? Math.floor((now.getTime() - user.lastActivityAt.getTime()) / (1000 * 60 * 60 * 24))
        : 0;

      // Calculate engagement score (0-100)
      let score = 0;
      
      // Login frequency (25 points max)
      const loginFrequency = daysSinceFirst > 0 ? (user.totalLogins || 0) / daysSinceFirst : 0;
      score += Math.min(25, loginFrequency * 5);
      
      // Feature usage (25 points max)
      const featureUsage = (user.filesAnalyzed || 0) + (user.chatMessagesCount || 0) / 10;
      score += Math.min(25, featureUsage);
      
      // Recency (25 points max)
      if (daysSinceLastActivity === 0) score += 25;
      else if (daysSinceLastActivity <= 1) score += 20;
      else if (daysSinceLastActivity <= 3) score += 15;
      else if (daysSinceLastActivity <= 7) score += 10;
      else if (daysSinceLastActivity <= 14) score += 5;
      
      // Time spent (25 points max)
      const avgTimePerSession = (user.totalSessions || 0) > 0 
        ? (user.totalTimeSpent || 0) / (user.totalSessions || 1) 
        : 0;
      score += Math.min(25, avgTimePerSession / 2);

      // Determine user segment
      let segment = 'new';
      if (daysSinceFirst > 30) {
        if (score >= 70) segment = 'active';
        else if (score >= 40) segment = 'at_risk';
        else segment = 'dormant';
      } else if (daysSinceFirst > 7) {
        segment = score >= 50 ? 'active' : 'at_risk';
      }

      // Update engagement score and segment
      await db
        .update(userEngagement)
        .set({
          engagementScore: Math.round(score),
          userSegment: segment,
          updatedAt: new Date(),
        })
        .where(eq(userEngagement.userId, userId));

    } catch (error) {
      console.error('Error calculating engagement score:', error);
    }
  }

  /**
   * Get user engagement data
   */
  async getUserEngagement(userId: number): Promise<UserEngagement | null> {
    try {
      const result = await db
        .select()
        .from(userEngagement)
        .where(eq(userEngagement.userId, userId))
        .limit(1);

      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error('Error getting user engagement:', error);
      return null;
    }
  }

  /**
   * Get user activity history
   */
  async getUserActivity(userId: number, limit: number = 50): Promise<UserActivityType[]> {
    try {
      return await db
        .select()
        .from(userActivity)
        .where(eq(userActivity.userId, userId))
        .orderBy(desc(userActivity.timestamp))
        .limit(limit);
    } catch (error) {
      console.error('Error getting user activity:', error);
      return [];
    }
  }

  // =============================================================================
  // EMAIL PREFERENCE MANAGEMENT
  // =============================================================================

  /**
   * Get user email preferences
   */
  async getEmailPreferences(userId: number): Promise<EmailPreferences | null> {
    try {
      const result = await db
        .select()
        .from(emailPreferences)
        .where(eq(emailPreferences.userId, userId))
        .limit(1);

      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error('Error getting email preferences:', error);
      return null;
    }
  }

  /**
   * Update user email preferences
   */
  async updateEmailPreferences(
    userId: number, 
    preferences: Partial<EmailPreferences>
  ): Promise<boolean> {
    try {
      await db
        .update(emailPreferences)
        .set({
          ...preferences,
          updatedAt: new Date(),
        })
        .where(eq(emailPreferences.userId, userId));

      return true;
    } catch (error) {
      console.error('Error updating email preferences:', error);
      return false;
    }
  }

  /**
   * Unsubscribe user from emails
   */
  async unsubscribeUser(token: string, reason?: string): Promise<boolean> {
    try {
      const result = await db
        .update(emailPreferences)
        .set({
          isUnsubscribed: true,
          unsubscribedAt: new Date(),
          unsubscribeReason: reason,
          updatedAt: new Date(),
        })
        .where(eq(emailPreferences.unsubscribeToken, token))
        .returning();

      return result.length > 0;
    } catch (error) {
      console.error('Error unsubscribing user:', error);
      return false;
    }
  }

  /**
   * Generate unsubscribe token
   */
  private async generateUnsubscribeToken(): Promise<string> {
    const crypto = await import('crypto');
    return crypto.randomBytes(32).toString('hex');
  }

  // =============================================================================
  // EMAIL CAMPAIGN MANAGEMENT
  // =============================================================================

  /**
   * Send welcome email to new user
   */
     async sendWelcomeEmail(userId: number): Promise<boolean> {
     try {
       const user = await this.getUserForEmail(userId);
       if (!user || !user.preferences?.welcomeEmails || user.preferences?.isUnsubscribed) {
         return false;
       }

       const trackingTokens = await this.generateTrackingTokens();
       
       await sendWelcomeEmail({
         to: user.email,
         name: user.firstName || user.username || '',
         unsubscribeToken: user.preferences?.unsubscribeToken || undefined,
         trackingPixel: trackingTokens.openToken,
       });

      await this.logEmailSent(userId, 'welcome', 'Welcome to Uterpi! Let\'s get you started üöÄ', trackingTokens);
      return true;
    } catch (error) {
      console.error('Error sending welcome email:', error);
      return false;
    }
  }

  /**
   * Send re-engagement email to inactive users
   */
  async sendReengagementEmail(userId: number): Promise<boolean> {
    try {
      const user = await this.getUserForEmail(userId);
      if (!user || !user.preferences?.reengagementEmails || user.preferences?.isUnsubscribed) {
        return false;
      }

      const engagement = await this.getUserEngagement(userId);
      if (!engagement) return false;

      const daysSinceLastLogin = engagement.lastLoginAt 
        ? Math.floor((Date.now() - engagement.lastLoginAt.getTime()) / (1000 * 60 * 60 * 24))
        : 30;

      const trackingTokens = await this.generateTrackingTokens();
      
      await sendReengagementEmail({
        to: user.email,
        name: user.firstName || user.username || '',
        unsubscribeToken: user.preferences?.unsubscribeToken || undefined,
        trackingPixel: trackingTokens.openToken,
        personalData: {
          daysSinceLastLogin,
          totalSessions: engagement.totalSessions,
          filesAnalyzed: engagement.filesAnalyzed,
          chatMessages: engagement.chatMessagesCount,
        },
      });

      await this.logEmailSent(userId, 'reengagement', `We miss you! Your Uterpi assistant is waiting ‚è∞`, trackingTokens);
      return true;
    } catch (error) {
      console.error('Error sending reengagement email:', error);
      return false;
    }
  }

  /**
   * Send feature discovery email
   */
  async sendFeatureDiscoveryEmail(userId: number): Promise<boolean> {
    try {
      const user = await this.getUserForEmail(userId);
      if (!user || !user.preferences?.featureUpdates || user.preferences?.isUnsubscribed) {
        return false;
      }

      const unusedFeatures = await this.getUnusedFeatures(userId);
      if (unusedFeatures.length === 0) return false;

      const trackingTokens = await this.generateTrackingTokens();
      
      await sendFeatureDiscoveryEmail({
        to: user.email,
        name: user.firstName || user.username || '',
        unsubscribeToken: user.preferences?.unsubscribeToken || undefined,
        trackingPixel: trackingTokens.openToken,
        personalData: { unusedFeatures },
      });

      await this.logEmailSent(userId, 'feature_discovery', 'Discover hidden Uterpi features! üîç', trackingTokens);
      return true;
    } catch (error) {
      console.error('Error sending feature discovery email:', error);
      return false;
    }
  }

  /**
   * Send usage insights email (weekly/monthly)
   */
  async sendUsageInsightsEmail(userId: number, period: 'week' | 'month' = 'week'): Promise<boolean> {
    try {
      const user = await this.getUserForEmail(userId);
      if (!user || !user.preferences?.usageInsights || user.preferences?.isUnsubscribed) {
        return false;
      }

      const stats = await this.getUserStats(userId, period);
      if (!stats) return false;

      const trackingTokens = await this.generateTrackingTokens();
      
      await sendUsageInsightsEmail({
        to: user.email,
        name: user.firstName || user.username || '',
        unsubscribeToken: user.preferences?.unsubscribeToken || undefined,
        trackingPixel: trackingTokens.openToken,
        personalData: { period, stats },
      });

      await this.logEmailSent(userId, 'usage_insights', `Your ${period}ly Uterpi insights are here! üìä`, trackingTokens);
      return true;
    } catch (error) {
      console.error('Error sending usage insights email:', error);
      return false;
    }
  }

  /**
   * Send product tips email
   */
  async sendProductTipsEmail(userId: number, tipCategory: string = 'general'): Promise<boolean> {
    try {
      const user = await this.getUserForEmail(userId);
      if (!user || !user.preferences?.productTips || user.preferences?.isUnsubscribed) {
        return false;
      }

      const trackingTokens = await this.generateTrackingTokens();
      
      await sendProductTipsEmail({
        to: user.email,
        name: user.firstName || user.username || '',
        unsubscribeToken: user.preferences?.unsubscribeToken || undefined,
        trackingPixel: trackingTokens.openToken,
        personalData: { tipCategory },
      });

      await this.logEmailSent(userId, 'product_tips', 'Here are your AI productivity tips! üí°', trackingTokens);
      return true;
    } catch (error) {
      console.error('Error sending product tips email:', error);
      return false;
    }
  }

  // =============================================================================
  // AUTOMATED CAMPAIGNS
  // =============================================================================

  /**
   * Run daily engagement campaigns
   */
  async runDailyCampaigns(): Promise<void> {
    console.log('Running daily engagement campaigns...');
    
    try {
      // Send welcome emails to users who registered 2 hours ago
      await this.sendWelcomeEmailsToNewUsers();
      
      // Send re-engagement emails to users inactive for 7+ days
      await this.sendReengagementEmails();
      
      // Send feature discovery emails to users who haven't used key features
      await this.sendFeatureDiscoveryEmails();
      
      console.log('Daily engagement campaigns completed');
    } catch (error) {
      console.error('Error running daily campaigns:', error);
    }
  }

  /**
   * Run weekly engagement campaigns
   */
  async runWeeklyCampaigns(): Promise<void> {
    console.log('Running weekly engagement campaigns...');
    
    try {
      // Send weekly usage insights
      await this.sendWeeklyUsageInsights();
      
      // Send product tips
      await this.sendWeeklyProductTips();
      
      console.log('Weekly engagement campaigns completed');
    } catch (error) {
      console.error('Error running weekly campaigns:', error);
    }
  }

  // =============================================================================
  // AUTOMATED CAMPAIGN IMPLEMENTATIONS
  // =============================================================================

  /**
   * Send welcome emails to users who registered 2 hours ago
   */
  private async sendWelcomeEmailsToNewUsers(): Promise<void> {
    try {
      console.log('üéâ Starting welcome email campaign...');
      
      // Find users who registered 2 hours ago but haven't received welcome emails
      const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
      const fourHoursAgo = new Date(Date.now() - 4 * 60 * 60 * 1000);
      
      const newUsers = await db
        .select({
          userId: users.id,
          email: users.email,
          firstName: users.firstName,
          username: users.username,
          createdAt: users.createdAt,
        })
        .from(users)
        .innerJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .leftJoin(
          emailSendLog,
          and(
            eq(emailSendLog.userId, users.id),
            eq(emailSendLog.emailType, 'welcome')
          )
        )
        .where(
          and(
            // Registered between 2-4 hours ago
            gte(users.createdAt, fourHoursAgo),
            lte(users.createdAt, twoHoursAgo),
            // Email preferences allow welcome emails
            eq(emailPreferences.welcomeEmails, true),
            eq(emailPreferences.isUnsubscribed, false),
            // No welcome email sent yet
            sql`${emailSendLog.id} IS NULL`
          )
        )
        .limit(50); // Process in batches

      console.log(`Found ${newUsers.length} users eligible for welcome emails`);

      if (newUsers.length === 0) {
        return;
      }

      let successCount = 0;
      let failureCount = 0;

      // Process users in smaller batches to avoid overwhelming email service
      for (const user of newUsers) {
        try {
          // Add small delay between emails to respect rate limits
          await this.delay(100);
          
          const success = await this.sendWelcomeEmail(user.userId);
          if (success) {
            successCount++;
            console.log(`‚úÖ Welcome email sent to ${user.email}`);
          } else {
            failureCount++;
            console.log(`‚ùå Failed to send welcome email to ${user.email} (preferences/eligibility)`);
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Error sending welcome email to ${user.email}:`, error);
        }
      }

      console.log(`üéâ Welcome email campaign completed: ${successCount} sent, ${failureCount} failed`);
      
    } catch (error) {
      console.error('‚ùå Error in sendWelcomeEmailsToNewUsers:', error);
    }
  }

  /**
   * Send re-engagement emails to users inactive for 7+ days
   */
  private async sendReengagementEmails(): Promise<void> {
    try {
      console.log('üìß Starting re-engagement email campaign...');
      
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const oneMonthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      // Find users who:
      // 1. Haven't been active for 7+ days
      // 2. Have been registered for at least 7 days (not too new)
      // 3. Haven't received a re-engagement email in the last 30 days
      const inactiveUsers = await db
        .select({
          userId: users.id,
          email: users.email,
          firstName: users.firstName,
          username: users.username,
          lastActivityAt: userEngagement.lastActivityAt,
          userSegment: userEngagement.userSegment,
        })
        .from(users)
        .innerJoin(userEngagement, eq(users.id, userEngagement.userId))
        .innerJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .leftJoin(
          emailSendLog,
          and(
            eq(emailSendLog.userId, users.id),
            eq(emailSendLog.emailType, 'reengagement'),
            gte(emailSendLog.sentAt, oneMonthAgo)
          )
        )
        .where(
          and(
            // User registered at least 7 days ago
            lte(users.createdAt, sevenDaysAgo),
            // Last activity was 7+ days ago
            lte(userEngagement.lastActivityAt, sevenDaysAgo),
            // User is at_risk or dormant (not new users)
            sql`${userEngagement.userSegment} IN ('at_risk', 'dormant')`,
            // Email preferences allow re-engagement
            eq(emailPreferences.reengagementEmails, true),
            eq(emailPreferences.isUnsubscribed, false),
            // No re-engagement email sent in last 30 days
            sql`${emailSendLog.id} IS NULL`
          )
        )
        .limit(30); // Conservative batch size for re-engagement

      console.log(`Found ${inactiveUsers.length} users eligible for re-engagement emails`);

      if (inactiveUsers.length === 0) {
        return;
      }

      let successCount = 0;
      let failureCount = 0;

      for (const user of inactiveUsers) {
        try {
          await this.delay(200); // Longer delay for re-engagement emails
          
          const success = await this.sendReengagementEmail(user.userId);
          if (success) {
            successCount++;
            console.log(`‚úÖ Re-engagement email sent to ${user.email} (${user.userSegment})`);
          } else {
            failureCount++;
            console.log(`‚ùå Failed to send re-engagement email to ${user.email}`);
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Error sending re-engagement email to ${user.email}:`, error);
        }
      }

      console.log(`üìß Re-engagement campaign completed: ${successCount} sent, ${failureCount} failed`);
      
    } catch (error) {
      console.error('‚ùå Error in sendReengagementEmails:', error);
    }
  }

  /**
   * Send feature discovery emails to users who haven't used key features
   */
  private async sendFeatureDiscoveryEmails(): Promise<void> {
    try {
      console.log('üîç Starting feature discovery email campaign...');
      
      const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
      const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
      
      // Find users who:
      // 1. Registered at least 3 days ago (give them time to explore)
      // 2. Have low feature usage (files analyzed = 0 OR chat messages < 5)
      // 3. Are active or at_risk (not dormant)
      // 4. Haven't received feature discovery email in last 2 weeks
      const underutilizedUsers = await db
        .select({
          userId: users.id,
          email: users.email,
          firstName: users.firstName,
          username: users.username,
          filesAnalyzed: userEngagement.filesAnalyzed,
          chatMessagesCount: userEngagement.chatMessagesCount,
          userSegment: userEngagement.userSegment,
        })
        .from(users)
        .innerJoin(userEngagement, eq(users.id, userEngagement.userId))
        .innerJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .leftJoin(
          emailSendLog,
          and(
            eq(emailSendLog.userId, users.id),
            eq(emailSendLog.emailType, 'feature_discovery'),
            gte(emailSendLog.sentAt, twoWeeksAgo)
          )
        )
        .where(
          and(
            // Registered at least 3 days ago
            lte(users.createdAt, threeDaysAgo),
            // Low feature usage
            sql`(${userEngagement.filesAnalyzed} = 0 OR ${userEngagement.chatMessagesCount} < 5)`,
            // Active or at-risk users (not dormant)
            sql`${userEngagement.userSegment} IN ('new', 'active', 'at_risk')`,
            // Email preferences allow feature updates
            eq(emailPreferences.featureUpdates, true),
            eq(emailPreferences.isUnsubscribed, false),
            // No feature discovery email sent in last 2 weeks
            sql`${emailSendLog.id} IS NULL`
          )
        )
        .limit(40);

      console.log(`Found ${underutilizedUsers.length} users eligible for feature discovery emails`);

      if (underutilizedUsers.length === 0) {
        return;
      }

      let successCount = 0;
      let failureCount = 0;

      for (const user of underutilizedUsers) {
        try {
          await this.delay(150);
          
          const success = await this.sendFeatureDiscoveryEmail(user.userId);
          if (success) {
            successCount++;
            console.log(`‚úÖ Feature discovery email sent to ${user.email} (files: ${user.filesAnalyzed}, chats: ${user.chatMessagesCount})`);
          } else {
            failureCount++;
            console.log(`‚ùå Failed to send feature discovery email to ${user.email}`);
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Error sending feature discovery email to ${user.email}:`, error);
        }
      }

      console.log(`üîç Feature discovery campaign completed: ${successCount} sent, ${failureCount} failed`);
      
    } catch (error) {
      console.error('‚ùå Error in sendFeatureDiscoveryEmails:', error);
    }
  }

  /**
   * Send weekly usage insights to active users
   */
  private async sendWeeklyUsageInsights(): Promise<void> {
    try {
      console.log('üìä Starting weekly usage insights campaign...');
      
      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      const tenDaysAgo = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000);
      
      // Send on Sundays or if no email sent in the last week
      const today = new Date();
      const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
      
      // Find active users who:
      // 1. Have been active in the last 7 days
      // 2. Want usage insights and weekly frequency
      // 3. Haven't received insights email in the last week
      const activeUsers = await db
        .select({
          userId: users.id,
          email: users.email,
          firstName: users.firstName,
          username: users.username,
          lastActivityAt: userEngagement.lastActivityAt,
          userSegment: userEngagement.userSegment,
        })
        .from(users)
        .innerJoin(userEngagement, eq(users.id, userEngagement.userId))
        .innerJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .leftJoin(
          emailSendLog,
          and(
            eq(emailSendLog.userId, users.id),
            eq(emailSendLog.emailType, 'usage_insights'),
            gte(emailSendLog.sentAt, tenDaysAgo)
          )
        )
        .where(
          and(
            // Active in the last 7 days
            gte(userEngagement.lastActivityAt, oneWeekAgo),
            // Active users only
            eq(userEngagement.userSegment, 'active'),
            // Email preferences
            eq(emailPreferences.usageInsights, true),
            eq(emailPreferences.emailFrequency, 'weekly'),
            eq(emailPreferences.isUnsubscribed, false),
            // No insights email in last 10 days
            sql`${emailSendLog.id} IS NULL`
          )
        )
        .limit(25); // Conservative limit for insights emails

      console.log(`Found ${activeUsers.length} users eligible for weekly usage insights`);

      if (activeUsers.length === 0) {
        return;
      }

      let successCount = 0;
      let failureCount = 0;

      for (const user of activeUsers) {
        try {
          await this.delay(300); // Longer delay for insights emails
          
          const success = await this.sendUsageInsightsEmail(user.userId, 'week');
          if (success) {
            successCount++;
            console.log(`‚úÖ Usage insights email sent to ${user.email}`);
          } else {
            failureCount++;
            console.log(`‚ùå Failed to send usage insights email to ${user.email}`);
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Error sending usage insights email to ${user.email}:`, error);
        }
      }

      console.log(`üìä Weekly usage insights campaign completed: ${successCount} sent, ${failureCount} failed`);
      
    } catch (error) {
      console.error('‚ùå Error in sendWeeklyUsageInsights:', error);
    }
  }

  /**
   * Send weekly product tips based on user behavior
   */
  private async sendWeeklyProductTips(): Promise<void> {
    try {
      console.log('üí° Starting weekly product tips campaign...');
      
      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
      
      // Find users who:
      // 1. Want product tips
      // 2. Are active or at_risk (engaged enough to benefit from tips)
      // 3. Haven't received tips in the last 2 weeks
      const eligibleUsers = await db
        .select({
          userId: users.id,
          email: users.email,
          firstName: users.firstName,
          username: users.username,
          filesAnalyzed: userEngagement.filesAnalyzed,
          chatMessagesCount: userEngagement.chatMessagesCount,
          userSegment: userEngagement.userSegment,
        })
        .from(users)
        .innerJoin(userEngagement, eq(users.id, userEngagement.userId))
        .innerJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .leftJoin(
          emailSendLog,
          and(
            eq(emailSendLog.userId, users.id),
            eq(emailSendLog.emailType, 'product_tips'),
            gte(emailSendLog.sentAt, twoWeeksAgo)
          )
        )
        .where(
          and(
            // Users who might benefit from tips
            sql`${userEngagement.userSegment} IN ('new', 'active', 'at_risk')`,
            // Email preferences
            eq(emailPreferences.productTips, true),
            eq(emailPreferences.isUnsubscribed, false),
            // No tips email in last 2 weeks
            sql`${emailSendLog.id} IS NULL`
          )
        )
        .limit(35);

      console.log(`Found ${eligibleUsers.length} users eligible for product tips`);

      if (eligibleUsers.length === 0) {
        return;
      }

      let successCount = 0;
      let failureCount = 0;

      for (const user of eligibleUsers) {
        try {
          await this.delay(200);
          
          // Determine tip category based on user behavior
          let tipCategory = 'general';
          if ((user.filesAnalyzed || 0) > 0) {
            tipCategory = 'files';
          } else if ((user.chatMessagesCount || 0) > 10) {
            tipCategory = 'productivity';
          }
          
          const success = await this.sendProductTipsEmail(user.userId, tipCategory);
          if (success) {
            successCount++;
            console.log(`‚úÖ Product tips email sent to ${user.email} (category: ${tipCategory})`);
          } else {
            failureCount++;
            console.log(`‚ùå Failed to send product tips email to ${user.email}`);
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Error sending product tips email to ${user.email}:`, error);
        }
      }

      console.log(`üí° Weekly product tips campaign completed: ${successCount} sent, ${failureCount} failed`);
      
    } catch (error) {
      console.error('‚ùå Error in sendWeeklyProductTips:', error);
    }
  }

  // =============================================================================
  // PRIVATE HELPER METHODS
  // =============================================================================

  private async getUserForEmail(userId: number) {
    try {
      const result = await db
        .select({
          id: users.id,
          email: users.email,
          username: users.username,
          firstName: users.firstName,
          lastName: users.lastName,
          preferences: emailPreferences,
        })
        .from(users)
        .leftJoin(emailPreferences, eq(users.id, emailPreferences.userId))
        .where(eq(users.id, userId))
        .limit(1);

      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error('Error getting user for email:', error);
      return null;
    }
  }

  private async generateTrackingTokens() {
    const crypto = await import('crypto');
    return {
      openToken: crypto.randomBytes(16).toString('hex'),
      clickToken: crypto.randomBytes(16).toString('hex'),
    };
  }

  private async logEmailSent(
    userId: number, 
    emailType: string, 
    subject: string, 
    trackingTokens: { openToken: string; clickToken: string },
    campaignId?: number
  ) {
    try {
      const user = await db.select({ email: users.email }).from(users).where(eq(users.id, userId)).limit(1);
      if (!user.length) return;

      await db.insert(emailSendLog).values({
        userId,
        campaignId,
        emailType,
        emailSubject: subject,
        recipientEmail: user[0].email,
        openTrackingToken: trackingTokens.openToken,
        clickTrackingToken: trackingTokens.clickToken,
      });
    } catch (error) {
      console.error('Error logging email sent:', error);
    }
  }

  private async getUnusedFeatures(userId: number): Promise<string[]> {
    try {
      const engagement = await this.getUserEngagement(userId);
      if (!engagement) return [];

      const unusedFeatures = [];
      
      if ((engagement.filesUploaded || 0) === 0) {
        unusedFeatures.push('File Analysis');
      }
      
      if ((engagement.chatMessagesCount || 0) < 5) {
        unusedFeatures.push('Advanced Chat Features');
      }

      // Check for model selection usage (this would need tracking)
      unusedFeatures.push('Model Selection');

      return unusedFeatures;
    } catch (error) {
      console.error('Error getting unused features:', error);
      return [];
    }
  }

  private async getUserStats(userId: number, period: 'week' | 'month') {
    try {
      const daysBack = period === 'week' ? 7 : 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - daysBack);

      const activities = await db
        .select()
        .from(userActivity)
        .where(
          and(
            eq(userActivity.userId, userId),
            gte(userActivity.timestamp, startDate)
          )
        );

      const sessionCount = activities.filter(a => a.activityType === 'session_start').length;
      const messageCount = activities.filter(a => a.activityType === 'chat_message').length;
      const filesAnalyzed = activities.filter(a => a.activityType === 'file_analyze').length;
      const totalDuration = activities
        .filter(a => a.activityType === 'session_end')
        .reduce((sum, a) => sum + (a.duration || 0), 0);

      // Find most active day
      const dailyActivities: Record<string, number> = {};
      activities.forEach(activity => {
        const day = activity.timestamp?.toISOString().split('T')[0] || '';
        dailyActivities[day] = (dailyActivities[day] || 0) + 1;
      });

      const mostActiveDay = Object.entries(dailyActivities)
        .sort(([,a], [,b]) => b - a)[0];

      const achievements = [];
      if (sessionCount >= 5) achievements.push('Consistent user - 5+ sessions');
      if (messageCount >= 50) achievements.push('Chat master - 50+ messages');
      if (filesAnalyzed >= 3) achievements.push('File analyzer - 3+ files');

      return {
        sessions: sessionCount,
        messages: messageCount,
        filesAnalyzed,
        timeSpent: Math.round(totalDuration / 60), // Convert to minutes
        mostActiveDay: mostActiveDay ? new Date(mostActiveDay[0]).toLocaleDateString('en-US', { weekday: 'long' }) : 'Wednesday',
        mostActiveDayCount: mostActiveDay ? mostActiveDay[1] : 0,
        achievements,
      };
    } catch (error) {
      console.error('Error getting user stats:', error);
      return null;
    }
  }

  /**
   * Add delay between email sends to respect rate limits
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Create singleton instance
export const engagementService = new EngagementService();

================
File: server/file-storage.ts
================
import { 
  files, 
  fileVersions, 
  filePermissions, 
  fileInteractions,
  type File, 
  type InsertFile, 
  type UpdateFile, 
  type FileVersion, 
  type FilePermission,
  type ShareFile,
  type InsertFileInteraction
} from "@shared/schema";
import { eq, desc, and, or, like, sql, isNull } from "drizzle-orm";
import { db } from "./db";
import { randomBytes } from "crypto";
import dotenv from "dotenv";
dotenv.config();

export interface FileStorageService {
  // Core file operations
  uploadFile(userId: number, fileData: {
    name: string;
    originalName: string;
    mimeType: string;
    content: Buffer | string;
    size: number;
    folder?: string;
    description?: string;
    tags?: string[];
  }): Promise<File>;
  
  getFile(fileId: number, userId: number): Promise<File | null>;
  getFileContent(fileId: number, userId: number): Promise<{ content: string; mimeType: string } | null>;
  updateFile(fileId: number, userId: number, updates: UpdateFile): Promise<File | null>;
  deleteFile(fileId: number, userId: number): Promise<boolean>;
  
  // File listing and search
  listUserFiles(userId: number, options?: {
    folder?: string;
    search?: string;
    tags?: string[];
    mimeType?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ files: File[]; total: number }>;
  
  // Version control
  createFileVersion(fileId: number, userId: number, content: Buffer | string, changeDescription?: string): Promise<FileVersion>;
  getFileVersions(fileId: number, userId: number): Promise<FileVersion[]>;
  restoreFileVersion(fileId: number, versionId: number, userId: number): Promise<File | null>;
  
  // File sharing and permissions
  shareFile(fileId: number, ownerId: number, shareData: ShareFile): Promise<FilePermission>;
  getFilePermissions(fileId: number, userId: number): Promise<FilePermission[]>;
  checkFileAccess(fileId: number, userId: number, requiredPermission?: 'read' | 'write' | 'admin'): Promise<boolean>;
  
  // Analytics and interactions
  logFileInteraction(fileId: number, userId: number, interaction: InsertFileInteraction): Promise<void>;
  getFileAnalytics(fileId: number, userId: number): Promise<any>;
  
  // AI Integration
  analyzeFileWithAI(fileId: number, userId: number): Promise<any>;
  updateFileAnalysis(fileId: number, analysis: any): Promise<File | null>;
}

export class DatabaseFileStorage implements FileStorageService {
  
  async uploadFile(userId: number, fileData: {
    name: string;
    originalName: string;
    mimeType: string;
    content: Buffer | string;
    size: number;
    folder?: string;
    description?: string;
    tags?: string[];
  }): Promise<File> {
    try {
      // Convert content to base64 if it's a Buffer
      let contentString: string;
      let encoding = 'utf-8';
      
      if (Buffer.isBuffer(fileData.content)) {
        if (fileData.mimeType.startsWith('text/') || fileData.mimeType === 'application/json') {
          contentString = fileData.content.toString('utf-8');
        } else {
          contentString = fileData.content.toString('base64');
          encoding = 'base64';
        }
      } else {
        contentString = fileData.content;
      }
      
      const newFile = {
        userId,
        name: fileData.name,
        originalName: fileData.originalName,
        mimeType: fileData.mimeType,
        content: contentString,
        encoding,
        size: fileData.size,
        folder: fileData.folder || '/',
        description: fileData.description || null,
        tags: fileData.tags || [],
        analysisStatus: 'pending',
        status: 'active',
        currentVersion: 1,
      };
      
      const result = await db.insert(files).values(newFile).returning();
      const file = result[0];
      
      // Create initial version
      await this.createFileVersion(file.id, userId, fileData.content, 'Initial upload');
      
      // Log upload interaction
      await this.logFileInteraction(file.id, userId, {
        interactionType: 'edit',
        details: { action: 'upload', originalName: fileData.originalName }
      });
      
      return file;
    } catch (error) {
      console.error("Error uploading file:", error);
      throw error;
    }
  }
  
  async getFile(fileId: number, userId: number): Promise<File | null> {
    try {
      // Check access first
      const hasAccess = await this.checkFileAccess(fileId, userId, 'read');
      if (!hasAccess) {
        return null;
      }
      
      const result = await db.select().from(files).where(eq(files.id, fileId));
      const file = result[0];
      
      if (file) {
        // Update last accessed time
        await db.update(files)
          .set({ lastAccessedAt: new Date() })
          .where(eq(files.id, fileId));
        
        // Log view interaction
        await this.logFileInteraction(fileId, userId, {
          interactionType: 'view',
          details: { timestamp: new Date().toISOString() }
        });
      }
      
      return file || null;
    } catch (error) {
      console.error("Error getting file:", error);
      return null;
    }
  }
  
  async getFileContent(fileId: number, userId: number): Promise<{ content: string; mimeType: string } | null> {
    try {
      const file = await this.getFile(fileId, userId);
      if (!file || !file.content) {
        return null;
      }
      
      return {
        content: file.content,
        mimeType: file.mimeType
      };
    } catch (error) {
      console.error("Error getting file content:", error);
      return null;
    }
  }
  
  async updateFile(fileId: number, userId: number, updates: UpdateFile): Promise<File | null> {
    try {
      // Check write access
      const hasAccess = await this.checkFileAccess(fileId, userId, 'write');
      if (!hasAccess) {
        return null;
      }
      
      const result = await db
        .update(files)
        .set({ ...updates, updatedAt: new Date() })
        .where(eq(files.id, fileId))
        .returning();
      
      if (result[0]) {
        // Log update interaction
        await this.logFileInteraction(fileId, userId, {
          interactionType: 'edit',
          details: { action: 'update', changes: Object.keys(updates) }
        });
      }
      
      return result[0] || null;
    } catch (error) {
      console.error("Error updating file:", error);
      return null;
    }
  }
  
  async deleteFile(fileId: number, userId: number): Promise<boolean> {
    try {
      // Check admin access or ownership
      const hasAccess = await this.checkFileAccess(fileId, userId, 'admin');
      if (!hasAccess) {
        return false;
      }
      
      // Soft delete by updating status
      const result = await db
        .update(files)
        .set({ 
          status: 'deleted',
          updatedAt: new Date()
        })
        .where(eq(files.id, fileId))
        .returning();
      
      if (result[0]) {
        // Log delete interaction
        await this.logFileInteraction(fileId, userId, {
          interactionType: 'delete',
          details: { action: 'soft_delete', timestamp: new Date().toISOString() }
        });
      }
      
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting file:", error);
      return false;
    }
  }
  
  async listUserFiles(userId: number, options?: {
    folder?: string;
    search?: string;
    tags?: string[];
    mimeType?: string;
    limit?: number;
    offset?: number;
  }): Promise<{ files: File[]; total: number }> {
    try {
      const limit = options?.limit || 50;
      const offset = options?.offset || 0;
      
      // Build dynamic where conditions
      const conditions = [
        eq(files.status, 'active'),
        or(
          eq(files.userId, userId),
          // Include files shared with the user
          sql`EXISTS (
            SELECT 1 FROM ${filePermissions} fp 
            WHERE fp.file_id = ${files.id} 
            AND fp.user_id = ${userId}
          )`
        )
      ];
      
      if (options?.folder) {
        conditions.push(eq(files.folder, options.folder));
      }
      
      if (options?.search) {
        conditions.push(
          or(
            like(files.name, `%${options.search}%`),
            like(files.description, `%${options.search}%`)
          )
        );
      }
      
      if (options?.mimeType) {
        conditions.push(like(files.mimeType, `${options.mimeType}%`));
      }
      
      if (options?.tags && options.tags.length > 0) {
        conditions.push(
          sql`${files.tags} @> ${JSON.stringify(options.tags)}`
        );
      }
      
      const whereClause = and(...conditions);
      
      // Get total count
      const countResult = await db
        .select({ count: sql<number>`count(*)` })
        .from(files)
        .where(whereClause);
      
      const total = countResult[0]?.count || 0;
      
      // Get files
      const fileResults = await db
        .select()
        .from(files)
        .where(whereClause)
        .orderBy(desc(files.updatedAt))
        .limit(limit)
        .offset(offset);
      
      return { files: fileResults, total };
    } catch (error) {
      console.error("Error listing files:", error);
      return { files: [], total: 0 };
    }
  }
  
  async createFileVersion(fileId: number, userId: number, content: Buffer | string, changeDescription?: string): Promise<FileVersion> {
    try {
      // Get current version number
      const currentFile = await db.select().from(files).where(eq(files.id, fileId));
      if (!currentFile[0]) {
        throw new Error('File not found');
      }
      
      const file = currentFile[0];
      const nextVersion = (file.currentVersion || 0) + 1;
      
      // Convert content to string
      let contentString: string;
      if (Buffer.isBuffer(content)) {
        if (currentFile[0].mimeType.startsWith('text/') || currentFile[0].mimeType === 'application/json') {
          contentString = content.toString('utf-8');
        } else {
          contentString = content.toString('base64');
        }
      } else {
        contentString = content;
      }
      
      const versionData = {
        fileId,
        versionNumber: nextVersion,
        content: contentString,
        size: Buffer.byteLength(contentString, 'utf-8'),
        changeDescription: changeDescription || `Version ${nextVersion}`,
        changeType: 'update',
        createdBy: userId,
      };
      
      const result = await db.insert(fileVersions).values(versionData).returning();
      
      // Update file's current version
      await db
        .update(files)
        .set({ 
          currentVersion: nextVersion,
          content: contentString,
          size: versionData.size,
          updatedAt: new Date()
        })
        .where(eq(files.id, fileId));
      
      return result[0];
    } catch (error) {
      console.error("Error creating file version:", error);
      throw error;
    }
  }
  
  async getFileVersions(fileId: number, userId: number): Promise<FileVersion[]> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, userId, 'read');
      if (!hasAccess) {
        return [];
      }
      
      const result = await db
        .select()
        .from(fileVersions)
        .where(eq(fileVersions.fileId, fileId))
        .orderBy(desc(fileVersions.versionNumber));
      
      return result;
    } catch (error) {
      console.error("Error getting file versions:", error);
      return [];
    }
  }
  
  async restoreFileVersion(fileId: number, versionId: number, userId: number): Promise<File | null> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, userId, 'write');
      if (!hasAccess) {
        return null;
      }
      
      // Get the version to restore
      const versionResult = await db
        .select()
        .from(fileVersions)
        .where(
          and(
            eq(fileVersions.id, versionId),
            eq(fileVersions.fileId, fileId)
          )
        );
      
      if (!versionResult[0]) {
        return null;
      }
      
      const version = versionResult[0];
      
      // Create new version with restored content
      await this.createFileVersion(
        fileId, 
        userId, 
        version.content, 
        `Restored from version ${version.versionNumber}`
      );
      
      // Log restore interaction
      await this.logFileInteraction(fileId, userId, {
        interactionType: 'edit',
        details: { 
          action: 'restore',
          restoredFromVersion: version.versionNumber
        }
      });
      
      // Return updated file
      return await this.getFile(fileId, userId);
    } catch (error) {
      console.error("Error restoring file version:", error);
      return null;
    }
  }
  
  async shareFile(fileId: number, ownerId: number, shareData: ShareFile): Promise<FilePermission> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, ownerId, 'admin');
      if (!hasAccess) {
        throw new Error('Insufficient permissions to share file');
      }
      
      const shareToken = randomBytes(32).toString('hex');
      const shareExpiry = shareData.shareExpiry ? new Date(shareData.shareExpiry) : null;
      
      const permissionData = {
        fileId,
        userId: shareData.userId || null,
        permission: shareData.permission,
        sharedBy: ownerId,
        shareToken,
        shareExpiry,
      };
      
      const result = await db.insert(filePermissions).values(permissionData).returning();
      
      // Log share interaction
      await this.logFileInteraction(fileId, ownerId, {
        interactionType: 'share',
        details: {
          sharedWith: shareData.userId || 'public',
          permission: shareData.permission,
          shareToken: shareToken
        }
      });
      
      return result[0];
    } catch (error) {
      console.error("Error sharing file:", error);
      throw error;
    }
  }
  
  async getFilePermissions(fileId: number, userId: number): Promise<FilePermission[]> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, userId, 'read');
      if (!hasAccess) {
        return [];
      }
      
      const result = await db
        .select()
        .from(filePermissions)
        .where(eq(filePermissions.fileId, fileId))
        .orderBy(desc(filePermissions.createdAt));
      
      return result;
    } catch (error) {
      console.error("Error getting file permissions:", error);
      return [];
    }
  }
  
  async checkFileAccess(fileId: number, userId: number, requiredPermission: 'read' | 'write' | 'admin' = 'read'): Promise<boolean> {
    try {
      // Get file to check ownership
      const fileResult = await db.select().from(files).where(eq(files.id, fileId));
      if (!fileResult[0]) {
        return false;
      }
      
      const file = fileResult[0];
      
      // Owner has all permissions
      if (file.userId === userId) {
        return true;
      }
      
      // Check if file is public for read access
      if (requiredPermission === 'read' && file.isPublic) {
        return true;
      }
      
      // Check explicit permissions
      const permissionResult = await db
        .select()
        .from(filePermissions)
        .where(
          and(
            eq(filePermissions.fileId, fileId),
            eq(filePermissions.userId, userId),
            or(
              isNull(filePermissions.shareExpiry),
              sql`${filePermissions.shareExpiry} > NOW()`
            )
          )
        );
      
      if (!permissionResult[0]) {
        return false;
      }
      
      const permission = permissionResult[0].permission;
      
      // Check permission hierarchy: owner > admin > write > read
      const permissionLevels = {
        'read': 1,
        'write': 2,
        'admin': 3,
        'owner': 4
      };
      
      const userLevel = permissionLevels[permission as keyof typeof permissionLevels] || 0;
      const requiredLevel = permissionLevels[requiredPermission] || 0;
      
      return userLevel >= requiredLevel;
    } catch (error) {
      console.error("Error checking file access:", error);
      return false;
    }
  }
  
  async logFileInteraction(fileId: number, userId: number, interaction: InsertFileInteraction): Promise<void> {
    try {
      const interactionData = {
        fileId,
        userId,
        ...interaction,
        createdAt: new Date()
      };
      
      await db.insert(fileInteractions).values(interactionData);
    } catch (error) {
      console.error("Error logging file interaction:", error);
      // Don't throw - logging failures shouldn't break the main flow
    }
  }
  
  async getFileAnalytics(fileId: number, userId: number): Promise<any> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, userId, 'read');
      if (!hasAccess) {
        return null;
      }
      
      // Get interaction statistics
      const interactionStats = await db
        .select({
          interactionType: fileInteractions.interactionType,
          count: sql<number>`count(*)`,
          lastInteraction: sql<Date>`max(${fileInteractions.createdAt})`
        })
        .from(fileInteractions)
        .where(eq(fileInteractions.fileId, fileId))
        .groupBy(fileInteractions.interactionType);
      
      // Get version count
      const versionCount = await db
        .select({ count: sql<number>`count(*)` })
        .from(fileVersions)
        .where(eq(fileVersions.fileId, fileId));
      
      return {
        interactions: interactionStats,
        totalVersions: versionCount[0]?.count || 0,
        lastActivity: interactionStats.reduce((latest, stat) => {
          return !latest || stat.lastInteraction > latest 
            ? stat.lastInteraction 
            : latest;
        }, null as Date | null)
      };
    } catch (error) {
      console.error("Error getting file analytics:", error);
      return null;
    }
  }
  
  async analyzeFileWithAI(fileId: number, userId: number): Promise<any> {
    try {
      const hasAccess = await this.checkFileAccess(fileId, userId, 'read');
      if (!hasAccess) {
        throw new Error('Insufficient permissions');
      }
      
      const file = await this.getFile(fileId, userId);
      if (!file || !file.content) {
        throw new Error('File not found or empty');
      }
      
      // Update analysis status
      await db
        .update(files)
        .set({ analysisStatus: 'analyzing' })
        .where(eq(files.id, fileId));
      
      // Import Azure AI service dynamically to avoid circular dependencies
      const { createAzureAIClient, extractAzureAIError, parseAzureAIJSON } = await import('./routes');
      const { client, config } = createAzureAIClient();
      
      // Determine analysis type based on file type and content size
      let analysisPrompt = '';
      let fileContent = file.content;
      
      // Limit content size to prevent token limit issues (roughly 4000 characters)
      const maxContentLength = 4000;
      if (fileContent.length > maxContentLength) {
        fileContent = fileContent.substring(0, maxContentLength) + '\n\n[Content truncated due to length]';
      }
      
      if (file.encoding === 'base64' && !file.mimeType.startsWith('text/')) {
        // For binary files, analyze metadata only
        analysisPrompt = `Analyze this file based on its metadata:

File Name: ${file.name}
Original Name: ${file.originalName}
MIME Type: ${file.mimeType}
Size: ${file.size} bytes
Description: ${file.description || 'No description'}
Tags: ${file.tags?.join(', ') || 'No tags'}

Provide insights about the file type, potential use cases, and any security considerations.

IMPORTANT: You must respond with ONLY valid JSON in this exact format:
{
  "summary": "Brief description of the file and its purpose",
  "quality": "excellent|good|fair|poor",
  "complexity": "low|medium|high",
  "improvements": ["suggestion1", "suggestion2"],
  "security": "Security assessment and recommendations",
  "confidence": "high|medium|low"
}

Do not include any text before or after the JSON. Ensure all string values are properly quoted.`;
        fileContent = ''; // Don't send binary content to AI
      } else {
        // For text files, analyze content
        analysisPrompt = `Analyze this ${file.mimeType} file:

File Name: ${file.name}
Content:
${fileContent}

Provide a comprehensive analysis including:
- Content summary
- Code quality assessment (if applicable)
- Potential improvements
- Security considerations
- Complexity assessment

IMPORTANT: You must respond with ONLY valid JSON in this exact format:
{
  "summary": "Comprehensive summary of the file content and purpose",
  "quality": "excellent|good|fair|poor",
  "complexity": "low|medium|high",
  "improvements": ["specific improvement suggestion 1", "specific improvement suggestion 2"],
  "security": "Detailed security assessment and recommendations",
  "confidence": "high|medium|low"
}

For quality assessment:
- "excellent": Well-structured, follows best practices, clean code
- "good": Generally well-written with minor issues
- "fair": Has some issues but functional
- "poor": Significant problems, needs major improvements

For complexity assessment:
- "low": Simple, straightforward code/content
- "medium": Moderate complexity, some advanced features
- "high": Complex logic, advanced patterns, difficult to understand

Do not include any text before or after the JSON. Ensure all string values are properly quoted.`;
      }
      
      console.log(`Analyzing file ${fileId} with Azure AI...`);
      
      const response = await client.path("/chat/completions").post({
        body: {
          messages: [
            {
              role: "system",
              content: "You are an expert file analyzer and code reviewer. Provide thorough, actionable insights about files. You MUST respond with ONLY valid JSON in the exact format specified by the user. Do not include any explanatory text, markdown formatting, or content outside the JSON object. Ensure all JSON is properly formatted with correct quotes, commas, and brackets."
            },
            {
              role: "user",
              content: analysisPrompt
            }
          ],
          max_tokens: 2048,
          temperature: 0.1, // Lower temperature for more consistent JSON output
          model: config.modelName,
          stream: false,
          response_format: { type: "json_object" } // Enforce JSON response format
        },
      });
      
      console.log(`Azure AI response status: ${response.status}`);
      
      // Check for successful response (2xx status codes)
      if (response.status < 200 || response.status >= 300) {
        const errorDetails = response.body?.error || response.body || 'Unknown error';
        console.error('Azure AI API error response:', errorDetails);
        throw new Error(`Azure AI API error: ${extractAzureAIError(errorDetails)}`);
      }
      
      // Extract response content
      const responseBody = response.body;
      if (!responseBody || !responseBody.choices || !responseBody.choices[0]) {
        throw new Error('Invalid response structure from Azure AI API');
      }
      
      const aiResponse = responseBody.choices[0].message?.content || "";
      console.log(`Azure AI response content length: ${aiResponse.length}`);
      
      if (!aiResponse.trim()) {
        throw new Error('Empty response from Azure AI API');
      }
      
      // Parse the AI response
      let analysis = parseAzureAIJSON(aiResponse);
      
      if (!analysis) {
        console.warn('Failed to parse Azure AI response as JSON. Response preview:', aiResponse.substring(0, 300));
        console.warn('Full AI response for debugging:', aiResponse);
        
        // Enhanced fallback analysis with meaningful values
        analysis = {
          summary: aiResponse.substring(0, 500) + (aiResponse.length > 500 ? '...' : ''),
          analysisType: 'basic',
          confidence: 'low',
          error: 'Failed to parse AI response as JSON',
          rawResponse: aiResponse.substring(0, 1000), // Store first 1000 chars for debugging
          // Provide intelligent fallback values based on response content
          quality: this.inferQualityFromResponse(aiResponse),
          complexity: this.inferComplexityFromResponse(aiResponse),
          improvements: this.extractImprovementsFromResponse(aiResponse),
          security: this.extractSecurityFromResponse(aiResponse)
        };
      }
      
      // Validate and normalize the parsed analysis
      analysis = this.validateAndNormalizeAnalysis(analysis, aiResponse);
      
      // Ensure analysis has required fields
      analysis = {
        summary: analysis.summary || 'Analysis completed',
        quality: analysis.quality || 'unknown',
        improvements: analysis.improvements || [],
        security: analysis.security || 'No security issues identified',
        complexity: analysis.complexity || 'unknown',
        analysisType: analysis.analysisType || 'ai_analysis',
        confidence: analysis.confidence || 'medium',
        ...analysis
      };
      
      // Add metadata to analysis
      analysis.analyzedAt = new Date().toISOString();
      analysis.fileMetadata = {
        name: file.name,
        mimeType: file.mimeType,
        size: file.size,
        encoding: file.encoding
      };
      
      console.log(`Analysis completed for file ${fileId}:`, {
        summary: analysis.summary?.substring(0, 100) + '...',
        complexity: analysis.complexity,
        confidence: analysis.confidence
      });
      
      // Update file with analysis results
      await this.updateFileAnalysis(fileId, analysis);
      
      // Log analysis interaction
      await this.logFileInteraction(fileId, userId, {
        interactionType: 'analyze',
        details: { 
          analysisType: 'ai_analysis', 
          success: true, 
          analysisId: `analysis_${fileId}_${Date.now()}`,
          model: config.modelName
        }
      });
      
      return analysis;
    } catch (error) {
      console.error("Error analyzing file with AI:", error);
      
      // Update analysis status to failed
      await db
        .update(files)
        .set({ analysisStatus: 'failed' })
        .where(eq(files.id, fileId));
      
      // Log failed analysis
      await this.logFileInteraction(fileId, userId, {
        interactionType: 'analyze',
        details: { 
          analysisType: 'ai_analysis', 
          success: false, 
          error: error instanceof Error ? error.message : String(error),
          timestamp: new Date().toISOString()
        }
      });
      
      throw error;
    }
  }
  
  async updateFileAnalysis(fileId: number, analysis: any): Promise<File | null> {
    try {
      const result = await db
        .update(files)
        .set({
          aiAnalysis: analysis,
          analysisStatus: 'completed',
          analyzedAt: new Date(),
          updatedAt: new Date()
        })
        .where(eq(files.id, fileId))
        .returning();
      
      return result[0] || null;
    } catch (error) {
      console.error("Error updating file analysis:", error);
      return null;
    }
  }

  private inferQualityFromResponse(response: string): string {
    const lowerResponse = response.toLowerCase();
    if (lowerResponse.includes('excellent') || lowerResponse.includes('well-structured') || lowerResponse.includes('clean code')) {
      return 'excellent';
    }
    if (lowerResponse.includes('good') || lowerResponse.includes('generally well-written') || lowerResponse.includes('minor issues')) {
      return 'good';
    }
    if (lowerResponse.includes('fair') || lowerResponse.includes('some issues') || lowerResponse.includes('functional')) {
      return 'fair';
    }
    if (lowerResponse.includes('poor') || lowerResponse.includes('significant problems') || lowerResponse.includes('needs major improvements')) {
      return 'poor';
    }
    return 'unknown';
  }

  private inferComplexityFromResponse(response: string): string {
    const lowerResponse = response.toLowerCase();
    if (lowerResponse.includes('low') || lowerResponse.includes('simple') || lowerResponse.includes('straightforward')) {
      return 'low';
    }
    if (lowerResponse.includes('medium') || lowerResponse.includes('moderate complexity') || lowerResponse.includes('some advanced features')) {
      return 'medium';
    }
    if (lowerResponse.includes('high') || lowerResponse.includes('complex logic') || lowerResponse.includes('advanced patterns') || lowerResponse.includes('difficult to understand')) {
      return 'high';
    }
    return 'unknown';
  }

  private extractImprovementsFromResponse(response: string): string[] {
    const improvements: string[] = [];
    const lowerResponse = response.toLowerCase();

    // Look for "improvements" or "suggestions"
    const improvementsMatch = lowerResponse.match(/improvements?:?\s*\[(.*?)\]/);
    if (improvementsMatch && improvementsMatch[1]) {
      const suggestions = improvementsMatch[1].split(',').map(s => s.trim());
      improvements.push(...suggestions);
    }

    // Look for "specific improvement suggestion"
    const specificImprovementsMatch = lowerResponse.match(/specific improvement suggestion\s*(\d+):\s*(.*?)(?=,|$)/g);
    if (specificImprovementsMatch) {
      specificImprovementsMatch.forEach(match => {
        const parts = match.split(':');
        if (parts.length > 1) {
          improvements.push(parts[1].trim());
        }
      });
    }

    // Look for "suggestion"
    const suggestionsMatch = lowerResponse.match(/suggestion\s*(\d+):\s*(.*?)(?=,|$)/g);
    if (suggestionsMatch) {
      suggestionsMatch.forEach(match => {
        const parts = match.split(':');
        if (parts.length > 1) {
          improvements.push(parts[1].trim());
        }
      });
    }

    // Look for "improvement"
    const improvementMatch = lowerResponse.match(/improvement\s*(\d+):\s*(.*?)(?=,|$)/g);
    if (improvementMatch) {
      improvementMatch.forEach(match => {
        const parts = match.split(':');
        if (parts.length > 1) {
          improvements.push(parts[1].trim());
        }
      });
    }

    // Remove duplicates and trim
    return Array.from(new Set(improvements.map((s: string) => s.trim()).filter((s: string) => s)));
  }

  private extractSecurityFromResponse(response: string): string {
    const lowerResponse = response.toLowerCase();
    if (lowerResponse.includes('security assessment') || lowerResponse.includes('recommendations') || lowerResponse.includes('considerations')) {
      return 'Detailed security assessment and recommendations';
    }
    if (lowerResponse.includes('no security issues')) {
      return 'No security issues identified';
    }
    return 'Unknown';
  }

  private validateAndNormalizeAnalysis(analysis: any, rawResponse: string): any {
    // Ensure summary is a string
    analysis.summary = String(analysis.summary || 'Analysis completed');

    // Ensure quality is one of the expected values
    analysis.quality = ['excellent', 'good', 'fair', 'poor', 'unknown'].includes(analysis.quality) ? analysis.quality : 'unknown';

    // Ensure complexity is one of the expected values
    analysis.complexity = ['low', 'medium', 'high', 'unknown'].includes(analysis.complexity) ? analysis.complexity : 'unknown';

    // Ensure confidence is one of the expected values
    analysis.confidence = ['high', 'medium', 'low', 'unknown'].includes(analysis.confidence) ? analysis.confidence : 'medium';

    // Ensure improvements is an array of strings
    analysis.improvements = Array.isArray(analysis.improvements) ? analysis.improvements.map((s: any) => String(s).trim()) : [];

    // Ensure security is a string
    analysis.security = String(analysis.security || 'No security issues identified');

    // Ensure analysisType is a string
    analysis.analysisType = String(analysis.analysisType || 'ai_analysis');

    // Ensure analyzedAt is a string
    analysis.analyzedAt = String(analysis.analyzedAt || new Date().toISOString());

    // Ensure fileMetadata is an object
    analysis.fileMetadata = analysis.fileMetadata || {};

    // Ensure rawResponse is a string
    analysis.rawResponse = String(analysis.rawResponse || rawResponse.substring(0, 1000)); // Fallback to first 1000 chars

    return analysis;
  }
}

// Export singleton instance
export const fileStorage = new DatabaseFileStorage();

================
File: server/friends-family-migration.ts
================
import { db } from './db';
import { users, subscriptionPlans, subscriptions } from '@shared/schema';
import { eq } from 'drizzle-orm';

/**
 * Migration script to implement Friends & Family subscription for existing users
 * 
 * This script:
 * 1. Creates a "Friends & Family" subscription plan if it doesn't exist
 * 2. Assigns this plan to ALL existing users in the database
 * 3. Updates their subscription status to "active"
 * 4. Sets their subscription tier to "friends_family"
 * 5. Provides a generous subscription end date (1 year from now)
 * 
 * IMPORTANT: This migration follows the zero-deletion policy - it only adds/updates data
 */

interface MigrationResult {
  success: boolean;
  planCreated: boolean;
  planId: number | null;
  usersUpdated: number;
  subscriptionsCreated: number;
  errors: string[];
  details: string[];
}

export async function migrateFriendsFamilySubscription(): Promise<MigrationResult> {
  const result: MigrationResult = {
    success: false,
    planCreated: false,
    planId: null,
    usersUpdated: 0,
    subscriptionsCreated: 0,
    errors: [],
    details: []
  };

  try {
    console.log('üöÄ Starting Friends & Family subscription migration...');
    
    // Step 1: Check if Friends & Family plan already exists
    const existingPlan = await db.select()
      .from(subscriptionPlans)
      .where(eq(subscriptionPlans.name, 'Friends & Family'))
      .limit(1);

    let friendsFamilyPlan;
    
    if (existingPlan.length > 0) {
      friendsFamilyPlan = existingPlan[0];
      result.details.push(`‚úì Friends & Family plan already exists (ID: ${friendsFamilyPlan.id})`);
    } else {
      // Step 2: Create the Friends & Family plan
      console.log('üìù Creating Friends & Family subscription plan...');
      
             const newPlan = await db.insert(subscriptionPlans).values({
         name: 'Friends & Family',
         description: 'Special access for friends and family members to test the full NomadAI experience',
         price: '0.00', // Free plan
         interval: 'month',
         features: [
           'Unlimited AI interactions',
           'Advanced code analysis', 
           'UI generation & cloning',
           'Performance insights',
           'Design pattern analysis',
           'All AI models available',
           'Code improvement suggestions',
           'Advanced debugging assistance',
           'Friends & Family special access'
         ],
         stripePriceId: 'price_1RmslfJYFJQbKiIKgGYujWWC', // Actual Stripe price ID for Friends & Family
         stripeProductId: 'prod_friends_family', // Placeholder - update with actual product ID if needed
         isActive: true,
         sortOrder: 0 // Put it first in the list
       }).returning();

      friendsFamilyPlan = newPlan[0];
      result.planCreated = true;
      result.details.push(`‚úì Created Friends & Family plan (ID: ${friendsFamilyPlan.id})`);
    }

    result.planId = friendsFamilyPlan.id;

    // Step 3: Get ONLY users who are currently on free tier (safe to migrate)
    console.log('üë• Fetching users on free tier only (preserving paid users)...');
    const freeUsers = await db.select().from(users)
      .where(eq(users.subscriptionTier, 'free'));
    
    result.details.push(`üìä Found ${freeUsers.length} users on free tier to migrate`);
    result.details.push(`üîí Preserving all existing paid subscriptions (no changes to paid users)`);

    if (freeUsers.length === 0) {
      result.details.push('‚ö†Ô∏è No free tier users found to migrate - all users appear to have existing subscriptions');
      result.success = true;
      return result;
    }

    // Step 4: Set subscription end date to 1 year from now
    const subscriptionEndDate = new Date();
    subscriptionEndDate.setFullYear(subscriptionEndDate.getFullYear() + 1);

    // Step 5: Update ONLY free tier users with Friends & Family subscription
    console.log('üîÑ Updating free tier users to Friends & Family subscription...');
    
    for (const user of freeUsers) {
      try {
        // Double-check: Only proceed if user is truly on free tier
        if (user.subscriptionTier !== 'free') {
          result.details.push(`‚ö†Ô∏è Skipping user ${user.email} - not on free tier (tier: ${user.subscriptionTier})`);
          continue;
        }

        // Update user subscription fields (safe - only free tier users)
        await db.update(users)
          .set({
            subscriptionStatus: 'active',
            subscriptionTier: 'friends_family',
            subscriptionEndsAt: subscriptionEndDate,
            updatedAt: new Date()
          })
          .where(eq(users.id, user.id));

        // Check for existing subscription records
        const existingSubscription = await db.select()
          .from(subscriptions)
          .where(eq(subscriptions.userId, user.id))
          .limit(1);

        if (existingSubscription.length === 0) {
          // Safe to create new subscription record
          await db.insert(subscriptions).values({
            userId: user.id,
            planId: friendsFamilyPlan.id,
            status: 'active',
            currentPeriodStart: new Date(),
            currentPeriodEnd: subscriptionEndDate,
            cancelAtPeriodEnd: false,
            createdAt: new Date(),
            updatedAt: new Date()
          });
          result.subscriptionsCreated++;
        } else {
          // SAFETY CHECK: Only update if existing subscription is also free/inactive
          const existingSub = existingSubscription[0];
          if (existingSub.status === 'active' && existingSub.planId !== null) {
            result.details.push(`üîí Preserving existing active subscription for user ${user.email} (ID: ${existingSub.id})`);
            continue; // Skip this user to preserve their existing subscription
          }
          
          // Safe to update inactive/free subscription
          await db.update(subscriptions)
            .set({
              planId: friendsFamilyPlan.id,
              status: 'active',
              currentPeriodStart: new Date(),
              currentPeriodEnd: subscriptionEndDate,
              cancelAtPeriodEnd: false,
              updatedAt: new Date()
            })
            .where(eq(subscriptions.id, existingSub.id));
        }

        result.usersUpdated++;
        
        result.details.push(`‚úì Updated user ${user.email} (ID: ${user.id})`);
        
      } catch (error) {
        const errorMsg = `Failed to update user ${user.email} (ID: ${user.id}): ${error}`;
        result.errors.push(errorMsg);
        console.error(errorMsg);
      }
    }

    result.success = result.errors.length === 0;
    
    console.log('‚úÖ Migration completed successfully!');
    result.details.push(`üéâ Migration completed: ${result.usersUpdated} users updated, ${result.subscriptionsCreated} subscriptions created`);
    
  } catch (error) {
    const errorMsg = `Migration failed: ${error}`;
    result.errors.push(errorMsg);
    console.error(errorMsg);
  }

  return result;
}

/**
 * Rollback function (if needed) - Only updates users back to free tier
 * DOES NOT delete the Friends & Family plan (following zero-deletion policy)
 */
export async function rollbackFriendsFamilyMigration(): Promise<MigrationResult> {
  const result: MigrationResult = {
    success: false,
    planCreated: false,
    planId: null,
    usersUpdated: 0,
    subscriptionsCreated: 0,
    errors: [],
    details: []
  };

  try {
    console.log('üîÑ Rolling back Friends & Family subscription migration...');
    
    // Get ONLY users with friends_family tier (safe to rollback)
    const friendsFamilyUsers = await db.select()
      .from(users)
      .where(eq(users.subscriptionTier, 'friends_family'));

    result.details.push(`üìä Found ${friendsFamilyUsers.length} users with Friends & Family subscription`);
    result.details.push(`üîí Will only affect Friends & Family users - preserving all other subscriptions`);

    for (const user of friendsFamilyUsers) {
      try {
        // Reset to free tier
        await db.update(users)
          .set({
            subscriptionStatus: 'free',
            subscriptionTier: 'free',
            subscriptionEndsAt: null,
            updatedAt: new Date()
          })
          .where(eq(users.id, user.id));

        result.usersUpdated++;
        result.details.push(`‚úì Rolled back user ${user.email} (ID: ${user.id}) to free tier`);
        
      } catch (error) {
        const errorMsg = `Failed to rollback user ${user.email} (ID: ${user.id}): ${error}`;
        result.errors.push(errorMsg);
        console.error(errorMsg);
      }
    }

    result.success = result.errors.length === 0;
    result.details.push(`üîÑ Rollback completed: ${result.usersUpdated} users reverted to free tier`);
    
  } catch (error) {
    const errorMsg = `Rollback failed: ${error}`;
    result.errors.push(errorMsg);
    console.error(errorMsg);
  }

  return result;
}

// CLI interface for running the migration
if (require.main === module) {
  const action = process.argv[2];
  
  if (action === 'rollback') {
    rollbackFriendsFamilyMigration()
      .then(result => {
        console.log('\nüìã ROLLBACK SUMMARY:');
        console.log('==================');
        console.log(`Success: ${result.success}`);
        console.log(`Users reverted: ${result.usersUpdated}`);
        
        if (result.details.length > 0) {
          console.log('\nDetails:');
          result.details.forEach(detail => console.log(detail));
        }
        
        if (result.errors.length > 0) {
          console.log('\nErrors:');
          result.errors.forEach(error => console.error(error));
        }
        
        process.exit(result.success ? 0 : 1);
      })
      .catch(error => {
        console.error('Migration script failed:', error);
        process.exit(1);
      });
  } else {
    migrateFriendsFamilySubscription()
      .then(result => {
        console.log('\nüìã MIGRATION SUMMARY:');
        console.log('====================');
        console.log(`Success: ${result.success}`);
        console.log(`Plan created: ${result.planCreated}`);
        console.log(`Plan ID: ${result.planId}`);
        console.log(`Users updated: ${result.usersUpdated}`);
        console.log(`Subscriptions created: ${result.subscriptionsCreated}`);
        
        if (result.details.length > 0) {
          console.log('\nDetails:');
          result.details.forEach(detail => console.log(detail));
        }
        
        if (result.errors.length > 0) {
          console.log('\nErrors:');
          result.errors.forEach(error => console.error(error));
        }
        
        process.exit(result.success ? 0 : 1);
      })
      .catch(error => {
        console.error('Migration script failed:', error);
        process.exit(1);
      });
  }
}

================
File: server/grandfather-users-migration.ts
================
/**
 * Grandfather Users Migration
 * Migrates existing users to the new subscription tier system while preserving their benefits
 */

import { db } from './db';
import { users, subscriptionPlans, subscriptions, aiCreditsTransactions, subscriptionFeatures } from '@shared/schema';
import { eq, and, isNotNull, sql } from 'drizzle-orm';

interface MigrationResult {
  success: boolean;
  usersProcessed: number;
  errors: string[];
  details: {
    freeToFree: number;
    nomadAIProToPro: number;
    friendsFamilyToPro: number;
    enterpriseToEnterprise: number;
    failed: number;
  };
}

/**
 * Main migration function to grandfather existing users
 */
export async function grandfatherExistingUsers(): Promise<MigrationResult> {
  const result: MigrationResult = {
    success: false,
    usersProcessed: 0,
    errors: [],
    details: {
      freeToFree: 0,
      nomadAIProToPro: 0,
      friendsFamilyToPro: 0,
      enterpriseToEnterprise: 0,
      failed: 0
    }
  };

  try {
    console.log('üîÑ Starting grandfather migration for existing users...');
    
    // Begin transaction
    await db.transaction(async (tx) => {
      // Step 1: Get all existing users
      const allUsers = await tx.select().from(users);
      console.log(`üìä Found ${allUsers.length} total users to process`);

      for (const user of allUsers) {
        try {
          const currentTier = user.subscriptionTier || 'free';
          let newTier = 'free';
          let grantCredits = 0;
          let shouldGrandfather = false;

          // Determine new tier based on current subscription
          switch (currentTier.toLowerCase()) {
            case 'free':
              // Free users migrate to freemium tier
              newTier = 'freemium';
              grantCredits = 0; // Freemium gets 10 messages, no credits
              result.details.freeToFree++;
              break;

            case 'nomadai pro':
            case 'premium':
            case 'basic':
              // NomadAI Pro ($5/month) users get grandfathered to Pro tier ($19 value)
              newTier = 'pro';
              grantCredits = 1000; // Pro tier credits
              shouldGrandfather = true;
              result.details.nomadAIProToPro++;
              console.log(`‚ú® Grandfathering user ${user.email} from NomadAI Pro to Pro tier`);
              break;

            case 'friends & family':
            case 'friends_family':
              // Friends & Family get grandfathered to Pro tier with special flag
              newTier = 'pro';
              grantCredits = 1000; // Pro tier credits
              shouldGrandfather = true;
              result.details.friendsFamilyToPro++;
              console.log(`üéÅ Grandfathering Friends & Family user ${user.email} to Pro tier`);
              break;

            case 'enterprise':
              // Enterprise users get upgraded to new Enterprise tier
              newTier = 'enterprise';
              grantCredits = 999999; // Effectively unlimited
              shouldGrandfather = true;
              result.details.enterpriseToEnterprise++;
              console.log(`üè¢ Migrating Enterprise user ${user.email} to new Enterprise tier`);
              break;

            default:
              console.warn(`‚ö†Ô∏è Unknown tier '${currentTier}' for user ${user.email}, defaulting to free`);
              newTier = 'free';
              grantCredits = 100;
              result.details.freeToFree++;
          }

          // Update user record
          await tx.update(users)
            .set({
              subscriptionTier: newTier,
              ai_credits_balance: grantCredits,
              ai_credits_used_this_month: 0,
              credits_reset_at: new Date(),
              is_grandfathered: shouldGrandfather,
              grandfathered_from_tier: shouldGrandfather ? currentTier : null,
              grandfathered_at: shouldGrandfather ? new Date() : null,
              updatedAt: new Date()
            })
            .where(eq(users.id, user.id));

          // Create initial credits transaction
          await tx.insert(aiCreditsTransactions).values({
            userId: user.id,
            transactionType: shouldGrandfather ? 'bonus' : 'monthly_reset',
            amount: grantCredits,
            balanceAfter: grantCredits,
            description: shouldGrandfather 
              ? `Grandfathered from ${currentTier} to ${newTier} tier with bonus credits`
              : `Initial credits allocation for ${newTier} tier`,
            metadata: {
              migration: 'grandfather_users',
              previousTier: currentTier,
              newTier: newTier,
              isGrandfathered: shouldGrandfather
            }
          });

          // Update subscription record if exists
          if (user.stripeCustomerId) {
            const userSubscriptions = await tx.select()
              .from(subscriptions)
              .where(eq(subscriptions.userId, user.id))
              .limit(1);

            if (userSubscriptions.length > 0) {
              const subscription = userSubscriptions[0];
              
              // For grandfathered paid users, maintain their original price
              if (shouldGrandfather && subscription.status === 'active') {
                // Add metadata to track grandfathered pricing
                await tx.update(subscriptions)
                  .set({
                    metadata: {
                      ...subscription.metadata,
                      isGrandfathered: true,
                      originalTier: currentTier,
                      originalPrice: currentTier === 'nomadai pro' ? '5.00' : 
                                   currentTier === 'enterprise' ? '25.00' : '0.00',
                      grandfatheredAt: new Date().toISOString()
                    },
                    updatedAt: new Date()
                  })
                  .where(eq(subscriptions.id, subscription.id));
              }
            }
          }

          result.usersProcessed++;

        } catch (userError) {
          console.error(`‚ùå Error processing user ${user.email}:`, userError);
          result.errors.push(`Failed to process user ${user.email}: ${userError}`);
          result.details.failed++;
        }
      }

      // Step 2: Create special pricing entries for grandfathered users
      // This allows them to keep their original pricing
      console.log('üí∞ Creating special pricing rules for grandfathered users...');
      
      // Create a special "Grandfathered Pro" plan for $5/month users
      const existingGrandfatheredPlan = await tx.select()
        .from(subscriptionPlans)
        .where(eq(subscriptionPlans.name, 'Grandfathered Pro'))
        .limit(1);

      if (existingGrandfatheredPlan.length === 0) {
        await tx.insert(subscriptionPlans).values({
          name: 'Grandfathered Pro',
          description: 'Special pricing for early adopters - Pro features at original price',
          price: '5.00', // Original NomadAI Pro price
          interval: 'month',
          features: [
            'All Pro tier features',
            'Unlimited Chat & AI Providers',
            '1,000 AI Credits/month',
            'Full-Codebase Context',
            'Git Integration', 
            '10 AI Code Reviews/month',
            'Grandfathered pricing - Thank you for being an early supporter!'
          ],
          stripePriceId: 'price_grandfathered_pro', // Use existing Stripe price ID if possible
          stripeProductId: 'prod_grandfathered',
          isActive: false, // Not available for new signups
          sortOrder: 999 // Hidden from regular pricing page
        });
      }

      console.log('‚úÖ Grandfather migration completed successfully!');
      result.success = true;
    });

  } catch (error) {
    console.error('‚ùå Grandfather migration failed:', error);
    result.errors.push(`Migration failed: ${error}`);
    result.success = false;
  }

  // Print summary
  console.log('\nüìä Migration Summary:');
  console.log(`Total users processed: ${result.usersProcessed}`);
  console.log(`Free ‚Üí Free: ${result.details.freeToFree}`);
  console.log(`NomadAI Pro ‚Üí Pro (grandfathered): ${result.details.nomadAIProToPro}`);
  console.log(`Friends & Family ‚Üí Pro (grandfathered): ${result.details.friendsFamilyToPro}`);
  console.log(`Enterprise ‚Üí Enterprise: ${result.details.enterpriseToEnterprise}`);
  console.log(`Failed: ${result.details.failed}`);
  
  if (result.errors.length > 0) {
    console.log('\n‚ö†Ô∏è Errors encountered:');
    result.errors.forEach(err => console.log(`  - ${err}`));
  }

  return result;
}

/**
 * Verify grandfather status for a user
 */
export async function verifyGrandfatherStatus(userId: number): Promise<{
  isGrandfathered: boolean;
  originalTier?: string;
  currentTier?: string;
  specialPricing?: boolean;
}> {
  const user = await db.select().from(users).where(eq(users.id, userId)).limit(1);
  
  if (!user[0]) {
    return { isGrandfathered: false };
  }

  const userData = user[0];
  
  return {
    isGrandfathered: userData.is_grandfathered || false,
    originalTier: userData.grandfathered_from_tier || undefined,
    currentTier: userData.subscriptionTier || undefined,
    specialPricing: userData.is_grandfathered && 
                   (userData.grandfathered_from_tier === 'nomadai pro' || 
                    userData.grandfathered_from_tier === 'friends_family')
  };
}

// Run migration if this file is executed directly
if (require.main === module) {
  grandfatherExistingUsers()
    .then(result => {
      console.log('\n‚ú® Migration completed!');
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('Fatal error during migration:', error);
      process.exit(1);
    });
}

================
File: server/index.ts
================
import express, { type Request, Response, NextFunction } from "express";
import session from "express-session";
import ConnectPgSimple from "connect-pg-simple";
import { setupVite, serveStatic, log } from "./vite";
import dotenv from "dotenv";
import fs from "fs";

// Load environment variables from multiple sources FIRST
if (fs.existsSync(".env.local")) {
  dotenv.config({ path: ".env.local" });
}
dotenv.config(); // Also load from .env if it exists

// Now import modules that depend on environment variables
import { registerRoutes } from "./routes";
import passport from "./auth";
import { handleStripeWebhook } from "./webhooks";

const app = express();

// Register Stripe webhook BEFORE any body parsers to preserve raw body for signature verification
app.post("/api/webhooks/stripe", express.raw({ type: "application/json" }), handleStripeWebhook);

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Sensible defaults to enable vector features for file management locally
// Enable vectorization unless explicitly disabled
if (!process.env.VECTORIZATION_DISABLED && !process.env.DISABLE_VECTORIZATION) {
  if (!process.env.VECTORS_ENABLED && !process.env.ENABLE_VECTORIZATION) {
    process.env.VECTORS_ENABLED = "true";
  }
}

// Set a default transformers cache directory to avoid repeated downloads
if (!process.env.TRANSFORMERS_CACHE_DIR) {
  process.env.TRANSFORMERS_CACHE_DIR = ".cache/transformers";
}

// Session configuration
const PgSession = ConnectPgSimple(session);

app.use(
  session({
    store: process.env.DATABASE_URL
      ? new PgSession({
          conString: process.env.DATABASE_URL,
          tableName: "session", // Optional: specify session table name
          createTableIfMissing: true,
        })
      : undefined, // Use memory store if no database URL
    secret: process.env.SESSION_SECRET || "your-session-secret-change-this-in-production",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: false, // Set to false for Replit deployments - Replit handles HTTPS at the edge
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 7, // 7 days
      sameSite: 'lax', // Allow cookies to be sent with same-site requests
    },
  })
);

// Initialize Passport middleware
app.use(passport.initialize());
app.use(passport.session());

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "‚Ä¶";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();

================
File: server/routes.ts
================
import type { Express, Request } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { requireAuth, requireGuest } from "./auth";
import passport from "./auth";
import { registerUserSchema, loginUserSchema, forgotPasswordSchema, resetPasswordSchema, publicUserSchema, updateProfileSchema, updateEmailPreferencesSchema, unsubscribeSchema, subscriptionPlans, subscriptions, users, files, subscriptionFeatures } from "@shared/schema";
import { engagementService } from "./engagement";
import { aiCoachService } from "./ai-coach";
import { db } from "./db";
import { eq, desc, and } from "drizzle-orm";
import { createStripeCustomer, createSetupIntent, createSubscription, cancelSubscription, reactivateSubscription, createBillingPortalSession, syncSubscriptionFromStripe } from "./stripe";
import { createSubscriptionCheckoutSession, createCreditsCheckoutSession, getCheckoutSession } from "./stripe-checkout";
import { requireActiveSubscription, enhanceWithSubscription, requireCredits, requireMinimumCredits, requireDynamicCredits, checkFreemiumLimit, getEnhancedSubscriptionDetails, requireFeature, requireTeamRole, requireAIProvider, tierBasedRateLimit, estimateRequiredCredits } from "./subscription-middleware";
import { trackAIUsage } from "./stripe-enhanced";
import { handleStripeWebhook, rawBodyParser } from "./webhooks";
import { fileStorage } from "./file-storage";
import { conversationService } from "./conversation-service";
import { vectorProcessor } from "./vector-processor";
import { vectorService } from "./vector-service";
import { contextEnhancer } from "./context-enhancer";
import { isVectorizationEnabled } from "./vector-flags";
import multer from 'multer';
import ModelClient from "@azure-rest/ai-inference";
import { AzureKeyCredential } from "@azure/core-auth";
import { GoogleGenerativeAI } from "@google/generative-ai";
import OpenAI from "openai";
import dotenv from "dotenv";
dotenv.config();

// Define custom request interface for file uploads
interface MulterRequest extends Request {
  file?: Express.Multer.File;
}

// Extend Request type to include user and creditsPending
interface AuthenticatedRequest extends Request {
  user?: any & {
    creditsPending?: {
      amount: number;
      operationType: string;
      currentBalance: number;
    };
  };
}

// Azure AI Configuration
interface AzureAIConfig {
  endpoint: string;
  apiKey: string;
  modelName: string;
  maxRetries?: number;
  retryDelay?: number;
  cacheEnabled?: boolean;
}

// Simple in-memory cache for AI responses
const aiResponseCache = new Map<string, { response: any; timestamp: number; ttl: number }>();

// AI service analytics and monitoring
interface AIServiceMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  cacheHits: number;
  totalResponseTime: number;
  avgResponseTime: number;
  endpointStats: Map<string, {
    requests: number;
    successes: number;
    failures: number;
    avgResponseTime: number;
  }>;
  errorTypes: Map<string, number>;
}

const aiMetrics: AIServiceMetrics = {
  totalRequests: 0,
  successfulRequests: 0,
  failedRequests: 0,
  cacheHits: 0,
  totalResponseTime: 0,
  avgResponseTime: 0,
  endpointStats: new Map(),
  errorTypes: new Map()
};

// Track AI service usage
function trackAIRequest(endpoint: string, success: boolean, responseTime: number, error?: string): void {
  aiMetrics.totalRequests++;
  aiMetrics.totalResponseTime += responseTime;
  aiMetrics.avgResponseTime = aiMetrics.totalResponseTime / aiMetrics.totalRequests;
  
  if (success) {
    aiMetrics.successfulRequests++;
  } else {
    aiMetrics.failedRequests++;
    if (error) {
      const errorCount = aiMetrics.errorTypes.get(error) || 0;
      aiMetrics.errorTypes.set(error, errorCount + 1);
    }
  }
  
  // Track endpoint-specific stats
  const endpointStat = aiMetrics.endpointStats.get(endpoint) || {
    requests: 0,
    successes: 0,
    failures: 0,
    avgResponseTime: 0
  };
  
  endpointStat.requests++;
  endpointStat.avgResponseTime = ((endpointStat.avgResponseTime * (endpointStat.requests - 1)) + responseTime) / endpointStat.requests;
  
  if (success) {
    endpointStat.successes++;
  } else {
    endpointStat.failures++;
  }
  
  aiMetrics.endpointStats.set(endpoint, endpointStat);
  
  // Log periodic summaries
  if (aiMetrics.totalRequests % 10 === 0) {
    console.log("üìä AI Service Metrics Summary:", {
      totalRequests: aiMetrics.totalRequests,
      successRate: `${((aiMetrics.successfulRequests / aiMetrics.totalRequests) * 100).toFixed(1)}%`,
      avgResponseTime: `${aiMetrics.avgResponseTime.toFixed(0)}ms`,
      cacheHitRate: `${((aiMetrics.cacheHits / aiMetrics.totalRequests) * 100).toFixed(1)}%`,
      topEndpoints: Array.from(aiMetrics.endpointStats.entries())
        .sort(([,a], [,b]) => b.requests - a.requests)
        .slice(0, 3)
        .map(([endpoint, stats]) => `${endpoint}: ${stats.requests} reqs`)
    });
  }
}

// Track cache hits
function trackCacheHit(): void {
  aiMetrics.cacheHits++;
}

// Helper function to estimate token count from text
// This is a rough approximation - for production, use proper tokenizer libraries
function estimateTokenCount(text: string): number {
  if (!text) return 0;
  
  // Rough estimation: 1 token ‚âà 4 characters for English text
  // This varies by model and language, but gives a reasonable approximation
  const avgCharsPerToken = 4;
  return Math.ceil(text.length / avgCharsPerToken);
}

// Helper function to count tokens from messages array
function countTokensFromMessages(messages: any[]): number {
  if (!Array.isArray(messages)) return 0;
  
  return messages.reduce((total, message) => {
    const content = message.content || '';
    return total + estimateTokenCount(content);
  }, 0);
}


// Helper function to deduct credits after AI response
async function deductCreditsAfterResponse(
  req: any, 
  inputTokens: number, 
  outputTokens: number, 
  modelUsed: string = 'unknown'
): Promise<{ creditsUsed: number; remainingBalance: number } | null> {
  if (req.user?.freeMessageUsed) {
    console.log(`‚è≠Ô∏è Skipping credit deduction for user ${req.user.id} - free message was used`);
    return null;
  }

  if (req.user?.needsCreditDeduction) {
    const totalTokens = inputTokens + outputTokens;
    console.log(`üí≥ Deducting credits for user ${req.user.id}: ${inputTokens} input + ${outputTokens} output = ${totalTokens} total tokens`);
    
    try {
      const result = await trackAIUsage({
        userId: req.user.id,
        operationType: req.user.needsCreditDeduction.operationType as any,
        modelUsed,
        tokensConsumed: totalTokens,
      });
      
      console.log(`‚úÖ Credits deducted for user ${req.user.id}: ${result.creditsUsed} credits used, ${result.remainingBalance} remaining`);
      return result;
    } catch (error) {
      console.error(`‚ùå Error deducting credits for user ${req.user.id}:`, error);
      // Don't fail the request if credit deduction fails - log and continue
      return null;
    }
  }
  
  return null;
}

// Robust JSON parser for Azure AI responses
// Enhanced error extraction with detailed logging
export function extractAzureAIError(error: any): string {
  if (!error) return "Unknown Azure AI error";
  
  // Log full error for debugging
  console.error("Full Azure AI error details:", JSON.stringify(error, null, 2));
  
  if (typeof error === 'string') return error;
  if (error.message) return error.message;
  if (error.error?.message) return error.error.message;
  if (error.details) return Array.isArray(error.details) ? error.details.join(', ') : error.details;
  if (error.code) return `Azure AI Error ${error.code}: ${error.message || 'Unknown error'}`;
  
  return "Unexpected Azure AI error format";
}

// Enhanced JSON parsing with better error recovery
export function parseAzureAIJSON(content: string): any {
  if (!content || typeof content !== 'string') {
    console.warn("Invalid content for JSON parsing:", typeof content);
    return null;
  }

  try {
    // Remove any markdown code block markers
    const cleanContent = content.replace(/```(?:json)?\n?/g, '').trim();
    
    // Try direct parsing first
    return JSON.parse(cleanContent);
  } catch (error) {
    console.warn("Direct JSON parsing failed, attempting recovery...");
    
    try {
      // Look for JSON-like structure in the content
      const cleanContent = content.replace(/```(?:json)?\n?/g, '').trim();
      const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
    } catch (recoveryError) {
      console.warn("JSON recovery failed:", recoveryError);
    }
    
    try {
      // Try to extract and fix common JSON issues
      const cleanContent = content.replace(/```(?:json)?\n?/g, '').trim();
      let fixedContent = cleanContent
        .replace(/([{,]\s*)(\w+):/g, '$1"$2":') // Add quotes to unquoted keys
        .replace(/:\s*'([^']*)'/g, ': "$1"') // Replace single quotes with double quotes
        .replace(/,\s*}/g, '}') // Remove trailing commas
        .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
      
      return JSON.parse(fixedContent);
    } catch (fixError) {
      console.error("All JSON parsing attempts failed:", fixError);
      return null;
    }
  }
}

// Exponential backoff retry logic
async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: any;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      if (attempt === maxRetries) {
        console.error(`Operation failed after ${maxRetries + 1} attempts:`, error);
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
      console.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms:`, extractAzureAIError(error));
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}

// Cache management functions
function getCacheKey(prompt: string, model: string, params: any): string {
  return btoa(JSON.stringify({ prompt: prompt.substring(0, 200), model, params }));
}

function getCachedResponse(cacheKey: string): any | null {
  const cached = aiResponseCache.get(cacheKey);
  if (!cached) return null;
  
  const now = Date.now();
  if (now > cached.timestamp + cached.ttl) {
    aiResponseCache.delete(cacheKey);
    return null;
  }
  
  trackCacheHit();
  console.log("üìÑ Using cached AI response");
  return cached.response;
}

function setCachedResponse(cacheKey: string, response: any, ttlMinutes: number = 30): void {
  const ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds
  aiResponseCache.set(cacheKey, {
    response,
    timestamp: Date.now(),
    ttl
  });
  
  // Clean up old cache entries periodically
  if (aiResponseCache.size > 100) {
    const now = Date.now();
    aiResponseCache.forEach((value, key) => {
      if (now > value.timestamp + value.ttl) {
        aiResponseCache.delete(key);
      }
    });
  }
}

// Helper function to get LM Studio base URL
function getLMStudioBaseUrl() {
  const isProduction = process.env.NODE_ENV === 'production' || !!process.env.REPL_SLUG;
  
  const sanitizeBaseUrl = (raw: string): string => {
    let base = (raw || "").trim();
    // Fix accidental duplicate port patterns like :1234:1234
    base = base.replace(/:(\d+):(\d+)/, ":$1");
    // Remove any trailing slash
    base = base.replace(/\/$/, "");
    // Strip accidental API path suffixes
    base = base.replace(/\/(v1|openai|api)(\/.*)?$/i, "");
    // Ensure protocol
    if (!/^https?:\/\//i.test(base)) {
      base = `http://${base}`;
    }
    // Validate URL
    try {
      // eslint-disable-next-line no-new
      new URL(base);
    } catch {
      throw new Error(`Invalid LMSTUDIO_BASE_URL provided: ${raw}`);
    }
    return base;
  };

  // Try multiple sources for LM Studio URL configuration
  // In production (Replit), use the Cloudflare tunnel URL with HTTPS
  // In development, use local IP or configured URL
  const defaultUrl = isProduction 
    ? "https://lmstudio.uterpi.com"  // Cloudflare tunnel URL for production (MUST be HTTPS)
    : "http://192.168.86.44:1234";   // Local IP for development
  
  const lmBaseRaw = process.env.LMSTUDIO_BASE_URL || process.env.VITE_LMSTUDIO_BASE_URL || defaultUrl;
  
  return {
    url: sanitizeBaseUrl(lmBaseRaw),
    isProduction
  };
}

// Create AI client based on provider
export function createAIClient(provider: string = 'gemini', userApiKey?: string): { client: any; config: any } {
  switch (provider.toLowerCase()) {
    case 'gemini': {
      const apiKey = userApiKey || process.env.VITE_GEMINI_API_KEY;
      if (!apiKey) {
        throw new Error("Gemini API key missing. Please provide an API key or set VITE_GEMINI_API_KEY environment variable.");
      }
      const genAI = new GoogleGenerativeAI(apiKey);
      return {
        client: genAI,
        config: { 
          modelName: 'gemini-2.5-flash',
          apiKey 
        }
      };
    }
    
    case 'openai': {
      const apiKey = userApiKey || process.env.VITE_OPENAI_API_KEY;
      if (!apiKey) {
        throw new Error("OpenAI API key missing. Please provide an API key or set VITE_OPENAI_API_KEY environment variable.");
      }
      const openai = new OpenAI({ apiKey });
      return {
        client: openai,
        config: {
          modelName: 'gpt-4o-mini',
          apiKey
        }
      };
    }
    
    case 'azure':
    case 'azureai': {
      const endpoint = process.env.VITE_AZURE_AI_ENDPOINT;
      const apiKey = userApiKey || process.env.VITE_AZURE_AI_API_KEY;
      const modelName = process.env.VITE_AZURE_AI_MODEL_NAME || "ministral-3b";
      
      if (!endpoint || !apiKey) {
        throw new Error("Azure AI configuration missing. Please set VITE_AZURE_AI_ENDPOINT and VITE_AZURE_AI_API_KEY environment variables.");
      }
      
      const credential = new AzureKeyCredential(apiKey);
      const client = ModelClient(endpoint, credential);
      
      return {
        client,
        config: {
          endpoint,
          apiKey,
          modelName,
          maxRetries: 3,
          retryDelay: 1000,
          cacheEnabled: true
        }
      };
    }
    
    case 'lmstudio': {
      const baseInfo = getLMStudioBaseUrl();
      const apiKey = userApiKey || process.env.LMSTUDIO_API_KEY || "lm-studio";
      
      // Create OpenAI client configured for LM Studio endpoint
      const openai = new OpenAI({
        apiKey: apiKey,
        baseURL: `${baseInfo.url}/v1`
      });
      
      return {
        client: openai,
        config: {
          modelName: 'nomadic-icdu-v8', // The actual default LM Studio model
          apiKey,
          baseURL: `${baseInfo.url}/v1`,
          maxRetries: 3,
          retryDelay: 1000
        }
      };
    }
    
    default:
      throw new Error(`Unsupported AI provider: ${provider}`);
  }
}

// Initialize Azure AI client (kept for backwards compatibility)
export function createAzureAIClient(): { client: any; config: AzureAIConfig } {
  const endpoint = process.env.VITE_AZURE_AI_ENDPOINT;
  const apiKey = process.env.VITE_AZURE_AI_API_KEY;
  const modelName = process.env.VITE_AZURE_AI_MODEL_NAME || "ministral-3b";

  if (!endpoint || !apiKey) {
    throw new Error(
      "Azure AI configuration missing. Please set VITE_AZURE_AI_ENDPOINT and VITE_AZURE_AI_API_KEY environment variables."
    );
  }

  const config: AzureAIConfig = { 
    endpoint, 
    apiKey, 
    modelName,
    maxRetries: 3,
    retryDelay: 1000,
    cacheEnabled: true
  };
  
  const client = ModelClient(endpoint, new AzureKeyCredential(apiKey));
  
  console.log(`üöÄ Azure AI client initialized with model: ${modelName}`);
  
  return { client, config };
}

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    // Accept images and documents (PDF, text, and Word DOCX)
    const mt = file.mimetype || '';
    const ok = mt.startsWith('image/') ||
      mt.includes('text/') ||
      mt === 'application/pdf' ||
      mt === 'application/msword' ||
      mt === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    if (ok) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  }
});

export async function registerRoutes(app: Express): Promise<Server> {

  // Generic LM Studio proxy handler
  const proxyLMStudioRequest = async (req: Request, res: any, endpoint: string) => {
    let lmBase = "";
    let isProduction = false;
    
    try {
      const baseInfo = getLMStudioBaseUrl();
      lmBase = baseInfo.url;
      isProduction = baseInfo.isProduction;
      
      const targetUrl = `${lmBase}${endpoint}`;
      const incomingAuth = req.get("authorization");
      const proxyAuth = incomingAuth || (process.env.LMSTUDIO_API_KEY ? `Bearer ${process.env.LMSTUDIO_API_KEY}` : "Bearer lm-studio");

      console.log(`[LMStudio Proxy] ${req.method} ${endpoint}`);
      console.log(`[LMStudio Proxy] Target: ${targetUrl}`);

      const headers: any = {
        "Content-Type": "application/json",
        "Authorization": proxyAuth,
        // Support for SSE streaming through Cloudflare tunnel
        "Accept": "text/event-stream, application/json"
      };

      const fetchOptions: any = {
        method: req.method,
        headers
      };

      // Add body for POST requests
      if (req.method === 'POST' && req.body) {
        fetchOptions.body = JSON.stringify(req.body);
      }

      const response = await fetch(targetUrl, fetchOptions);
      const contentType = response.headers.get("content-type") || "";
      const isEventStream = contentType.includes("text/event-stream");

      // Handle Server-Sent Events for streaming
      if (isEventStream) {
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no"); // Disable proxy buffering for nginx/Cloudflare

        const reader = (response as any).body?.getReader?.();
        if (!reader) {
          res.status(502).end("Upstream stream missing");
          return;
        }

        const decoder = new TextDecoder();
        let streamedContent = '';
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            
            // Collect streamed content for credit calculation
            try {
              const lines = chunk.split('\n');
              for (const line of lines) {
                if (line.startsWith('data: ') && !line.includes('[DONE]')) {
                  const dataStr = line.substring(6).trim();
                  if (dataStr && dataStr !== '[DONE]') {
                    try {
                      const parsed = JSON.parse(dataStr);
                      const content = parsed?.choices?.[0]?.delta?.content || '';
                      streamedContent += content;
                    } catch (e) {
                      // Ignore parsing errors for individual chunks
                    }
                  }
                }
              }
            } catch (e) {
              // Ignore content collection errors
            }
            
            res.write(chunk);
          }
        } finally {
          res.end();
          
          // Deduct credits after streaming is complete (only for chat/completions endpoints)
          if (endpoint.includes('/chat/completions') || endpoint.includes('/completions')) {
            try {
              const messages = req.body?.messages || (req.body?.prompt ? [{ content: req.body.prompt }] : []);
              const inputTokens = countTokensFromMessages(messages);
              const outputTokens = estimateTokenCount(streamedContent);
              console.log(`üí≥ Post-stream credit deduction (LM Studio Proxy): ${inputTokens} input + ${outputTokens} output tokens for content: "${streamedContent.substring(0, 100)}..."`);
              await deductCreditsAfterResponse(req as any, inputTokens, outputTokens, req.body?.model || 'lmstudio');
            } catch (creditError) {
              console.error('‚ùå Error deducting credits after LM Studio proxy streaming:', creditError);
            }
          }
        }
        return;
      }

      // Non-streaming: forward status and body
      const text = await response.text();
      console.log(`[LMStudio Proxy] Response ${response.status} ${contentType}`);
      res.status(response.status);
      
      // Deduct credits for non-streaming completions responses
      if (response.ok && (endpoint.includes('/chat/completions') || endpoint.includes('/completions'))) {
        try {
          const messages = req.body?.messages || (req.body?.prompt ? [{ content: req.body.prompt }] : []);
          const inputTokens = countTokensFromMessages(messages);
          let outputContent = '';
          
          if (contentType.includes("application/json")) {
            try {
              const parsed = JSON.parse(text);
              outputContent = parsed?.choices?.[0]?.message?.content || parsed?.choices?.[0]?.text || '';
            } catch (e) {
              // Ignore parsing errors
            }
          }
          
          const outputTokens = estimateTokenCount(outputContent);
          console.log(`üí≥ Credit deduction (LM Studio Proxy non-streaming): ${inputTokens} input + ${outputTokens} output tokens`);
          await deductCreditsAfterResponse(req as any, inputTokens, outputTokens, req.body?.model || 'lmstudio');
        } catch (creditError) {
          console.error('‚ùå Error deducting credits after LM Studio proxy non-streaming:', creditError);
        }
      }
      
      if (contentType.includes("application/json")) {
        res.type("application/json").send(text);
      } else {
        res.send(text);
      }
    } catch (err: any) {
      console.error(`LM Studio proxy error (${endpoint}):`, err?.stack || err);
      const isNetworkError = err?.cause?.code === "ECONNREFUSED" || err?.message?.includes("fetch failed");
      const statusCode = isNetworkError ? 502 : 500;
      
      // More detailed error message for debugging
      let message = "LM Studio proxy failed";
      let details = err?.message || String(err);
      
      if (isNetworkError) {
        if (isProduction) {
          message = "Unable to connect to LM Studio via Cloudflare tunnel";
          details = `Attempted to connect to: ${lmBase}. Ensure lmstudio.uterpi.com is configured in Cloudflare tunnel and LM Studio is running. Error: ${err?.message}`;
        } else {
          message = "Unable to connect to LM Studio locally";
          details = `Check that LM Studio is running on ${lmBase}. Error: ${err?.message}`;
        }
      }
      
      console.error(`[LMStudio Proxy] ${message}: ${details}`);
      res.status(statusCode).json({ error: message, message: details });
    }
  };

  // LM Studio proxy endpoints (OpenAI-compatible)
  
  // Chat completions endpoint (with streaming support)
  app.post("/lmstudio/v1/chat/completions", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { messages, model } = req.body;
    const hasAttachments = messages?.some((msg: any) => msg.attachments && msg.attachments.length > 0);
    return estimateRequiredCredits(messages || [], false, hasAttachments, model || '');
  }, 'chat'), async (req, res) => {
    await proxyLMStudioRequest(req, res, "/v1/chat/completions");
  });

  // Text completions endpoint (non-chat)
  app.post("/lmstudio/v1/completions", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { prompt, model } = req.body;
    const messages = [{ content: prompt || '' }];
    return estimateRequiredCredits(messages, false, false, model || '');
  }, 'completion'), async (req, res) => {
    await proxyLMStudioRequest(req, res, "/v1/completions");
  });

  // Embeddings endpoint
  app.post("/lmstudio/v1/embeddings", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { input } = req.body;
    const inputText = Array.isArray(input) ? input.join(' ') : (input || '');
    const messages = [{ content: inputText }];
    return Math.max(1, Math.ceil(estimateRequiredCredits(messages, false, false, '') * 0.5)); // Embeddings typically cost less
  }, 'embedding'), async (req, res) => {
    await proxyLMStudioRequest(req, res, "/v1/embeddings");
  });

  // Models endpoint
  app.get("/lmstudio/v1/models", async (req, res) => {
    await proxyLMStudioRequest(req, res, "/v1/models");
  });

  // =============================================================================
  // VECTORIZATION SYSTEM TEST ENDPOINT
  // =============================================================================

  // Test endpoint for vectorization system
  app.post("/api/test/vectorization", requireAuth, async (req, res) => {
    try {
      const { testVectorizationSystem } = await import('./test-vectorization');
      console.log('üß™ Running vectorization system tests...');
      
      const results = await testVectorizationSystem();
      const totalTests = results.length;
      const passedTests = results.filter(r => r.success).length;
      
      res.json({
        success: true,
        summary: {
          totalTests,
          passedTests,
          failedTests: totalTests - passedTests,
          successRate: ((passedTests / totalTests) * 100).toFixed(1) + '%'
        },
        results,
        systemReady: passedTests >= totalTests * 0.8
      });
    } catch (error) {
      console.error('‚ùå Vectorization test failed:', error);
      res.status(500).json({
        success: false,
        error: error?.toString(),
        message: 'Vectorization system test failed'
      });
    }
  });

  // Get vectorization queue status
  app.get("/api/vectorization/status", requireAuth, async (req, res) => {
    try {
      const queueStatus = vectorProcessor.getQueueStatus();
      
      res.json({
        success: true,
        queueStatus,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('‚ùå Error getting vectorization status:', error);
      res.status(500).json({
        success: false,
        error: error?.toString()
      });
    }
  });

  // Get user conversations
  app.get("/api/conversations", requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const limit = parseInt(req.query.limit as string) || 20;
      
      const conversations = await conversationService.getUserConversations(userId, limit);
      
      res.json({
        success: true,
        conversations,
        count: conversations.length
      });
    } catch (error) {
      console.error('‚ùå Error getting user conversations:', error);
      res.status(500).json({
        success: false,
        error: error?.toString()
      });
    }
  });

  // Get conversation messages
  app.get("/api/conversations/:id/messages", requireAuth, async (req, res) => {
    try {
      const conversationId = parseInt(req.params.id);
      const messages = await conversationService.getConversationMessages(conversationId);
      
      res.json({
        success: true,
        messages,
        count: messages.length
      });
    } catch (error) {
      console.error('‚ùå Error getting conversation messages:', error);
      res.status(500).json({
        success: false,
        error: error?.toString()
      });
    }
  });

  // =============================================================================
  // UNIVERSAL AI PROXY WITH CREDIT CHECKING
  // =============================================================================

  // Universal AI chat completions endpoint with dynamic credit checking for all providers
  app.post("/ai/v1/chat/completions", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const body: any = (req as any).body || {};
    const raw = body.original_messages || body.messages;
    const enableContext = body.enableContext ?? true;
    const model = body.model;
    const hasAttachments = raw?.some((msg: any) => msg.attachments && msg.attachments.length > 0);
    const effectiveEnableContext = isVectorizationEnabled() ? enableContext : false;
    return estimateRequiredCredits(raw || [], effectiveEnableContext, hasAttachments, model || '');
  }, 'chat'), async (req, res) => {
    console.log('üöÄ Chat endpoint called for user:', req.user?.id);
    try {
      const { provider, messages, model, max_tokens, temperature, top_p, stream, sessionId, enableContext = true, original_messages, ...otherParams } = req.body;
      
      if (!provider) {
        return res.status(400).json({ error: 'Provider is required' });
      }

      // Get user's configuration
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      const userId = req.user!.id;
      let modelName = model || "nomadic-icdu-v8"; // Default to preferred model
      let response;
      let conversation;
      let userMessage;
      let aiResponse;
      let enhancedMessages = messages; // Default to provider-formatted messages
      const rawMessages = original_messages || messages; // Prefer originals for storage/context

      // =============================================================================
      // VECTORIZATION PIPELINE INTEGRATION
      // =============================================================================

      try {
        // 1. Get or create conversation
        conversation = await conversationService.getOrCreateConversation(
          userId, 
          provider.toLowerCase(), 
          modelName, 
          sessionId
        );

        console.log(`üí¨ Using conversation ${conversation.id} for user ${userId}`);

        // 2. Store user message (last message in the array)
        const lastMessage = rawMessages[rawMessages.length - 1];
        if (lastMessage && lastMessage.role === 'user') {
          userMessage = await conversationService.addMessage({
            conversationId: conversation.id,
            content: lastMessage.content,
            role: 'user',
            attachments: lastMessage.attachments,
            metadata: lastMessage.metadata
          });

          console.log(`üìù Stored user message ${userMessage.id} in conversation ${conversation.id}`);
        }

        // 3. Enhance messages with context from past conversations (if enabled and vectors available)
        if (enableContext && isVectorizationEnabled()) {
          try {
            const contextResult = await contextEnhancer.enhanceMessagesWithContext(
              rawMessages, 
              userId,
              { maxSimilarMessages: 3, maxSimilarConversations: 2, similarityThreshold: 0.75, includeConversationContext: true, includeMessageContext: true, maxContextLength: 2000 }
            );

            enhancedMessages = contextResult.enhancedMessages;
            console.log(`üß† Enhanced messages with context: ${contextResult.similarMessages.length} similar messages, ${contextResult.similarConversations.length} similar conversations`);

            // Attach context file snippets to be returned to the client for citations
            (req as any)._contextFileSnippets = contextResult.fileSnippets || [];
          } catch (contextError) {
            console.warn('‚ö†Ô∏è Context enhancement skipped/failed, proceeding without context:', contextError);
          }
        }

      } catch (vectorError) {
        console.error('‚ùå Vectorization pipeline error (proceeding without storage):', vectorError);
        // Continue with the request even if vectorization fails
      }

      // =============================================================================
      // AI PROVIDER PROCESSING (Enhanced with vectorization)
      // =============================================================================

      switch (provider.toLowerCase()) {
        case 'azure':
        case 'azureai': {
          const endpoint = process.env.VITE_AZURE_AI_ENDPOINT;
          const apiKey = process.env.VITE_AZURE_AI_API_KEY;
          modelName = model || process.env.VITE_AZURE_AI_MODEL_NAME || "ministral-3b";

          if (!endpoint || !apiKey) {
            return res.status(400).json({ error: 'Azure AI configuration missing' });
          }

          const client = ModelClient(endpoint, new AzureKeyCredential(apiKey));
          
          let apiPath = "/chat/completions";
          if (modelName === "breaking-better-v6-1-ft") {
            apiPath = "/openai/deployments/5-04-14-ft-af30ee616d674bf7b5ca3e085fe544c4-breaking-better-v6-1/chat/completions?api-version=2025-01-01-preview";
          }

          const requestBody: any = {
            messages: enhancedMessages || messages,
            model: modelName,
            max_tokens: max_tokens || 1024,
            temperature: temperature || 0.7,
            top_p: top_p || 0.9,
            stream: stream || false,
            ...otherParams
          };

          response = await client.path(apiPath as any).post({
            body: requestBody,
          });
          break;
        }

        case 'uterpi': {
          const endpointUrl = process.env.VITE_UTERPI_ENDPOINT_URL;
          const apiToken = process.env.VITE_UTERPI_API_TOKEN;

          if (!endpointUrl || !apiToken) {
            return res.status(400).json({ error: 'Uterpi LLM configuration missing' });
          }

          // Convert messages to HuggingFace format
          const prompt = (enhancedMessages || messages)
            .map((m: any) => {
              const role = m.role === "assistant" ? "Assistant" : m.role === "user" ? "User" : "System";
              return `${role}: ${m.content}`;
            })
            .join("\n\n") + "\n\nAssistant:";

          const requestBody = {
            inputs: prompt,
            parameters: {
              max_new_tokens: max_tokens || 1024,
              temperature: temperature || 0.7,
              top_p: top_p || 0.9,
              return_full_text: false
            }
          };

          response = await fetch(endpointUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${apiToken}`
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const errText = await response.text();
            throw new Error(`Uterpi LLM error (${response.status}): ${errText}`);
          }

          // Convert HuggingFace response to OpenAI format
          const data = await response.json();
          let text = "";
          if (Array.isArray(data)) {
            const first = data[0] || {};
            text = first.generated_text || first.summary_text || "";
          } else if (typeof data === "object" && data) {
            text = (data as any).generated_text || "";
          } else if (typeof data === "string") {
            text = data;
          }

          // Return in OpenAI-compatible format
          response = {
            status: "200",
            body: {
              choices: [{
                message: {
                  content: text,
                  role: "assistant"
                }
              }]
            }
          };
          break;
        }

        case 'lmstudio': {
          const baseInfo = getLMStudioBaseUrl();
          const targetUrl = `${baseInfo.url}/v1/chat/completions`;
          const proxyAuth = process.env.LMSTUDIO_API_KEY ? `Bearer ${process.env.LMSTUDIO_API_KEY}` : "Bearer lm-studio";

          const requestBody = {
            messages: enhancedMessages || messages,
            model: model || "nomadic-icdu-v8",
            max_tokens: max_tokens || 1024,
            temperature: temperature || 0.7,
            top_p: top_p || 0.9,
            stream: stream || false,
            ...otherParams
          };

          const lmResponse = await fetch(targetUrl, {
            method: 'POST',
            headers: {
              "Content-Type": "application/json",
              "Authorization": proxyAuth,
              "Accept": stream ? "text/event-stream" : "application/json"
            },
            body: JSON.stringify(requestBody)
          });

          if (!lmResponse.ok) {
            const errText = await lmResponse.text();
            throw new Error(`LM Studio error (${lmResponse.status}): ${errText}`);
          }

          if (stream) {
            // Handle streaming response - pass through the stream
            console.log('üåä LM Studio: Handling streaming response');
            res.setHeader('Content-Type', 'text/event-stream');
            res.setHeader('Cache-Control', 'no-cache');
            res.setHeader('Connection', 'keep-alive');
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Cache-Control');

            // Pipe the streaming response directly to client
            const reader = lmResponse.body?.getReader();
            if (!reader) {
              throw new Error('No response body for streaming');
            }

            const decoder = new TextDecoder();
            let streamedContent = '';
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                console.log('üåä LM Studio chunk:', chunk.substring(0, 100) + '...');
                
                // Collect streamed content for credit calculation
                try {
                  const lines = chunk.split('\n');
                  for (const line of lines) {
                    if (line.startsWith('data: ') && !line.includes('[DONE]')) {
                      const dataStr = line.substring(6).trim();
                      if (dataStr && dataStr !== '[DONE]') {
                        try {
                          const parsed = JSON.parse(dataStr);
                          const content = parsed?.choices?.[0]?.delta?.content || '';
                          streamedContent += content;
                        } catch (e) {
                          // Ignore parsing errors for individual chunks
                        }
                      }
                    }
                  }
                } catch (e) {
                  // Ignore content collection errors
                }
                
                res.write(chunk);
              }
              res.end();
              
              // Deduct credits after streaming is complete
              try {
                const inputTokens = countTokensFromMessages(messages || []);
                const outputTokens = estimateTokenCount(streamedContent);
                console.log(`üí≥ Post-stream credit deduction: ${inputTokens} input + ${outputTokens} output tokens for streamed content: "${streamedContent.substring(0, 100)}..."`);
                await deductCreditsAfterResponse(req, inputTokens, outputTokens, model || 'lmstudio');
              } catch (creditError) {
                console.error('‚ùå Error deducting credits after streaming:', creditError);
              }
              
              return;
            } finally {
              reader.releaseLock();
            }
          } else {
            // Handle non-streaming response
            const responseText = await lmResponse.text();
            console.log('üîç LM Studio raw response:', responseText.substring(0, 200) + '...');
            
            let data;
            try {
              data = JSON.parse(responseText);
            } catch (parseError) {
              console.error('‚ùå Failed to parse LM Studio response as JSON:', parseError);
              console.error('‚ùå Raw response text:', responseText);
              throw new Error(`LM Studio returned invalid JSON: ${responseText.substring(0, 100)}...`);
            }

            response = {
              status: "200",
              body: data
            };
          }
          break;
        }

        case 'openai': {
          const apiKey = (req.body as any)?.apiKey || process.env.VITE_OPENAI_API_KEY;
          if (!apiKey) {
            return res.status(400).json({ error: 'OpenAI configuration missing' });
          }

          const requestBody = {
            messages: enhancedMessages || messages,
            model: model || "gpt-4o-mini",
            max_tokens: max_tokens || 1024,
            temperature: temperature || 0.7,
            top_p: top_p || 0.9,
            stream: stream || false,
            ...otherParams
          };

          response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const errText = await response.text();
            throw new Error(`OpenAI error (${response.status}): ${errText}`);
          }

          const data = await response.json();
          response = {
            status: "200",
            body: data
          };
          break;
        }

        case 'gemini': {
          const apiKey = (req.body as any)?.apiKey || process.env.VITE_GEMINI_API_KEY;
          if (!apiKey) {
            return res.status(400).json({ error: 'Gemini configuration missing' });
          }

          // Convert messages to Gemini format
          const geminiMessages = (enhancedMessages || messages).map((msg: any) => ({
            role: msg.role === "assistant" ? "model" : "user",
            parts: [{ text: msg.content || "" }]
          }));

          const requestBody = {
            contents: geminiMessages,
            generationConfig: {
              maxOutputTokens: max_tokens || 1024,
              temperature: temperature || 0.7,
              topP: top_p || 0.9
            }
          };

          if (stream) {
            console.log('üåä Gemini: Handling REAL streaming request');
            
            // Use the REAL Gemini streaming API endpoint with SSE
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model || "gemini-2.5-flash"}:streamGenerateContent?alt=sse&key=${apiKey}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
              const errText = await response.text();
              throw new Error(`Gemini streaming error (${response.status}): ${errText}`);
            }

            // Set up Server-Sent Events headers
            res.setHeader('Content-Type', 'text/event-stream');
            res.setHeader('Cache-Control', 'no-cache');
            res.setHeader('Connection', 'keep-alive');
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Cache-Control');
            // Disable proxy buffering if behind nginx/ingress
            res.setHeader('X-Accel-Buffering', 'no');

            console.log('üåä Gemini: Starting REAL streaming from API');

            // Process the real streaming response
            const reader = response.body?.getReader();
            if (!reader) {
              throw new Error('No response body for Gemini streaming');
            }

            const decoder = new TextDecoder();
            let fullContent = '';

            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                console.log('üåä Gemini raw chunk:', chunk.substring(0, 200) + '...');

                // Process each line; Gemini SSE streams in lines prefixed with 'data:'
                const lines = chunk.split('\n');
                for (const line of lines) {
                  const trimmedLine = line.trim();
                  if (!trimmedLine) continue;

                  // Handle SSE control lines
                  if (trimmedLine.startsWith('event:')) {
                    continue; // ignore event labels
                  }

                  let payload = trimmedLine;
                  if (payload.startsWith('data:')) {
                    payload = payload.slice(5).trim(); // remove 'data:'
                  }

                  if (payload === '[DONE]') {
                    // Forward DONE marker and finish
                    res.write('data: [DONE]\n\n');
                    console.log('üåä Gemini: Received DONE marker');
                    continue;
                  }

                  try {
                    const jsonChunk = JSON.parse(payload);
                    const content = jsonChunk?.candidates?.[0]?.content?.parts?.[0]?.text || '';

                    if (content) {
                      fullContent += content;

                      // Send the chunk to client in OpenAI-compatible SSE format
                      const openAIChunk = {
                        choices: [{
                          delta: { content },
                          index: 0
                        }]
                      };

                      res.write(`data: ${JSON.stringify(openAIChunk)}\n\n`);
                      // Hint some environments to flush
                      // @ts-ignore - node types may not include flush
                      if (typeof (res as any).flush === 'function') {
                        try { (res as any).flush(); } catch {}
                      }
                      console.log('üåä Gemini streaming content:', content.substring(0, 50) + '...');
                    }
                  } catch (e) {
                    // Ignore non-JSON payloads
                  }
                }
              }

              // Send completion marker
              res.write('data: [DONE]\n\n');
              res.end();

              console.log('üåä Gemini: REAL streaming complete, total content length:', fullContent.length);

              // Deduct credits after streaming is complete
              try {
                const inputTokens = countTokensFromMessages(messages || []);
                const outputTokens = estimateTokenCount(fullContent);
                console.log(`üí≥ Post-stream credit deduction (Gemini REAL): ${inputTokens} input + ${outputTokens} output tokens for content: "${fullContent.substring(0, 100)}..."`);
                await deductCreditsAfterResponse(req, inputTokens, outputTokens, model || 'gemini');
              } catch (creditError) {
                console.error('‚ùå Error deducting credits after Gemini REAL streaming:', creditError);
              }

            } finally {
              reader.releaseLock();
            }
            
            return;
          } else {
            // Non-streaming
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model || "gemini-2.5-flash"}:generateContent?key=${apiKey}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
              const errText = await response.text();
              throw new Error(`Gemini error (${response.status}): ${errText}`);
            }

            const data = await response.json();
            console.log('üîç Gemini API response data:', JSON.stringify(data, null, 2));
            
            const content = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
            console.log('üîç Extracted content:', content ? content.substring(0, 100) + '...' : 'EMPTY');

            // Convert to OpenAI-compatible format
            const responseBody = {
              choices: [{
                message: {
                  content: content,
                  role: "assistant"
                }
              }]
            };
            console.log('üîç Backend: Returning response body:', JSON.stringify(responseBody, null, 2));
            return res.json(responseBody);
          }
        }

        default:
          return res.status(400).json({ error: `Unsupported provider: ${provider}` });
      }

      // =============================================================================
      // POST-PROCESSING: Store AI response and queue vectorization
      // =============================================================================
      
      // Calculate actual token usage and deduct credits
      if ((response as any).status === "200" || (response as any).status === 200) {
        const responseBody = (response as any).body;
        console.log('üîç Backend: Returning response body:', JSON.stringify(responseBody, null, 2));
        
        // Extract AI response content
        const outputContent = responseBody?.choices?.[0]?.message?.content || '';
        
        // Store AI response in conversation (always); vectorization queueing below is gated
        if (conversation && outputContent) {
          try {
            aiResponse = await conversationService.addMessage({
              conversationId: conversation.id,
              content: outputContent,
              role: 'assistant',
              metadata: {
                model: modelName,
                provider: provider.toLowerCase(),
                tokensUsed: responseBody?.usage?.total_tokens
              }
            });

            console.log(`ü§ñ Stored AI response ${aiResponse.id} in conversation ${conversation.id}`);

            // Queue both user and AI messages for vectorization (only when enabled)
            if (isVectorizationEnabled()) {
              if (userMessage) {
                await vectorProcessor.queueMessageVectorization(userMessage.id, conversation.id, 'normal');
              }
              await vectorProcessor.queueMessageVectorization(aiResponse.id, conversation.id, 'normal');
            }

            // Generate conversation title if this is the first exchange
            const messageCount = await conversationService.getConversationMessages(conversation.id);
            if (messageCount.length <= 2) { // First user + AI message pair
              await conversationService.generateConversationTitle(conversation.id);
            }

            // Queue conversation summary update (low priority, after several messages)
            if (isVectorizationEnabled()) {
              if (messageCount.length >= 6) { // After 3 exchanges
                await vectorProcessor.queueConversationSummary(conversation.id, 'low');
              }
            }

          } catch (storageError) {
            console.error('‚ùå Error storing AI response (continuing with response):', storageError);
          }
        }
        
        // Calculate actual token usage
        const inputTokens = countTokensFromMessages(messages || []);
        const outputTokens = estimateTokenCount(outputContent);
        
        // Deduct credits based on actual token usage
        const creditInfo = await deductCreditsAfterResponse(req, inputTokens, outputTokens, modelName || provider);
        
        // Include credit information and sources in response for real-time updates
        if (creditInfo) {
          responseBody.uterpi_credit_info = {
            credits_used: creditInfo.creditsUsed,
            remaining_balance: creditInfo.remainingBalance
          };
        }

        // Add sources/citations if available
        try {
          const fileSnippets = (req as any)._contextFileSnippets as Array<{ fileId: number; fileName: string; mimeType: string; similarity: number; snippet: string }>;
          if (Array.isArray(fileSnippets) && fileSnippets.length > 0) {
            responseBody.sources = fileSnippets.slice(0, 8).map(s => ({
              fileId: s.fileId,
              name: s.fileName,
              mimeType: s.mimeType,
              similarity: s.similarity,
              snippet: s.snippet
            }));
          }
        } catch {}
        
        res.json(responseBody);
      } else {
        const errorDetails = ((response as any).body as any)?.error?.message || 'Unknown AI error';
        console.error('‚ùå Backend: AI API error:', errorDetails);
        res.status(500).json({ error: `AI API error: ${errorDetails}` });
      }

    } catch (error) {
      console.error('Universal AI proxy error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  // Azure AI chat completions endpoint with dynamic credit checking (legacy support)
  app.post("/azure/v1/chat/completions", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const body: any = (req as any).body || {};
    const raw = body.original_messages || body.messages;
    const model = body.model;
    const hasAttachments = raw?.some((msg: any) => msg.attachments && msg.attachments.length > 0);
    return estimateRequiredCredits(raw || [], false, hasAttachments, model || '');
  }, 'chat'), async (req, res) => {
    try {
      const { messages, model, max_tokens, temperature, top_p, stream } = req.body;
      
      // Get user's Azure AI configuration
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      const endpoint = process.env.VITE_AZURE_AI_ENDPOINT;
      const apiKey = process.env.VITE_AZURE_AI_API_KEY;
      const modelName = model || process.env.VITE_AZURE_AI_MODEL_NAME || "ministral-3b";

      if (!endpoint || !apiKey) {
        return res.status(400).json({ error: 'Azure AI configuration missing' });
      }

      // Create Azure AI client
      const client = ModelClient(endpoint, new AzureKeyCredential(apiKey));
      
      // Determine API path based on model
      let apiPath = "/chat/completions";
      if (modelName === "breaking-better-v6-1-ft") {
        apiPath = "/openai/deployments/5-04-14-ft-af30ee616d674bf7b5ca3e085fe544c4-breaking-better-v6-1/chat/completions?api-version=2025-01-01-preview";
      }

      // Prepare request body
      const requestBody: any = {
        messages,
        model: modelName,
        max_tokens: max_tokens || 1024,
        temperature: temperature || 0.7,
        top_p: top_p || 0.9,
        stream: stream || false,
      };

      // Make request to Azure AI
      const response = await client.path(apiPath as any).post({
        body: requestBody,
      });

      if (response.status !== "200") {
        const errorDetails = (response.body as any)?.error?.message || 'Unknown Azure AI error';
        return res.status(500).json({ error: `Azure AI API error: ${errorDetails}` });
      }

      // Calculate actual token usage and deduct credits
      const inputTokens = countTokensFromMessages(requestBody.messages || []);
      const outputContent = (response.body as any)?.choices?.[0]?.message?.content || '';
      const outputTokens = estimateTokenCount(outputContent);
      
      // Deduct credits based on actual token usage
      const creditInfo = await deductCreditsAfterResponse(req, inputTokens, outputTokens, modelName);

      // Include credit information in response for real-time updates
      const responseBody = response.body as any;
      if (creditInfo) {
        responseBody.uterpi_credit_info = {
          credits_used: creditInfo.creditsUsed,
          remaining_balance: creditInfo.remainingBalance
        };
      }

      // Return the response
      res.json(responseBody);

    } catch (error) {
      console.error('Azure AI proxy error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });
  
  // =============================================================================
  // AUTHENTICATION ROUTES
  // =============================================================================
  
  // User registration
  app.post("/api/auth/register", requireGuest, async (req, res) => {
    try {
      const validatedData = registerUserSchema.parse(req.body);
      const user = await storage.createUser(validatedData);
      
      // Automatically log in the user after registration
      req.login(user as any, (err) => {
        if (err) {
          console.error("Login after registration failed:", err);
          return res.status(500).json({ error: "Registration successful but login failed" });
        }
        
        // Return public user data
        const publicUser = publicUserSchema.parse(user);
        res.status(201).json({ 
          success: true, 
          message: "User registered successfully",
          user: publicUser 
        });
      });
    } catch (error: any) {
      console.error("Registration error:", error);
      if (error.message?.includes("already exists")) {
        res.status(409).json({ error: error.message });
      } else if (error.issues) {
        // Zod validation error
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Registration failed" });
      }
    }
  });

  // User login
  app.post("/api/auth/login", requireGuest, (req, res, next) => {
    try {
      const validatedData = loginUserSchema.parse(req.body);
      
      passport.authenticate("local", (err: any, user: any, info: any) => {
        if (err) {
          console.error("Login error:", err);
          return res.status(500).json({ error: "Login failed" });
        }
        
        if (!user) {
          return res.status(401).json({ 
            error: info?.message || "Invalid email or password" 
          });
        }
        
        req.login(user, (loginErr) => {
          if (loginErr) {
            console.error("Session creation failed:", loginErr);
            return res.status(500).json({ error: "Login failed" });
          }
          
          res.json({ 
            success: true, 
            message: "Login successful",
            user: user
          });
        });
      })(req, res, next);
    } catch (error: any) {
      if (error.issues) {
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(400).json({ error: "Invalid login data" });
      }
    }
  });

  // User logout
  app.post("/api/auth/logout", requireAuth, (req, res) => {
    req.logout((err) => {
      if (err) {
        console.error("Logout error:", err);
        return res.status(500).json({ error: "Logout failed" });
      }
      
      req.session.destroy((sessionErr) => {
        if (sessionErr) {
          console.error("Session destruction failed:", sessionErr);
          return res.status(500).json({ error: "Logout failed" });
        }
        
        res.json({ success: true, message: "Logout successful" });
      });
    });
  });

  // Get current user
  app.get("/api/auth/me", requireAuth, (req, res) => {
    res.json({ 
      success: true, 
      user: req.user 
    });
  });

  // Check authentication status
  app.get("/api/auth/status", (req, res) => {
    res.json({ 
      authenticated: req.isAuthenticated(),
      user: req.isAuthenticated() ? req.user : null
    });
  });

  // Google OAuth routes
  app.get("/api/auth/google", 
    passport.authenticate("google", { 
      scope: ["profile", "email"] 
    })
  );

  app.get("/api/auth/google/callback",
    passport.authenticate("google", { failureRedirect: "/login?error=oauth_failed" }),
    (req, res) => {
      // Successful authentication, redirect to frontend
      res.redirect("/?auth=success");
    }
  );

  // Password reset routes
  app.post("/api/auth/forgot-password", requireGuest, async (req, res) => {
    try {
      const validatedData = forgotPasswordSchema.parse(req.body);
      const { email } = validatedData;

      // Generate reset token
      const resetToken = await storage.generatePasswordResetToken(email);
      
      if (!resetToken) {
        // For security reasons, we don't reveal if the email exists or not
        // Always return success even if email doesn't exist
        return res.json({ 
          success: true, 
          message: "If an account with that email exists, a password reset link has been sent." 
        });
      }

      // Get user info for email personalization
      const user = await storage.getUserByEmail(email);
      const displayName = user?.firstName || user?.username || '';

      // Send password reset email
      const { sendPasswordResetEmail } = await import('./email');
      await sendPasswordResetEmail({
        to: email,
        name: displayName,
        resetToken
      });

      res.json({ 
        success: true, 
        message: "If an account with that email exists, a password reset link has been sent." 
      });
    } catch (error: any) {
      console.error("Forgot password error:", error);
      if (error.issues) {
        // Zod validation error
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Failed to process password reset request" });
      }
    }
  });

  // =============================================================================
  // ACCOUNT DELETION (IMMEDIATE) - cancels Stripe at period end
  // =============================================================================
  app.delete("/api/account", requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;

      // Fetch user subscriptions to cancel at period end
      const activeSubs = await db
        .select()
        .from(subscriptions)
        .where(and(eq(subscriptions.userId, userId), eq(subscriptions.status, "active")));

      // Cancel each subscription at period end (Stripe + local mirror)
      for (const sub of activeSubs) {
        if (sub.stripeSubscriptionId) {
          try {
            await cancelSubscription(sub.stripeSubscriptionId, true);
          } catch (e) {
            console.error("Stripe cancel at period end failed", e);
          }
        }

        // Mirror cancel_at_period_end locally
        await db
          .update(subscriptions)
          .set({ cancelAtPeriodEnd: true, updatedAt: new Date() })
          .where(eq(subscriptions.id, sub.id));
      }

      // Soft-delete user files
      try {
        const userFiles = await db
          .select()
          .from(files)
          .where(eq(files.userId, userId));

        for (const f of userFiles) {
          await db
            .update(files)
            .set({ status: "deleted", updatedAt: new Date() })
            .where(eq(files.id, f.id));
        }
      } catch (e) {
        console.error("Soft-deleting user files failed", e);
      }

      // Mark user as deleted (soft-delete)
      await db
        .update(users)
        .set({ deletedAt: new Date(), updatedAt: new Date() })
        .where(eq(users.id, userId));

      // Destroy session
      req.logout(() => {
        req.session.destroy(() => {
          res.json({ success: true, message: "Your account has been deleted. This cannot be undone." });
        });
      });
    } catch (error) {
      console.error("Account deletion error:", error);
      res.status(500).json({ error: "Failed to delete account" });
    }
  });

  app.post("/api/auth/reset-password", requireGuest, async (req, res) => {
    try {
      const validatedData = resetPasswordSchema.parse(req.body);
      const { token, password } = validatedData;

      // Validate token and reset password
      const success = await storage.resetPassword(token, password);
      
      if (!success) {
        return res.status(400).json({ error: "Invalid or expired reset token" });
      }

      // Get user info to send confirmation email
      const user = await storage.validatePasswordResetToken(token);
      if (user) {
        try {
          const { sendPasswordResetConfirmationEmail } = await import('./email');
          await sendPasswordResetConfirmationEmail(
            user.email, 
            user.firstName || user.username || ''
          );
        } catch (emailError) {
          console.error("Failed to send confirmation email:", emailError);
          // Don't fail the password reset if confirmation email fails
        }
      }

      res.json({ 
        success: true, 
        message: "Password has been reset successfully. You can now log in with your new password." 
      });
    } catch (error: any) {
      console.error("Reset password error:", error);
      if (error.issues) {
        // Zod validation error
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Failed to reset password" });
      }
    }
  });

  // =============================================================================
  // ENGAGEMENT SYSTEM ROUTES
  // =============================================================================

  // Track user activity
  app.post("/api/engagement/track", requireAuth, async (req, res) => {
    try {
      const { activityType, activityData, duration } = req.body;
      
      if (!activityType) {
        return res.status(400).json({ error: "Activity type is required" });
      }

      const sessionId = req.sessionID;
      const userAgent = req.headers['user-agent'];
      const ipAddress = req.ip || req.connection.remoteAddress;

      await engagementService.trackActivity(
        req.user!.id,
        activityType,
        activityData,
        sessionId,
        userAgent,
        ipAddress,
        duration
      );

      res.json({ success: true });
    } catch (error) {
      console.error("Track activity error:", error);
      res.status(500).json({ error: "Failed to track activity" });
    }
  });

  // Get user engagement data
  app.get("/api/engagement/stats", requireAuth, async (req, res) => {
    try {
      let engagement = await engagementService.getUserEngagement(req.user!.id);
      
      // If engagement doesn't exist for existing user, initialize it
      if (!engagement) {
        console.log(`Initializing engagement for existing user stats: ${req.user!.id}`);
        await engagementService.ensureUserEngagementExists(req.user!.id);
        engagement = await engagementService.getUserEngagement(req.user!.id);
      }

      const activity = await engagementService.getUserActivity(req.user!.id, 20);

      res.json({
        success: true,
        data: {
          engagement,
          recentActivity: activity,
        }
      });
    } catch (error) {
      console.error("Get engagement stats error:", error);
      res.status(500).json({ error: "Failed to get engagement stats" });
    }
  });

  // Get email preferences
  app.get("/api/engagement/email-preferences", requireAuth, async (req, res) => {
    try {
      let preferences = await engagementService.getEmailPreferences(req.user!.id);
      
      // If preferences don't exist for existing user, initialize them
      if (!preferences) {
        console.log(`Initializing engagement for existing user: ${req.user!.id}`);
        await engagementService.initializeUserEngagement(req.user!.id);
        
        // Try to get preferences again after initialization
        preferences = await engagementService.getEmailPreferences(req.user!.id);
        
        if (!preferences) {
          return res.status(500).json({ error: "Failed to initialize email preferences" });
        }
      }

      // Return preferences without sensitive tokens
      const { unsubscribeToken, ...safePreferences } = preferences;
      res.json({
        success: true,
        preferences: safePreferences
      });
    } catch (error) {
      console.error("Get email preferences error:", error);
      res.status(500).json({ error: "Failed to get email preferences" });
    }
  });

  // Update email preferences
  app.put("/api/engagement/email-preferences", requireAuth, async (req, res) => {
    try {
      const validatedData = updateEmailPreferencesSchema.parse(req.body);
      
      const success = await engagementService.updateEmailPreferences(req.user!.id, validatedData);
      
      if (success) {
        res.json({ success: true, message: "Email preferences updated" });
      } else {
        res.status(500).json({ error: "Failed to update email preferences" });
      }
    } catch (error: any) {
      console.error("Update email preferences error:", error);
      if (error.issues) {
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Failed to update email preferences" });
      }
    }
  });

  // Unsubscribe from emails (public endpoint)
  app.post("/api/engagement/unsubscribe", async (req, res) => {
    try {
      const validatedData = unsubscribeSchema.parse(req.body);
      
      const success = await engagementService.unsubscribeUser(validatedData.token, validatedData.reason);
      
      if (success) {
        res.json({ success: true, message: "Successfully unsubscribed from emails" });
      } else {
        res.status(400).json({ error: "Invalid unsubscribe token" });
      }
    } catch (error: any) {
      console.error("Unsubscribe error:", error);
      if (error.issues) {
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Failed to unsubscribe" });
      }
    }
  });

  // Email tracking endpoints
  app.get("/api/engagement/track-open", async (req, res) => {
    try {
      const { token } = req.query;
      
      if (token && typeof token === 'string') {
        // Track email open in database
        // This would update the emailSendLog table
        console.log('Email opened:', token);
      }

      // Return 1x1 transparent pixel
      const pixel = Buffer.from('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', 'base64');
      res.set({
        'Content-Type': 'image/gif',
        'Content-Length': pixel.length,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      res.send(pixel);
    } catch (error) {
      console.error("Track email open error:", error);
      res.status(200).send(); // Always return success for tracking
    }
  });

  app.get("/api/engagement/track-click", async (req, res) => {
    try {
      const { token, url } = req.query;
      
      if (token && typeof token === 'string') {
        // Track email click in database
        console.log('Email link clicked:', token);
      }

      // Redirect to the intended URL
      if (url && typeof url === 'string') {
        res.redirect(url);
      } else {
        res.redirect('/');
      }
    } catch (error) {
      console.error("Track email click error:", error);
      res.redirect('/'); // Always redirect somewhere
    }
  });

  // Manual email triggers (for testing/admin)
  app.post("/api/engagement/send-email", requireAuth, async (req, res) => {
    try {
      const { emailType, ...options } = req.body;
      
      let success = false;
      switch (emailType) {
        case 'welcome':
          success = await engagementService.sendWelcomeEmail(req.user!.id);
          break;
        case 'reengagement':
          success = await engagementService.sendReengagementEmail(req.user!.id);
          break;
        case 'feature_discovery':
          success = await engagementService.sendFeatureDiscoveryEmail(req.user!.id);
          break;
        case 'usage_insights':
          success = await engagementService.sendUsageInsightsEmail(req.user!.id, options.period);
          break;
        case 'product_tips':
          success = await engagementService.sendProductTipsEmail(req.user!.id, options.category);
          break;
        default:
          return res.status(400).json({ error: "Invalid email type" });
      }

      if (success) {
        res.json({ success: true, message: "Email sent successfully" });
      } else {
        res.status(400).json({ error: "Email could not be sent (user preferences or eligibility)" });
      }
    } catch (error) {
      console.error("Send email error:", error);
      res.status(500).json({ error: "Failed to send email" });
    }
  });

  // =============================================================================
  // AI COACH SYSTEM ROUTES
  // =============================================================================

  // Get pending AI Coach insights
  app.get("/api/coach/insights", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 5;
      const insights = await aiCoachService.getPendingInsights(req.user!.id, limit);
      
      res.json({ insights });
    } catch (error) {
      console.error('Error fetching coach insights:', error);
      res.status(500).json({ error: "Failed to fetch insights" });
    }
  });

  // Mark insight as shown
  app.post("/api/coach/insights/:id/shown", requireAuth, async (req, res) => {
    try {
      const insightId = parseInt(req.params.id);
      await aiCoachService.markInsightShown(insightId);
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error marking insight as shown:', error);
      res.status(500).json({ error: "Failed to update insight" });
    }
  });

  // Record feedback on insight
  app.post("/api/coach/insights/:id/feedback", requireAuth, async (req, res) => {
    try {
      const insightId = parseInt(req.params.id);
      const { feedback, details } = req.body;
      
      if (!['positive', 'negative', 'neutral'].includes(feedback)) {
        return res.status(400).json({ error: "Invalid feedback type" });
      }
      
      await aiCoachService.recordInsightFeedback(insightId, feedback, details);
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error recording insight feedback:', error);
      res.status(500).json({ error: "Failed to record feedback" });
    }
  });

  // Get user workflow statistics
  app.get("/api/coach/workflow-stats", requireAuth, async (req, res) => {
    try {
      const stats = await aiCoachService.getUserWorkflowStats(req.user!.id);
      
      res.json({ stats });
    } catch (error) {
      console.error('Error fetching workflow stats:', error);
      res.status(500).json({ error: "Failed to fetch workflow statistics" });
    }
  });

  // Track workflow command (for real-time tracking)
  app.post("/api/coach/track-command", requireAuth, async (req, res) => {
    try {
      const { command, model, duration, success } = req.body;
      const sessionId = req.sessionID;
      
      await aiCoachService.trackWorkflowActivity(
        req.user!.id,
        sessionId,
        'command',
        {
          command,
          model,
          duration,
          success,
          timestamp: new Date().toISOString(),
        }
      );
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error tracking command:', error);
      res.status(500).json({ error: "Failed to track command" });
    }
  });

  // Track model switch
  app.post("/api/coach/track-model-switch", requireAuth, async (req, res) => {
    try {
      const { fromModel, toModel, reason } = req.body;
      const sessionId = req.sessionID;
      
      await aiCoachService.trackWorkflowActivity(
        req.user!.id,
        sessionId,
        'model_switch',
        {
          fromModel,
          toModel,
          reason,
          timestamp: new Date().toISOString(),
        }
      );
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error tracking model switch:', error);
      res.status(500).json({ error: "Failed to track model switch" });
    }
  });

  // =============================================================================
  // USER PROFILE ROUTES
  // =============================================================================
  
  // Get user profile
  app.get("/api/user/profile", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      
      // Return public user data (excluding password and sensitive info)
      const profile = {
        id: user.id,
        email: user.email,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
        avatar: user.avatar,
        age: user.age,
        dateOfBirth: user.dateOfBirth,
        bio: user.bio,
        emailVerified: user.emailVerified,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      };
      
      res.json({ 
        success: true, 
        profile 
      });
    } catch (error) {
      console.error("Get profile error:", error);
      res.status(500).json({ error: "Failed to get profile" });
    }
  });

  // Update user profile
  app.put("/api/user/profile", requireAuth, async (req, res) => {
    try {
      const validatedData = updateProfileSchema.parse(req.body);
      
      // Check if username is being updated and if it's already taken
      if (validatedData.username && validatedData.username !== req.user!.username) {
        const existingUser = await storage.getUserByUsername(validatedData.username);
        if (existingUser && existingUser.id !== req.user!.id) {
          return res.status(409).json({ error: "Username already taken" });
        }
      }

      const updatedUser = await storage.updateUserProfile(req.user!.id, validatedData);
      
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }

      // Return public user data
      const profile = {
        id: updatedUser.id,
        email: updatedUser.email,
        username: updatedUser.username,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        avatar: updatedUser.avatar,
        age: updatedUser.age,
        dateOfBirth: updatedUser.dateOfBirth,
        bio: updatedUser.bio,
        emailVerified: updatedUser.emailVerified,
        createdAt: updatedUser.createdAt,
        updatedAt: updatedUser.updatedAt,
      };

      res.json({ 
        success: true, 
        message: "Profile updated successfully",
        profile 
      });
    } catch (error: any) {
      console.error("Update profile error:", error);
      if (error.issues) {
        // Zod validation error
        res.status(400).json({ 
          error: "Validation failed", 
          details: error.issues 
        });
      } else {
        res.status(500).json({ error: "Failed to update profile" });
      }
    }
  });

  // =============================================================================
  // SUBSCRIPTION ROUTES
  // =============================================================================
  
  // Get available subscription plans
  app.get("/api/subscription/plans", async (req, res) => {
    try {
      const plans = await db.select().from(subscriptionPlans)
        .where(eq(subscriptionPlans.isActive, true))
        .orderBy(subscriptionPlans.sortOrder);
      
      res.json({ 
        success: true, 
        plans 
      });
    } catch (error) {
      console.error("Get subscription plans error:", error);
      res.status(500).json({ error: "Failed to get subscription plans" });
    }
  });

  // Get user's subscription status
  app.get("/api/subscription/status", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get user's current subscription
      const subscription = await db.select().from(subscriptions)
        .where(eq(subscriptions.userId, req.user!.id))
        .orderBy(desc(subscriptions.createdAt))
        .limit(1);

      const subscriptionData = subscription[0] || null;
      let planData = null;

      if (subscriptionData?.planId) {
        const plan = await db.select().from(subscriptionPlans)
          .where(eq(subscriptionPlans.id, subscriptionData.planId))
          .limit(1);
        planData = plan[0] || null;
      }

      res.json({
        success: true,
        subscription: {
          status: user.subscriptionStatus || 'freemium',
          tier: user.subscriptionTier || 'freemium',
          endsAt: user.subscriptionEndsAt,
          plan: planData,
          details: subscriptionData,
        }
      });
    } catch (error) {
      console.error("Get subscription status error:", error);
      res.status(500).json({ error: "Failed to get subscription status" });
    }
  });

  // Get detailed subscription information (for upgrade flows)
  app.get("/api/subscription/details", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get user's current subscription with enhanced details
      const tier = user.subscriptionTier || 'freemium';
      
      // Get features from subscription_features table
      const [features] = await db.select()
        .from(subscriptionFeatures)
        .where(eq(subscriptionFeatures.tierName, tier));
      
      // Calculate messages remaining for freemium users
      const monthlyMessageAllowance = features?.monthlyMessageAllowance || 0;
      const messagesUsed = user.messages_used_this_month || 0;
      const messagesRemaining = Math.max(0, monthlyMessageAllowance - messagesUsed);
      
      res.json({
        hasAccess: ['active', 'trialing', 'freemium'].includes(user.subscriptionStatus || tier),
        tier,
        features: {
          unlimitedChat: features?.unlimitedChat || false,
          monthlyMessageAllowance,
          messagesUsedThisMonth: messagesUsed,
          messagesRemaining,
          aiProvidersAccess: features?.aiProvidersAccess || ['basic'],
          monthlyAiCredits: features?.monthlyAiCredits || 0,
          currentCreditsBalance: user.ai_credits_balance || 0,
          maxProjects: features?.maxProjects || 1,
          fullCodebaseContext: features?.fullCodebaseContext || false,
          gitIntegration: features?.gitIntegration || false,
          aiCodeReviewsPerMonth: features?.aiCodeReviewsPerMonth || 0,
          aiCodeReviewsUsed: 0,
          teamFeaturesEnabled: features?.teamFeaturesEnabled || false,
          sharedWorkspaces: features?.sharedWorkspaces || false,
          ssoEnabled: features?.ssoEnabled || false,
          auditLogs: features?.auditLogs || false,
          supportLevel: features?.supportLevel || 'email'
        },
        isGrandfathered: user.is_grandfathered || false,
        grandfatheredFrom: user.grandfathered_from_tier
      });
    } catch (error) {
      console.error("Get subscription details error:", error);
      res.status(500).json({ error: "Failed to get subscription details" });
    }
  });

  // Create setup intent for payment method collection
  app.post("/api/subscription/setup-intent", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      let customerId = user.stripeCustomerId;

      // Create Stripe customer if doesn't exist
      if (!customerId) {
        const customer = await createStripeCustomer({
          email: user.email,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || undefined,
          metadata: { userId: user.id.toString() }
        });
        
        customerId = customer.id;
        
        // Update user with Stripe customer ID
        await db.update(users)
          .set({ stripeCustomerId: customerId })
          .where(eq(users.id, user.id));
      }

      const setupIntent = await createSetupIntent(customerId);

      res.json({
        success: true,
        clientSecret: setupIntent.client_secret,
        customerId
      });
    } catch (error) {
      console.error("Create setup intent error:", error);
      res.status(500).json({ error: "Failed to create setup intent" });
    }
  });

  // Create subscription
  app.post("/api/subscription/create", requireAuth, async (req, res) => {
    try {
      const { planId, paymentMethodId } = req.body;
      
      if (!planId) {
        return res.status(400).json({ error: "Plan ID is required" });
      }

      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get the subscription plan
      const plan = await db.select().from(subscriptionPlans)
        .where(eq(subscriptionPlans.id, planId))
        .limit(1);

      if (!plan[0]) {
        return res.status(404).json({ error: "Subscription plan not found" });
      }

      const planData = plan[0];

      // For free plans, just update user status
      if (planData.price === '0.00') {
        await db.update(users)
          .set({
            subscriptionStatus: 'active',
            subscriptionTier: planData.name.toLowerCase(),
            updatedAt: new Date()
          })
          .where(eq(users.id, user.id));

        return res.json({
          success: true,
          message: "Free plan activated successfully"
        });
      }

      // For paid plans, require payment method
      if (!paymentMethodId) {
        return res.status(400).json({ error: "Payment method is required for paid plans" });
      }

      let customerId = user.stripeCustomerId;

      // Create Stripe customer if doesn't exist
      if (!customerId) {
        const customer = await createStripeCustomer({
          email: user.email,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || undefined,
          metadata: { userId: user.id.toString() }
        });
        
        customerId = customer.id;
        
        // Update user with Stripe customer ID
        await db.update(users)
          .set({ stripeCustomerId: customerId })
          .where(eq(users.id, user.id));
      }

      // Create subscription in Stripe
      const subscription = await createSubscription({
        customerId,
        priceId: planData.stripePriceId,
        paymentMethodId
      });

      // Sync subscription data to database
      await syncSubscriptionFromStripe(subscription.id, user.id);

      res.json({
        success: true,
        subscription: {
          id: subscription.id,
          status: subscription.status,
          clientSecret: (typeof subscription.latest_invoice === 'object' && subscription.latest_invoice) 
            ? (subscription.latest_invoice as any)?.payment_intent?.client_secret 
            : undefined
        }
      });
    } catch (error) {
      console.error("Create subscription error:", error);
      res.status(500).json({ error: "Failed to create subscription" });
    }
  });

  // Cancel subscription
  app.post("/api/subscription/cancel", requireAuth, async (req, res) => {
    try {
      const { immediate = false } = req.body;
      
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get user's active subscription
      const subscription = await db.select().from(subscriptions)
        .where(eq(subscriptions.userId, req.user!.id))
        .orderBy(desc(subscriptions.createdAt))
        .limit(1);

      if (!subscription[0]?.stripeSubscriptionId) {
        return res.status(404).json({ error: "No active subscription found" });
      }

      const canceledSubscription = await cancelSubscription(
        subscription[0].stripeSubscriptionId,
        !immediate
      );

      // Sync updated subscription data
      await syncSubscriptionFromStripe(canceledSubscription.id, user.id);

      res.json({
        success: true,
        message: immediate ? "Subscription canceled immediately" : "Subscription will cancel at period end"
      });
    } catch (error) {
      console.error("Cancel subscription error:", error);
      res.status(500).json({ error: "Failed to cancel subscription" });
    }
  });

  // Reactivate subscription
  app.post("/api/subscription/reactivate", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get user's subscription
      const subscription = await db.select().from(subscriptions)
        .where(eq(subscriptions.userId, req.user!.id))
        .orderBy(desc(subscriptions.createdAt))
        .limit(1);

      if (!subscription[0]?.stripeSubscriptionId) {
        return res.status(404).json({ error: "No subscription found" });
      }

      const reactivatedSubscription = await reactivateSubscription(
        subscription[0].stripeSubscriptionId
      );

      // Sync updated subscription data
      await syncSubscriptionFromStripe(reactivatedSubscription.id, user.id);

      res.json({
        success: true,
        message: "Subscription reactivated successfully"
      });
    } catch (error) {
      console.error("Reactivate subscription error:", error);
      res.status(500).json({ error: "Failed to reactivate subscription" });
    }
  });

  // Create billing portal session
  app.post("/api/subscription/billing-portal", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user?.stripeCustomerId) {
        return res.status(404).json({ error: "No Stripe customer found" });
      }

      const session = await createBillingPortalSession(
        user.stripeCustomerId,
        `${req.protocol}://${req.get('host')}/dashboard`
      );

      res.json({
        success: true,
        url: session.url
      });
    } catch (error) {
      console.error("Create billing portal session error:", error);
      res.status(500).json({ error: "Failed to create billing portal session" });
    }
  });

  // ===== NEW CHECKOUT SESSIONS ENDPOINTS =====

  // Create Stripe Checkout Session for Subscription
  app.post("/api/checkout/subscription", requireAuth, async (req, res) => {
    try {
      const { tier, interval, teamName, memberEmails } = req.body;
      
      if (!tier || !interval) {
        return res.status(400).json({ error: "Tier and interval are required" });
      }

      if (!['pro', 'team', 'enterprise'].includes(tier)) {
        return res.status(400).json({ error: "Invalid subscription tier" });
      }

      if (!['month', 'year'].includes(interval)) {
        return res.status(400).json({ error: "Invalid billing interval" });
      }

      // Enterprise requires custom pricing
      if (tier === 'enterprise') {
        return res.status(400).json({ 
          error: "Enterprise plans require custom pricing. Please contact sales.",
          contactSales: true 
        });
      }

      const baseUrl = `${req.protocol}://${req.get('host')}`;
      const session = await createSubscriptionCheckoutSession({
        userId: req.user!.id,
        tier,
        interval,
        successUrl: `${baseUrl}/checkout/success`,
        cancelUrl: `${baseUrl}/checkout/cancel`,
        teamName,
        memberEmails,
      });

      res.json({ 
        success: true, 
        sessionId: session.id,
        url: session.url 
      });
    } catch (error) {
      console.error("Create subscription checkout error:", error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : "Failed to create checkout session" 
      });
    }
  });

  // Create Stripe Checkout Session for AI Credits
  app.post("/api/checkout/credits", requireAuth, async (req, res) => {
    try {
      const { packageId } = req.body;
      
      if (!packageId) {
        return res.status(400).json({ error: "Package ID is required" });
      }

      const validPackages = ['credits_100', 'credits_500', 'credits_1000', 'credits_5000'];
      if (!validPackages.includes(packageId)) {
        return res.status(400).json({ error: "Invalid credit package" });
      }

      const baseUrl = `${req.protocol}://${req.get('host')}`;
      const session = await createCreditsCheckoutSession({
        userId: req.user!.id,
        packageId,
        successUrl: `${baseUrl}/checkout/success`,
        cancelUrl: `${baseUrl}/checkout/cancel`,
      });

      res.json({ 
        success: true, 
        sessionId: session.id,
        url: session.url 
      });
    } catch (error) {
      console.error("Create credits checkout error:", error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : "Failed to create checkout session" 
      });
    }
  });

  // Handle Checkout Success (retrieve session details)
  app.get("/api/checkout/session/:sessionId", requireAuth, async (req, res) => {
    try {
      const { sessionId } = req.params;
      
      if (!sessionId) {
        return res.status(400).json({ error: "Session ID is required" });
      }

      const session = await getCheckoutSession(sessionId);
      
      // Verify this session belongs to the authenticated user
      const sessionUserId = parseInt(session.metadata?.userId || '0');
      if (sessionUserId !== req.user!.id) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json({
        success: true,
        session: {
          id: session.id,
          status: session.status,
          mode: session.mode,
          amountTotal: session.amount_total,
          currency: session.currency,
          customerEmail: session.customer_details?.email,
          paymentStatus: session.payment_status,
          metadata: session.metadata,
        }
      });
    } catch (error) {
      console.error("Get checkout session error:", error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : "Failed to retrieve checkout session" 
      });
    }
  });

  // =============================================================================
  // STRIPE WEBHOOK ROUTES
  // =============================================================================
  
  // Stripe webhooks are registered in index.ts before body parsers to preserve raw body

  // =============================================================================
  // AI-POWERED FEATURE ROUTES (SUBSCRIPTION PROTECTED)
  // =============================================================================
  
  // AI Service metrics and monitoring endpoint
  app.get("/api/ai/metrics", requireAuth, async (req, res) => {
    try {
      const metrics = {
        overview: {
          totalRequests: aiMetrics.totalRequests,
          successfulRequests: aiMetrics.successfulRequests,
          failedRequests: aiMetrics.failedRequests,
          successRate: aiMetrics.totalRequests > 0 ? 
            ((aiMetrics.successfulRequests / aiMetrics.totalRequests) * 100).toFixed(1) + '%' : '0%',
          avgResponseTime: Math.round(aiMetrics.avgResponseTime) + 'ms',
          cacheHits: aiMetrics.cacheHits,
          cacheHitRate: aiMetrics.totalRequests > 0 ? 
            ((aiMetrics.cacheHits / aiMetrics.totalRequests) * 100).toFixed(1) + '%' : '0%'
        },
        endpoints: Array.from(aiMetrics.endpointStats.entries()).map(([endpoint, stats]) => ({
          endpoint,
          requests: stats.requests,
          successes: stats.successes,
          failures: stats.failures,
          successRate: stats.requests > 0 ? ((stats.successes / stats.requests) * 100).toFixed(1) + '%' : '0%',
          avgResponseTime: Math.round(stats.avgResponseTime) + 'ms'
        })).sort((a, b) => b.requests - a.requests),
        errors: Array.from(aiMetrics.errorTypes.entries()).map(([error, count]) => ({
          error,
          count,
          percentage: aiMetrics.failedRequests > 0 ? ((count / aiMetrics.failedRequests) * 100).toFixed(1) + '%' : '0%'
        })).sort((a, b) => b.count - a.count),
        cache: {
          size: aiResponseCache.size,
          entries: aiResponseCache.size
        },
        timestamp: new Date().toISOString()
      };
      
      res.json({
        success: true,
        metrics
      });
    } catch (error) {
      console.error("AI metrics error:", error);
      res.status(500).json({ error: "Failed to retrieve AI service metrics" });
    }
  });

  // AI Template Generation Endpoint
  app.post("/api/ai/generate-templates", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { prompt, templateType, complexity } = req.body;
    const messages = [{ content: prompt || 'Generate templates' }];
    return Math.max(5, estimateRequiredCredits(messages, false, false, ''));
  }, 'template-generation'), async (req, res) => {
    console.log('üé® AI Template Generation called for user:', req.user?.id);
    try {
      const { description, provider, model } = req.body;
      
      if (!description || description.trim().length < 10) {
        return res.status(400).json({ error: 'Description must be at least 10 characters long' });
      }

      // Get user's configuration
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      // Use provided provider or default to gemini (no user preferences stored yet)
      const aiProvider = provider || 'gemini';
      const { client, config } = createAIClient(aiProvider);

      const templatePrompt = `Based on this description: "${description}"

Generate 3-5 relevant web page templates that would fulfill this requirement. For each template, provide:
- A unique ID (kebab-case)
- A clear name
- A detailed description
- Complexity level (simple/medium/complex)
- Estimated implementation effort in credits (5-30 range)

Return a JSON object with this structure:
{
  "templates": [
    {
      "id": "template-id",
      "name": "Template Name",
      "description": "Detailed description of what this template includes",
      "complexity": "medium",
      "estimatedCredits": 15,
      "features": ["feature1", "feature2", "feature3"],
      "confidence": 0.9
    }
  ]
}

Focus on practical, implementable templates that match the user's requirements. Be specific about what components and features each template would include.`;

      let aiResponse;
      
      if (aiProvider.toLowerCase() === 'gemini') {
        const aiModel = client.getGenerativeModel({ 
          model: config.modelName,
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 2048
          }
        });
        
        const result = await aiModel.generateContent(templatePrompt);
        const response = await result.response;
        aiResponse = response.text();
      } else if (aiProvider.toLowerCase() === 'openai' || aiProvider.toLowerCase() === 'lmstudio') {
        const response = await client.chat.completions.create({
          model: config.modelName,
          messages: [
            {
              role: "system",
              content: "You are a senior web developer and UX designer specializing in creating practical, user-focused web page templates. Generate templates that are implementable and match user requirements closely."
            },
            {
              role: "user",
              content: templatePrompt
            }
          ],
          max_tokens: 2048,
          temperature: 0.3
        });
        
        aiResponse = response.choices[0].message.content;
      } else if (aiProvider.toLowerCase() === 'azure' || aiProvider.toLowerCase() === 'azureai') {
        const response = await retryWithBackoff(async () => {
          return await client.path("/chat/completions").post({
            body: {
              messages: [
                {
                  role: "system",
                  content: "You are a senior web developer and UX designer specializing in creating practical, user-focused web page templates. Generate templates that are implementable and match user requirements closely."
                },
                {
                  role: "user",
                  content: templatePrompt
                }
              ],
              max_tokens: 2048,
              temperature: 0.3,
              model: config.modelName,
              stream: false,
            },
          });
        }, config.maxRetries || 3, config.retryDelay || 1000);

        if (response.status !== "200") {
          const errorDetail = extractAzureAIError(response.body?.error || response.body);
          throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
        }

        aiResponse = response.body.choices[0]?.message?.content;
      } else {
        throw new Error(`Unsupported provider: ${aiProvider}`);
      }

      // Parse the AI response
      let parsedResponse;
      try {
        // Clean up the response to extract JSON
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsedResponse = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.warn('Failed to parse AI response, using fallback templates');
        parsedResponse = {
          templates: [
            {
              id: 'ai-suggested-landing',
              name: 'AI-Suggested Landing Page',
              description: 'Custom landing page based on your requirements',
              complexity: 'medium',
              estimatedCredits: 15,
              features: ['hero-section', 'features', 'cta'],
              confidence: 0.7
            }
          ]
        };
      }

      // Deduct credits (5 credits for template generation)
      await trackAIUsage({
        userId: req.user!.id,
        operationType: 'app_generation',
        modelUsed: config.modelName,
        tokensConsumed: 500 // Estimated tokens for template generation
      });

      res.json({
        success: true,
        templates: parsedResponse.templates || [],
        aiProvider,
        model: config.modelName
      });

    } catch (error) {
      console.error('‚ùå AI Template Generation error:', error);
      res.status(500).json({ 
        error: 'Failed to generate AI templates',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // AI Suggestions Endpoint
  app.post("/api/ai/generate-suggestions", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { context, type } = req.body;
    const messages = [{ content: context || 'Generate suggestions' }];
    return Math.max(2, estimateRequiredCredits(messages, false, false, ''));
  }, 'suggestion-generation'), async (req, res) => {
    console.log('üí° AI Suggestions called for user:', req.user?.id);
    try {
      const { input, context, provider, model } = req.body;
      
      if (!input || input.trim().length < 5) {
        return res.status(400).json({ error: 'Input must be at least 5 characters long' });
      }

      // Get user's configuration
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      // Use provided provider or default to gemini (no user preferences stored yet)
      const aiProvider = provider || 'gemini';
      const { client, config } = createAIClient(aiProvider);

      const suggestionPrompt = `Based on this user input for ${context || 'page generation'}: "${input}"

Generate 3-5 helpful suggestions to improve or expand their requirements. Each suggestion should be:
- Specific and actionable
- Relevant to web page creation
- Categorized as 'requirement', 'style', or 'component'
- Include a confidence score (0.1-1.0)

Return a JSON object with this structure:
{
  "suggestions": [
    {
      "id": "suggestion-1",
      "text": "Consider adding a testimonials section to build trust with visitors",
      "type": "requirement",
      "confidence": 0.8
    },
    {
      "id": "suggestion-2", 
      "text": "Use a modern, clean design with plenty of whitespace",
      "type": "style",
      "confidence": 0.9
    }
  ]
}

Focus on practical suggestions that would enhance the user's page concept.`;

      let aiResponse;
      
      if (aiProvider.toLowerCase() === 'gemini') {
        const aiModel = client.getGenerativeModel({ 
          model: config.modelName,
          generationConfig: {
            temperature: 0.4,
            maxOutputTokens: 1024
          }
        });
        
        const result = await aiModel.generateContent(suggestionPrompt);
        const response = await result.response;
        aiResponse = response.text();
      } else if (aiProvider.toLowerCase() === 'openai' || aiProvider.toLowerCase() === 'lmstudio') {
        const response = await client.chat.completions.create({
          model: config.modelName,
          messages: [
            {
              role: "system",
              content: "You are a helpful UX consultant and web development expert. Provide practical, actionable suggestions to improve web page concepts."
            },
            {
              role: "user",
              content: suggestionPrompt
            }
          ],
          max_tokens: 1024,
          temperature: 0.4
        });
        
        aiResponse = response.choices[0].message.content;
      } else if (aiProvider.toLowerCase() === 'azure' || aiProvider.toLowerCase() === 'azureai') {
        const response = await retryWithBackoff(async () => {
          return await client.path("/chat/completions").post({
            body: {
              messages: [
                {
                  role: "system",
                  content: "You are a helpful UX consultant and web development expert. Provide practical, actionable suggestions to improve web page concepts."
                },
                {
                  role: "user",
                  content: suggestionPrompt
                }
              ],
              max_tokens: 1024,
              temperature: 0.4,
              model: config.modelName,
              stream: false,
            },
          });
        }, config.maxRetries || 3, config.retryDelay || 1000);

        if (response.status !== "200") {
          const errorDetail = extractAzureAIError(response.body?.error || response.body);
          throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
        }

        aiResponse = response.body.choices[0]?.message?.content;
      } else {
        throw new Error(`Unsupported provider: ${aiProvider}`);
      }

      // Parse the AI response
      let parsedResponse;
      try {
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsedResponse = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.warn('Failed to parse AI suggestions, returning empty array');
        parsedResponse = { suggestions: [] };
      }

      // Deduct credits (2 credits for suggestions)
      await trackAIUsage({
        userId: req.user!.id,
        operationType: 'chat',
        modelUsed: config.modelName,
        tokensConsumed: 200 // Estimated tokens for suggestions
      });

      res.json({
        success: true,
        suggestions: parsedResponse.suggestions || [],
        aiProvider,
        model: config.modelName
      });

    } catch (error) {
      console.error('‚ùå AI Suggestions error:', error);
      res.status(500).json({ 
        error: 'Failed to generate AI suggestions',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // AI Page Generation Endpoint
  app.post("/api/ai/generate-page", requireAuth, checkFreemiumLimit(), requireDynamicCredits((req) => {
    const { description, features, complexity } = req.body;
    const messages = [{ content: description || 'Generate page' }];
    const baseCredits = estimateRequiredCredits(messages, false, false, '');
    // Page generation is complex, so ensure minimum of 15 credits
    return Math.max(15, baseCredits * 2);
  }, 'page-generation'), async (req, res) => {
    console.log('üöÄ AI Page Generation called for user:', req.user?.id);
    try {
      const { template, requirements, style, aiConfig, userContext } = req.body;
      
      if (!template || !requirements) {
        return res.status(400).json({ error: 'Template and requirements are required' });
      }

      // Get user's configuration
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      // Use provided AI config or default
      const aiProvider = aiConfig?.provider || 'gemini';
      const { client, config } = createAIClient(aiProvider);

      const pagePrompt = `Generate a complete React/TypeScript web page based on these specifications:

Template: ${template}
Requirements: ${requirements}
Style: ${style}
Complexity: ${aiConfig?.complexity || 'medium'}

Generate the following components:
1. Main page component (React/TypeScript)
2. Supporting components if needed
3. CSS/Tailwind styles
4. Any necessary configuration files

Return a JSON object with this structure:
{
  "page": {
    "template": "${template}",
    "components": [
      {
        "name": "MainPage",
        "props": ["title", "content"],
        "description": "Main page component"
      }
    ],
    "styles": {
      "theme": "${style}",
      "colors": {
        "primary": "#3b82f6",
        "secondary": "#64748b", 
        "accent": "#f59e0b"
      },
      "spacing": "8px",
      "borderRadius": "8px"
    },
    "routes": ["/", "/about", "/contact"],
    "creditsUsed": ${aiConfig?.estimatedCredits || 15}
  },
  "files": [
    {
      "name": "MainPage.tsx",
      "content": "// Complete React component code here",
      "type": "component"
    },
    {
      "name": "styles.css", 
      "content": "/* CSS styles here */",
      "type": "style"
    }
  ],
  "warnings": [],
  "suggestions": ["Consider adding responsive design", "Add accessibility features"]
}

Generate production-ready, modern React code with TypeScript, proper error handling, and accessibility features. Use Tailwind CSS for styling. Make the code clean, well-documented, and following best practices.`;

      let aiResponse;
      
      if (aiProvider.toLowerCase() === 'gemini') {
        const aiModel = client.getGenerativeModel({ 
          model: config.modelName,
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 8192
          }
        });
        
        const result = await aiModel.generateContent(pagePrompt);
        const response = await result.response;
        aiResponse = response.text();
      } else if (aiProvider.toLowerCase() === 'openai' || aiProvider.toLowerCase() === 'lmstudio') {
        const response = await client.chat.completions.create({
          model: config.modelName,
          messages: [
            {
              role: "system",
              content: "You are a senior React/TypeScript developer specializing in creating production-ready web applications. Generate clean, accessible, and modern code that follows industry best practices."
            },
            {
              role: "user",
              content: pagePrompt
            }
          ],
          max_tokens: 8192,
          temperature: 0.2
        });
        
        aiResponse = response.choices[0].message.content;
      } else if (aiProvider.toLowerCase() === 'azure' || aiProvider.toLowerCase() === 'azureai') {
        const response = await retryWithBackoff(async () => {
          return await client.path("/chat/completions").post({
            body: {
              messages: [
                {
                  role: "system",
                  content: "You are a senior React/TypeScript developer specializing in creating production-ready web applications. Generate clean, accessible, and modern code that follows industry best practices."
                },
                {
                  role: "user",
                  content: pagePrompt
                }
              ],
              max_tokens: 8192,
              temperature: 0.2,
              model: config.modelName,
              stream: false,
            },
          });
        }, config.maxRetries || 3, config.retryDelay || 1000);

        if (response.status !== "200") {
          const errorDetail = extractAzureAIError(response.body?.error || response.body);
          throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
        }

        aiResponse = response.body.choices[0]?.message?.content;
      } else {
        throw new Error(`Unsupported provider: ${aiProvider}`);
      }

      // Parse the AI response
      let parsedResponse;
      try {
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsedResponse = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.warn('Failed to parse AI page response, using fallback');
        parsedResponse = {
          page: {
            template,
            components: [{ name: 'GeneratedPage', props: [], description: 'AI Generated Page' }],
            styles: {
              theme: style,
              colors: { primary: '#3b82f6', secondary: '#64748b', accent: '#f59e0b' },
              spacing: '8px',
              borderRadius: '8px'
            },
            routes: ['/'],
            creditsUsed: aiConfig?.estimatedCredits || 15
          },
          files: [
            {
              name: 'GeneratedPage.tsx',
              content: `import React from 'react';\n\nconst GeneratedPage: React.FC = () => {\n  return (\n    <div className="min-h-screen bg-gray-50 p-8">\n      <h1 className="text-3xl font-bold text-gray-900 mb-4">Generated Page</h1>\n      <p className="text-gray-600">This page was generated based on your requirements: ${requirements}</p>\n    </div>\n  );\n};\n\nexport default GeneratedPage;`,
              type: 'component'
            }
          ],
          warnings: ['AI response parsing failed, using fallback template'],
          suggestions: ['Try regenerating with more specific requirements']
        };
      }

      // Deduct credits based on estimated cost
      const creditsToDeduct = aiConfig?.estimatedCredits || 15;
      await trackAIUsage({
        userId: req.user!.id,
        operationType: 'app_generation',
        modelUsed: config.modelName,
        tokensConsumed: creditsToDeduct * 100 // Estimated tokens based on credits
      });

      res.json({
        success: true,
        ...parsedResponse,
        aiProvider,
        model: config.modelName
      });

    } catch (error) {
      console.error('‚ùå AI Page Generation error:', error);
      res.status(500).json({ 
        error: 'Failed to generate AI page',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Model capabilities checking endpoint - now returns optimized configurations
  app.get("/api/model/capabilities/:modelId", async (req, res) => {
    try {
      const { modelId } = req.params;
      
      // Return the enhanced model configuration information
      // This provides much more detailed and accurate information than API testing
      res.json({
        success: true,
        modelId,
        message: "Model capabilities determined from configuration system",
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false,
          supportsSystemMessages: true,
          supportsJSONMode: false,
          supportsFunctionCalling: false,
          supportsStreaming: true,
          supportsStop: true,
          supportsLogitBias: false,
          supportsFrequencyPenalty: false,
          supportsPresencePenalty: false
        },
        optimizationNote: "Model parameters are now automatically optimized based on model-specific configurations in the frontend."
      });
    } catch (error) {
      console.error("Model capabilities check error:", error);
      res.status(500).json({ 
        success: false,
        error: "Failed to check model capabilities",
        capabilities: {
          supportsVision: false,
          supportsCodeGeneration: true,
          supportsAnalysis: true,
          supportsImageGeneration: false,
          supportsSystemMessages: true,
          supportsJSONMode: false,
          supportsFunctionCalling: false,
          supportsStreaming: true,
          supportsStop: true,
          supportsLogitBias: false,
          supportsFrequencyPenalty: false,
          supportsPresencePenalty: false
        }
      });
    }
  });

  // Enhanced Clone UI endpoints (requires subscription and credits)
  app.post("/api/clone-ui/analyze", requireActiveSubscription({
    customMessage: "AI-powered UI analysis requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { description, complexity } = req.body;
    const messages = [{ content: description || 'Analyze UI image' }];
    const baseCredits = estimateRequiredCredits(messages, false, true, ''); // Has image attachment
    return Math.max(8, baseCredits); // UI analysis is complex
  }, 'ui-analysis'), upload.single('image'), async (req: MulterRequest, res) => {
    const startTime = Date.now();
    try {
      if (!req.file) {
        trackAIRequest('/api/clone-ui/analyze', false, Date.now() - startTime, 'No image file provided');
        return res.status(400).json({ error: "No image file provided" });
      }

      // Get provider and API key from request
      const provider = req.body.provider || 'gemini';
      const userApiKey = req.body.apiKey;
      
      console.log(`üñºÔ∏è Starting enhanced UI clone analysis with ${provider}...`);
      const { client, config } = createAIClient(provider, userApiKey);
      
      // Convert image to base64 for Azure AI Vision
      const imageBase64 = req.file.buffer.toString('base64');
      const imageMimeType = req.file.mimetype;

      // Enhanced AI prompt for better UI analysis
      const analysisPrompt = `You are an expert UI/UX designer and frontend developer. Analyze this web design image with precision and detail.

**ANALYSIS REQUIREMENTS:**

1. **Component Identification**: Identify ALL visible UI components with specific descriptions
2. **Layout Analysis**: Describe the layout system (grid, flexbox, absolute positioning)
3. **Color Extraction**: Extract the EXACT color palette with hex codes from the design
4. **Typography Assessment**: Identify font styles, sizes, and hierarchies
5. **Complexity Estimation**: Assess implementation difficulty based on components and interactions

**RESPONSE FORMAT:**
You MUST respond with ONLY valid JSON in this exact structure. No markdown, no explanations, just the JSON:

{
  "components": [
    {
      "type": "specific_component_name",
      "description": "detailed description with position and purpose",
      "complexity": "simple|moderate|complex"
    }
  ],
  "layout": {
    "system": "grid|flexbox|absolute|hybrid",
    "structure": "detailed layout description",
    "responsive": "mobile-first|desktop-first|adaptive"
  },
  "colorPalette": {
    "primary": "#hex_code",
    "secondary": "#hex_code",
    "accent": "#hex_code",
    "background": "#hex_code",
    "text": "#hex_code",
    "additional": ["#hex1", "#hex2"]
  },
  "typography": {
    "primary": "font family and weight",
    "secondary": "secondary font details",
    "sizes": ["heading sizes", "body sizes"]
  },
  "estimatedComplexity": "low|medium|high",
  "implementationNotes": [
    "specific technical considerations",
    "required dependencies or libraries",
    "potential challenges"
  ]
}`;

      // Use provider-specific AI call
      let analysisResult;
      
      if (provider.toLowerCase() === 'gemini') {
        const model = client.getGenerativeModel({ 
          model: config.modelName,
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 3072,
            responseMimeType: "application/json"
          }
        });
        
        const imagePart = {
          inlineData: {
            data: imageBase64,
            mimeType: imageMimeType
          }
        };
        
        const result = await model.generateContent([analysisPrompt, imagePart]);
        const response = await result.response;
        const text = response.text();
        
        try {
          analysisResult = JSON.parse(text);
        } catch (e) {
          console.error("Failed to parse Gemini response:", text);
          throw new Error("Invalid JSON response from Gemini");
        }
      } else if (provider.toLowerCase() === 'openai') {
        const response = await client.chat.completions.create({
          model: config.modelName,
          messages: [
            {
              role: "system",
              content: "You are an expert UI/UX designer and frontend developer specializing in React/TypeScript. Provide detailed, accurate, and actionable analysis of web interfaces. Always respond with valid JSON only."
            },
            {
              role: "user",
              content: [
                { type: "text", text: analysisPrompt },
                { 
                  type: "image_url", 
                  image_url: { 
                    url: `data:${imageMimeType};base64,${imageBase64}` 
                  } 
                }
              ]
            }
          ],
          max_tokens: 3072,
          temperature: 0.2,
          response_format: { type: "json_object" }
        });
        
        analysisResult = JSON.parse(response.choices[0].message.content || "{}");
      } else if (provider.toLowerCase() === 'azure' || provider.toLowerCase() === 'azureai') {
        const response = await retryWithBackoff(async () => {
          return await client.path("/chat/completions").post({
            body: {
              messages: [
                {
                  role: "system",
                  content: "You are an expert UI/UX designer and frontend developer specializing in React/TypeScript. Provide detailed, accurate, and actionable analysis of web interfaces. Always respond with valid JSON only."
                },
                {
                  role: "user",
                  content: [
                    { type: "text", text: analysisPrompt },
                    { 
                      type: "image_url", 
                      image_url: { 
                        url: `data:${imageMimeType};base64,${imageBase64}` 
                      } 
                    }
                  ]
                }
              ],
              max_tokens: 3072,
              temperature: 0.2,
              model: config.modelName,
              stream: false,
              response_format: { type: "json_object" }
            },
          });
        }, config.maxRetries, config.retryDelay);
        
        if (!response.body?.choices?.[0]?.message?.content) {
          throw new Error("Invalid response from Azure AI");
        }
        
        analysisResult = JSON.parse(response.body.choices[0].message.content);
      } else {
        throw new Error(`Unsupported provider: ${provider}`);
      }
      
      // Validate the analysis result
      if (!analysisResult) {
        console.warn("‚ùå Failed to parse AI analysis");
        throw new Error(`Invalid analysis response from ${provider}`);
      }

      console.log("‚úÖ UI Analysis successful:", {
        componentsFound: analysisResult.components?.length || 0,
        layoutSystem: analysisResult.layout?.system || 'unknown',
        complexity: analysisResult.estimatedComplexity || 'unknown'
      });

      // Generate code based on AI analysis with caching
      const cacheKey = getCacheKey(
        `ui-code-gen-${JSON.stringify(analysisResult)}`,
        config.modelName,
        { temperature: 0.2 }
      );
      
      let generatedCode = config.cacheEnabled ? getCachedResponse(cacheKey) : null;
      
      if (!generatedCode) {
        generatedCode = await generateUICodeWithAI(client, config, analysisResult, provider);
        if (config.cacheEnabled !== false && generatedCode) {
          setCachedResponse(cacheKey, generatedCode, 60); // Cache for 1 hour
        }
      }

      const responseTime = Date.now() - startTime;
      trackAIRequest('/api/clone-ui/analyze', true, responseTime);
      
      console.log("‚úÖ UI clone analysis completed successfully in", responseTime + 'ms');
      
      res.json({
        success: true,
        analysis: analysisResult,
        generatedCode,
        metadata: {
          model: config.modelName,
          cached: !!getCachedResponse(cacheKey),
          responseTime: responseTime + 'ms',
          analysisTime: Date.now()
        }
      });
    } catch (error) {
      const responseTime = Date.now() - startTime;
      const errorMsg = extractAzureAIError(error);
      trackAIRequest('/api/clone-ui/analyze', false, responseTime, errorMsg);
      
      console.error("‚ùå Clone UI analysis error:", errorMsg);
      
      // Provide more detailed error information while keeping it safe for client
      let errorMessage = "Failed to analyze image with Azure AI";
      if (error instanceof Error) {
        errorMessage = error.message.includes('Azure AI API error') 
          ? error.message 
          : `Analysis failed: ${error.message}`;
      }
      
      res.status(500).json({ 
        error: errorMessage,
        details: "Please check that your image is a valid UI/web design screenshot",
        responseTime: responseTime + 'ms'
      });
    }
  });

  // Enhanced Create Page endpoints (requires subscription and credits)
  app.post("/api/create-page/generate", requireActiveSubscription({
    customMessage: "AI-powered page generation requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { template, requirements, style } = req.body;
    const messages = [{ content: `${template} ${requirements} ${style}` || 'Generate page' }];
    const baseCredits = estimateRequiredCredits(messages, false, false, '');
    return Math.max(12, baseCredits * 2); // Page generation is complex
  }, 'page-creation'), async (req, res) => {
    try {
      const { template, requirements, style } = req.body;
      
      if (!template || !requirements) {
        return res.status(400).json({ 
          error: "Missing required parameters: template and requirements are required" 
        });
      }
      
      console.log("üèóÔ∏è Starting enhanced page generation:", { template, style });
      
      const { client, config } = createAzureAIClient();
      
      // Use caching for page generation
      const cacheKey = getCacheKey(
        `page-gen-${template}-${requirements}-${style}`,
        config.modelName,
        { temperature: 0.3 }
      );
      
      let cachedResult = config.cacheEnabled ? getCachedResponse(cacheKey) : null;
      if (cachedResult) {
        console.log("üìÑ Using cached page generation result");
        return res.json({
          success: true,
          ...cachedResult,
          metadata: {
            model: config.modelName,
            cached: true,
            generationTime: Date.now()
          }
        });
      }
      
      // Use Azure AI to generate page structure and components
      const pageResult = await generatePageWithAI(client, config, template, requirements, style);
      const files = await generatePageFilesWithAI(client, config, pageResult);

      const result = {
        page: pageResult,
        files
      };
      
      // Cache the successful result
      if (config.cacheEnabled) {
        setCachedResponse(cacheKey, result, 90); // Cache for 1.5 hours
      }

      console.log("‚úÖ Page generation successful:", {
        template,
        componentsGenerated: pageResult.components?.length || 0,
        filesGenerated: files.length
      });

      res.json({
        success: true,
        ...result,
        metadata: {
          model: config.modelName,
          cached: false,
          generationTime: Date.now()
        }
      });
    } catch (error) {
      console.error("‚ùå Create page error:", extractAzureAIError(error));
      res.status(500).json({ 
        error: "Failed to generate page with Azure AI",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  app.get("/api/create-page/templates", async (req, res) => {
    res.json({
      templates: [
        { id: "landing", name: "Landing Page", description: "Modern landing page with hero and features" },
        { id: "dashboard", name: "Dashboard", description: "Admin dashboard with charts and tables" },
        { id: "portfolio", name: "Portfolio", description: "Personal portfolio with projects showcase" },
        { id: "blog", name: "Blog", description: "Blog layout with articles and sidebar" },
        { id: "ecommerce", name: "E-commerce", description: "Product catalog with shopping cart" }
      ]
    });
  });

  // Improve functionality endpoints (requires subscription and credits)
  app.post("/api/improve/analyze", requireActiveSubscription({
    customMessage: "AI-powered code analysis requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { code, context } = req.body;
    const messages = [{ content: `${code || ''} ${context || ''}` || 'Analyze code' }];
    const baseCredits = estimateRequiredCredits(messages, false, true, ''); // Has file attachment
    return Math.max(6, baseCredits); // Code analysis is moderately complex
  }, 'code-analysis'), upload.single('codeFile'), async (req: MulterRequest, res) => {
    try {
      const { code, component, provider, apiKey } = req.body;
      let codeToAnalyze = code;

      if (req.file) {
        codeToAnalyze = req.file.buffer.toString('utf-8');
      }

      if (!codeToAnalyze || codeToAnalyze.trim().length === 0) {
        return res.status(400).json({ error: "No code provided for analysis" });
      }

      // Get provider from request or use default
      const aiProvider = provider || 'gemini';
      console.log(`üìù Starting code analysis with ${aiProvider}...`);
      
      const { client, config } = createAIClient(aiProvider, apiKey);
      
      // Use AI to analyze and improve the code based on provider
      const result = await analyzeAndImproveCodeWithAI(client, config, codeToAnalyze, aiProvider);

      res.json({
        success: true,
        improvements: result.improvements,
        optimizedCode: result.optimizedCode
      });
    } catch (error) {
      console.error("Improve code error:", error);
      res.status(500).json({ error: "Failed to analyze code with Azure AI" });
    }
  });

  // Analyze functionality endpoints (requires subscription and credits)
  app.post("/api/analyze/performance", requireActiveSubscription({
    customMessage: "AI-powered performance analysis requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { code, component } = req.body;
    const messages = [{ content: `${code || ''} ${component || ''}` || 'Analyze performance' }];
    const baseCredits = estimateRequiredCredits(messages, false, false, '');
    return Math.max(7, baseCredits); // Performance analysis is complex
  }, 'performance-analysis'), async (req, res) => {
    try {
      const { projectPath, metrics } = req.body;

      const uterpiEndpoint = process.env.VITE_UTERPI_ENDPOINT_URL;
      const uterpiToken = process.env.VITE_UTERPI_API_TOKEN;

      if (!uterpiEndpoint || !uterpiToken) {
        return res.status(500).json({
          error: "Uterpi API not configured. Set VITE_UTERPI_ENDPOINT_URL and VITE_UTERPI_API_TOKEN."
        });
      }

      const raw = await analyzePerformanceWithUterpi(
        {
          endpointUrl: uterpiEndpoint,
          apiToken: uterpiToken,
          cacheEnabled: true,
          maxRetries: 3,
          retryDelay: 1000
        },
        projectPath,
        metrics || []
      );

      const analysis = mapUterpiPerformanceToModalShape(raw);
      res.json({
        success: true,
        analysis
      });
    } catch (error) {
      console.error("Performance analysis error:", error);
      res.status(500).json({ error: "Failed to analyze performance with Uterpi" });
    }
  });

  app.post("/api/analyze/design-patterns", requireActiveSubscription({
    customMessage: "AI-powered design pattern analysis requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { code, patterns } = req.body;
    const messages = [{ content: `${code || ''} ${patterns || ''}` || 'Analyze design patterns' }];
    const baseCredits = estimateRequiredCredits(messages, false, false, '');
    return Math.max(6, baseCredits); // Design pattern analysis is moderately complex
  }, 'design-analysis'), async (req, res) => {
    try {
      const { codebase } = req.body;
      const { client, config } = createAzureAIClient();
      
      // Use Azure AI to analyze design patterns
      const patterns = await analyzeDesignPatternsWithAI(client, config, codebase);

      res.json({
        success: true,
        patterns
      });
    } catch (error) {
      console.error("Design pattern analysis error:", error);
      res.status(500).json({ error: "Failed to analyze design patterns with Azure AI" });
    }
  });

  // File Management System Routes
  
  // Upload file endpoint
  app.post("/api/files/upload", requireAuth, upload.single('file'), async (req: MulterRequest, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No file provided" });
      }

      const { folder, description, tags } = req.body;
      const user = req.user as any;
      
      // Parse tags if provided as string
      let parsedTags: string[] = [];
      if (tags) {
        try {
          parsedTags = typeof tags === 'string' ? JSON.parse(tags) : tags;
        } catch {
          parsedTags = typeof tags === 'string' ? [tags] : tags;
        }
      }

      const fileData = {
        name: req.file.originalname,
        originalName: req.file.originalname,
        mimeType: req.file.mimetype,
        content: req.file.buffer,
        size: req.file.size,
        folder: folder || '/',
        description: description || null,
        tags: parsedTags,
      };

      const uploadedFile = await fileStorage.uploadFile(user.id, fileData);
      // Queue vectorization for supported files (non-blocking). Binary types will extract text.
      try {
        if (isVectorizationEnabled()) {
          await vectorProcessor.queueFileVectorization(uploadedFile.id, user.id);
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Failed to queue file vectorization:', e);
      }
      
      res.json({
        success: true,
        file: {
          id: uploadedFile.id,
          name: uploadedFile.name,
          originalName: uploadedFile.originalName,
          mimeType: uploadedFile.mimeType,
          size: uploadedFile.size,
          folder: uploadedFile.folder,
          description: uploadedFile.description,
          tags: uploadedFile.tags,
          createdAt: uploadedFile.createdAt,
          analysisStatus: uploadedFile.analysisStatus,
          aiAnalysis: uploadedFile.aiAnalysis,
          analyzedAt: uploadedFile.analyzedAt
        }
      });
    } catch (error) {
      console.error("File upload error:", error);
      res.status(500).json({ error: "Failed to upload file" });
    }
  });
  // Reindex a file's embeddings (admin/user utility)
  app.post("/api/files/:fileId/reindex", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;
      if (!fileId) {
        return res.status(400).json({ error: "Invalid file ID" });
      }
      // Queue reindex; do not block
      if (isVectorizationEnabled()) {
        await vectorProcessor.queueFileVectorization(fileId, user.id);
      }
      res.json({ success: true, message: 'File reindex queued' });
    } catch (error) {
      console.error("File reindex error:", error);
      res.status(500).json({ error: "Failed to reindex file" });
    }
  });

  // Helper function to validate fileId
  const validateFileId = (fileIdParam: string): number => {
    const fileId = parseInt(fileIdParam);
    if (isNaN(fileId) || fileId <= 0) {
      throw new Error('Invalid file ID');
    }
    return fileId;
  };

  // File folders/organization endpoints (MUST be before :fileId route)
  app.get("/api/files/folders", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      
      // Get unique folders for the user
      const result = await db
        .selectDistinct({ folder: files.folder })
        .from(files)
        .where(
          and(
            eq(files.userId, user.id),
            eq(files.status, 'active')
          )
        )
        .orderBy(files.folder);

      const folders = result.map(r => r.folder).filter(Boolean);
      
      res.json({
        success: true,
        folders
      });
    } catch (error) {
      console.error("Get folders error:", error);
      res.status(500).json({ error: "Failed to get folders" });
    }
  });

  // Get file details
  app.get("/api/files/:fileId", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;
      
      const file = await fileStorage.getFile(fileId, user.id);
      if (!file) {
        return res.status(404).json({ error: "File not found or access denied" });
      }

      // Return file metadata without content
      res.json({
        success: true,
        file: {
          id: file.id,
          name: file.name,
          originalName: file.originalName,
          mimeType: file.mimeType,
          size: file.size,
          folder: file.folder,
          description: file.description,
          tags: file.tags,
          isPublic: file.isPublic,
          analysisStatus: file.analysisStatus,
          aiAnalysis: file.aiAnalysis,
          currentVersion: file.currentVersion,
          createdAt: file.createdAt,
          updatedAt: file.updatedAt,
          lastAccessedAt: file.lastAccessedAt,
          analyzedAt: file.analyzedAt
        }
      });
    } catch (error) {
      console.error("Get file error:", error);
      if (error instanceof Error && error.message === 'Invalid file ID') {
        return res.status(400).json({ error: "Invalid file ID" });
      }
      res.status(500).json({ error: "Failed to get file" });
    }
  });

  // Download file content
  app.get("/api/files/:fileId/download", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;
      
      const file = await fileStorage.getFile(fileId, user.id);
      if (!file) {
        return res.status(404).json({ error: "File not found or access denied" });
      }

      const fileContent = await fileStorage.getFileContent(fileId, user.id);
      if (!fileContent) {
        return res.status(404).json({ error: "File content not found" });
      }

      // Set appropriate headers
      res.setHeader('Content-Type', fileContent.mimeType);
      res.setHeader('Content-Disposition', `attachment; filename="${file.originalName}"`);
      
      // Handle different encodings
      if (file.encoding === 'base64' && !fileContent.mimeType.startsWith('text/')) {
        const buffer = Buffer.from(fileContent.content, 'base64');
        res.send(buffer);
      } else {
        res.send(fileContent.content);
      }
    } catch (error) {
      console.error("Download file error:", error);
      if (error instanceof Error && error.message === 'Invalid file ID') {
        return res.status(400).json({ error: "Invalid file ID" });
      }
      res.status(500).json({ error: "Failed to download file" });
    }
  });

  // Update file metadata
  app.put("/api/files/:fileId", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;
      const { name, description, tags, folder, isPublic } = req.body;

      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (description !== undefined) updates.description = description;
      if (tags !== undefined) updates.tags = tags;
      if (folder !== undefined) updates.folder = folder;
      if (isPublic !== undefined) updates.isPublic = isPublic;

      const updatedFile = await fileStorage.updateFile(fileId, user.id, updates);
      if (!updatedFile) {
        return res.status(404).json({ error: "File not found or access denied" });
      }

      res.json({
        success: true,
        file: {
          id: updatedFile.id,
          name: updatedFile.name,
          description: updatedFile.description,
          tags: updatedFile.tags,
          folder: updatedFile.folder,
          isPublic: updatedFile.isPublic,
          analysisStatus: updatedFile.analysisStatus,
          aiAnalysis: updatedFile.aiAnalysis,
          analyzedAt: updatedFile.analyzedAt,
          updatedAt: updatedFile.updatedAt
        }
      });
    } catch (error) {
      console.error("Update file error:", error);
      if (error instanceof Error && error.message === 'Invalid file ID') {
        return res.status(400).json({ error: "Invalid file ID" });
      }
      res.status(500).json({ error: "Failed to update file" });
    }
  });

  // Delete file
  app.delete("/api/files/:fileId", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;

      const success = await fileStorage.deleteFile(fileId, user.id);
      if (!success) {
        return res.status(404).json({ error: "File not found or access denied" });
      }

      res.json({
        success: true,
        message: "File deleted successfully"
      });
    } catch (error) {
      console.error("Delete file error:", error);
      if (error instanceof Error && error.message === 'Invalid file ID') {
        return res.status(400).json({ error: "Invalid file ID" });
      }
      res.status(500).json({ error: "Failed to delete file" });
    }
  });

  // List user files
  app.get("/api/files", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const { 
        folder, 
        search, 
        tags, 
        mimeType, 
        limit = 50, 
        offset = 0 
      } = req.query;

      const options: any = {
        limit: parseInt(limit as string),
        offset: parseInt(offset as string)
      };

      if (folder) options.folder = folder as string;
      if (search) options.search = search as string;
      if (mimeType) options.mimeType = mimeType as string;
      if (tags) {
        try {
          options.tags = typeof tags === 'string' ? JSON.parse(tags) : tags;
        } catch {
          options.tags = [tags];
        }
      }

      const result = await fileStorage.listUserFiles(user.id, options);
      
      res.json({
        success: true,
        files: result.files.map(file => ({
          id: file.id,
          name: file.name,
          originalName: file.originalName,
          mimeType: file.mimeType,
          size: file.size,
          folder: file.folder,
          description: file.description,
          tags: file.tags,
          isPublic: file.isPublic,
          analysisStatus: file.analysisStatus,
          aiAnalysis: file.aiAnalysis,
          analyzedAt: file.analyzedAt,
          currentVersion: file.currentVersion,
          createdAt: file.createdAt,
          updatedAt: file.updatedAt,
          lastAccessedAt: file.lastAccessedAt
        })),
        total: result.total,
        pagination: {
          limit: options.limit,
          offset: options.offset,
          hasMore: result.total > options.offset + options.limit
        }
      });
    } catch (error) {
      console.error("List files error:", error);
      res.status(500).json({ error: "Failed to list files" });
    }
  });

  // AI Analysis endpoint (requires subscription and credits)
  app.post("/api/files/:fileId/analyze", requireActiveSubscription({
    customMessage: "AI-powered file analysis requires a paid subscription"
  }), requireDynamicCredits((req) => {
    const { analysisType, context } = req.body;
    const messages = [{ content: `${analysisType || ''} ${context || ''}` || 'Analyze file' }];
    const baseCredits = estimateRequiredCredits(messages, false, true, ''); // Has file attachment
    return Math.max(5, baseCredits); // File analysis is moderately complex
  }, 'file-analysis'), async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;

      const analysis = await fileStorage.analyzeFileWithAI(fileId, user.id);
      
      res.json({
        success: true,
        analysis
      });
         } catch (error) {
       console.error("File analysis error:", error);
       res.status(500).json({ 
         error: error instanceof Error ? error.message : "Failed to analyze file with Azure AI" 
       });
     }
  });

  // File version endpoints
  app.get("/api/files/:fileId/versions", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;

      const versions = await fileStorage.getFileVersions(fileId, user.id);
      
      res.json({
        success: true,
        versions: versions.map(version => ({
          id: version.id,
          versionNumber: version.versionNumber,
          size: version.size,
          changeDescription: version.changeDescription,
          changeType: version.changeType,
          createdAt: version.createdAt,
          createdBy: version.createdBy
        }))
      });
    } catch (error) {
      console.error("Get file versions error:", error);
      res.status(500).json({ error: "Failed to get file versions" });
    }
  });

  app.post("/api/files/:fileId/versions/:versionId/restore", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const versionId = parseInt(req.params.versionId);
      const user = req.user as any;

      const restoredFile = await fileStorage.restoreFileVersion(fileId, versionId, user.id);
      if (!restoredFile) {
        return res.status(404).json({ error: "File or version not found, or access denied" });
      }

      res.json({
        success: true,
        message: "File version restored successfully",
        currentVersion: restoredFile.currentVersion
      });
    } catch (error) {
      console.error("Restore file version error:", error);
      res.status(500).json({ error: "Failed to restore file version" });
    }
  });

  // File sharing endpoints
  app.post("/api/files/:fileId/share", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;
      const { userId, permission, shareExpiry } = req.body;

      if (!permission || !['read', 'write'].includes(permission)) {
        return res.status(400).json({ error: "Invalid permission. Must be 'read' or 'write'" });
      }

      const shareData = {
        userId: userId || null,
        permission,
        shareExpiry: shareExpiry || null
      };

      const sharedPermission = await fileStorage.shareFile(fileId, user.id, shareData);
      
      res.json({
        success: true,
        shareToken: sharedPermission.shareToken,
        permission: sharedPermission.permission,
        shareExpiry: sharedPermission.shareExpiry
      });
         } catch (error) {
       console.error("Share file error:", error);
       res.status(500).json({ 
         error: error instanceof Error ? error.message : "Failed to share file" 
       });
     }
  });

  app.get("/api/files/:fileId/permissions", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;

      const permissions = await fileStorage.getFilePermissions(fileId, user.id);
      
      res.json({
        success: true,
        permissions: permissions.map(perm => ({
          id: perm.id,
          userId: perm.userId,
          permission: perm.permission,
          shareToken: perm.shareToken,
          shareExpiry: perm.shareExpiry,
          createdAt: perm.createdAt
        }))
      });
    } catch (error) {
      console.error("Get file permissions error:", error);
      res.status(500).json({ error: "Failed to get file permissions" });
    }
  });

  // File analytics endpoint
  app.get("/api/files/:fileId/analytics", requireAuth, async (req, res) => {
    try {
      const fileId = validateFileId(req.params.fileId);
      const user = req.user as any;

      const analytics = await fileStorage.getFileAnalytics(fileId, user.id);
      if (!analytics) {
        return res.status(404).json({ error: "File not found or access denied" });
      }

      res.json({
        success: true,
        analytics
      });
    } catch (error) {
      console.error("Get file analytics error:", error);
      res.status(500).json({ error: "Failed to get file analytics" });
    }
  });

  // Bulk file operations
  app.post("/api/files/bulk/delete", requireAuth, async (req, res) => {
    try {
      const { fileIds } = req.body;
      const user = req.user as any;

      if (!Array.isArray(fileIds) || fileIds.length === 0) {
        return res.status(400).json({ error: "Invalid file IDs array" });
      }

      const results = await Promise.allSettled(
        fileIds.map(id => fileStorage.deleteFile(parseInt(id), user.id))
      );

      const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
      const failed = results.length - successful;

      res.json({
        success: true,
        deleted: successful,
        failed,
        message: `Successfully deleted ${successful} files${failed > 0 ? `, ${failed} failed` : ''}`
      });
    } catch (error) {
      console.error("Bulk delete error:", error);
      res.status(500).json({ error: "Failed to delete files" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

// Enhanced UI code generation with Azure AI
async function generateUICodeWithAI(client: any, config: any, analysis: any, provider: string = 'azure'): Promise<string> {
  try {
    console.log("üöÄ Starting enhanced UI code generation...");
    
    // Enhanced code generation prompt
    const codePrompt = `Generate a production-ready React TypeScript component based on this detailed UI analysis.

**UI ANALYSIS:**
${JSON.stringify(analysis, null, 2)}

**GENERATION REQUIREMENTS:**

1. **Component Structure**:
   - Main functional component with proper TypeScript interfaces
   - Modular sub-components for complex sections
   - Props interface for reusability

2. **Styling Implementation**:
   - Use Tailwind CSS classes exclusively
   - Implement the exact color palette provided
   - Responsive design (mobile-first approach)
   - Modern spacing and typography

3. **Code Quality**:
   - Follow React best practices and hooks patterns
   - Include proper TypeScript types and interfaces
   - Add meaningful prop types and default values
   - Use semantic HTML elements

4. **Accessibility**:
   - Include ARIA labels and roles
   - Proper heading hierarchy (h1, h2, h3...)
   - Alt text for images and meaningful link text
   - Keyboard navigation support

5. **Modern Features**:
   - Use React 18+ patterns
   - Implement proper state management if needed
   - Include loading states and error boundaries where applicable
   - Add hover effects and smooth transitions

**OUTPUT REQUIREMENTS:**
- Provide ONLY the complete React component code
- No markdown formatting, explanations, or comments outside the code
- Ensure the component is immediately usable
- Include all necessary imports at the top

**COMPONENT NAME:** GeneratedUIComponent`;

    let generatedCode;
    
    if (provider.toLowerCase() === 'gemini') {
      const model = client.getGenerativeModel({ 
        model: config.modelName,
        generationConfig: {
          temperature: 0.1,
          maxOutputTokens: 4096
        }
      });
      
      const systemPrompt = "You are a senior React/TypeScript developer specializing in creating production-ready components. Generate clean, accessible, and modern code that follows industry best practices. Focus on code quality, performance, and maintainability.";
      const fullPrompt = `${systemPrompt}\n\n${codePrompt}`;
      
      const result = await model.generateContent(fullPrompt);
      const response = await result.response;
      generatedCode = response.text();
    } else if (provider.toLowerCase() === 'openai') {
      const response = await client.chat.completions.create({
        model: config.modelName,
        messages: [
          {
            role: "system",
            content: "You are a senior React/TypeScript developer specializing in creating production-ready components. Generate clean, accessible, and modern code that follows industry best practices. Focus on code quality, performance, and maintainability."
          },
          {
            role: "user",
            content: codePrompt
          }
        ],
        max_tokens: 4096,
        temperature: 0.1
      });
      
      generatedCode = response.choices[0].message.content;
    } else if (provider.toLowerCase() === 'azure' || provider.toLowerCase() === 'azureai') {
      const response = await retryWithBackoff(async () => {
        return await client.path("/chat/completions").post({
          body: {
            messages: [
              {
                role: "system",
                content: "You are a senior React/TypeScript developer specializing in creating production-ready components. Generate clean, accessible, and modern code that follows industry best practices. Focus on code quality, performance, and maintainability."
              },
              {
                role: "user",
                content: codePrompt
              }
            ],
            max_tokens: 4096,
            temperature: 0.1,
            model: config.modelName,
            stream: false,
          },
        });
      }, config.maxRetries, config.retryDelay);

      if (response.status !== "200") {
        const errorDetail = extractAzureAIError(response.body?.error || response.body);
        throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
      }

      generatedCode = response.body.choices[0]?.message?.content;
    } else {
      throw new Error(`Unsupported provider: ${provider}`);
    }
    
         if (!generatedCode || generatedCode.trim().length < 100) {
       console.warn("‚ö†Ô∏è Generated code seems too short, using enhanced fallback");
       return generateFallbackUICode(analysis);
     }

     console.log("‚úÖ UI code generation successful, length:", generatedCode.length);
     return generatedCode;
     
   } catch (error) {
     console.error("‚ùå AI code generation error:", extractAzureAIError(error));
     return generateFallbackUICode(analysis);
   }
}

// Fallback function for when AI generation fails
function generateFallbackUICode(analysis: any): string {
  return `
import React from 'react';

const GeneratedComponent: React.FC = () => {
  return (
    <div className="min-h-screen bg-slate-50">
      <header className="bg-slate-900 text-white p-4">
        <nav className="max-w-6xl mx-auto flex justify-between items-center">
          <h1 className="text-xl font-bold">Your Logo</h1>
          <div className="hidden md:flex space-x-6">
            <a href="#" className="hover:text-violet-400">Home</a>
            <a href="#" className="hover:text-violet-400">About</a>
            <a href="#" className="hover:text-violet-400">Contact</a>
          </div>
        </nav>
      </header>
      
      <main className="max-w-6xl mx-auto px-4 py-12">
        <section className="text-center mb-16">
          <h2 className="text-4xl font-bold mb-4">Welcome to Your Site</h2>
          <p className="text-xl text-gray-600 mb-8">Generated from your design</p>
          <button className="bg-violet-600 text-white px-8 py-3 rounded-lg hover:bg-violet-700">
            Get Started
          </button>
        </section>
        
        <section className="grid md:grid-cols-3 gap-8">
          ${analysis.components.map((comp: any, i: number) => `
          <div key={${i}} className="p-6 bg-white rounded-lg shadow-md">
            <h3 className="text-xl font-semibold mb-2">${comp.type}</h3>
            <p className="text-gray-600">${comp.description}</p>
          </div>
          `).join('')}
        </section>
      </main>
    </div>
  );
};

export default GeneratedComponent;
  `.trim();
}

// Enhanced Azure AI-powered page generation
async function generatePageWithAI(client: any, config: AzureAIConfig, template: string, requirements: string, style: string): Promise<any> {
  try {
    console.log("üèóÔ∏è Starting enhanced page structure generation...");
    
    const pagePrompt = `Design a comprehensive ${template} page structure with modern web architecture principles.

**PROJECT SPECIFICATIONS:**
- Template Type: ${template}
- Requirements: ${requirements}
- Style Theme: ${style}
- Target Framework: React TypeScript with Tailwind CSS

**DESIGN REQUIREMENTS:**

1. **Component Architecture**:
   - Modular, reusable component structure
   - Proper component hierarchy and organization
   - TypeScript interfaces for all props
   - Accessibility-first design patterns

2. **Modern Web Principles**:
   - Mobile-first responsive design
   - Performance optimization considerations
   - SEO-friendly structure
   - Progressive enhancement approach

3. **User Experience**:
   - Intuitive navigation and information architecture
   - Clear visual hierarchy and content flow
   - Interactive elements and micro-interactions
   - Loading states and error handling

4. **Technical Implementation**:
   - Modern React patterns (hooks, context, suspense)
   - Code splitting and lazy loading opportunities
   - State management strategy
   - API integration points

**RESPONSE FORMAT:**
Respond with ONLY valid JSON in this exact structure:

{
  "projectMetadata": {
    "template": "${template}",
    "complexity": "low|medium|high",
    "estimatedDevTime": "estimated development time",
    "recommendedFeatures": ["feature suggestions based on requirements"]
  },
  "pageStructure": {
    "layout": "grid|flexbox|hybrid",
    "sections": [
      {
        "name": "section name",
        "type": "header|hero|content|sidebar|footer|etc",
        "purpose": "section purpose and content",
        "priority": "high|medium|low"
      }
    ]
  },
  "components": [
    {
      "name": "ComponentName",
      "type": "functional|class",
      "purpose": "component responsibility",
      "props": [
        {
          "name": "prop name",
          "type": "TypeScript type",
          "required": true/false,
          "description": "prop description"
        }
      ],
      "dependencies": ["required dependencies"],
      "complexity": "simple|moderate|complex"
    }
  ],
  "designSystem": {
    "colorPalette": {
      "primary": "#hex",
      "secondary": "#hex",
      "accent": "#hex",
      "neutral": "#hex",
      "background": "#hex",
      "text": "#hex",
      "error": "#hex",
      "success": "#hex",
      "warning": "#hex"
    },
    "typography": {
      "headings": "font family and scales",
      "body": "body text specifications",
      "special": "accent typography"
    },
    "spacing": {
      "scale": "spacing scale (4px, 8px, 16px, etc.)",
      "containerMaxWidth": "max container width",
      "sectionPadding": "section padding specifications"
    },
    "borderRadius": "border radius scale",
    "shadows": "shadow system",
    "animations": "transition and animation specifications"
  },
  "routes": [
    "route paths as simple strings (e.g. '/', '/about', '/contact')"
  ],
  "stateManagement": {
    "strategy": "context|redux|zustand|local",
    "globalState": ["global state requirements"],
    "localState": ["component-specific state needs"]
  },
  "integrations": {
    "apis": ["required API integrations"],
    "thirdParty": ["third-party service integrations"],
    "authentication": "auth strategy if needed"
  }
}`;

    const response = await retryWithBackoff(async () => {
      return await client.path("/chat/completions").post({
        body: {
          messages: [
            {
              role: "system",
              content: "You are a senior web architect and full-stack developer specializing in modern React applications. Design comprehensive, production-ready page structures with careful attention to scalability, maintainability, and user experience. Focus on practical, implementable solutions."
            },
            {
              role: "user",
              content: pagePrompt
            }
          ],
          max_tokens: 3072,
          temperature: 0.3,
          model: config.modelName,
          stream: false,
          response_format: { type: "json_object" }
        },
      });
    }, config.maxRetries, config.retryDelay);

    if (response.status !== "200") {
      const errorDetail = extractAzureAIError(response.body?.error || response.body);
      throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
    }

    const aiResponse = response.body.choices[0]?.message?.content || "";
    console.log("üéØ Page generation AI response received, length:", aiResponse.length);
    
    const parsed = parseAzureAIJSON(aiResponse);
    if (parsed && parsed.components) {
      console.log("‚úÖ Page structure generation successful:", {
        componentsCount: parsed.components.length,
        sectionsCount: parsed.pageStructure?.sections?.length || 0,
        complexity: parsed.projectMetadata?.complexity
      });
      return parsed;
    }

    console.warn("‚ö†Ô∏è Failed to parse AI page generation, using fallback");
    return generateFallbackPageStructure(template, style);
    
  } catch (error) {
    console.error("‚ùå AI page generation error:", extractAzureAIError(error));
    return generateFallbackPageStructure(template, style);
  }
}

async function generatePageFilesWithAI(client: any, config: AzureAIConfig, pageResult: any): Promise<any[]> {
  // Declare safePageResult outside try block for proper scope
  let safePageResult: any;
  
  try {
    console.log("üìÅ Starting enhanced file generation...");
    
    // Comprehensive safety check and normalization for pageResult
    if (!pageResult || typeof pageResult !== 'object') {
      console.warn("‚ö†Ô∏è Invalid pageResult provided, using fallback structure");
      pageResult = {};
    }
    
    // Ensure all required properties exist with safe defaults
    safePageResult = {
      template: "landing",
      components: [],
      designSystem: {
        colorPalette: {
          primary: "#6366f1",
          secondary: "#1e293b",
          accent: "#f59e0b",
          neutral: "#6b7280",
          background: "#ffffff",
          text: "#111827"
        },
        theme: "modern",
        typography: {
          headings: "Inter, system-ui, sans-serif",
          body: "Inter, system-ui, sans-serif"
        }
      },
      routes: [],
      projectMetadata: {
        template: "landing"
      },
      ...pageResult // Override with actual data if available
    };
    
    // Safely merge design system data
    if (pageResult?.designSystem) {
      safePageResult.designSystem = {
        ...safePageResult.designSystem,
        ...pageResult.designSystem
      };
    }
    
    // Handle legacy styles property
    if (pageResult?.styles && !pageResult?.designSystem) {
      safePageResult.designSystem = {
        ...safePageResult.designSystem,
        ...pageResult.styles
      };
    }
    
    // Ensure color palette is properly structured
    if (pageResult?.designSystem?.colorPalette) {
      safePageResult.designSystem.colorPalette = {
        ...safePageResult.designSystem.colorPalette,
        ...pageResult.designSystem.colorPalette
      };
    } else if (pageResult?.styles?.colors) {
      safePageResult.designSystem.colorPalette = {
        ...safePageResult.designSystem.colorPalette,
        ...pageResult.styles.colors
      };
    }
    
    console.log("üîç Debug pageResult structure:", {
      hasPageResult: !!pageResult,
      hasDesignSystem: !!pageResult?.designSystem,
      hasStyles: !!pageResult?.styles,
      pageResultKeys: pageResult ? Object.keys(pageResult) : [],
      safeStructureKeys: Object.keys(safePageResult)
    });
    
    const files = [];
    
    // Extract design system information with guaranteed safety
    const designSystem = safePageResult.designSystem;
    const colorPalette = designSystem.colorPalette;
    const theme = designSystem.theme || "modern";
    const template = safePageResult.projectMetadata?.template || safePageResult.template || "landing";
    const typography = designSystem.typography || {
      headings: "Inter, system-ui, sans-serif",
      body: "Inter, system-ui, sans-serif"
    };
    
    console.log("üé® Using design system:", {
      hasDesignSystem: !!pageResult?.designSystem,
      hasStyles: !!pageResult?.styles,
      designSystemKeys: designSystem ? Object.keys(designSystem) : [],
      colorKeys: colorPalette ? Object.keys(colorPalette) : [],
      theme,
      template
    });
    
    // Generate main App component with enhanced prompting
    const componentsList = safePageResult.components && Array.isArray(safePageResult.components) 
      ? safePageResult.components.map((c: any) => (c && c.name) || 'Component').join(', ')
      : 'Header, Hero, Features, Footer';
      
    const appPrompt = `Generate a production-ready React TypeScript App component for a ${template} page.

**PROJECT SPECIFICATIONS:**
Template: ${template}
Components: ${componentsList}
Style Theme: ${theme}
Color Palette: ${JSON.stringify(colorPalette, null, 2)}

**DESIGN SYSTEM:**
${JSON.stringify(designSystem, null, 2)}

**GENERATION REQUIREMENTS:**
1. Complete React TypeScript functional component
2. Use Tailwind CSS classes with the specified color palette
3. Include all specified components in a logical layout
4. Implement responsive design (mobile-first)
5. Add proper TypeScript interfaces for all props
6. Include proper accessibility attributes
7. Use semantic HTML elements
8. Export as default

**CRITICAL: REACT RENDERING RULES:**
- NEVER render objects directly as React children
- Only render: strings, numbers, JSX elements, or arrays of these
- If you need to display route data, extract strings/properties first
- Example: {route.path} NOT {route}
- Example: {routes.map(r => <a key={r} href={r}>{r}</a>)} NOT {routes.map(r => r)}

**OUTPUT FORMAT:**
Provide ONLY the complete React component code with imports. No explanations or markdown.`;

    const appResponse = await retryWithBackoff(async () => {
      return await client.path("/chat/completions").post({
        body: {
          messages: [
            {
              role: "system",
              content: "You are a senior React/TypeScript developer specializing in creating production-ready, accessible components. Generate clean, modern code using Tailwind CSS and React best practices."
            },
            {
              role: "user",
              content: appPrompt
            }
          ],
          max_tokens: 4096,
          temperature: 0.2,
          model: config.modelName,
          stream: false,
        },
      });
    }, config.maxRetries, config.retryDelay);

    if (appResponse.status === "200") {
      const appCode = appResponse.body.choices[0]?.message?.content || "";
      if (appCode.trim()) {
        files.push({
          name: "App.tsx",
          content: appCode,
          type: "component"
        });
        console.log("‚úÖ Generated App.tsx component");
      }
    }

    // Generate individual components with enhanced prompting
    const componentsToGenerate = (safePageResult.components && Array.isArray(safePageResult.components)) 
      ? safePageResult.components.slice(0, 3) 
      : [];
      
    for (const component of componentsToGenerate) {
      // Ensure component is a valid object
      const safeComponent = component || {};
      
      try {
        const componentProps = safeComponent.props || [];
        const propsDescription = Array.isArray(componentProps) ? 
          componentProps.map(p => typeof p === 'string' ? p : `${p?.name || 'prop'}: ${p?.type || 'any'}`).join(', ') : 
          'Standard React props';
          
        const componentPrompt = `Generate a React TypeScript ${safeComponent.name || 'Component'} component.

**COMPONENT SPECIFICATIONS:**
Name: ${safeComponent.name || 'Component'}
Purpose: ${safeComponent.purpose || 'UI component'}
Props: ${propsDescription}
Complexity: ${safeComponent.complexity || 'simple'}

**DESIGN SYSTEM:**
Style Theme: ${theme}
Color Palette: ${JSON.stringify(colorPalette, null, 2)}
Typography: ${JSON.stringify(typography, null, 2)}

**REQUIREMENTS:**
1. Functional React TypeScript component
2. Proper TypeScript interface for props
3. Use Tailwind CSS with provided color palette
4. Responsive and accessible design
5. Clean, maintainable code structure
6. Export as default

**CRITICAL: REACT RENDERING RULES:**
- NEVER render objects directly as React children
- Only render: strings, numbers, JSX elements, or arrays of these
- If using data objects, extract specific properties first
- Example: {item.name} NOT {item}

Provide ONLY the complete component code. No explanations.`;

        const componentResponse = await retryWithBackoff(async () => {
          return await client.path("/chat/completions").post({
            body: {
              messages: [
                {
                  role: "system",
                  content: "You are an expert React developer. Create reusable, accessible, and well-structured components using modern React patterns and Tailwind CSS."
                },
                {
                  role: "user",
                  content: componentPrompt
                }
              ],
              max_tokens: 2048,
              temperature: 0.2,
              model: config.modelName,
              stream: false,
            },
          });
        }, config.maxRetries, config.retryDelay);

        if (componentResponse.status === "200") {
          const componentCode = componentResponse.body.choices?.[0]?.message?.content || "";
          if (componentCode.trim()) {
            files.push({
              name: `${safeComponent.name || 'Component'}.tsx`,
              content: componentCode,
              type: "component"
            });
            console.log(`‚úÖ Generated ${safeComponent.name || 'Component'}.tsx component`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to generate component ${safeComponent.name || 'Unknown'}:`, extractAzureAIError(error));
      }
    }

    // Add configuration files with proper error handling
    try {
      files.push(
        {
          name: "tailwind.config.js",
          content: generateTailwindConfig(colorPalette),
          type: "config"
        },
        {
          name: "routes.ts", 
          content: generateRoutesFile(safePageResult.routes || []),
          type: "config"
        }
      );
      console.log("‚úÖ Generated configuration files");
    } catch (error) {
      console.warn("‚ö†Ô∏è Failed to generate config files:", error);
    }

    console.log(`‚úÖ File generation completed. Generated ${files.length} files.`);
    return files;
    
  } catch (error) {
    console.error("‚ùå AI file generation error:", extractAzureAIError(error));
    return generateFallbackPageFiles(safePageResult);
  }
}

// Enhanced fallback functions
function generateFallbackPageStructure(template: string, style: string): any {
  const timestamp = Date.now();
  return {
    projectMetadata: {
      template: template || "landing",
      complexity: "medium",
      estimatedDevTime: "2-3 days",
      recommendedFeatures: ["Responsive design", "SEO optimization", "Performance monitoring"]
    },
    pageStructure: {
      layout: "flexbox",
      sections: [
        { name: "Header", type: "header", purpose: "Site navigation and branding", priority: "high" },
        { name: "Hero", type: "hero", purpose: "Main value proposition and call-to-action", priority: "high" },
        { name: "Features", type: "content", purpose: "Showcase key features and benefits", priority: "medium" },
        { name: "Footer", type: "footer", purpose: "Secondary navigation and contact info", priority: "low" }
      ]
    },
    components: [
      { 
        name: "Header", 
        type: "functional",
        purpose: "Site navigation and branding",
        props: [
          { name: "title", type: "string", required: true, description: "Site title" },
          { name: "navigation", type: "NavItem[]", required: true, description: "Navigation menu items" }
        ],
        dependencies: ["React", "Tailwind CSS"],
        complexity: "simple"
      },
      { 
        name: "Hero", 
        type: "functional",
        purpose: "Main landing section with call-to-action",
        props: [
          { name: "title", type: "string", required: true, description: "Main heading" },
          { name: "subtitle", type: "string", required: false, description: "Supporting text" },
          { name: "cta", type: "CTAButton", required: true, description: "Call-to-action button" }
        ],
        dependencies: ["React", "Tailwind CSS"],
        complexity: "simple"
      },
      { 
        name: "Features", 
        type: "functional",
        purpose: "Feature showcase grid",
        props: [
          { name: "items", type: "FeatureItem[]", required: true, description: "List of features" },
          { name: "layout", type: "grid|list", required: false, description: "Layout style" }
        ],
        dependencies: ["React", "Tailwind CSS"],
        complexity: "moderate"
      },
      { 
        name: "Footer", 
        type: "functional",
        purpose: "Site footer with links and information",
        props: [
          { name: "links", type: "FooterLink[]", required: true, description: "Footer navigation links" },
          { name: "copyright", type: "string", required: true, description: "Copyright notice" }
        ],
        dependencies: ["React", "Tailwind CSS"],
        complexity: "simple"
      }
    ],
    designSystem: {
      colorPalette: {
        primary: "#6366f1",
        secondary: "#1e293b",
        accent: "#f59e0b",
        neutral: "#6b7280",
        background: "#ffffff",
        text: "#111827",
        error: "#ef4444",
        success: "#10b981",
        warning: "#f59e0b"
      },
      typography: {
        headings: "Inter, system-ui, sans-serif",
        body: "Inter, system-ui, sans-serif",
        special: "Inter, system-ui, sans-serif"
      },
      spacing: {
        scale: "4px, 8px, 16px, 24px, 32px, 48px, 64px",
        containerMaxWidth: "1200px",
        sectionPadding: "4rem 1rem"
      },
      borderRadius: "0.5rem",
      shadows: "0 1px 3px rgba(0, 0, 0, 0.1)",
      animations: "transition-all duration-300 ease-in-out"
    },
    routes: getDefaultRoutes(template),
    stateManagement: {
      strategy: "context",
      globalState: ["theme", "user", "navigation"],
      localState: ["form state", "modal visibility", "loading states"]
    },
    integrations: {
      apis: ["REST API for content", "Analytics tracking"],
      thirdParty: ["Google Analytics", "Email service"],
      authentication: "JWT-based authentication"
    },
    _fallback: true,
    _timestamp: timestamp
  };
}

function generateFallbackPageFiles(pageResult: any): any[] {
  console.log("üîÑ Using fallback page files generation");
  
  // Extract colors with fallbacks
  const colors = pageResult.designSystem?.colorPalette || 
                pageResult.styles?.colors || 
                {
                  primary: "#6366f1",
                  secondary: "#1e293b",
                  accent: "#f59e0b"
                };
  
  const routes = pageResult.routes || [];
  
  return [
    { 
      name: "App.tsx", 
      content: `import React from 'react';

const App: React.FC = () => {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-slate-900 text-white p-4">
        <div className="max-w-6xl mx-auto">
          <h1 className="text-xl font-bold">Your Application</h1>
        </div>
      </header>
      
      <main className="max-w-6xl mx-auto px-4 py-8">
        <section className="text-center mb-12">
          <h2 className="text-4xl font-bold mb-4">Welcome</h2>
          <p className="text-xl text-gray-600 mb-8">
            Your generated application is ready to be customized.
          </p>
          <button className="bg-violet-600 text-white px-8 py-3 rounded-lg hover:bg-violet-700 transition-colors">
            Get Started
          </button>
        </section>
      </main>
      
      <footer className="bg-gray-100 p-8 mt-16">
        <div className="max-w-6xl mx-auto text-center text-gray-600">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
        </div>
      </footer>
    </div>
  );
};

export default App;`, 
      type: "component" 
    },
    { 
      name: "Header.tsx", 
      content: `import React from 'react';

interface HeaderProps {
  title?: string;
  navigation?: Array<{ label: string; href: string }>;
}

const Header: React.FC<HeaderProps> = ({ 
  title = "Your App", 
  navigation = [] 
}) => {
  return (
    <header className="bg-slate-900 text-white p-4">
      <div className="max-w-6xl mx-auto flex justify-between items-center">
        <h1 className="text-xl font-bold">{title}</h1>
        <nav className="hidden md:flex space-x-6">
          {navigation.map((item, index) => (
            <a 
              key={index} 
              href={item.href} 
              className="hover:text-violet-400 transition-colors"
            >
              {item.label}
            </a>
          ))}
        </nav>
      </div>
    </header>
  );
};

export default Header;`, 
      type: "component" 
    },
    { 
      name: "tailwind.config.js", 
      content: generateTailwindConfig(colors), 
      type: "config" 
    },
    { 
      name: "routes.ts", 
      content: generateRoutesFile(routes), 
      type: "config" 
    }
  ];
}

function getDefaultRoutes(template: string): string[] {
  const routes = {
    landing: ["/", "/about", "/contact"],
    dashboard: ["/dashboard", "/analytics", "/settings"],
    portfolio: ["/", "/projects", "/about", "/contact"],
    blog: ["/", "/posts", "/categories", "/about"],
    ecommerce: ["/", "/products", "/cart", "/checkout"]
  };
  
  return routes[template as keyof typeof routes] || ["/"];
}

function generateTailwindConfig(colors: any): string {
  return `module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        primary: "${colors.primary}",
        secondary: "${colors.secondary}",
        accent: "${colors.accent}"
      }
    }
  },
  plugins: []
};`;
}

function generateRoutesFile(routes: string[]): string {
  return `export const routes = ${JSON.stringify(routes, null, 2)};
  
export default routes;`;
}

// Enhanced Azure AI-powered performance analysis
async function analyzePerformanceWithAI(client: any, config: AzureAIConfig, projectPath: string, metrics: string[]): Promise<any> {
  try {
    console.log("üöÄ Starting enhanced performance analysis...");
    
    const performancePrompt = `Conduct a comprehensive performance analysis of a React/TypeScript project.

**PROJECT CONTEXT:**
- Project Path: ${projectPath}
- Requested Metrics: ${metrics.join(', ')}
- Analysis Type: Full-stack performance evaluation

**ANALYSIS REQUIREMENTS:**

1. **Frontend Performance Metrics**:
   - Initial page load time and Time to Interactive (TTI)
   - Bundle size analysis and code splitting effectiveness
   - Render performance and React component optimization
   - Memory usage patterns and potential leaks
   - Network request optimization and caching strategies

2. **React-Specific Analysis**:
   - Component re-render frequency and causes
   - State management efficiency
   - Hook usage patterns and optimization opportunities
   - Virtual DOM performance considerations
   - Concurrent features utilization

3. **Build and Bundle Analysis**:
   - Webpack/Vite bundle analysis
   - Tree-shaking effectiveness
   - Code splitting strategy evaluation
   - Asset optimization (images, fonts, etc.)
   - Third-party library impact

4. **Runtime Performance**:
   - JavaScript execution time
   - Paint and layout performance
   - Memory consumption patterns
   - User interaction responsiveness
   - Progressive loading strategies

**RESPONSE FORMAT:**
Respond with ONLY valid JSON in this exact structure:

{
  "performanceMetrics": {
    "loadTime": {
      "value": "realistic load time in seconds (0.5-8.0)",
      "grade": "A|B|C|D|F",
      "benchmark": "comparison to industry standards"
    },
    "bundleSize": {
      "main": "main bundle size in KB",
      "chunks": "number and size of chunks",
      "total": "total bundle size in KB",
      "grade": "A|B|C|D|F"
    },
    "renderPerformance": {
      "firstPaint": "time to first paint in ms",
      "firstContentfulPaint": "time to FCP in ms",
      "largestContentfulPaint": "time to LCP in ms",
      "cumulativeLayoutShift": "CLS score 0-1",
      "grade": "A|B|C|D|F"
    },
    "memoryUsage": {
      "initialHeap": "initial memory usage in MB",
      "peakHeap": "peak memory usage in MB",
      "memoryLeaks": "potential leak indicators",
      "grade": "A|B|C|D|F"
    }
  },
  "optimizationSuggestions": [
    {
      "category": "loading|rendering|memory|bundle|network",
      "priority": "critical|high|medium|low",
      "issue": "specific performance issue identified",
      "solution": "detailed solution with implementation steps",
      "expectedImprovement": "quantified expected improvement",
      "effort": "low|medium|high",
      "impact": "low|medium|high"
    }
  ],
  "codeQualityMetrics": {
    "codeSmells": "number of code smells (0-15)",
    "duplicateCode": "percentage of duplicate code",
    "complexity": "cyclomatic complexity score",
    "maintainability": "maintainability index (0-100)"
  },
  "securityAssessment": {
    "vulnerabilities": "number of security issues (0-10)",
    "riskLevel": "low|medium|high|critical",
    "recommendations": ["security improvement suggestions"]
  },
  "overallScore": {
    "performance": "overall performance score (0-100)",
    "grade": "A|B|C|D|F",
    "summary": "concise summary of current state",
    "priorityActions": ["top 3 priority improvements"]
  }
}`;

    // Use caching for performance analysis
    const cacheKey = getCacheKey(
      `perf-analysis-${projectPath}-${metrics.join(',')}`,
      config.modelName,
      { temperature: 0.2 }
    );
    
    let cachedResult = config.cacheEnabled ? getCachedResponse(cacheKey) : null;
    if (cachedResult) {
      console.log("üìÑ Using cached performance analysis result");
      return cachedResult;
    }

    const response = await retryWithBackoff(async () => {
      return await client.path("/chat/completions").post({
        body: {
          messages: [
            {
              role: "system",
              content: "You are a senior performance engineer and React optimization specialist with expertise in modern web applications. Provide comprehensive, data-driven performance analysis with specific, actionable recommendations that deliver measurable improvements."
            },
            {
              role: "user",
              content: performancePrompt
            }
          ],
          max_tokens: 3072,
          temperature: 0.2,
          model: config.modelName,
          stream: false,
          response_format: { type: "json_object" }
        },
      });
    }, config.maxRetries, config.retryDelay);

    if (response.status !== "200") {
      const errorDetail = extractAzureAIError(response.body?.error || response.body);
      throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
    }

    const aiResponse = response.body.choices[0]?.message?.content || "";
    console.log("üéØ Performance analysis AI response received, length:", aiResponse.length);
    
    const parsed = parseAzureAIJSON(aiResponse);
    if (parsed && parsed.performanceMetrics) {
      // Cache the successful result
      if (config.cacheEnabled) {
        setCachedResponse(cacheKey, parsed, 180); // Cache for 3 hours
      }
      
      console.log("‚úÖ Performance analysis successful:", {
        overallScore: parsed.overallScore?.performance || 'unknown',
        grade: parsed.overallScore?.grade || 'unknown',
        suggestionsCount: parsed.optimizationSuggestions?.length || 0
      });
      
      return parsed;
    }

    console.warn("‚ö†Ô∏è Failed to parse AI performance analysis, using fallback");
    return generateFallbackPerformanceAnalysis();
    
  } catch (error) {
    console.error("‚ùå AI performance analysis error:", extractAzureAIError(error));
    return generateFallbackPerformanceAnalysis();
  }
}

// Uterpi-backed performance analysis using Hugging Face-style Inference Endpoint
type UterpiConfig = {
  endpointUrl: string;
  apiToken: string;
  cacheEnabled?: boolean;
  maxRetries?: number;
  retryDelay?: number;
  modelName?: string;
};

async function analyzePerformanceWithUterpi(config: UterpiConfig, projectPath: string, metrics: string[]): Promise<any> {
  try {
    console.log("üöÄ Starting enhanced performance analysis (Uterpi)...");

    const performancePrompt = `Conduct a comprehensive performance analysis of a React/TypeScript project.

**PROJECT CONTEXT:**
- Project Path: ${projectPath}
- Requested Metrics: ${metrics.join(', ')}
- Analysis Type: Full-stack performance evaluation

**ANALYSIS REQUIREMENTS:**

1. **Frontend Performance Metrics**:
   - Initial page load time and Time to Interactive (TTI)
   - Bundle size analysis and code splitting effectiveness
   - Render performance and React component optimization
   - Memory usage patterns and potential leaks
   - Network request optimization and caching strategies

2. **React-Specific Analysis**:
   - Component re-render frequency and causes
   - State management efficiency
   - Hook usage patterns and optimization opportunities
   - Virtual DOM performance considerations
   - Concurrent features utilization

3. **Build and Bundle Analysis**:
   - Webpack/Vite bundle analysis
   - Tree-shaking effectiveness
   - Code splitting strategy evaluation
   - Asset optimization (images, fonts, etc.)
   - Third-party library impact

4. **Runtime Performance**:
   - JavaScript execution time
   - Paint and layout performance
   - Memory consumption patterns
   - User interaction responsiveness
   - Progressive loading strategies

**RESPONSE FORMAT:**
Respond with ONLY valid JSON in this exact structure:

{
  "performanceMetrics": {
    "loadTime": {
      "value": "realistic load time in seconds (0.5-8.0)",
      "grade": "A|B|C|D|F",
      "benchmark": "comparison to industry standards"
    },
    "bundleSize": {
      "main": "main bundle size in KB",
      "chunks": "number and size of chunks",
      "total": "total bundle size in KB",
      "grade": "A|B|C|D|F"
    },
    "renderPerformance": {
      "firstPaint": "time to first paint in ms",
      "firstContentfulPaint": "time to FCP in ms",
      "largestContentfulPaint": "time to LCP in ms",
      "cumulativeLayoutShift": "CLS score 0-1",
      "grade": "A|B|C|D|F"
    },
    "memoryUsage": {
      "initialHeap": "initial memory usage in MB",
      "peakHeap": "peak memory usage in MB",
      "memoryLeaks": "potential leak indicators",
      "grade": "A|B|C|D|F"
    }
  },
  "optimizationSuggestions": [
    {
      "category": "loading|rendering|memory|bundle|network",
      "priority": "critical|high|medium|low",
      "issue": "specific performance issue identified",
      "solution": "detailed solution with implementation steps",
      "expectedImprovement": "quantified expected improvement",
      "effort": "low|medium|high",
      "impact": "low|medium|high"
    }
  ],
  "codeQualityMetrics": {
    "codeSmells": "number of code smells (0-15)",
    "duplicateCode": "percentage of duplicate code",
    "complexity": "cyclomatic complexity score",
    "maintainability": "maintainability index (0-100)"
  },
  "securityAssessment": {
    "vulnerabilities": "number of security issues (0-10)",
    "riskLevel": "low|medium|high|critical",
    "recommendations": ["security improvement suggestions"]
  },
  "overallScore": {
    "performance": "overall performance score (0-100)",
    "grade": "A|B|C|D|F",
    "summary": "concise summary of current state",
    "priorityActions": ["top 3 priority improvements"]
  }
}`;

    const cacheKey = getCacheKey(
      `perf-analysis-${projectPath}-${metrics.join(',')}`,
      config.modelName || 'uterpi-endpoint',
      { temperature: 0.2 }
    );

    let cachedResult = config.cacheEnabled ? getCachedResponse(cacheKey) : null;
    if (cachedResult) {
      console.log("üìÑ Using cached performance analysis result (Uterpi)");
      return cachedResult;
    }

    const maxRetries = config.maxRetries ?? 3;
    const retryDelay = config.retryDelay ?? 1000;

    const response = await retryWithBackoff(async () => {
      const r = await fetch(config.endpointUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${config.apiToken}`
        },
        body: JSON.stringify({
          inputs: performancePrompt,
          parameters: {
            max_new_tokens: 2048,
            temperature: 0.2,
            top_p: 0.9,
            return_full_text: false
          }
        })
      });
      if (!r.ok) {
        const errText = await r.text().catch(() => "");
        throw new Error(`Uterpi endpoint error (${r.status}): ${errText}`);
      }
      return r;
    }, maxRetries, retryDelay);

    let aiResponseText = "";
    try {
      const data: any = await response.json();
      if (Array.isArray(data)) {
        aiResponseText = data[0]?.generated_text || data[0]?.summary_text || "";
      } else if (data && typeof data === 'object') {
        aiResponseText = data.generated_text || data?.choices?.[0]?.message?.content || "";
      }
      if (typeof data === 'string' && !aiResponseText) {
        aiResponseText = data;
      }
    } catch (e) {
      console.warn("Failed to parse Uterpi JSON response, attempting text fallback");
      aiResponseText = await response.text();
    }

    console.log("üéØ Performance analysis response (Uterpi) received, length:", aiResponseText?.length || 0);

    const parsed = parseAzureAIJSON(aiResponseText);
    if (parsed && parsed.performanceMetrics) {
      if (config.cacheEnabled) {
        setCachedResponse(cacheKey, parsed, 180);
      }
      console.log("‚úÖ Performance analysis (Uterpi) successful:", {
        overallScore: parsed.overallScore?.performance || 'unknown',
        grade: parsed.overallScore?.grade || 'unknown',
        suggestionsCount: parsed.optimizationSuggestions?.length || 0
      });
      return parsed;
    }

    console.warn("‚ö†Ô∏è Failed to parse Uterpi performance analysis, using fallback");
    return generateFallbackPerformanceAnalysis();

  } catch (error) {
    console.error("‚ùå Uterpi performance analysis error:", error);
    return generateFallbackPerformanceAnalysis();
  }
}

// Map Uterpi JSON to AnalyzeModal expected shape
function mapUterpiPerformanceToModalShape(uterpiJson: any): {
  performance: { loadTime: number; bundleSize: number; renderTime: number };
  suggestions: string[];
  codeSmells: number;
  securityIssues: number;
} {
  // Defaults to avoid client crashes on missing fields
  const defaults = {
    performance: { loadTime: 2.1, bundleSize: 570, renderTime: 1850 },
    suggestions: [
      "Enable code splitting for large routes",
      "Optimize repeated renders with memoization",
      "Audit dependencies for bundle impact"
    ],
    codeSmells: 3,
    securityIssues: 1
  };

  if (!uterpiJson || typeof uterpiJson !== 'object') return defaults;

  const pm = uterpiJson.performanceMetrics || {};
  const render = pm.renderPerformance || {};
  const bundle = pm.bundleSize || {};

  const loadTimeNum = Number(pm.loadTime?.value ?? 2.1);
  const bundleTotalNum = Number(bundle.total ?? 570);
  const renderTimeNum = Number(render.largestContentfulPaint ?? 1850);

  const suggestions: string[] = Array.isArray(uterpiJson.optimizationSuggestions)
    ? uterpiJson.optimizationSuggestions.map((s: any) => s?.solution || s?.issue).filter(Boolean)
    : defaults.suggestions;

  const codeSmells = Number(uterpiJson.codeQualityMetrics?.codeSmells ?? defaults.codeSmells);
  const securityIssues = Number(uterpiJson.securityAssessment?.vulnerabilities ?? defaults.securityIssues);

  return {
    performance: {
      loadTime: isFinite(loadTimeNum) ? loadTimeNum : defaults.performance.loadTime,
      bundleSize: isFinite(bundleTotalNum) ? bundleTotalNum : defaults.performance.bundleSize,
      renderTime: isFinite(renderTimeNum) ? renderTimeNum : defaults.performance.renderTime,
    },
    suggestions: suggestions.length ? suggestions : defaults.suggestions,
    codeSmells: isFinite(codeSmells) ? codeSmells : defaults.codeSmells,
    securityIssues: isFinite(securityIssues) ? securityIssues : defaults.securityIssues
  };
}

// Azure AI-powered design pattern analysis
async function analyzeDesignPatternsWithAI(client: any, config: AzureAIConfig, codebase: string): Promise<any> {
  try {
    const patternsPrompt = `Analyze a React/TypeScript codebase for design patterns and anti-patterns.

Codebase Context: ${codebase}

Please respond in JSON format with this structure:
{
  "detected": [
    {
      "name": "PatternName",
      "usage": "percentage%",
      "recommendation": "assessment and recommendation"
    }
  ],
  "antiPatterns": [
    {
      "name": "AntiPatternName",
      "instances": number,
      "severity": "low|medium|high"
    }
  ]
}

Focus on common React patterns like:
- Component Composition
- State Management (Context, Redux, Zustand)
- Error Boundaries
- Custom Hooks
- Render Props
- Higher-Order Components

And anti-patterns like:
- Prop Drilling
- Large Components
- Direct DOM Manipulation
- Memory Leaks
- Performance Issues`;

    const response = await client.path("/chat/completions").post({
      body: {
        messages: [
          {
            role: "system",
            content: "You are an expert React architect and design pattern specialist. Analyze codebases for architectural patterns and provide insightful recommendations."
          },
          {
            role: "user",
            content: patternsPrompt
          }
        ],
        max_tokens: 2048,
        temperature: 0.3,
        model: config.modelName,
        stream: false,
      },
    });

    if (response.status !== "200") {
      throw new Error(`Azure AI API error: ${response.body?.error || 'Unknown error'}`);
    }

    const aiResponse = response.body.choices[0]?.message?.content || "";
    
    const parsed = parseAzureAIJSON(aiResponse);
    if (parsed) {
      return parsed;
    }

    // Fallback
    return generateFallbackPatternAnalysis();
  } catch (error) {
    console.error("AI pattern analysis error:", error);
    return generateFallbackPatternAnalysis();
  }
}

// Enhanced fallback functions with intelligent context awareness
function generateFallbackPerformanceAnalysis(): any {
  const timestamp = Date.now();
  return {
    performanceMetrics: {
      loadTime: {
        value: "2.1",
        grade: "C",
        benchmark: "Above average for modern React applications"
      },
      bundleSize: {
        main: "285",
        chunks: "3 chunks averaging 95KB each",
        total: "570",
        grade: "B"
      },
      renderPerformance: {
        firstPaint: "820",
        firstContentfulPaint: "1240",
        largestContentfulPaint: "1850",
        cumulativeLayoutShift: "0.12",
        grade: "B"
      },
      memoryUsage: {
        initialHeap: "12",
        peakHeap: "28",
        memoryLeaks: "None detected",
        grade: "A"
      }
    },
    optimizationSuggestions: [
      {
        category: "loading",
        priority: "high",
        issue: "Large initial bundle size affecting load time",
        solution: "Implement code splitting with React.lazy() and dynamic imports for routes",
        expectedImprovement: "30-40% reduction in initial load time",
        effort: "medium",
        impact: "high"
      },
      {
        category: "rendering",
        priority: "medium",
        issue: "Unnecessary re-renders in component tree",
        solution: "Add React.memo() to expensive components and optimize useCallback/useMemo usage",
        expectedImprovement: "15-25% improvement in render performance",
        effort: "low",
        impact: "medium"
      },
      {
        category: "bundle",
        priority: "medium",
        issue: "Unused code and dependencies in bundle",
        solution: "Enable tree-shaking optimization and audit dependency usage",
        expectedImprovement: "20-30% bundle size reduction",
        effort: "medium",
        impact: "medium"
      }
    ],
    codeQualityMetrics: {
      codeSmells: "3",
      duplicateCode: "8%",
      complexity: "6.2",
      maintainability: "78"
    },
    securityAssessment: {
      vulnerabilities: "1",
      riskLevel: "low",
      recommendations: ["Update dependencies with known vulnerabilities", "Implement input validation for user-generated content"]
    },
    overallScore: {
      performance: "75",
      grade: "B",
      summary: "Good performance with room for optimization in bundle size and render efficiency",
      priorityActions: ["Implement code splitting", "Optimize component re-renders", "Audit and reduce bundle size"]
    },
    _fallback: true,
    _timestamp: timestamp
  };
}

function generateFallbackPatternAnalysis(): any {
  return {
    detected: [
      { name: "Component Composition", usage: "85%", recommendation: "Good usage of composition over inheritance" },
      { name: "Custom Hooks", usage: "70%", recommendation: "Well implemented for logic reuse" },
      { name: "State Management", usage: "60%", recommendation: "Consider upgrading to more robust solution for complex state" },
      { name: "Error Boundaries", usage: "40%", recommendation: "Add more error boundaries for better error handling" }
    ],
    antiPatterns: [
      { name: "Prop Drilling", instances: 3, severity: "medium" },
      { name: "Large Components", instances: 2, severity: "low" },
      { name: "Inline Styles", instances: 1, severity: "low" }
    ]
  };
}

// Enhanced Azure AI-powered code analysis and improvement
async function analyzeAndImproveCodeWithAI(client: any, config: any, code: string, provider: string = 'azure'): Promise<any> {
  try {
    console.log("üîç Starting enhanced code analysis...");
    
    const analysisPrompt = `Perform a comprehensive analysis of this React/TypeScript code and provide detailed improvement suggestions.

**CODE TO ANALYZE:**
\`\`\`typescript
${code}
\`\`\`

**ANALYSIS FRAMEWORK:**

1. **Performance Analysis**:
   - Unnecessary re-renders and optimization opportunities
   - Bundle size and tree-shaking considerations
   - Memory leaks and performance bottlenecks
   - React optimization patterns (memo, useMemo, useCallback)

2. **Code Quality Assessment**:
   - TypeScript usage and type safety
   - Component structure and organization
   - Error handling and boundary conditions
   - Code readability and maintainability

3. **Security Review**:
   - Input validation and sanitization
   - XSS and injection vulnerabilities
   - Authentication and authorization patterns
   - Data exposure and privacy concerns

4. **Accessibility Audit**:
   - ARIA attributes and roles
   - Keyboard navigation support
   - Screen reader compatibility
   - Color contrast and visual accessibility

5. **Modern React Patterns**:
   - Hook usage and custom hooks
   - Context and state management
   - Concurrent features and Suspense
   - Error boundaries and fallbacks

**RESPONSE FORMAT:**
Respond with ONLY valid JSON in this exact structure:

{
  "analysisMetadata": {
    "codeLength": ${code.length},
    "complexity": "low|medium|high",
    "overallScore": "score from 1-10",
    "primaryLanguage": "typescript|javascript"
  },
  "improvements": [
    {
      "category": "performance|security|accessibility|maintainability|modernization",
      "type": "specific improvement type",
      "description": "Clear description of the issue",
      "severity": "low|medium|high|critical",
      "line": "line number or range",
      "currentCode": "problematic code snippet",
      "suggestedFix": "improved code snippet",
      "reasoning": "why this improvement is important",
      "impact": "expected impact of the change"
    }
  ],
  "optimizedCode": "Complete improved version of the code with all fixes applied",
  "summary": {
    "totalIssues": "number of issues found",
    "criticalIssues": "number of critical issues",
    "estimatedImprovement": "percentage improvement expected",
    "keyBenefits": ["list of main benefits from improvements"]
  }
}`;

    // Use caching for code analysis
    const cacheKey = getCacheKey(
      `code-analysis-${code.substring(0, 500)}`,
      config.modelName,
      { temperature: 0.1 }
    );
    
    let cachedResult = config.cacheEnabled ? getCachedResponse(cacheKey) : null;
    if (cachedResult) {
      console.log("üìÑ Using cached code analysis result");
      return cachedResult;
    }

    let parsed;
    
    if (provider.toLowerCase() === 'gemini') {
      const model = client.getGenerativeModel({ 
        model: config.modelName,
        generationConfig: {
          temperature: 0.1,
          maxOutputTokens: 4096,
          responseMimeType: "application/json"
        }
      });
      
      const systemPrompt = "You are a senior software architect and code reviewer specializing in React/TypeScript. Provide comprehensive, actionable code analysis with specific improvements. Focus on practical, implementable suggestions that deliver measurable benefits.";
      const fullPrompt = `${systemPrompt}\n\n${analysisPrompt}`;
      
      const result = await model.generateContent(fullPrompt);
      const response = await result.response;
      const text = response.text();
      
      try {
        parsed = JSON.parse(text);
      } catch (e) {
        console.error("Failed to parse Gemini response:", text);
        throw new Error("Invalid JSON response from Gemini");
      }
    } else if (provider.toLowerCase() === 'openai') {
      const response = await client.chat.completions.create({
        model: config.modelName,
        messages: [
          {
            role: "system",
            content: "You are a senior software architect and code reviewer specializing in React/TypeScript. Provide comprehensive, actionable code analysis with specific improvements. Focus on practical, implementable suggestions that deliver measurable benefits."
          },
          {
            role: "user",
            content: analysisPrompt
          }
        ],
        max_tokens: 4096,
        temperature: 0.1,
        response_format: { type: "json_object" }
      });
      
      parsed = JSON.parse(response.choices[0].message.content || "{}");
    } else if (provider.toLowerCase() === 'azure' || provider.toLowerCase() === 'azureai') {
      const response = await retryWithBackoff(async () => {
        return await client.path("/chat/completions").post({
          body: {
            messages: [
              {
                role: "system",
                content: "You are a senior software architect and code reviewer specializing in React/TypeScript. Provide comprehensive, actionable code analysis with specific improvements. Focus on practical, implementable suggestions that deliver measurable benefits."
              },
              {
                role: "user",
                content: analysisPrompt
              }
            ],
            max_tokens: 4096,
            temperature: 0.1,
            model: config.modelName,
            stream: false,
            response_format: { type: "json_object" }
          },
        });
      }, config.maxRetries, config.retryDelay);

      if (response.status !== "200") {
        const errorDetail = extractAzureAIError(response.body?.error || response.body);
        throw new Error(`Azure AI API error (${response.status}): ${errorDetail}`);
      }

      const aiResponse = response.body.choices[0]?.message?.content || "";
      console.log("üéØ Code analysis AI response received, length:", aiResponse.length);
      
      parsed = parseAzureAIJSON(aiResponse);
    } else {
      throw new Error(`Unsupported provider: ${provider}`);
    }
    if (parsed && parsed.improvements) {
      const result = {
        improvements: parsed.improvements || [],
        optimizedCode: parsed.optimizedCode || code,
        analysisMetadata: parsed.analysisMetadata || {},
        summary: parsed.summary || {}
      };
      
      // Cache the successful result
      if (config.cacheEnabled) {
        setCachedResponse(cacheKey, result, 120); // Cache for 2 hours
      }
      
      console.log("‚úÖ Code analysis successful:", {
        issuesFound: result.improvements.length,
        complexity: result.analysisMetadata.complexity,
        score: result.analysisMetadata.overallScore
      });
      
      return result;
    }

    console.warn("‚ö†Ô∏è Failed to parse AI code analysis, using fallback");
    return generateFallbackCodeAnalysis(code);
    
  } catch (error) {
    console.error("‚ùå AI code analysis error:", extractAzureAIError(error));
    return generateFallbackCodeAnalysis(code);
  }
}

function generateFallbackCodeAnalysis(code: string): any {
  return {
    improvements: [
      {
        type: "performance",
        description: "Consider using React.memo for expensive components",
        severity: "medium",
        line: 1,
        suggestion: "Wrap component with React.memo to prevent unnecessary re-renders"
      },
      {
        type: "accessibility",
        description: "Ensure proper ARIA labels and semantic HTML",
        severity: "high",
        line: 1,
        suggestion: "Add descriptive alt attributes and ARIA labels where needed"
      },
      {
        type: "security",
        description: "Validate and sanitize user inputs",
        severity: "high",
        line: 1,
        suggestion: "Use proper input validation and sanitization techniques"
      }
    ],
    optimizedCode: code // Return original code if AI optimization fails
  };
}

================
File: server/run-migration.ts
================
import dotenv from 'dotenv';
import { migrateFriendsFamilySubscription } from './friends-family-migration';

// Load environment variables
dotenv.config();

/**
 * Execute the Friends & Family subscription migration
 * This script safely migrates all existing users to the Friends & Family plan
 */
async function runMigration() {
  console.log('üöÄ Starting Friends & Family Subscription Migration');
  console.log('===================================================');
  console.log('This migration will:');
  console.log('1. Create a "Friends & Family" subscription plan (if not exists)');
  console.log('2. Grant all existing users active Friends & Family subscriptions');
  console.log('3. Set subscription expiry to 1 year from now');
  console.log('4. Enable full access to all AI features for testing\n');

  try {
    // Check if we have database connection
    if (!process.env.DATABASE_URL) {
      throw new Error('DATABASE_URL environment variable is required');
    }

    console.log('‚úì Database URL configured');
    console.log('‚úì Starting migration process...\n');

    const result = await migrateFriendsFamilySubscription();

    console.log('\nüìã MIGRATION RESULTS:');
    console.log('=====================');
    console.log(`‚úÖ Success: ${result.success}`);
    console.log(`üì¶ Plan created: ${result.planCreated}`);
    console.log(`üÜî Plan ID: ${result.planId}`);
    console.log(`üë§ Users updated: ${result.usersUpdated}`);
    console.log(`üìã Subscriptions created: ${result.subscriptionsCreated}`);

    if (result.details.length > 0) {
      console.log('\nüìù DETAILS:');
      result.details.forEach(detail => console.log(`  ${detail}`));
    }

    if (result.errors.length > 0) {
      console.log('\n‚ùå ERRORS:');
      result.errors.forEach(error => console.error(`  ${error}`));
    }

    if (result.success) {
      console.log('\nüéâ Migration completed successfully!');
      console.log('All existing users now have active Friends & Family subscriptions.');
      console.log('They can now access all premium AI features for testing.');
    } else {
      console.error('\n‚ùå Migration failed with errors. Please review the details above.');
      process.exit(1);
    }

  } catch (error) {
    console.error('\nüí• Migration failed with exception:');
    console.error(error);
    process.exit(1);
  }
}

// Execute if run directly
if (require.main === module) {
  runMigration();
}

export { runMigration };

================
File: server/sample-plans.sql
================
-- Sample subscription plans for testing
-- Note: You'll need to create these products and prices in your Stripe dashboard first
-- and replace the stripe_price_id and stripe_product_id with actual values

INSERT INTO subscription_plans (
  name, 
  description, 
  price, 
  interval, 
  features, 
  stripe_price_id, 
  stripe_product_id, 
  is_active, 
  sort_order
) VALUES 
(
  'Free',
  'Perfect for getting started with basic AI assistance',
  '0.00',
  'month',
  '["Basic chat access", "Limited AI interactions (10/month)", "Community support", "Basic code suggestions"]',
  'price_free', -- Replace with actual Stripe price ID
  'prod_free',  -- Replace with actual Stripe product ID
  true,
  1
),
(
  'NomadAI Pro',
  'Complete AI development assistant - Everything you need for just $5/month',
  '5.00',
  'month',
  '["Unlimited AI interactions", "Advanced code analysis", "UI generation & cloning", "Performance insights", "Design pattern analysis", "Email support", "Priority processing", "All AI models available", "Code improvement suggestions", "Advanced debugging assistance"]',
  'price_pro_monthly', -- Replace with actual Stripe price ID
  'prod_pro',          -- Replace with actual Stripe product ID
  true,
  2
),
(
  'Enterprise',
  'Advanced features for teams and organizations',
  '25.00',
  'month',
  '["Everything in NomadAI Pro", "Team collaboration tools", "Advanced analytics", "Custom integrations", "Priority support", "SLA guarantee", "Team management", "Custom model training", "Dedicated account manager"]',
  'price_enterprise_monthly', -- Replace with actual Stripe price ID
  'prod_enterprise',          -- Replace with actual Stripe product ID
  true,
  3
);

-- Optional: Annual plans with discount
INSERT INTO subscription_plans (
  name, 
  description, 
  price, 
  interval, 
  features, 
  stripe_price_id, 
  stripe_product_id, 
  is_active, 
  sort_order
) VALUES 
(
  'NomadAI Pro Annual',
  'Save $12/year with annual billing - Just $4.17/month!',
  '50.00',
  'year',
  '["Everything in NomadAI Pro", "2 months free with annual billing", "$12 annual savings", "Annual billing"]',
  'price_pro_yearly', -- Replace with actual Stripe price ID
  'prod_pro',         -- Same product, different price
  true,
  4
),
(
  'Enterprise Annual',
  'Best value for growing teams - Save $60/year',
  '240.00',
  'year',
  '["Everything in Enterprise monthly", "2 months free with annual billing", "$60 annual savings", "Annual billing"]',
  'price_enterprise_yearly', -- Replace with actual Stripe price ID
  'prod_enterprise',         -- Same product, different price
  true,
  5
);

================
File: server/storage.ts
================
import { users, type User, type InsertUser, type RegisterUser, type OAuthUser, type UpdateProfile } from "@shared/schema";
import { eq } from "drizzle-orm";
import bcrypt from "bcryptjs";
import { db } from "./db";
import { engagementService } from "./engagement";
import dotenv from "dotenv";
import { Profile } from "passport";
dotenv.config();

export interface IStorage {
  // User CRUD operations
  getUser(id: number): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByGoogleId(googleId: string): Promise<User | undefined>;
  
  // Authentication methods
  createUser(user: RegisterUser): Promise<User>;
  createOAuthUser(user: OAuthUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  updateUserProfile(id: number, profileData: UpdateProfile): Promise<User | undefined>;
  verifyPassword(email: string, password: string): Promise<User | null>;
  
  // OAuth linking
  linkGoogleAccount(userId: number, googleId: string): Promise<User | undefined>;
  
  // Password reset methods
  generatePasswordResetToken(email: string): Promise<string | null>;
  validatePasswordResetToken(token: string): Promise<User | null>;
  resetPassword(token: string, newPassword: string): Promise<boolean>;
  clearPasswordResetToken(userId: number): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.id, id));
      return result[0];
    } catch (error) {
      console.error("Error getting user by ID:", error);
      return undefined;
    }
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.email, email));
      return result[0];
    } catch (error) {
      console.error("Error getting user by email:", error);
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      if (!username) return undefined;
      const result = await db.select().from(users).where(eq(users.username, username));
      return result[0];
    } catch (error) {
      console.error("Error getting user by username:", error);
      return undefined;
    }
  }

  async getUserByGoogleId(googleId: string): Promise<User | undefined> {
    try {
      const result = await db.select().from(users).where(eq(users.googleId, googleId));
      return result[0];
    } catch (error) {
      console.error("Error getting user by Google ID:", error);
      return undefined;
    }
  }

  async createUser(userData: RegisterUser): Promise<User> {
    try {
      // Hash the password
      const saltRounds = 12;
      const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
      
      // Check if user with email already exists
      const existingUser = await this.getUserByEmail(userData.email);
      if (existingUser) {
        throw new Error("User with this email already exists");
      }
      
      // Check if username is provided and already exists
      if (userData.username) {
        const existingUsername = await this.getUserByUsername(userData.username);
        if (existingUsername) {
          throw new Error("Username already exists");
        }
      }
      
      const newUser = {
        email: userData.email,
        password: hashedPassword,
        username: userData.username || null,
        firstName: userData.firstName || null,
        lastName: userData.lastName || null,
        emailVerified: false,
        age: null,
        dateOfBirth: null,
        bio: null,
        // New team and credits fields with defaults
        teamId: null,
        teamRole: null,
        ai_credits_balance: 0,
        ai_credits_used_this_month: 0,
        credits_reset_at: new Date(),
        messages_used_this_month: 0,
        messages_reset_at: new Date(),
        is_grandfathered: false,
        grandfathered_from_tier: null,
        grandfathered_at: null,
        // Set default subscription tier to freemium
        subscription_tier: 'freemium',
        subscription_status: 'freemium',
        deletedAt: null,
      };
      
      const result = await db.insert(users).values(newUser).returning();
      const user = result[0];
      
      // Initialize engagement tracking for new user
      if (user) {
        await engagementService.initializeUserEngagement(user.id);
      }
      
      return user;
    } catch (error) {
      console.error("Error creating user:", error);
      throw error;
    }
  }

  async createOAuthUser(userData: OAuthUser): Promise<User> {
    try {
      // Check if user with email already exists
      const existingUser = await this.getUserByEmail(userData.email);
      if (existingUser) {
        // If user exists but doesn't have this OAuth provider linked, link it
        if (userData.googleId && !existingUser.googleId) {
          const updated = await this.linkGoogleAccount(existingUser.id, userData.googleId);
          if (updated) return updated;
        }
        return existingUser;
      }
      
      // Check if OAuth ID already exists
      if (userData.googleId) {
        const existingOAuth = await this.getUserByGoogleId(userData.googleId);
        if (existingOAuth) {
          return existingOAuth;
        }
      }
      
      const newUser = {
        email: userData.email,
        googleId: userData.googleId || null,
        firstName: userData.firstName || null,
        lastName: userData.lastName || null,
        avatar: userData.avatar || null,
        emailVerified: userData.emailVerified ?? true,
        password: null, // OAuth users don't have passwords initially
        age: null,
        dateOfBirth: null,
        bio: null,
        // New team and credits fields with defaults
        teamId: null,
        teamRole: null,
        ai_credits_balance: 0,
        ai_credits_used_this_month: 0,
        credits_reset_at: new Date(),
        messages_used_this_month: 0,
        messages_reset_at: new Date(),
        is_grandfathered: false,
        grandfathered_from_tier: null,
        grandfathered_at: null,
        deletedAt: null,
      };
      
      const result = await db.insert(users).values(newUser).returning();
      const user = result[0];
      
      // Initialize engagement tracking for new user
      if (user) {
        await engagementService.initializeUserEngagement(user.id);
      }
      
      return user;
    } catch (error) {
      console.error("Error creating OAuth user:", error);
      throw error;
    }
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    try {
      const result = await db
        .update(users)
        .set({ ...updates, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      return result[0];
    } catch (error) {
      console.error("Error updating user:", error);
      return undefined;
    }
  }

  async updateUserProfile(id: number, profileData: UpdateProfile): Promise<User | undefined> {
    try {
      const result = await db
        .update(users)
        .set({ ...profileData, updatedAt: new Date() } as any)
        .where(eq(users.id, id))
        .returning();
      return result[0];
    } catch (error) {
      console.error("Error updating user profile:", error);
      return undefined;
    }
  }

  async verifyPassword(email: string, password: string): Promise<User | null> {
    try {
      const user = await this.getUserByEmail(email);
      if (!user || !user.password) {
        return null;
      }
      
      const isValid = await bcrypt.compare(password, user.password);
      return isValid ? user : null;
    } catch (error) {
      console.error("Error verifying password:", error);
      return null;
    }
  }

  async linkGoogleAccount(userId: number, googleId: string): Promise<User | undefined> {
    try {
      const result = await db
        .update(users)
        .set({ googleId, updatedAt: new Date() })
        .where(eq(users.id, userId))
        .returning();
      return result[0];
    } catch (error) {
      console.error("Error linking Google account:", error);
      return undefined;
    }
  }

  async generatePasswordResetToken(email: string): Promise<string | null> {
    try {
      const user = await this.getUserByEmail(email);
      if (!user) {
        return null; // User doesn't exist
      }

      // Generate a secure random token
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      
      // Set expiry to 1 hour from now
      const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

      // Update user with reset token
      await db
        .update(users)
        .set({ 
          resetToken,
          resetTokenExpiry,
          updatedAt: new Date()
        })
        .where(eq(users.id, user.id));

      return resetToken;
    } catch (error) {
      console.error("Error generating password reset token:", error);
      return null;
    }
  }

  async validatePasswordResetToken(token: string): Promise<User | null> {
    try {
      const result = await db
        .select()
        .from(users)
        .where(eq(users.resetToken, token));
      
      const user = result[0];
      if (!user || !user.resetTokenExpiry) {
        return null; // Token doesn't exist
      }

      // Check if token has expired
      if (new Date() > user.resetTokenExpiry) {
        // Clear expired token
        await this.clearPasswordResetToken(user.id);
        return null;
      }

      return user;
    } catch (error) {
      console.error("Error validating password reset token:", error);
      return null;
    }
  }

  async resetPassword(token: string, newPassword: string): Promise<boolean> {
    try {
      const user = await this.validatePasswordResetToken(token);
      if (!user) {
        return false; // Invalid or expired token
      }

      // Hash the new password
      const saltRounds = 12;
      const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

      // Update password and clear reset token
      await db
        .update(users)
        .set({
          password: hashedPassword,
          resetToken: null,
          resetTokenExpiry: null,
          updatedAt: new Date()
        })
        .where(eq(users.id, user.id));

      return true;
    } catch (error) {
      console.error("Error resetting password:", error);
      return false;
    }
  }

  async clearPasswordResetToken(userId: number): Promise<void> {
    try {
      await db
        .update(users)
        .set({
          resetToken: null,
          resetTokenExpiry: null,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
    } catch (error) {
      console.error("Error clearing password reset token:", error);
      // Don't throw, as this is a cleanup operation
    }
  }
}

// Keep memory storage for development/testing purposes (fallback)
export class MemStorage implements IStorage {
  private users: Map<number, User>;
  currentId: number;

  constructor() {
    this.users = new Map();
    this.currentId = 1;
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.email === email,
    );
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async getUserByGoogleId(googleId: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.googleId === googleId,
    );
  }

  async createUser(userData: RegisterUser): Promise<User> {
    // Check if user already exists
    const existing = await this.getUserByEmail(userData.email);
    if (existing) {
      throw new Error("User with this email already exists");
    }

    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    const id = this.currentId++;
    const user: User = {
      id,
      email: userData.email,
      password: hashedPassword,
      username: userData.username || null,
      firstName: userData.firstName || null,
      lastName: userData.lastName || null,
      emailVerified: false,
      googleId: null,
      avatar: null,
      age: null,
      dateOfBirth: null,
      bio: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      stripeCustomerId: null,
      subscriptionStatus: 'freemium',
      subscriptionTier: 'freemium',
      subscriptionEndsAt: null,
      overrideExpiresAt: null,
      accessOverride: null,
      overrideReason: null,
      overrideGrantedBy: null,
      overrideGrantedAt: null,
      resetToken: null,
      resetTokenExpiry: null,
      // New team and credits fields
      deletedAt: null,
      ai_credits_balance: 0,
      ai_credits_used_this_month: 0,
      credits_reset_at: new Date(),
      messages_used_this_month: 0,
      messages_reset_at: new Date(),
      teamId: null,
      teamRole: null,
      is_grandfathered: false,
      grandfathered_from_tier: null,
      grandfathered_at: null,
    };
    
    this.users.set(id, user);
    return user;
  }

  async createOAuthUser(userData: OAuthUser): Promise<User> {
    const existing = await this.getUserByEmail(userData.email);
    if (existing) return existing;

    const id = this.currentId++;
    const user: User = {
      id,
      email: userData.email,
      password: null,
      username: null,
      firstName: userData.firstName || null,
      lastName: userData.lastName || null,
      emailVerified: userData.emailVerified ?? true,
      googleId: userData.googleId || null,
      avatar: userData.avatar || null,
      age: null,
      dateOfBirth: null,
      bio: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      stripeCustomerId: null,
      subscriptionStatus: 'freemium',
      subscriptionTier: 'freemium',
      subscriptionEndsAt: null,
      overrideExpiresAt: null,
      accessOverride: null,
      overrideReason: null,
      overrideGrantedBy: null,
      overrideGrantedAt: null,
      resetToken: null,
      resetTokenExpiry: null,
      // New team and credits fields
      deletedAt: null,
      ai_credits_balance: 0,
      ai_credits_used_this_month: 0,
      credits_reset_at: new Date(),
      messages_used_this_month: 0,
      messages_reset_at: new Date(),
      teamId: null,
      teamRole: null,
      is_grandfathered: false,
      grandfathered_from_tier: null,
      grandfathered_at: null,
    };
    
    this.users.set(id, user);
    return user;
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;

    const updatedUser = { ...user, ...updates, updatedAt: new Date() };
    this.users.set(id, updatedUser);
    return updatedUser;
  }

  async updateUserProfile(id: number, profileData: UpdateProfile): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;

    const updatedUser = { ...user, ...profileData, updatedAt: new Date() } as any;
    this.users.set(id, updatedUser);
    return updatedUser;
  }

  async verifyPassword(email: string, password: string): Promise<User | null> {
    const user = await this.getUserByEmail(email);
    if (!user || !user.password) return null;

    const isValid = await bcrypt.compare(password, user.password);
    return isValid ? user : null;
  }

  async linkGoogleAccount(userId: number, googleId: string): Promise<User | undefined> {
    return this.updateUser(userId, { googleId });
  }

  async generatePasswordResetToken(email: string): Promise<string | null> {
    const user = await this.getUserByEmail(email);
    if (!user) return null;

    // Generate a simple token for memory storage
    const crypto = await import('crypto');
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    const updatedUser = { 
      ...user, 
      resetToken, 
      resetTokenExpiry, 
      updatedAt: new Date() 
    };
    this.users.set(user.id, updatedUser);
    return resetToken;
  }

  async validatePasswordResetToken(token: string): Promise<User | null> {
    const userArray = Array.from(this.users.values());
    for (const user of userArray) {
      if (user.resetToken === token && user.resetTokenExpiry) {
        if (new Date() > user.resetTokenExpiry) {
          // Clear expired token
          await this.clearPasswordResetToken(user.id);
          return null;
        }
        return user;
      }
    }
    return null;
  }

  async resetPassword(token: string, newPassword: string): Promise<boolean> {
    const user = await this.validatePasswordResetToken(token);
    if (!user) return false;

    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

    const updatedUser = {
      ...user,
      password: hashedPassword,
      resetToken: null,
      resetTokenExpiry: null,
      updatedAt: new Date()
    };
    this.users.set(user.id, updatedUser);
    return true;
  }

  async clearPasswordResetToken(userId: number): Promise<void> {
    const user = this.users.get(userId);
    if (user) {
      const updatedUser = {
        ...user,
        resetToken: null,
        resetTokenExpiry: null,
        updatedAt: new Date()
      };
      this.users.set(userId, updatedUser);
    }
  }
}

// Always use database storage since Replit has PostgreSQL configured
export const storage = new DatabaseStorage();

================
File: server/stripe-checkout.ts
================
/**
 * Stripe Checkout Sessions Implementation
 * Modern best practice for subscription and one-time payments
 */

import Stripe from 'stripe';
import { db } from './db';
import { users, subscriptions, aiCreditsTransactions, subscriptionFeatures } from '@shared/schema';
import { eq } from 'drizzle-orm';
import { STRIPE_PRODUCTS, CREDIT_PACKAGES } from './stripe-enhanced';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  // Using default API version to avoid type conflicts
});

/**
 * Create Checkout Session for Subscription Plans
 */
export async function createSubscriptionCheckoutSession(params: {
  userId: number;
  tier: 'pro' | 'team' | 'enterprise';
  interval: 'month' | 'year';
  successUrl: string;
  cancelUrl: string;
  teamName?: string;
  memberEmails?: string[];
}): Promise<Stripe.Checkout.Session> {
  
  // Get user from database
  const [user] = await db.select().from(users).where(eq(users.id, params.userId)).limit(1);
  if (!user) {
    throw new Error('User not found');
  }

  // Get or create Stripe customer
  let customerId = user.stripeCustomerId;
  if (!customerId) {
    const customer = await stripe.customers.create({
      email: user.email,
      name: user.username || user.email.split('@')[0],
      metadata: {
        userId: params.userId.toString(),
        tier: params.tier,
      }
    });
    customerId = customer.id;
    
    // Update user with Stripe customer ID
    await db.update(users)
      .set({ stripeCustomerId: customerId })
      .where(eq(users.id, params.userId));
  }

  // Get the correct price ID based on tier and interval
  let priceId: string;
  let lineItems: Stripe.Checkout.SessionCreateParams.LineItem[] = [];
  
  switch (params.tier) {
    case 'pro':
      priceId = params.interval === 'year' 
        ? STRIPE_PRODUCTS.PRO.annualPriceId 
        : STRIPE_PRODUCTS.PRO.monthlyPriceId;
      lineItems = [{ price: priceId, quantity: 1 }];
      break;
      
    case 'team':
      priceId = params.interval === 'year' 
        ? STRIPE_PRODUCTS.TEAM.annualPriceId 
        : STRIPE_PRODUCTS.TEAM.monthlyPriceId;
      // Default to minimum 3 members for team plan (users can add more members later)
      const teamSize = Math.max(params.memberEmails?.length || 3, 3);
      lineItems = [{ price: priceId, quantity: teamSize }];
      break;
      
    case 'enterprise':
      // Enterprise uses custom pricing - redirect to contact sales
      throw new Error('Enterprise plans require custom pricing. Please contact sales.');
      
    default:
      throw new Error('Invalid subscription tier');
  }

  // Create checkout session
  const sessionParams: Stripe.Checkout.SessionCreateParams = {
    mode: 'subscription',
    customer: customerId,
    line_items: lineItems,
    success_url: params.successUrl + '?session_id={CHECKOUT_SESSION_ID}',
    cancel_url: params.cancelUrl,
    
    // Subscription-specific settings  
    billing_address_collection: 'auto',
    
    // Allow coupon codes
    allow_promotion_codes: true,
    
    // Metadata for webhook processing
    metadata: {
      userId: params.userId.toString(),
      tier: params.tier,
      interval: params.interval,
      teamName: params.teamName || '',
      memberEmails: params.memberEmails?.join(',') || '',
    },
    
    // Tax collection disabled to prevent customer_tax_location_invalid errors
    // Enable this after implementing proper address validation
    // automatic_tax: { enabled: true },
    
    // Customer update options
    customer_update: {
      address: 'auto',
      name: 'auto',
    }
  };

  return await stripe.checkout.sessions.create(sessionParams);
}

/**
 * Create Checkout Session for AI Credit Packages
 */
export async function createCreditsCheckoutSession(params: {
  userId: number;
  packageId: string; // e.g., 'credits_500'
  successUrl: string;
  cancelUrl: string;
}): Promise<Stripe.Checkout.Session> {
  
  // Get user from database
  const [user] = await db.select().from(users).where(eq(users.id, params.userId)).limit(1);
  if (!user) {
    throw new Error('User not found');
  }

  // Find the credit package
  const creditPackage = CREDIT_PACKAGES.find(pkg => 
    pkg.priceId === STRIPE_PRODUCTS.AI_CREDITS[params.packageId as keyof typeof STRIPE_PRODUCTS.AI_CREDITS]
  );
  
  if (!creditPackage) {
    throw new Error('Invalid credit package');
  }

  // Get or create Stripe customer
  let customerId = user.stripeCustomerId;
  if (!customerId) {
    const customer = await stripe.customers.create({
      email: user.email,
      name: user.username || user.email.split('@')[0],
      metadata: {
        userId: params.userId.toString(),
      }
    });
    customerId = customer.id;
    
    // Update user with Stripe customer ID
    await db.update(users)
      .set({ stripeCustomerId: customerId })
      .where(eq(users.id, params.userId));
  }

  // Create checkout session for one-time payment
  const sessionParams: Stripe.Checkout.SessionCreateParams = {
    mode: 'payment',
    customer: customerId,
    line_items: [{
      price: creditPackage.priceId,
      quantity: 1,
    }],
    success_url: params.successUrl + '?session_id={CHECKOUT_SESSION_ID}',
    cancel_url: params.cancelUrl,
    
    // One-time payment settings
    billing_address_collection: 'auto',
    
    // Allow coupon codes
    allow_promotion_codes: true,
    
    // Metadata for webhook processing
    metadata: {
      userId: params.userId.toString(),
      type: 'ai_credits',
      packageId: params.packageId,
      credits: creditPackage.credits.toString(),
      amount: creditPackage.price.toString(),
    },
    
    // Tax collection disabled to prevent customer_tax_location_invalid errors
    // Enable this after implementing proper address validation  
    // automatic_tax: { enabled: true },
  };

  return await stripe.checkout.sessions.create(sessionParams);
}

/**
 * Retrieve checkout session details
 */
export async function getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session> {
  return await stripe.checkout.sessions.retrieve(sessionId, {
    expand: ['subscription', 'payment_intent']
  });
}

/**
 * Handle successful subscription checkout completion
 */
export async function handleSubscriptionCheckoutSuccess(session: Stripe.Checkout.Session): Promise<void> {
  const userId = parseInt(session.metadata?.userId || '0');
  const tier = session.metadata?.tier;
  const interval = session.metadata?.interval;
  const teamName = session.metadata?.teamName;
  const memberEmails = session.metadata?.memberEmails?.split(',') || [];
  
  if (!userId || !tier) {
    console.error('Missing required metadata in checkout session:', session.id);
    return;
  }

  try {
    // Create subscription record in database
    const subscriptionData = {
      userId,
      stripeSubscriptionId: session.subscription as string,
      stripeCustomerId: session.customer as string,
      stripePriceId: (session as any).line_items?.data[0]?.price?.id || '',
      status: 'active',
      tier,
      currentPeriodStart: new Date(),
      currentPeriodEnd: new Date(Date.now() + (interval === 'year' ? 365 : 30) * 24 * 60 * 60 * 1000),
      metadata: {
        checkoutSessionId: session.id,
        teamName,
        memberCount: memberEmails.length,
        interval,
      }
    };

    await db.insert(subscriptions).values(subscriptionData);

    // Update user subscription status
    await db.update(users)
      .set({
        subscriptionStatus: 'active',
        subscriptionTier: tier,
        stripeCustomerId: session.customer as string,
      })
      .where(eq(users.id, userId));

    // Grant initial monthly credits for this tier (idempotent by subscription id)
    try {
      await grantMonthlyCreditsForTier({
        userId,
        tier,
        source: 'activation',
        subscriptionId: (session.subscription as string) || undefined,
      });
    } catch (grantError) {
      console.error('Granting initial monthly credits failed:', grantError);
    }

    // Handle team-specific setup if it's a team plan
    if (tier === 'team' && teamName && memberEmails.length >= 3) {
      // TODO: Create team and send invites to members
      // This would integrate with your existing team creation logic
    }

    console.log(`Subscription created successfully for user ${userId}, tier: ${tier}`);
    
  } catch (error) {
    console.error('Error handling subscription checkout success:', error);
    throw error;
  }
}

/**
 * Grant monthly credits for a user's tier. Idempotent based on a deterministic description key.
 */
export async function grantMonthlyCreditsForTier(params: {
  userId: number;
  tier: string;
  source: 'activation' | 'invoice';
  subscriptionId?: string;
  invoiceId?: string;
  periodStart?: number; // unix seconds
}): Promise<void> {
  // Determine description key for idempotency
  const descriptorParts = [
    'Monthly', params.source === 'activation' ? 'activation' : 'renewal', 'credits',
    `tier:${params.tier.toLowerCase()}`,
  ];
  if (params.subscriptionId) descriptorParts.push(`sub:${params.subscriptionId}`);
  if (params.invoiceId) descriptorParts.push(`inv:${params.invoiceId}`);
  if (params.periodStart) descriptorParts.push(`periodStart:${params.periodStart}`);
  const descriptionKey = descriptorParts.join(' ');

  await db.transaction(async (tx) => {
    // Check if already granted (idempotency via exact description match)
    const existing = await tx.select().from(aiCreditsTransactions)
      .where(eq(aiCreditsTransactions.userId, params.userId))
      .limit(50); // small window scan
    const alreadyExists = existing.some(r => (r.description || '') === descriptionKey);
    if (alreadyExists) {
      return; // already granted
    }

    // Look up monthly credits for the tier
    const [features] = await tx.select().from(subscriptionFeatures)
      .where(eq(subscriptionFeatures.tierName, params.tier.toLowerCase()));
    const monthlyCredits = Number(features?.monthlyAiCredits || 0);
    if (!monthlyCredits || monthlyCredits <= 0) {
      return; // nothing to grant
    }

    // Get current balance
    const [user] = await tx.select().from(users).where(eq(users.id, params.userId));
    if (!user) return;
    const currentBalance = user.ai_credits_balance || 0;
    const newBalance = currentBalance + monthlyCredits;

    // Update balance
    await tx.update(users)
      .set({ ai_credits_balance: newBalance, updatedAt: new Date() })
      .where(eq(users.id, params.userId));

    // Record transaction
    await tx.insert(aiCreditsTransactions).values({
      userId: params.userId,
      transactionType: 'bonus',
      amount: monthlyCredits,
      balanceAfter: newBalance,
      description: descriptionKey,
      metadata: {
        type: 'monthly_grant',
        source: params.source,
        tier: params.tier,
        subscriptionId: params.subscriptionId,
        invoiceId: params.invoiceId,
        periodStart: params.periodStart,
      } as any,
    });
  });
}

/**
 * Handle successful AI credits checkout completion
 */
export async function handleCreditsCheckoutSuccess(session: Stripe.Checkout.Session): Promise<void> {
  const userId = parseInt(session.metadata?.userId || '0');
  const credits = parseInt(session.metadata?.credits || '0');
  const amount = parseFloat(session.metadata?.amount || '0');
  const packageId = session.metadata?.packageId;
  
  if (!userId || !credits || !amount) {
    console.error('Missing required metadata in checkout session:', session.id);
    return;
  }

  try {
    // Add credits to user account
    const [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1);
    if (!user) {
      throw new Error('User not found');
    }

    const newBalance = (user.ai_credits_balance || 0) + credits;
    
    // Update user balance
    await db.update(users)
      .set({ ai_credits_balance: newBalance })
      .where(eq(users.id, userId));

    // Create transaction record
    await db.insert(aiCreditsTransactions).values({
      userId,
      transactionType: 'purchase',
      amount: credits,
      balanceAfter: newBalance,
      stripePaymentIntentId: session.payment_intent as string,
      description: `Purchased ${credits} AI credits`,
      metadata: {
        checkoutSessionId: session.id,
        packageId,
        priceUsd: amount,
      }
    });

    console.log(`${credits} AI credits added to user ${userId}, new balance: ${newBalance}`);
    
  } catch (error) {
    console.error('Error handling credits checkout success:', error);
    throw error;
  }
}

================
File: server/stripe-enhanced.ts
================
/**
 * Enhanced Stripe Integration for Multi-tier Subscriptions with Usage-based Billing
 */

import Stripe from 'stripe';
import { db } from './db';
import { users, subscriptions, subscriptionPlans, aiCreditsTransactions, teams } from '@shared/schema';
import { eq, and } from 'drizzle-orm';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  // Using default API version to avoid type conflicts
});

// Stripe Product/Price IDs (replace with actual IDs from Stripe Dashboard)
export const STRIPE_PRODUCTS = {
  PRO: {
    productId: process.env.STRIPE_PRO_PRODUCT_ID || 'prod_pro_v2',
    monthlyPriceId: process.env.STRIPE_PRO_MONTHLY_PRICE_ID || 'price_pro_v2_monthly',
    annualPriceId: process.env.STRIPE_PRO_ANNUAL_PRICE_ID || 'price_pro_v2_annual',
  },
  TEAM: {
    productId: process.env.STRIPE_TEAM_PRODUCT_ID || 'prod_team_v2',
    monthlyPriceId: process.env.STRIPE_TEAM_MONTHLY_PRICE_ID || 'price_team_v2_monthly',
    annualPriceId: process.env.STRIPE_TEAM_ANNUAL_PRICE_ID || 'price_team_v2_annual',
  },
  ENTERPRISE: {
    productId: process.env.STRIPE_ENTERPRISE_PRODUCT_ID || 'prod_enterprise_v2',
    customPriceId: process.env.STRIPE_ENTERPRISE_CUSTOM_PRICE_ID || 'price_enterprise_v2_custom',
  },
  AI_CREDITS: {
    productId: process.env.STRIPE_AI_CREDITS_PRODUCT_ID || 'prod_ai_credits',
    // Different credit packages
    credits_100: process.env.STRIPE_CREDITS_100_PRICE_ID || 'price_credits_100',
    credits_500: process.env.STRIPE_CREDITS_500_PRICE_ID || 'price_credits_500',
    credits_1000: process.env.STRIPE_CREDITS_1000_PRICE_ID || 'price_credits_1000',
    credits_5000: process.env.STRIPE_CREDITS_5000_PRICE_ID || 'price_credits_5000',
  }
};

// Credit package definitions
export const CREDIT_PACKAGES = [
  { credits: 100, price: 1.99, priceId: STRIPE_PRODUCTS.AI_CREDITS.credits_100 },
  { credits: 500, price: 8.99, priceId: STRIPE_PRODUCTS.AI_CREDITS.credits_500 },
  { credits: 1000, price: 15.99, priceId: STRIPE_PRODUCTS.AI_CREDITS.credits_1000 },
  { credits: 5000, price: 69.99, priceId: STRIPE_PRODUCTS.AI_CREDITS.credits_5000 },
];

/**
 * Create a team subscription (for Team and Enterprise plans)
 */
export async function createTeamSubscription(data: {
  teamName: string;
  ownerId: number;
  tier: 'team' | 'enterprise';
  memberEmails: string[];
  paymentMethodId: string;
  billingEmail: string;
}): Promise<{ subscription: Stripe.Subscription; teamId: number }> {
  try {
    // Validate minimum team size for Team plan
    if (data.tier === 'team' && data.memberEmails.length < 3) {
      throw new Error('Team plan requires minimum 3 members');
    }

    // Create team in database
    const [team] = await db.insert(teams).values({
      name: data.teamName,
      ownerId: data.ownerId,
      subscriptionTier: data.tier,
      maxMembers: data.tier === 'enterprise' ? 999999 : data.memberEmails.length,
      currentMembers: 1, // Owner counts as first member
      pooledAiCredits: data.tier === 'enterprise' ? 999999 : 5000 * data.memberEmails.length,
    }).returning();

    // Update owner's team association
    await db.update(users)
      .set({ 
        teamId: team.id,
        teamRole: 'owner',
        subscriptionTier: data.tier
      })
      .where(eq(users.id, data.ownerId));

    // Get or create Stripe customer
    const owner = await db.select().from(users).where(eq(users.id, data.ownerId)).limit(1);
    let customerId = owner[0].stripeCustomerId;

    if (!customerId) {
      const customer = await stripe.customers.create({
        email: data.billingEmail,
        name: data.teamName,
        metadata: {
          teamId: team.id.toString(),
          ownerId: data.ownerId.toString(),
          teamName: data.teamName,
        }
      });
      customerId = customer.id;
      
      await db.update(users)
        .set({ stripeCustomerId: customerId })
        .where(eq(users.id, data.ownerId));
    }

    // Attach payment method
    await stripe.paymentMethods.attach(data.paymentMethodId, {
      customer: customerId,
    });

    // Set as default payment method
    await stripe.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: data.paymentMethodId,
      },
    });

    // Create subscription with quantity based on team size
    const priceId = data.tier === 'enterprise' 
      ? STRIPE_PRODUCTS.ENTERPRISE.customPriceId
      : STRIPE_PRODUCTS.TEAM.monthlyPriceId;

    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{
        price: priceId,
        quantity: data.memberEmails.length, // Charge per seat
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { 
        save_default_payment_method: 'on_subscription' 
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        teamId: team.id.toString(),
        teamName: data.teamName,
        tier: data.tier,
      }
    });

    // Save subscription to database
    await db.insert(subscriptions).values({
      userId: data.ownerId,
      teamId: team.id,
      stripeSubscriptionId: subscription.id,
      stripePriceId: priceId,
      status: subscription.status,
      currentPeriodStart: new Date((subscription as any).current_period_start * 1000),
      currentPeriodEnd: new Date((subscription as any).current_period_end * 1000),
    });

    // Send invitations to team members
    for (const email of data.memberEmails) {
      if (email !== owner[0].email) {
        // TODO: Send invitation email
        console.log(`Invitation would be sent to ${email} to join team ${data.teamName}`);
      }
    }

    return { subscription, teamId: team.id };

  } catch (error) {
    console.error('Error creating team subscription:', error);
    throw error;
  }
}

/**
 * Purchase additional AI credits
 */
export async function purchaseAICredits(data: {
  userId: number;
  creditPackage: typeof CREDIT_PACKAGES[0];
  paymentMethodId?: string;
}): Promise<Stripe.PaymentIntent> {
  try {
    const user = await db.select().from(users).where(eq(users.id, data.userId)).limit(1);
    if (!user[0]) {
      throw new Error('User not found');
    }

    let customerId = user[0].stripeCustomerId;

    // Create customer if doesn't exist
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user[0].email,
        metadata: { userId: data.userId.toString() }
      });
      customerId = customer.id;
      
      await db.update(users)
        .set({ stripeCustomerId: customerId })
        .where(eq(users.id, data.userId));
    }

    // Create one-time payment for credits
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(data.creditPackage.price * 100), // Convert to cents
      currency: 'usd',
      customer: customerId,
      payment_method: data.paymentMethodId,
      confirm: true,
      metadata: {
        userId: data.userId.toString(),
        credits: data.creditPackage.credits.toString(),
        type: 'credit_purchase'
      },
      description: `Purchase of ${data.creditPackage.credits} AI Credits`,
    });

    // If payment successful, add credits to user account
    if (paymentIntent.status === 'succeeded') {
      await addCreditsToUser(
        data.userId,
        data.creditPackage.credits,
        paymentIntent.id,
        data.creditPackage.price
      );
    }

    return paymentIntent;

  } catch (error) {
    console.error('Error purchasing AI credits:', error);
    throw error;
  }
}

/**
 * Add credits to user account and create transaction record
 */
async function addCreditsToUser(
  userId: number,
  credits: number,
  stripePaymentIntentId: string,
  purchaseAmount: number
): Promise<void> {
  await db.transaction(async (tx) => {
    // Get current balance
    const [user] = await tx.select().from(users).where(eq(users.id, userId));
    const currentBalance = user.ai_credits_balance || 0;
    const newBalance = currentBalance + credits;

    // Update user balance
    await tx.update(users)
      .set({ 
        ai_credits_balance: newBalance,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));

    // Create transaction record
    await tx.insert(aiCreditsTransactions).values({
      userId,
      transactionType: 'purchase',
      amount: credits,
      balanceAfter: newBalance,
      stripePaymentIntentId,
      purchaseAmountCents: Math.round(purchaseAmount * 100),
      description: `Purchased ${credits} AI Credits`,
    });
  });
}

/**
 * Update team subscription (add/remove seats)
 */
export async function updateTeamSeats(
  teamId: number,
  newSeatCount: number
): Promise<Stripe.Subscription> {
  try {
    // Get team and subscription info
    const [team] = await db.select().from(teams).where(eq(teams.id, teamId));
    if (!team) {
      throw new Error('Team not found');
    }

    const [subscription] = await db.select()
      .from(subscriptions)
      .where(eq(subscriptions.teamId, teamId));
    
    if (!subscription || !subscription.stripeSubscriptionId) {
      throw new Error('No active subscription found for team');
    }

    // Update subscription quantity in Stripe
    const stripeSubscription = await stripe.subscriptions.retrieve(
      subscription.stripeSubscriptionId
    );

    const updatedSubscription = await stripe.subscriptions.update(
      subscription.stripeSubscriptionId,
      {
        items: [{
          id: stripeSubscription.items.data[0].id,
          quantity: newSeatCount,
        }],
        proration_behavior: 'always_invoice', // Create prorated invoice immediately
      }
    );

    // Update team limits
    await db.update(teams)
      .set({
        maxMembers: newSeatCount,
        pooledAiCredits: 5000 * newSeatCount, // Adjust pooled credits
        updatedAt: new Date()
      })
      .where(eq(teams.id, teamId));

    return updatedSubscription;

  } catch (error) {
    console.error('Error updating team seats:', error);
    throw error;
  }
}

/**
 * Handle usage-based billing for AI operations
 */
export async function trackAIUsage(data: {
  userId: number;
  operationType: 'chat' | 'codebase_analysis' | 'app_generation' | 'code_review' | 'advanced_model';
  modelUsed: string;
  tokensConsumed: number;
}): Promise<{ creditsUsed: number; remainingBalance: number }> {
  console.log(`üí≥ Calculating credits for user ${data.userId}: ${data.tokensConsumed} tokens consumed for ${data.operationType} with model ${data.modelUsed}`);
  
  // Base calculation: 1 credit per 100 tokens (adjust this ratio as needed)
  const tokensPerCredit = 100;
  let creditsToDeduct = Math.max(1, Math.ceil(data.tokensConsumed / tokensPerCredit));
  
  // Operation type multipliers for different complexity levels
  const operationMultipliers = {
    chat: 1.0,                    // Standard chat - 1x
    codebase_analysis: 2.0,       // Complex analysis - 2x
    app_generation: 3.0,          // App generation - 3x
    code_review: 1.5,             // Code review - 1.5x
    advanced_model: 1.0,          // Handled by model multiplier below
  };

  // Apply operation multiplier
  creditsToDeduct = Math.ceil(creditsToDeduct * (operationMultipliers[data.operationType] || 1.0));
  
  // Apply premium model multipliers
  let modelMultiplier = 1.0;
  if (data.modelUsed.includes('gpt-4') || data.modelUsed.includes('claude-3-opus')) {
    modelMultiplier = 2.0; // Premium models cost 2x
  } else if (data.modelUsed.includes('claude-3-sonnet') || data.modelUsed.includes('gpt-3.5-turbo-16k')) {
    modelMultiplier = 1.5; // Mid-tier models cost 1.5x
  }
  
  creditsToDeduct = Math.ceil(creditsToDeduct * modelMultiplier);
  
  // Ensure minimum credit usage of 1
  creditsToDeduct = Math.max(1, creditsToDeduct);
  
  console.log(`üí≥ Credit calculation for user ${data.userId}: ${data.tokensConsumed} tokens ‚Üí ${creditsToDeduct} credits (${data.operationType} ${operationMultipliers[data.operationType]}x, ${data.modelUsed} ${modelMultiplier}x)`);

  return await db.transaction(async (tx) => {
    // Get user and check if part of a team
    const [user] = await tx.select().from(users).where(eq(users.id, data.userId));
    
    if (!user) {
      throw new Error('User not found');
    }

    let currentBalance: number;
    let newBalance: number;

    if (user.teamId) {
      // Use team pooled credits
      const [team] = await tx.select().from(teams).where(eq(teams.id, user.teamId));
      currentBalance = team.pooledAiCredits || 0;
      
      if (currentBalance < creditsToDeduct) {
        throw new Error('Insufficient AI credits');
      }

      newBalance = currentBalance - creditsToDeduct;
      
      await tx.update(teams)
        .set({
          pooledAiCredits: newBalance,
          pooledCreditsUsedThisMonth: (team.pooledCreditsUsedThisMonth || 0) + creditsToDeduct,
        })
        .where(eq(teams.id, user.teamId));

    } else {
      // Use individual credits
      currentBalance = user.ai_credits_balance || 0;
      
      if (currentBalance < creditsToDeduct) {
        throw new Error('Insufficient AI credits');
      }

      newBalance = currentBalance - creditsToDeduct;
      
      await tx.update(users)
        .set({
          ai_credits_balance: newBalance,
          ai_credits_used_this_month: (user.ai_credits_used_this_month || 0) + creditsToDeduct,
        })
        .where(eq(users.id, data.userId));
    }

    // Record transaction
    await tx.insert(aiCreditsTransactions).values({
      userId: data.userId,
      teamId: user.teamId,
      transactionType: 'usage',
      amount: -creditsToDeduct, // Negative for usage
      balanceAfter: newBalance,
      operationType: data.operationType,
      modelUsed: data.modelUsed,
      tokensConsumed: data.tokensConsumed,
      description: `Used ${creditsToDeduct} credits for ${data.operationType}`,
    });

    return {
      creditsUsed: creditsToDeduct,
      remainingBalance: newBalance,
    };
  });
}

/**
 * Check if user has sufficient credits for an operation
 */
export async function checkCreditBalance(
  userId: number,
  requiredCredits: number
): Promise<{ hasCredits: boolean; currentBalance: number; isTeamPooled: boolean }> {
  const [user] = await db.select().from(users).where(eq(users.id, userId));
  
  if (!user) {
    return { hasCredits: false, currentBalance: 0, isTeamPooled: false };
  }

  if (user.teamId) {
    const [team] = await db.select().from(teams).where(eq(teams.id, user.teamId));
    const balance = team?.pooledAiCredits || 0;
    return {
      hasCredits: balance >= requiredCredits,
      currentBalance: balance,
      isTeamPooled: true,
    };
  }

  const balance = user.ai_credits_balance || 0;
  return {
    hasCredits: balance >= requiredCredits,
    currentBalance: balance,
    isTeamPooled: false,
  };
}

export default {
  createTeamSubscription,
  purchaseAICredits,
  updateTeamSeats,
  trackAIUsage,
  checkCreditBalance,
  STRIPE_PRODUCTS,
  CREDIT_PACKAGES,
};

================
File: server/stripe.ts
================
import Stripe from 'stripe';
import { db } from './db';
import { users, subscriptions, subscriptionPlans } from '@shared/schema';
import { eq } from 'drizzle-orm';
import type { User, SubscriptionPlan } from '@shared/schema';

// Initialize Stripe with the secret key
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-06-30.basil',
});

export interface CreateCustomerData {
  email: string;
  name?: string;
  metadata?: Record<string, string>;
}

export interface CreateSubscriptionData {
  customerId: string;
  priceId: string;
  paymentMethodId?: string;
  trialPeriodDays?: number;
}

/**
 * Create a Stripe customer
 */
export async function createStripeCustomer(data: CreateCustomerData): Promise<Stripe.Customer> {
  try {
    const customer = await stripe.customers.create({
      email: data.email,
      name: data.name,
      metadata: data.metadata || {},
    });
    
    return customer;
  } catch (error) {
    console.error('Error creating Stripe customer:', error);
    throw new Error('Failed to create customer in Stripe');
  }
}

/**
 * Create a subscription setup intent for collecting payment method
 */
export async function createSetupIntent(customerId: string): Promise<Stripe.SetupIntent> {
  try {
    const setupIntent = await stripe.setupIntents.create({
      customer: customerId,
      usage: 'off_session',
      payment_method_types: ['card'],
    });
    
    return setupIntent;
  } catch (error) {
    console.error('Error creating setup intent:', error);
    throw new Error('Failed to create setup intent');
  }
}

/**
 * Create a subscription
 */
export async function createSubscription(data: CreateSubscriptionData): Promise<Stripe.Subscription> {
  try {
    const subscriptionData: Stripe.SubscriptionCreateParams = {
      customer: data.customerId,
      items: [{ price: data.priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent'],
    };

    // Add payment method if provided
    if (data.paymentMethodId) {
      subscriptionData.default_payment_method = data.paymentMethodId;
    }

    // Add trial period if specified
    if (data.trialPeriodDays) {
      subscriptionData.trial_period_days = data.trialPeriodDays;
    }

    const subscription = await stripe.subscriptions.create(subscriptionData);
    
    return subscription;
  } catch (error) {
    console.error('Error creating subscription:', error);
    throw new Error('Failed to create subscription');
  }
}

/**
 * Retrieve a subscription from Stripe
 */
export async function getStripeSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
  try {
    const subscription = await stripe.subscriptions.retrieve(subscriptionId);
    return subscription;
  } catch (error) {
    console.error('Error retrieving subscription:', error);
    throw new Error('Failed to retrieve subscription');
  }
}

/**
 * Cancel a subscription
 */
export async function cancelSubscription(subscriptionId: string, atPeriodEnd: boolean = true): Promise<Stripe.Subscription> {
  try {
    const subscription = await stripe.subscriptions.update(subscriptionId, {
      cancel_at_period_end: atPeriodEnd,
    });
    
    return subscription;
  } catch (error) {
    console.error('Error canceling subscription:', error);
    throw new Error('Failed to cancel subscription');
  }
}

/**
 * Reactivate a subscription
 */
export async function reactivateSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
  try {
    const subscription = await stripe.subscriptions.update(subscriptionId, {
      cancel_at_period_end: false,
    });
    
    return subscription;
  } catch (error) {
    console.error('Error reactivating subscription:', error);
    throw new Error('Failed to reactivate subscription');
  }
}

/**
 * Create a billing portal session for customer self-service
 */
export async function createBillingPortalSession(customerId: string, returnUrl: string): Promise<Stripe.BillingPortal.Session> {
  try {
    const session = await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: returnUrl,
    });
    
    return session;
  } catch (error) {
    console.error('Error creating billing portal session:', error);
    throw new Error('Failed to create billing portal session');
  }
}

/**
 * Sync subscription data from Stripe to database
 */
export async function syncSubscriptionFromStripe(stripeSubscriptionId: string, userId: number): Promise<void> {
  try {
    const stripeSubscription = await getStripeSubscription(stripeSubscriptionId);
    const priceId = stripeSubscription.items.data[0]?.price.id;
    
    // Find the plan in our database
    const plan = await db.select().from(subscriptionPlans).where(eq(subscriptionPlans.stripePriceId, priceId)).limit(1);
    
    const subscriptionData = {
      userId,
      planId: plan[0]?.id || null,
      stripeSubscriptionId: stripeSubscription.id,
      stripePriceId: priceId,
      status: stripeSubscription.status,
      currentPeriodStart: stripeSubscription.items.data[0]?.current_period_start ? new Date(stripeSubscription.items.data[0].current_period_start * 1000) : null,
      currentPeriodEnd: stripeSubscription.items.data[0]?.current_period_end ? new Date(stripeSubscription.items.data[0].current_period_end * 1000) : null,
      cancelAtPeriodEnd: stripeSubscription.cancel_at_period_end,
      canceledAt: stripeSubscription.canceled_at ? new Date(stripeSubscription.canceled_at * 1000) : null,
      trialStart: stripeSubscription.trial_start ? new Date(stripeSubscription.trial_start * 1000) : null,
      trialEnd: stripeSubscription.trial_end ? new Date(stripeSubscription.trial_end * 1000) : null,
      updatedAt: new Date(),
    };

    // Check if subscription already exists
    const existingSubscription = await db.select().from(subscriptions)
      .where(eq(subscriptions.stripeSubscriptionId, stripeSubscriptionId))
      .limit(1);

    if (existingSubscription.length > 0) {
      // Update existing subscription
      await db.update(subscriptions)
        .set(subscriptionData)
        .where(eq(subscriptions.stripeSubscriptionId, stripeSubscriptionId));
    } else {
      // Create new subscription record
      await db.insert(subscriptions).values(subscriptionData);
    }

    // Update user subscription status
    const tier = plan[0]?.name.toLowerCase() || 'freemium';
    await db.update(users)
      .set({
        subscriptionStatus: stripeSubscription.status,
        subscriptionTier: tier,
        subscriptionEndsAt: stripeSubscription.items.data[0]?.current_period_end ? new Date(stripeSubscription.items.data[0].current_period_end * 1000) : null,
        updatedAt: new Date(),
      })
      .where(eq(users.id, userId));

  } catch (error) {
    console.error('Error syncing subscription from Stripe:', error);
    throw new Error('Failed to sync subscription data');
  }
}

/**
 * Verify webhook signature
 */
export function verifyWebhookSignature(payload: string | Buffer, signature: string, secret: string): Stripe.Event {
  try {
    return stripe.webhooks.constructEvent(payload, signature, secret);
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    throw new Error('Invalid webhook signature');
  }
}

export { stripe };

================
File: server/subscription-middleware.ts
================
/**
 * Consolidated Subscription Middleware
 * Combines all subscription-related middleware functionality in one file
 */

import type { Request, Response, NextFunction } from 'express';
import { db } from './db';
import { users, subscriptions, subscriptionFeatures, teams, aiCreditsTransactions, rateLimits } from '@shared/schema';
import { eq, desc, and, gte, sql } from 'drizzle-orm';
import { storage } from './storage';
import { checkCreditBalance } from './stripe-enhanced';
import { isVectorizationEnabled } from './vector-flags';

// Helper: detect if request should be BYOK-exempt from app-side limits/credits
function isBYOKNonLmstudio(req: any): boolean {
  try {
    const provider = (req?.body?.provider || req?.query?.provider || '').toString().toLowerCase();
    const hasApiKey = Boolean(req?.body?.apiKey);
    // Exempt when user supplies their own API key for non-LMStudio providers
    return hasApiKey && provider && provider !== 'lmstudio';
  } catch {
    return false;
  }
}

// Estimate required credits based on message complexity and context
export function estimateRequiredCredits(messages: any[], enableContext: boolean = false, hasAttachments: boolean = false, model: string = ''): number {
  if (!messages || messages.length === 0) {
    return 2; // Minimum for any request
  }

  // Get the latest user message for analysis
  const latestMessage = messages[messages.length - 1];
  const content = typeof latestMessage?.content === 'string' ? latestMessage.content : '';
  
  // Base estimation on message length and complexity
  let estimatedCredits = 2; // Base minimum
  
  // Message length analysis
  if (content.length < 50) {
    // Short messages like "Hi", "Thanks", "Yes" - very low cost
    estimatedCredits = 2;
  } else if (content.length < 200) {
    // Medium messages - moderate cost
    estimatedCredits = 3;
  } else if (content.length < 500) {
    // Longer messages - higher cost
    estimatedCredits = 5;
  } else {
    // Very long messages - highest cost
    estimatedCredits = 8;
  }

  // Add buffer for context enhancement only when vectors are enabled (and not for very simple messages)
  if (isVectorizationEnabled() && enableContext && content.length > 10) {
    estimatedCredits += 2;
  }

  // Add buffer for attachments
  if (hasAttachments) {
    estimatedCredits += 3;
  }

  // Add buffer for premium models
  if (model.includes('gpt-4') || model.includes('claude-3-opus')) {
    estimatedCredits = Math.ceil(estimatedCredits * 1.5);
  }

  // Consider conversation history length (more context = more tokens)
  if (messages.length > 10) {
    estimatedCredits += 2;
  } else if (messages.length > 5) {
    estimatedCredits += 1;
  }

  // Cap the maximum to prevent excessive requirements
  return Math.min(estimatedCredits, 10);
}

// Extend Request type to include user
interface AuthenticatedRequest extends Request {
  user?: any & {
    creditsPending?: {
      amount: number;
      operationType: string;
      currentBalance: number;
    };
    /**
     * Flag set by checkFreemiumLimit() when this request consumed a free message.
     * When true, downstream credit checks must be skipped for this request only.
     */
    freeMessageUsed?: boolean;
    /**
     * Flag set by requireMinimumCredits() when this request needs credit deduction after completion.
     * Contains info needed for post-completion credit tracking.
     */
    needsCreditDeduction?: {
      operationType: string;
      currentBalance: number;
      isTeamPooled: boolean;
    };
  };
}

// Basic subscription check result
export interface SubscriptionCheckResult {
  hasAccess: boolean;
  reason: 'active_subscription' | 'trial_period' | 'admin_override' | 'no_subscription' | 'expired' | 'payment_failed';
  tier?: string;
  expiresAt?: Date;
  upgradeRequired?: boolean;
}

// Enhanced subscription check with detailed features
export interface EnhancedSubscriptionCheck {
  hasAccess: boolean;
  tier: string;
  status: string;
  features: {
    unlimitedChat: boolean;
    monthlyMessageAllowance: number;
    messagesUsedThisMonth: number;
    messagesRemaining: number;
    aiProvidersAccess: string[];
    monthlyAiCredits: number;
    currentCreditsBalance: number;
    maxProjects: number;
    fullCodebaseContext: boolean;
    gitIntegration: boolean;
    aiCodeReviewsPerMonth: number;
    aiCodeReviewsUsed: number;
    teamFeaturesEnabled: boolean;
    sharedWorkspaces: boolean;
    ssoEnabled: boolean;
    auditLogs: boolean;
    supportLevel: string;
  };
  team?: {
    id: number;
    name: string;
    role: string;
    members: number;
    maxMembers: number;
  };
  isGrandfathered: boolean;
  grandfatheredFrom?: string;
}

/**
 * Check if monthly reset is needed and perform it atomically
 */
async function checkAndPerformMonthlyReset(userId: number): Promise<void> {
  const now = new Date();
  const startOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  
  // Use a transaction to atomically check and reset if needed
  await db.transaction(async (tx) => {
    const [user] = await tx.select({
      id: users.id,
      messagesResetAt: users.messages_reset_at,
      messagesUsedThisMonth: users.messages_used_this_month
    }).from(users).where(eq(users.id, userId));

    if (!user) return;

    // If messages_reset_at is null or before the start of current month, reset
    if (!user.messagesResetAt || user.messagesResetAt < startOfCurrentMonth) {
      await tx.update(users)
        .set({
          messages_used_this_month: 0,
          messages_reset_at: startOfCurrentMonth,
          updatedAt: now
        })
        .where(eq(users.id, userId));
    }
  });
}

/**
 * Helper function to get monthly usage for a specific operation type
 */
async function getMonthlyUsage(userId: number, operationType: string): Promise<number> {
  const startOfMonth = new Date();
  startOfMonth.setDate(1);
  startOfMonth.setHours(0, 0, 0, 0);

  const result = await db
    .select({
      count: sql`COUNT(*)::int`
    })
    .from(aiCreditsTransactions)
    .where(
      and(
        eq(aiCreditsTransactions.userId, userId),
        eq(aiCreditsTransactions.operationType, operationType),
        gte(aiCreditsTransactions.createdAt, startOfMonth)
      )
    );

  return Number(result[0]?.count) || 0;
}

/**
 * Check if a user has valid subscription access (basic check)
 */
export async function checkSubscriptionAccess(userId: number): Promise<SubscriptionCheckResult> {
  try {
    // Get user with current subscription status
    const user = await storage.getUser(userId);
    if (!user) {
      return {
        hasAccess: false,
        reason: 'no_subscription',
        upgradeRequired: true
      };
    }

    // Check for admin override first
    if (user.accessOverride) {
      // Check if override has expired
      if (user.overrideExpiresAt && new Date() > user.overrideExpiresAt) {
        // Override expired, remove it
        await db.update(users)
          .set({ 
            accessOverride: false,
            overrideReason: null,
            overrideExpiresAt: null 
          })
          .where(eq(users.id, userId));
      } else {
        return {
          hasAccess: true,
          reason: 'admin_override',
          tier: user.subscriptionTier || 'pro'
        };
      }
    }

    // Check for grandfathered users - they always have access
    if (user.is_grandfathered && user.grandfathered_from_tier) {
      return {
        hasAccess: true,
        reason: 'admin_override', // Treat as admin override since they have special status
        tier: user.subscriptionTier || 'pro' // Default to pro for grandfathered users
      };
    }

    // Check subscription status
    const validStatuses = ['active', 'trialing'];
    if (user.subscriptionStatus && validStatuses.includes(user.subscriptionStatus)) {
      return {
        hasAccess: true,
        reason: user.subscriptionStatus === 'trialing' ? 'trial_period' : 'active_subscription',
        tier: user.subscriptionTier || 'freemium',
        expiresAt: user.subscriptionEndsAt || undefined
      };
    }

    // Get detailed subscription info for more specific error handling
    const subscription = await db.select().from(subscriptions)
      .where(eq(subscriptions.userId, userId))
      .orderBy(desc(subscriptions.createdAt))
      .limit(1);

    const currentSubscription = subscription[0];
    
    // Determine specific failure reason
    if (!currentSubscription) {
      return {
        hasAccess: false,
        reason: 'no_subscription',
        upgradeRequired: true
      };
    }

    if (currentSubscription.status === 'past_due') {
      return {
        hasAccess: false,
        reason: 'payment_failed',
        upgradeRequired: true,
        tier: user.subscriptionTier || 'freemium'
      };
    }

    return {
      hasAccess: false,
      reason: 'expired',
      upgradeRequired: true,
      tier: user.subscriptionTier || 'freemium'
    };

  } catch (error) {
    console.error('Error checking subscription access:', error);
    // In case of error, deny access but don't indicate upgrade requirement
    // This might be a temporary issue
    return {
      hasAccess: false,
      reason: 'no_subscription',
      upgradeRequired: false
    };
  }
}

/**
 * Get comprehensive subscription details including features and credits
 * 
 * This function handles special cases for grandfathered users:
 * - Grandfathered users get Pro tier features regardless of their current subscription tier
 * - They maintain their original pricing (e.g., $5/month for NomadAI Pro users)
 * - They receive enhanced credit benefits and minimum credit guarantees
 * - Friends & Family users get Pro tier features as a special benefit
 * 
 * The function uses an "effective tier" concept where grandfathered users
 * get Pro tier features while maintaining their original tier for billing purposes.
 */
export async function getEnhancedSubscriptionDetails(
  userId: number
): Promise<EnhancedSubscriptionCheck> {
  try {
    // First, check and perform monthly reset if needed
    await checkAndPerformMonthlyReset(userId);

    // Get user with team info
    const [user] = await db.select().from(users).where(eq(users.id, userId));
    
    if (!user) {
      throw new Error('User not found');
    }

    const tier = user.subscriptionTier || 'freemium';
    
    // Handle grandfathered plans - they get enhanced features regardless of current tier
    let effectiveTier = tier;
    if (user.is_grandfathered && user.grandfathered_from_tier) {
      // Grandfathered users get Pro tier features regardless of their original tier
      // This includes:
      // - NomadAI Pro users ($5/month) -> Pro tier features at original pricing
      // - Friends & Family users -> Pro tier features as a benefit
      // - Other legacy users -> Enhanced features based on migration logic
      effectiveTier = 'pro';
    }
    
    // Get feature configuration for the effective tier
    const [features] = await db.select()
      .from(subscriptionFeatures)
      .where(eq(subscriptionFeatures.tierName, effectiveTier));

    if (!features) {
      // Create default features based on effective tier
      const defaultFeatures = effectiveTier === 'pro' ? {
        tierName: 'pro',
        unlimitedChat: true,
        monthlyMessageAllowance: 1000,
        aiProvidersAccess: ['openai', 'anthropic', 'azure'],
        monthlyAiCredits: 100,
        maxProjects: 10,
        fullCodebaseContext: true,
        gitIntegration: true,
        aiCodeReviewsPerMonth: 50,
        teamFeaturesEnabled: false,
        sharedWorkspaces: false,
        ssoEnabled: false,
        auditLogs: false,
        supportLevel: 'email'
      } : {
        tierName: 'freemium',
        unlimitedChat: false,
        monthlyMessageAllowance: 10,
        aiProvidersAccess: ['basic'],
        monthlyAiCredits: 0,
        maxProjects: 1,
        fullCodebaseContext: false,
        gitIntegration: false,
        aiCodeReviewsPerMonth: 0,
        teamFeaturesEnabled: false,
        sharedWorkspaces: false,
        ssoEnabled: false,
        auditLogs: false,
        supportLevel: 'community'
      };

      await db.insert(subscriptionFeatures).values(defaultFeatures).onConflictDoNothing();
      
      throw new Error(`No features defined for tier: ${effectiveTier}. Default features created.`);
    }

    // Get current credits balance
    let creditsBalance = user.ai_credits_balance || 0;
    let teamInfo = undefined;

    // If user is part of a team, get team details
    if (user.teamId) {
      const [team] = await db.select().from(teams).where(eq(teams.id, user.teamId));
      if (team) {
        creditsBalance = team.pooledAiCredits || 0;
        teamInfo = {
          id: team.id,
          name: team.name,
          role: user.teamRole || 'member',
          members: team.currentMembers || 1,
          maxMembers: team.maxMembers || 3,
        };
      }
    }

    // Handle special grandfathered user benefits
    if (user.is_grandfathered && user.grandfathered_from_tier) {
      // Grandfathered users get enhanced credit benefits
      // Based on migration logic, they received bonus credits during migration
      // and maintain Pro tier features at their original pricing
      
      // Ensure grandfathered users have minimum credit balance for Pro features
      // This is a safety net to ensure they can use Pro features even if credits run low
      const minGrandfatheredCredits = 50; // Minimum credits for grandfathered users
      if (creditsBalance < minGrandfatheredCredits && !user.teamId) {
        creditsBalance = Math.max(creditsBalance, minGrandfatheredCredits);
      }
    }

    // Calculate AI code reviews used this month
    const aiCodeReviewsUsed = await getMonthlyUsage(userId, 'code_review');

    // Calculate messages remaining for freemium users
    const monthlyMessageAllowance = features.monthlyMessageAllowance || 0;
    const messagesUsed = user.messages_used_this_month || 0;
    const messagesRemaining = Math.max(0, monthlyMessageAllowance - messagesUsed);

    // Determine access - grandfathered users always have access
    const hasAccess = user.is_grandfathered || 
                     ['active', 'trialing', 'freemium'].includes(user.subscriptionStatus || 'freemium');

    return {
      hasAccess,
      tier,
      status: user.subscriptionStatus || 'freemium',
      features: {
        unlimitedChat: features.unlimitedChat || false,
        monthlyMessageAllowance,
        messagesUsedThisMonth: messagesUsed,
        messagesRemaining,
        aiProvidersAccess: Array.isArray(features.aiProvidersAccess) ? features.aiProvidersAccess : ['basic'],
          monthlyAiCredits: features.monthlyAiCredits || 0,
        currentCreditsBalance: creditsBalance,
        maxProjects: features.maxProjects || 1,
        fullCodebaseContext: features.fullCodebaseContext || false,
        gitIntegration: features.gitIntegration || false,
        aiCodeReviewsPerMonth: features.aiCodeReviewsPerMonth || 0,
        aiCodeReviewsUsed,
        teamFeaturesEnabled: features.teamFeaturesEnabled || false,
        sharedWorkspaces: features.sharedWorkspaces || false,
        ssoEnabled: features.ssoEnabled || false,
        auditLogs: features.auditLogs || false,
        supportLevel: features.supportLevel || 'community',
      },
      team: teamInfo,
      isGrandfathered: user.is_grandfathered || false,
      grandfatheredFrom: user.grandfathered_from_tier || undefined,
    };
  } catch (error) {
    console.error('Error getting subscription details:', error);
    throw error;
  }
}

/**
 * Middleware to require active subscription for access
 */
export function requireActiveSubscription(options: {
  allowTrial?: boolean;
  requiredTier?: 'freemium' | 'pro' | 'team' | 'enterprise';
  customMessage?: string;
} = {}) {
  const { allowTrial = true, requiredTier, customMessage } = options;

  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      // First check if user is authenticated
      if (!req.user || !req.user.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
          redirectTo: '/login'
        });
      }

      // Check subscription access
      const accessCheck = await checkSubscriptionAccess(req.user.id);

      if (!accessCheck.hasAccess) {
        const responses: Record<string, any> = {
          no_subscription: {
            status: 402,
            error: customMessage || 'Subscription required to access this feature',
            code: 'SUBSCRIPTION_REQUIRED',
            redirectTo: '/subscribe',
            reason: 'no_subscription'
          },
          expired: {
            status: 402,
            error: customMessage || 'Your subscription has expired',
            code: 'SUBSCRIPTION_EXPIRED',
            redirectTo: '/subscribe',
            reason: 'expired'
          },
          payment_failed: {
            status: 402,
            error: customMessage || 'Please update your payment method',
            code: 'PAYMENT_FAILED',
            redirectTo: '/billing',
            reason: 'payment_failed'
          }
        };

        const response = responses[accessCheck.reason as string] || responses.no_subscription;
        return res.status(response.status).json(response);
      }

      // Check if trial access is allowed
      if (accessCheck.reason === 'trial_period' && !allowTrial) {
        return res.status(402).json({
          error: customMessage || 'This feature requires a paid subscription',
          code: 'PAID_SUBSCRIPTION_REQUIRED',
          redirectTo: '/subscribe',
          reason: 'trial_not_allowed'
        });
      }

      // Check tier requirements
      if (requiredTier) {
        // Canonical mapping with legacy aliases for backward compatibility
        const tierHierarchy: Record<string, number> = {
          freemium: 0,
          pro: 2,
          team: 3,
          enterprise: 4,
          // legacy aliases
          basic: 0,
          premium: 2,
          friends_family: 2,
          nomadai_pro: 2,
          'nomadai pro': 2,
        };

        const userTierLevel = tierHierarchy[(accessCheck.tier || '').toLowerCase()] || 0;
        const requiredTierLevel = tierHierarchy[requiredTier.toLowerCase()] || 0;

        if (userTierLevel < requiredTierLevel) {
          return res.status(402).json({
            error: customMessage || `This feature requires a ${requiredTier} subscription`,
            code: 'TIER_UPGRADE_REQUIRED',
            redirectTo: '/subscribe',
            reason: 'tier_insufficient',
            currentTier: accessCheck.tier,
            requiredTier
          });
        }
      }

      // Access granted - attach subscription info to request
      req.user = {
        ...req.user,
        subscriptionStatus: accessCheck.reason,
        subscriptionTier: accessCheck.tier,
      };

      next();
    } catch (error) {
      console.error('Subscription middleware error:', error);
      res.status(500).json({
        error: 'Unable to verify subscription status',
        code: 'SUBSCRIPTION_CHECK_FAILED'
      });
    }
  };
}

/**
 * Middleware for features that have different behavior based on subscription
 * (e.g., rate limiting, feature access)
 */
export function enhanceWithSubscription() {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.id) {
      return next(); // Continue without subscription info if not authenticated
    }

    try {
      const accessCheck = await checkSubscriptionAccess(req.user.id);
      
      // Attach subscription info to request for use in route handlers
      req.user = {
        ...req.user,
        subscriptionStatus: accessCheck.hasAccess ? accessCheck.reason : 'none',
        subscriptionTier: accessCheck.tier || 'freemium',
      };
      
      next();
    } catch (error) {
      console.error('Subscription enhancement error:', error);
      // Continue without subscription info rather than failing the request
      next();
    }
  };
}

/**
 * Middleware to check freemium message allowance with atomic increment
 */
export function checkFreemiumLimit() {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      // BYOK exemption: if user supplies their own API key for non-LMStudio providers, skip freemium gating
      if (isBYOKNonLmstudio(req)) {
        return next();
      }

      // Use database transaction to atomically check and increment
      const result = await db.transaction(async (tx) => {
        // First, check and perform monthly reset if needed
        await checkAndPerformMonthlyReset(req.user.id);

        // Get fresh subscription details after potential reset
        const subscriptionDetails = await getEnhancedSubscriptionDetails(req.user.id);
        
        // Check for freemium users
        if (subscriptionDetails.tier === 'freemium') {
          const { messagesRemaining, currentCreditsBalance } = subscriptionDetails.features;

          console.log(`üîç Freemium limit check for user ${req.user.id}:`, {
            messagesRemaining,
            currentCreditsBalance,
            messagesUsed: subscriptionDetails.features.messagesUsedThisMonth,
            monthlyAllowance: subscriptionDetails.features.monthlyMessageAllowance
          });

          // If free messages remain, consume one and mark flag to skip credit deduction for this request
          if (messagesRemaining > 0) {
            console.log(`‚úÖ Using free message for user ${req.user.id} (${messagesRemaining} remaining)`);
            
            // Atomically increment message usage
            await tx.update(users)
              .set({
                messages_used_this_month: sql`${users.messages_used_this_month} + 1`,
                updatedAt: new Date(),
              })
              .where(eq(users.id, req.user.id));

            // Signal downstream middleware to skip credit checks for this request
            req.user.freeMessageUsed = true;

            return { success: true };
          }

          // If no free messages remain, check if user has purchased AI credits
          if (currentCreditsBalance > 0) {
            console.log(`üí≥ Free messages exhausted for user ${req.user.id}, using AI credits (${currentCreditsBalance} available)`);
            // Allow the request to continue to requireCredits() middleware which will deduct credits
            // DO NOT set freeMessageUsed flag - we want credits to be deducted
            return { success: true };
          }

          // No free messages and no credits - block the request
          console.log(`üö´ Blocking user ${req.user.id}: no free messages (${messagesRemaining}) and no credits (${currentCreditsBalance})`);
          return {
            success: false,
            error: {
              error: 'Monthly message limit reached',
              code: 'MESSAGE_LIMIT_EXCEEDED',
              messagesUsed: subscriptionDetails.features.messagesUsedThisMonth,
              monthlyAllowance: subscriptionDetails.features.monthlyMessageAllowance,
              currentCreditsBalance: currentCreditsBalance,
              upgradeUrl: '/pricing',
              purchaseCreditsUrl: '/settings/billing/credits',
              message: 'You have used all your free messages this month. Upgrade to Pro or purchase AI Credits to continue.',
            }
          };
        }

        // For paid tiers, check if they have credits
        if (subscriptionDetails.tier !== 'freemium' && subscriptionDetails.features.currentCreditsBalance <= 0) {
          console.log(`üö´ Paid tier user ${req.user.id} has no credits: ${subscriptionDetails.features.currentCreditsBalance}`);
          return {
            success: false,
            error: {
              error: 'No AI credits available',
              code: 'NO_CREDITS_AVAILABLE',
              currentBalance: subscriptionDetails.features.currentCreditsBalance,
              purchaseUrl: '/settings/billing/credits',
              message: 'Purchase AI Credits to continue using the service.',
            }
          };
        }

        return { success: true };
      });

      if (!result.success) {
        return res.status(402).json(result.error);
      }

      next();
    } catch (error) {
      console.error('Freemium limit check error:', error);
      res.status(500).json({
        error: 'Unable to verify message allowance',
        code: 'LIMIT_CHECK_FAILED',
      });
    }
  };
}

/**
 * Middleware to check for specific feature access
 */
export function requireFeature(featureName: keyof EnhancedSubscriptionCheck['features']) {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      const subscriptionDetails = await getEnhancedSubscriptionDetails(req.user.id);

      // Check if user has access to the feature
      const featureValue = subscriptionDetails.features[featureName];
      
      // Handle boolean features
      if (typeof featureValue === 'boolean' && !featureValue) {
        return res.status(403).json({
          error: `This feature requires a higher subscription tier`,
          code: 'FEATURE_NOT_AVAILABLE',
          feature: featureName,
          currentTier: subscriptionDetails.tier,
          upgradeUrl: '/pricing',
        });
      }

      // Handle numeric limits (e.g., maxProjects)
      if (typeof featureValue === 'number' && featureValue === 0) {
        return res.status(403).json({
          error: `You have reached the limit for this feature`,
          code: 'FEATURE_LIMIT_REACHED',
          feature: featureName,
          limit: featureValue,
          currentTier: subscriptionDetails.tier,
          upgradeUrl: '/pricing',
        });
      }

      // Attach subscription details to request
      req.user.subscription = subscriptionDetails;
      next();

    } catch (error) {
      console.error('Feature check error:', error);
      res.status(500).json({
        error: 'Unable to verify feature access',
        code: 'FEATURE_CHECK_FAILED',
      });
    }
  };
}

/**
 * Middleware to check minimum credit threshold (does not pre-allocate credits)
 * Credits will be deducted after AI response based on actual token usage
 */
export function requireMinimumCredits(minimumCredits: number = 10, operationType: string = 'chat') {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      // BYOK exemption
      if (isBYOKNonLmstudio(req)) {
        return next();
      }

      // If a free message was consumed upstream (freemium), skip credit check for this request
      if (req.user.freeMessageUsed) {
        console.log(`‚è≠Ô∏è Skipping credit check for user ${req.user.id} - free message was used`);
        return next();
      }

      console.log(`üí≥ Checking minimum credits for user ${req.user.id}: ${minimumCredits} minimum required for ${operationType}`);
      const creditCheck = await checkCreditBalance(req.user.id, minimumCredits);

      if (!creditCheck.hasCredits) {
        console.log(`üö´ Insufficient credits for user ${req.user.id}: has ${creditCheck.currentBalance}, needs minimum ${minimumCredits}`);
        return res.status(402).json({
          error: 'Insufficient AI credits',
          code: 'INSUFFICIENT_CREDITS',
          creditsRequired: minimumCredits,
          currentBalance: creditCheck.currentBalance,
          isTeamPooled: creditCheck.isTeamPooled,
          purchaseUrl: '/settings/billing/credits',
          message: `You need at least ${minimumCredits} AI credits to start this operation. You currently have ${creditCheck.currentBalance} credits.`,
        });
      }

      console.log(`‚úÖ Minimum credit check passed for user ${req.user.id}: has ${creditCheck.currentBalance}, minimum ${minimumCredits} required for ${operationType}`);

      // Mark that this user will need credit deduction after the operation
      req.user.needsCreditDeduction = {
        operationType,
        currentBalance: creditCheck.currentBalance,
        isTeamPooled: creditCheck.isTeamPooled,
      };

      next();

    } catch (error) {
      console.error('Credit check error:', error);
      res.status(500).json({
        error: 'Unable to verify credit balance',
        code: 'CREDIT_CHECK_FAILED',
      });
    }
  };
}

/**
 * Dynamic middleware to check minimum credit threshold based on message analysis
 * Credits will be deducted after AI response based on actual token usage
 */
export function requireDynamicCredits(estimateFunction: (req: any) => number, operationType: string = 'chat') {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      // BYOK exemption
      if (isBYOKNonLmstudio(req)) {
        return next();
      }

      // If a free message was consumed upstream (freemium), skip credit check for this request
      if (req.user.freeMessageUsed) {
        console.log(`‚è≠Ô∏è Skipping credit check for user ${req.user.id} - free message was used`);
        return next();
      }

      // Calculate dynamic minimum based on message analysis
      const minimumCredits = estimateFunction(req);
      
      console.log(`üí≥ Checking dynamic credits for user ${req.user.id}: ${minimumCredits} minimum required for ${operationType}`);
      const creditCheck = await checkCreditBalance(req.user.id, minimumCredits);

      if (!creditCheck.hasCredits) {
        console.log(`üö´ Insufficient credits for user ${req.user.id}: has ${creditCheck.currentBalance}, needs minimum ${minimumCredits}`);
        return res.status(402).json({
          error: 'Insufficient AI credits',
          code: 'INSUFFICIENT_CREDITS',
          creditsRequired: minimumCredits,
          currentBalance: creditCheck.currentBalance,
          isTeamPooled: creditCheck.isTeamPooled,
          purchaseUrl: '/settings/billing/credits',
          message: `You need at least ${minimumCredits} AI credits to start this operation. You currently have ${creditCheck.currentBalance} credits.`,
        });
      }

      console.log(`‚úÖ Dynamic credit check passed for user ${req.user.id}: has ${creditCheck.currentBalance}, minimum ${minimumCredits} required for ${operationType}`);

      // Mark that this user will need credit deduction after the operation
      req.user.needsCreditDeduction = {
        operationType,
        currentBalance: creditCheck.currentBalance,
        isTeamPooled: creditCheck.isTeamPooled,
      };

      next();

    } catch (error) {
      console.error('Dynamic credit check error:', error);
      res.status(500).json({
        error: 'Unable to verify credit balance',
        code: 'CREDIT_CHECK_FAILED',
      });
    }
  };
}

/**
 * Legacy middleware for backward compatibility - now just checks minimum credits
 * @deprecated Use requireMinimumCredits instead
 */
export function requireCredits(creditsRequired: number, operationType: string) {
  return requireMinimumCredits(creditsRequired, operationType);
}

/**
 * Middleware to check team permissions
 */
export function requireTeamRole(allowedRoles: Array<'owner' | 'admin' | 'member'>) {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      const [user] = await db.select().from(users).where(eq(users.id, req.user.id));

      if (!user.teamId) {
        return res.status(403).json({
          error: 'This feature requires team membership',
          code: 'TEAM_REQUIRED',
        });
      }

      const userRole = user.teamRole || 'member';
      
      if (!allowedRoles.includes(userRole as any)) {
        return res.status(403).json({
          error: 'Insufficient team permissions',
          code: 'INSUFFICIENT_TEAM_PERMISSIONS',
          requiredRoles: allowedRoles,
          currentRole: userRole,
        });
      }

      req.user.teamId = user.teamId;
      req.user.teamRole = userRole;
      next();

    } catch (error) {
      console.error('Team role check error:', error);
      res.status(500).json({
        error: 'Unable to verify team permissions',
        code: 'TEAM_CHECK_FAILED',
      });
    }
  };
}

/**
 * Check if user has access to a specific AI provider
 */
export function requireAIProvider(provider: string) {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NOT_AUTHENTICATED',
        });
      }

      const subscriptionDetails = await getEnhancedSubscriptionDetails(req.user.id);
      const allowedProviders = subscriptionDetails.features.aiProvidersAccess;

      if (!allowedProviders.includes(provider) && !allowedProviders.includes('all')) {
        return res.status(403).json({
          error: `Access to ${provider} requires a higher subscription tier`,
          code: 'AI_PROVIDER_NOT_AVAILABLE',
          provider,
          allowedProviders,
          currentTier: subscriptionDetails.tier,
          upgradeUrl: '/pricing',
        });
      }

      next();

    } catch (error) {
      console.error('AI provider check error:', error);
      res.status(500).json({
        error: 'Unable to verify AI provider access',
        code: 'PROVIDER_CHECK_FAILED',
      });
    }
  };
}

/**
 * Rate limiting based on subscription tier
 */
export function tierBasedRateLimit() {
  const limits: Record<string, { requests: number; windowMs: number }> = {
    freemium: { requests: 10, windowMs: 60 * 1000 },
    pro: { requests: 60, windowMs: 60 * 1000 },
    team: { requests: 120, windowMs: 60 * 1000 },
    enterprise: { requests: 999999, windowMs: 60 * 1000 },
  };

  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    // Allow unauthenticated through without tier-based limits (can add a public IP limiter separately)
    if (!req.user?.id) {
      return next();
    }

    try {
      // Provider-aware skipping: only rate-limit LMStudio (Uterpi) requests
      const providerRaw = (req.body?.provider || req.query?.provider || '').toString().toLowerCase();
      if (providerRaw && providerRaw !== 'lmstudio') {
        return next();
      }

      const [user] = await db.select().from(users).where(eq(users.id, req.user.id));
      const tier = user?.subscriptionTier || 'freemium';
      const limit = limits[tier] || limits.freemium;

      const route = req.path;
      // Include provider in key to isolate limits (even if currently only lmstudio is limited)
      const provider = providerRaw || 'lmstudio';
      const principalKey = `user:${req.user.id}:provider:${provider}`;
      const now = new Date();
      const windowStart = new Date(Math.floor(now.getTime() / limit.windowMs) * limit.windowMs);
      const windowEnd = new Date(windowStart.getTime() + limit.windowMs);

      // Upsert row and increment count atomically
      const result = await db.transaction(async (tx) => {
        // Try update existing row
        const updated = await tx.execute(sql`
          UPDATE ${rateLimits}
          SET ${rateLimits.count} = ${rateLimits.count} + 1, ${rateLimits.updatedAt} = now()
          WHERE ${rateLimits.key} = ${principalKey}
            AND ${rateLimits.route} = ${route}
            AND ${rateLimits.windowStart} = ${windowStart}
          RETURNING ${rateLimits.count}
        ` as any);

        if ((updated as any)?.rows?.length) {
          return Number((updated as any).rows[0].count) || 1;
        }

        // Insert new window row; on conflict, increment safely
        const inserted = await tx.execute(sql`
          INSERT INTO rate_limits (key, route, window_start, window_end, window_ms, count)
          VALUES (${principalKey}, ${route}, ${windowStart}, ${windowEnd}, ${limit.windowMs}, 1)
          ON CONFLICT (key, route, window_start)
          DO UPDATE SET count = rate_limits.count + 1, updated_at = now()
          RETURNING count
        `);
        return Number((inserted as any).rows[0].count) || 1;
      });

      const used = result;
      const remaining = Math.max(0, limit.requests - used);
      const resetMs = windowEnd.getTime() - now.getTime();
      const retryAfter = remaining > 0 ? 0 : Math.ceil(resetMs / 1000);

      // Standard headers
      res.setHeader('X-RateLimit-Limit', String(limit.requests));
      res.setHeader('X-RateLimit-Remaining', String(remaining));
      res.setHeader('X-RateLimit-Reset', String(Math.floor(windowEnd.getTime() / 1000)));
      if (retryAfter > 0) {
        res.setHeader('Retry-After', String(retryAfter));
      }

      if (used > limit.requests) {
        return res.status(429).json({
          error: 'Rate limit exceeded',
          code: 'RATE_LIMIT_EXCEEDED',
          tier,
          limit: limit.requests,
          window: Math.floor(limit.windowMs / 1000),
          retryAfter,
        });
      }

      next();
    } catch (error) {
      console.error('Rate limit check error:', error);
      // Fail-open to avoid breaking requests due to DB hiccups
      next();
    }
  };
}

/**
 * Grant admin override for a user
 */
export async function grantAccessOverride(
  userId: number, 
  grantedBy: number, 
  reason: string, 
  expiresAt?: Date
): Promise<void> {
  try {
    await db.update(users)
      .set({
        accessOverride: true,
        overrideReason: reason,
        overrideGrantedBy: grantedBy,
        overrideGrantedAt: new Date(),
        overrideExpiresAt: expiresAt || null,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
  } catch (error) {
    console.error('Error granting access override:', error);
    throw new Error('Failed to grant access override');
  }
}

/**
 * Remove admin override for a user
 */
export async function removeAccessOverride(userId: number): Promise<void> {
  try {
    await db.update(users)
      .set({
        accessOverride: false,
        overrideReason: null,
        overrideGrantedBy: null,
        overrideGrantedAt: null,
        overrideExpiresAt: null,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
  } catch (error) {
    console.error('Error removing access override:', error);
    throw new Error('Failed to remove access override');
  }
}

/**
 * Scheduled task to reset monthly message counters (should be run via cron)
 */
export async function resetMonthlyMessageCounters(): Promise<void> {
  try {
    const startOfCurrentMonth = new Date();
    startOfCurrentMonth.setDate(1);
    startOfCurrentMonth.setHours(0, 0, 0, 0);

    // Reset all users whose reset date is before the current month
    const result = await db.update(users)
      .set({
        messages_used_this_month: 0,
        messages_reset_at: startOfCurrentMonth,
        updatedAt: new Date()
      })
      .where(
        sql`${users.messages_reset_at} < ${startOfCurrentMonth} OR ${users.messages_reset_at} IS NULL`
      );

    console.log(`Monthly reset completed. Updated users: ${result.rowCount}`);
  } catch (error) {
    console.error('Error during monthly reset:', error);
    throw error;
  }
}

================
File: server/subscription-routes.ts
================
/**
 * API Routes for Enhanced Subscription System
 */

import { Router } from 'express';
import type { Request, Response } from 'express';
import { requireAuth } from './auth';
import { 
  requireFeature, 
  requireCredits, 
  requireTeamRole,
  getEnhancedSubscriptionDetails 
} from './subscription-middleware';
import {
  createTeamSubscription,
  purchaseAICredits,
  updateTeamSeats,
  trackAIUsage,
  checkCreditBalance,
  CREDIT_PACKAGES,
  STRIPE_PRODUCTS
} from './stripe-enhanced';
import { db } from './db';
import { 
  users, 
  teams, 
  subscriptionPlans, 
  subscriptionFeatures,
  aiCreditsTransactions 
} from '@shared/schema';
import { eq, desc, and, gte, sql } from 'drizzle-orm';
import { grandfatherExistingUsers, verifyGrandfatherStatus } from './grandfather-users-migration';

const router = Router();

// Extend Express User interface to include team properties
declare global {
  namespace Express {
    interface User {
      teamId?: number;
      teamRole?: string;
    }
  }
}

// =============================================================================
// SUBSCRIPTION INFORMATION ENDPOINTS
// =============================================================================

/**
 * Get current subscription details with features and credits
 */
router.get('/subscription/details', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const details = await getEnhancedSubscriptionDetails(req.user.id);
    
    // Add grandfather status if applicable
    const grandfatherStatus = await verifyGrandfatherStatus(req.user.id);
    
    res.json({
      ...details,
      grandfather: grandfatherStatus,
    });
  } catch (error) {
    console.error('Error fetching subscription details:', error);
    res.status(500).json({ error: 'Failed to fetch subscription details' });
  }
});

/**
 * Get available subscription plans
 */
router.get('/subscription/plans', async (req, res) => {
  try {
    const plans = await db.select()
      .from(subscriptionPlans)
      .where(eq(subscriptionPlans.isActive, true))
      .orderBy(subscriptionPlans.sortOrder);

    // Get feature details for each plan
    const plansWithFeatures = await Promise.all(plans.map(async (plan) => {
      const tierName = plan.name.toLowerCase().replace(' ', '_');
      const [features] = await db.select()
        .from(subscriptionFeatures)
        .where(eq(subscriptionFeatures.tierName, tierName));

      return {
        ...plan,
        features: features || {},
      };
    }));

    res.json({ plans: plansWithFeatures });
  } catch (error) {
    console.error('Error fetching subscription plans:', error);
    res.status(500).json({ error: 'Failed to fetch subscription plans' });
  }
});

// =============================================================================
// AI CREDITS ENDPOINTS
// =============================================================================

/**
 * Get current AI credits balance and usage
 */
router.get('/credits/balance', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const creditCheck = await checkCreditBalance(req.user.id, 0);
    
    // Get usage history for current month
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);

    const transactions = await db.select()
      .from(aiCreditsTransactions)
      .where(
        and(
          eq(aiCreditsTransactions.userId, req.user.id!),
          gte(aiCreditsTransactions.createdAt, startOfMonth)
        )
      )
      .orderBy(desc(aiCreditsTransactions.createdAt))
      .limit(10);

    res.json({
      balance: creditCheck.currentBalance,
      isTeamPooled: creditCheck.isTeamPooled,
      recentTransactions: transactions,
    });
  } catch (error) {
    console.error('Error fetching credit balance:', error);
    res.status(500).json({ error: 'Failed to fetch credit balance' });
  }
});

/**
 * Get available credit packages for purchase
 */
router.get('/credits/packages', requireAuth, async (req: Request, res: Response) => {
  res.json({ packages: CREDIT_PACKAGES });
});

/**
 * Purchase additional AI credits
 */
router.post('/credits/purchase', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const { packageId, paymentMethodId } = req.body;
    
    const creditPackage = CREDIT_PACKAGES.find(p => p.priceId === packageId);
    if (!creditPackage) {
      return res.status(400).json({ error: 'Invalid credit package' });
    }

    const paymentIntent = await purchaseAICredits({
      userId: req.user.id,
      creditPackage,
      paymentMethodId,
    });

    res.json({
      success: true,
      paymentIntent: {
        id: paymentIntent.id,
        status: paymentIntent.status,
        amount: paymentIntent.amount,
      },
      creditsAdded: creditPackage.credits,
    });
  } catch (error) {
    console.error('Error purchasing credits:', error);
    res.status(500).json({ error: 'Failed to purchase credits' });
  }
});

/**
 * Track AI usage (called internally by AI operations)
 */
router.post('/credits/track-usage', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const { operationType, modelUsed, tokensConsumed } = req.body;

    const result = await trackAIUsage({
      userId: req.user.id,
      operationType,
      modelUsed,
      tokensConsumed: tokensConsumed || 0,
    });

    res.json(result);
  } catch (error: unknown) {
    console.error('Error tracking AI usage:', error);
    if (error instanceof Error && error.message === 'Insufficient AI credits') {
      res.status(402).json({ 
        error: 'Insufficient AI credits',
        code: 'INSUFFICIENT_CREDITS',
      });
    } else {
      res.status(500).json({ error: 'Failed to track AI usage' });
    }
  }
});

// =============================================================================
// TEAM MANAGEMENT ENDPOINTS
// =============================================================================

/**
 * Create a new team subscription
 */
router.post('/team/create', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id || !req.user?.email) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const { 
      teamName, 
      tier, 
      memberEmails, 
      paymentMethodId,
      billingEmail 
    } = req.body;

    if (!['team', 'enterprise'].includes(tier)) {
      return res.status(400).json({ error: 'Invalid team tier' });
    }

    const result = await createTeamSubscription({
      teamName,
      ownerId: req.user.id,
      tier,
      memberEmails,
      paymentMethodId,
      billingEmail: billingEmail || req.user.email,
    });

    res.json({
      success: true,
      teamId: result.teamId,
      subscription: {
        id: result.subscription.id,
        status: result.subscription.status,
      },
    });
  } catch (error: unknown) {
    console.error('Error creating team:', error);
    const message = error instanceof Error ? error.message : 'Failed to create team';
    res.status(500).json({ error: message });
  }
});

/**
 * Get team details
 */
router.get('/team/details', requireAuth, requireTeamRole(['owner', 'admin', 'member']), async (req: Request, res: Response) => {
  try {
    if (!req.user?.teamId) {
      return res.status(400).json({ error: 'No team associated with user' });
    }
    
    const [team] = await db.select()
      .from(teams)
      .where(eq(teams.id, req.user.teamId));

    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    // Get team members
    const members = await db.select({
      id: users.id,
      email: users.email,
      firstName: users.firstName,
      lastName: users.lastName,
      role: users.teamRole,
      joinedAt: users.updatedAt,
    })
      .from(users)
      .where(eq(users.teamId, team.id));

    res.json({
      team: {
        ...team,
        members,
      },
    });
  } catch (error) {
    console.error('Error fetching team details:', error);
    res.status(500).json({ error: 'Failed to fetch team details' });
  }
});

/**
 * Update team seats (add/remove members)
 */
router.post('/team/update-seats', requireAuth, requireTeamRole(['owner']), async (req: Request, res: Response) => {
  try {
    if (!req.user?.teamId) {
      return res.status(400).json({ error: 'No team associated with user' });
    }
    
    const { newSeatCount } = req.body;

    if (newSeatCount < 3) {
      return res.status(400).json({ error: 'Team plan requires minimum 3 seats' });
    }

    const subscription = await updateTeamSeats(req.user.teamId, newSeatCount);

    res.json({
      success: true,
      subscription: {
        id: subscription.id,
        status: subscription.status,
        quantity: subscription.items.data[0].quantity,
      },
    });
  } catch (error) {
    console.error('Error updating team seats:', error);
    res.status(500).json({ error: 'Failed to update team seats' });
  }
});

/**
 * Invite team member
 */
router.post('/team/invite', requireAuth, requireTeamRole(['owner', 'admin']), async (req: Request, res: Response) => {
  try {
    if (!req.user?.teamId) {
      return res.status(400).json({ error: 'No team associated with user' });
    }
    
    const { email, role = 'member' } = req.body;

    const [team] = await db.select()
      .from(teams)
      .where(eq(teams.id, req.user.teamId));

    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    if ((team.currentMembers || 0) >= (team.maxMembers || 3)) {
      return res.status(400).json({ 
        error: 'Team has reached maximum member limit',
        currentMembers: team.currentMembers || 0,
        maxMembers: team.maxMembers || 3,
      });
    }

    // TODO: Send invitation email
    // For now, just return success
    res.json({
      success: true,
      message: `Invitation sent to ${email}`,
    });
  } catch (error) {
    console.error('Error inviting team member:', error);
    res.status(500).json({ error: 'Failed to invite team member' });
  }
});

// =============================================================================
// USAGE ANALYTICS ENDPOINTS
// =============================================================================

/**
 * Get usage analytics for the current month
 */
router.get('/usage/analytics', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);

    // Get credit usage by operation type
    const usageByType = await db.select({
      operationType: aiCreditsTransactions.operationType,
      totalCredits: sql`SUM(ABS(${aiCreditsTransactions.amount}))::int`,
      count: sql`COUNT(*)::int`,
    })
      .from(aiCreditsTransactions)
      .where(
        and(
          eq(aiCreditsTransactions.userId, req.user.id),
          eq(aiCreditsTransactions.transactionType, 'usage'),
          gte(aiCreditsTransactions.createdAt, startOfMonth)
        )
      )
      .groupBy(aiCreditsTransactions.operationType);

    // Get daily usage trend
    const dailyUsage = await db.select({
      date: sql`DATE(${aiCreditsTransactions.createdAt})`,
      credits: sql`SUM(ABS(${aiCreditsTransactions.amount}))::int`,
    })
      .from(aiCreditsTransactions)
      .where(
        and(
          eq(aiCreditsTransactions.userId, req.user.id),
          eq(aiCreditsTransactions.transactionType, 'usage'),
          gte(aiCreditsTransactions.createdAt, startOfMonth)
        )
      )
      .groupBy(sql`DATE(${aiCreditsTransactions.createdAt})`)
      .orderBy(sql`DATE(${aiCreditsTransactions.createdAt})`);

    res.json({
      usageByType,
      dailyUsage,
      period: {
        start: startOfMonth.toISOString(),
        end: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error('Error fetching usage analytics:', error);
    res.status(500).json({ error: 'Failed to fetch usage analytics' });
  }
});

// =============================================================================
// ADMIN ENDPOINTS
// =============================================================================

/**
 * Run grandfather migration (admin only)
 */
router.post('/admin/grandfather-migration', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    // Check if user is admin (you should implement proper admin check)
    const [user] = await db.select().from(users).where(eq(users.id, req.user.id));
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // For now, check if user email is admin email
    const adminEmails = process.env.ADMIN_EMAILS?.split(',') || [];
    if (!adminEmails.includes(user.email)) {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const result = await grandfatherExistingUsers();
    
    res.json(result);
  } catch (error) {
    console.error('Error running grandfather migration:', error);
    res.status(500).json({ error: 'Failed to run migration' });
  }
});

export default router;

================
File: server/test-vectorization.ts
================
import { conversationService } from './conversation-service';
import { vectorService } from './vector-service';
import { vectorProcessor } from './vector-processor';
import { contextEnhancer } from './context-enhancer';

/**
 * Comprehensive test suite for the chat vectorization system
 * Tests all components with different AI providers
 */

interface TestResult {
  component: string;
  test: string;
  success: boolean;
  error?: string;
  data?: any;
}

class VectorizationTester {
  private results: TestResult[] = [];
  private testUserId = 1; // Use test user ID

  /**
   * Run all vectorization tests
   */
  async runAllTests(): Promise<TestResult[]> {
    console.log('üß™ Starting comprehensive vectorization system tests...\n');

    // Test each component
    await this.testConversationService();
    await this.testVectorService();
    await this.testVectorProcessor();
    await this.testContextEnhancer();
    await this.testProviderCompatibility();

    // Print summary
    this.printTestSummary();
    
    return this.results;
  }

  /**
   * Test conversation service functionality
   */
  private async testConversationService(): Promise<void> {
    console.log('üìù Testing Conversation Service...');

    try {
      // Test conversation creation
      const conversation = await conversationService.createConversation({
        userId: this.testUserId,
        provider: 'uterpi',
        model: 'nomadic-icdu-v8',
        title: 'Test Conversation'
      });

      this.addResult('ConversationService', 'Create Conversation', true, undefined, {
        conversationId: conversation.id,
        provider: conversation.provider,
        model: conversation.model
      });

      // Test message addition
      const userMessage = await conversationService.addMessage({
        conversationId: conversation.id,
        content: 'Hello, this is a test message about machine learning and AI.',
        role: 'user'
      });

      this.addResult('ConversationService', 'Add User Message', true, undefined, {
        messageId: userMessage.id,
        messageIndex: userMessage.messageIndex
      });

      const aiMessage = await conversationService.addMessage({
        conversationId: conversation.id,
        content: 'Hello! I can help you with machine learning and AI topics. What specific area would you like to explore?',
        role: 'assistant',
        metadata: {
          model: 'nomadic-icdu-v8',
          provider: 'uterpi',
          tokensUsed: 45
        }
      });

      this.addResult('ConversationService', 'Add AI Message', true, undefined, {
        messageId: aiMessage.id,
        messageIndex: aiMessage.messageIndex
      });

      // Test conversation retrieval
      const messages = await conversationService.getConversationMessages(conversation.id);
      this.addResult('ConversationService', 'Get Messages', messages.length === 2, 
        messages.length !== 2 ? `Expected 2 messages, got ${messages.length}` : undefined,
        { messageCount: messages.length }
      );

      // Test title generation
      const title = await conversationService.generateConversationTitle(conversation.id);
      this.addResult('ConversationService', 'Generate Title', title.length > 0, 
        title.length === 0 ? 'Title generation failed' : undefined,
        { title }
      );

    } catch (error) {
      this.addResult('ConversationService', 'Overall Test', false, error?.toString());
    }
  }

  /**
   * Test vector service functionality
   */
  private async testVectorService(): Promise<void> {
    console.log('üî§ Testing Vector Service...');

    try {
      // Test local embedding generation (Transformers.js with hash fallback)
      const testText = 'This is a test about artificial intelligence and machine learning algorithms.';
      const embeddingResult = await vectorService.generateEmbedding(testText);
      this.addResult('VectorService', 'Generate Local Embedding', true, undefined, {
        model: embeddingResult.model,
        dimensions: embeddingResult.dimensions,
        embeddingLength: embeddingResult.embedding.length
      });

      // Test conversation summary generation
      const conversation = await conversationService.createConversation({
        userId: this.testUserId,
        provider: 'test',
        model: 'test-model'
      });

      await conversationService.addMessage({
        conversationId: conversation.id,
        content: 'What is machine learning?',
        role: 'user'
      });

      await conversationService.addMessage({
        conversationId: conversation.id,
        content: 'Machine learning is a subset of artificial intelligence that focuses on algorithms that can learn from data.',
        role: 'assistant'
      });

      const summary = await vectorService.generateConversationSummary(conversation.id);
      this.addResult('VectorService', 'Generate Conversation Summary', summary.length > 0,
        summary.length === 0 ? 'Summary generation failed' : undefined,
        { summaryLength: summary.length, summary: summary.substring(0, 100) + '...' }
      );

    } catch (error) {
      this.addResult('VectorService', 'Overall Test', false, error?.toString());
    }
  }

  /**
   * Test vector processor functionality
   */
  private async testVectorProcessor(): Promise<void> {
    console.log('‚öôÔ∏è Testing Vector Processor...');

    try {
      // Get processor status
      const status = vectorProcessor.getQueueStatus();
      this.addResult('VectorProcessor', 'Get Queue Status', true, undefined, {
        messageQueue: status.messageQueue,
        conversationQueue: status.conversationQueue,
        isProcessing: status.isProcessing
      });

      // Test queueing (without actual processing to avoid external dependencies)
      const conversation = await conversationService.createConversation({
        userId: this.testUserId,
        provider: 'test',
        model: 'test-model'
      });

      const message = await conversationService.addMessage({
        conversationId: conversation.id,
        content: 'Test message for vectorization queue',
        role: 'user'
      });

      // Queue message for vectorization
      await vectorProcessor.queueMessageVectorization(message.id, conversation.id, 'high');
      
      const newStatus = vectorProcessor.getQueueStatus();
      this.addResult('VectorProcessor', 'Queue Message', newStatus.messageQueue > status.messageQueue,
        newStatus.messageQueue <= status.messageQueue ? 'Message was not queued' : undefined,
        { queueSize: newStatus.messageQueue }
      );

      // Clear queue for clean test environment
      vectorProcessor.clearQueues();
      
      const clearedStatus = vectorProcessor.getQueueStatus();
      this.addResult('VectorProcessor', 'Clear Queues', clearedStatus.totalPending === 0,
        clearedStatus.totalPending > 0 ? 'Queues were not cleared' : undefined,
        { totalPending: clearedStatus.totalPending }
      );

    } catch (error) {
      this.addResult('VectorProcessor', 'Overall Test', false, error?.toString());
    }
  }

  /**
   * Test context enhancer functionality
   */
  private async testContextEnhancer(): Promise<void> {
    console.log('üß† Testing Context Enhancer...');

    try {
      // Test basic context enhancement (without actual similar messages)
      const testMessages = [
        { role: 'user' as const, content: 'Tell me about neural networks' },
        { role: 'assistant' as const, content: 'Neural networks are computational models inspired by biological neural networks.' },
        { role: 'user' as const, content: 'How do they learn?' }
      ];

      const contextOptions = {
        maxSimilarMessages: 2,
        maxSimilarConversations: 1,
        similarityThreshold: 0.8,
        includeConversationContext: true,
        includeMessageContext: true,
        maxContextLength: 1000
      };

      const enhancedContext = await contextEnhancer.enhanceMessagesWithContext(
        testMessages,
        this.testUserId,
        contextOptions
      );

      this.addResult('ContextEnhancer', 'Enhance Messages', enhancedContext.enhancedMessages.length > 0,
        enhancedContext.enhancedMessages.length === 0 ? 'No enhanced messages generated' : undefined,
        {
          originalMessageCount: testMessages.length,
          enhancedMessageCount: enhancedContext.enhancedMessages.length,
          similarMessagesFound: enhancedContext.similarMessages.length,
          similarConversationsFound: enhancedContext.similarConversations.length,
          contextLength: enhancedContext.contextualSystemMessage.length
        }
      );

      // Test context quality analysis
      const qualityAnalysis = await contextEnhancer.analyzeContextQuality(enhancedContext);
      this.addResult('ContextEnhancer', 'Analyze Context Quality', true, undefined, {
        hasRelevantContext: qualityAnalysis.hasRelevantContext,
        averageSimilarity: qualityAnalysis.averageSimilarity,
        contextLength: qualityAnalysis.contextLength
      });

    } catch (error) {
      this.addResult('ContextEnhancer', 'Overall Test', false, error?.toString());
    }
  }

  /**
   * Test compatibility with different AI providers
   */
  private async testProviderCompatibility(): Promise<void> {
    console.log('ü§ñ Testing AI Provider Compatibility...');

    const providers = [
      { name: 'uterpi', model: 'nomadic-icdu-v8' },
      { name: 'lmstudio', model: 'nomadic-icdu-v8' },
      { name: 'openai', model: 'gpt-4o-mini' },
      { name: 'gemini', model: 'gemini-2.5-flash' },
      { name: 'azure', model: 'ministral-3b' }
    ];

    for (const provider of providers) {
      try {
        // Test conversation creation for each provider
        const conversation = await conversationService.createConversation({
          userId: this.testUserId,
          provider: provider.name,
          model: provider.model,
          title: `Test ${provider.name} Conversation`
        });

        this.addResult('ProviderCompatibility', `Create ${provider.name} Conversation`, true, undefined, {
          provider: provider.name,
          model: provider.model,
          conversationId: conversation.id
        });

        // Test message storage
        const message = await conversationService.addMessage({
          conversationId: conversation.id,
          content: `Test message for ${provider.name} provider`,
          role: 'user'
        });

        this.addResult('ProviderCompatibility', `Store ${provider.name} Message`, true, undefined, {
          provider: provider.name,
          messageId: message.id
        });

      } catch (error) {
        this.addResult('ProviderCompatibility', `Test ${provider.name}`, false, error?.toString());
      }
    }
  }

  /**
   * Add test result
   */
  private addResult(component: string, test: string, success: boolean, error?: string, data?: any): void {
    this.results.push({ component, test, success, error, data });
    
    const status = success ? '‚úÖ' : '‚ùå';
    const errorMsg = error ? ` - ${error}` : '';
    console.log(`  ${status} ${test}${errorMsg}`);
    
    if (data && success) {
      console.log(`    Data:`, JSON.stringify(data, null, 2));
    }
  }

  /**
   * Print test summary
   */
  private printTestSummary(): void {
    const totalTests = this.results.length;
    const passedTests = this.results.filter(r => r.success).length;
    const failedTests = totalTests - passedTests;

    console.log('\nüìä VECTORIZATION SYSTEM TEST SUMMARY');
    console.log('=====================================');
    console.log(`Total Tests: ${totalTests}`);
    console.log(`‚úÖ Passed: ${passedTests}`);
    console.log(`‚ùå Failed: ${failedTests}`);
    console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

    if (failedTests > 0) {
      console.log('\n‚ùå FAILED TESTS:');
      this.results
        .filter(r => !r.success)
        .forEach(r => console.log(`  - ${r.component}: ${r.test} - ${r.error}`));
    }

    console.log('\nüéØ SYSTEM STATUS:');
    if (passedTests >= totalTests * 0.8) {
      console.log('‚úÖ Vectorization system is ready for production!');
    } else {
      console.log('‚ö†Ô∏è Vectorization system needs attention before production use.');
    }
  }
}

// Export test function for manual execution
export async function testVectorizationSystem(): Promise<TestResult[]> {
  const tester = new VectorizationTester();
  return await tester.runAllTests();
}

// For direct execution
if (require.main === module) {
  testVectorizationSystem()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Test execution failed:', error);
      process.exit(1);
    });
}

================
File: server/vector-flags.ts
================
/**
 * Centralized feature flag for vectorization.
 *
 * Disable vectorization by setting any of these env vars:
 * - VECTORIZATION_DISABLED=true
 * - DISABLE_VECTORIZATION=true
 * - VECTORS_ENABLED=false
 * - ENABLE_VECTORIZATION=false
 *
 * Default: disabled (returns false) to fail-safe if unset.
 */
export function isVectorizationEnabled(): boolean {
  try {
    const env = process.env || {} as any;

    const disabledRaw = String(env.VECTORIZATION_DISABLED || env.DISABLE_VECTORIZATION || '').toLowerCase();
    if (disabledRaw === '1' || disabledRaw === 'true' || disabledRaw === 'yes') return false;

    const enabledRaw = String(env.VECTORS_ENABLED || env.ENABLE_VECTORIZATION || '').toLowerCase();
    if (enabledRaw === '1' || enabledRaw === 'true' || enabledRaw === 'yes') return true;
    if (enabledRaw === '0' || enabledRaw === 'false' || enabledRaw === 'no') return false;

    // Default: off unless explicitly enabled
    return false;
  } catch {
    return false;
  }
}

================
File: server/vector-processor.ts
================
import { vectorService } from "./vector-service";
import { db } from "./db";
import { files } from "@shared/schema";
import { eq } from "drizzle-orm";
import { isVectorizationEnabled } from "./vector-flags";
import { conversationService, MessageData } from "./conversation-service";

export interface VectorizationJob {
  id: string;
  messageId: number;
  conversationId: number;
  priority: 'high' | 'normal' | 'low';
  retryCount: number;
  maxRetries: number;
  createdAt: Date;
  scheduledAt?: Date;
}

export interface ConversationSummaryJob {
  id: string;
  conversationId: number;
  priority: 'high' | 'normal' | 'low';
  retryCount: number;
  maxRetries: number;
  createdAt: Date;
}

/**
 * Background processor for vectorizing messages and conversation summaries
 * Handles asynchronous embedding generation to avoid blocking chat responses
 */
export class VectorProcessor {
  private messageQueue: VectorizationJob[] = [];
  private conversationQueue: ConversationSummaryJob[] = [];
  private fileQueue: Array<{ id: string; fileId: number; userId: number; retryCount: number; maxRetries: number; createdAt: Date }>= [];
  private isProcessing = false;
  private processingInterval: NodeJS.Timeout | null = null;
  private readonly processingIntervalMs = 5000; // Process every 5 seconds
  private readonly maxRetries = 3;
  private readonly retryDelayMs = 30000; // 30 seconds between retries

  constructor() {
    if (isVectorizationEnabled()) {
      this.startProcessing();
    } else {
      console.log('‚è∏Ô∏è Vector processor disabled by feature flag');
    }
  }

  /**
   * Start the background processing loop
   */
  private startProcessing(): void {
    if (this.processingInterval) {
      return; // Already started
    }

    console.log('üîÑ Starting vector processor background loop');
    this.processingInterval = setInterval(() => {
      this.processQueues();
    }, this.processingIntervalMs);

    // Also process immediately
    this.processQueues();
  }

  /**
   * Stop the background processing loop
   */
  public stopProcessing(): void {
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
      console.log('‚èπÔ∏è Stopped vector processor background loop');
    }
  }

  /**
   * Queue message for vectorization
   */
  async queueMessageVectorization(
    messageId: number, 
    conversationId: number, 
    priority: 'high' | 'normal' | 'low' = 'normal'
  ): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    const job: VectorizationJob = {
      id: `msg_${messageId}_${Date.now()}`,
      messageId,
      conversationId,
      priority,
      retryCount: 0,
      maxRetries: this.maxRetries,
      createdAt: new Date()
    };

    this.messageQueue.push(job);
    console.log(`üì• Queued message ${messageId} for vectorization (priority: ${priority}, queue size: ${this.messageQueue.length})`);

    // Process immediately if high priority
    if (priority === 'high' && !this.isProcessing) {
      this.processQueues();
    }
  }

  /**
   * Queue multiple messages for vectorization
   */
  async queueMultipleMessages(messageIds: number[], conversationId: number): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    for (const messageId of messageIds) {
      await this.queueMessageVectorization(messageId, conversationId, 'normal');
    }
  }

  /**
   * Queue conversation summary for vectorization
   */
  async queueConversationSummary(conversationId: number, priority: 'high' | 'normal' | 'low' = 'low'): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    // Check if already queued
    const existing = this.conversationQueue.find(job => job.conversationId === conversationId);
    if (existing) {
      console.log(`‚è≠Ô∏è Conversation ${conversationId} already queued for summary vectorization`);
      return;
    }

    const job: ConversationSummaryJob = {
      id: `conv_${conversationId}_${Date.now()}`,
      conversationId,
      priority,
      retryCount: 0,
      maxRetries: this.maxRetries,
      createdAt: new Date()
    };

    this.conversationQueue.push(job);
    console.log(`üì• Queued conversation ${conversationId} for summary vectorization (priority: ${priority})`);
  }

  /**
   * Process both message and conversation queues
   */
  private async processQueues(): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    if (this.isProcessing) {
      return; // Already processing
    }

    this.isProcessing = true;

    try {
      // Process high priority items first
      await this.processMessageQueue('high');
      await this.processConversationQueue('high');
      await this.processFileQueue();
      
      // Then normal priority
      await this.processMessageQueue('normal');
      await this.processConversationQueue('normal');
      await this.processFileQueue();
      
      // Finally low priority
      await this.processMessageQueue('low');
      await this.processConversationQueue('low');
      await this.processFileQueue();

    } catch (error) {
      console.error('‚ùå Error in vector processor queue processing:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Queue file for vectorization (chunk embeddings)
   */
  async queueFileVectorization(fileId: number, userId: number): Promise<void> {
    if (!isVectorizationEnabled()) {
      return;
    }
    const job = { id: `file_${fileId}_${Date.now()}`, fileId, userId, retryCount: 0, maxRetries: this.maxRetries, createdAt: new Date() };
    this.fileQueue.push(job);
    console.log(`üì• Queued file ${fileId} for vectorization (file queue size: ${this.fileQueue.length})`);
  }

  /**
   * Process file vectorization queue
   */
  private async processFileQueue(): Promise<void> {
    if (!isVectorizationEnabled()) {
      return;
    }
    if (this.fileQueue.length === 0) return;
    const jobs = [...this.fileQueue];
    console.log(`üîÑ Processing ${jobs.length} file vectorization jobs`);
    for (const job of jobs) {
      try {
        await this.processSingleFileVectorization(job.fileId, job.userId);
        this.fileQueue = this.fileQueue.filter(j => j.id !== job.id);
      } catch (error) {
        console.error(`‚ùå File vectorization failed for file ${job.fileId}:`, error);
        if (job.retryCount < job.maxRetries) {
          job.retryCount++;
          console.log(`üîÑ Retry ${job.retryCount}/${job.maxRetries} for file job ${job.id}`);
        } else {
          console.error(`‚ùå Max retries exceeded for file vectorization job ${job.id}, removing from queue`);
          this.fileQueue = this.fileQueue.filter(j => j.id !== job.id);
        }
      }
      await this.sleep(100);
    }
  }

  /**
   * Process single file vectorization
   */
  private async processSingleFileVectorization(fileId: number, userId: number): Promise<void> {
    if (!isVectorizationEnabled()) {
      return;
    }
    // Fetch file to ensure it belongs to user and has content
    const result = await db.select().from(files).where(eq(files.id, fileId));
    const file = result[0];
    if (!file) throw new Error('File not found');
    if (!file.content) {
      console.log(`‚ÑπÔ∏è File ${fileId} has no content, skipping embedding`);
      return;
    }

    // Determine text to embed based on encoding and mime type
    let textForEmbedding = '';
    const encoding = String(file.encoding || 'utf-8').toLowerCase();
    const mime = String(file.mimeType || '').toLowerCase();

    try {
      if (encoding === 'utf-8' || encoding === 'utf8') {
        // Already stored as UTF-8 text
        textForEmbedding = String(file.content || '');
      } else {
        // Binary content (base64). Attempt extraction for supported types (pdf/docx)
        textForEmbedding = await vectorService.extractTextForFileRecord(file);
      }
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to derive text for embeddings for file ${fileId}:`, e);
      textForEmbedding = '';
    }

    if (!textForEmbedding || !textForEmbedding.trim()) {
      console.log(`‚ÑπÔ∏è No extractable text for file ${fileId} (mime=${mime}). Skipping embedding.`);
      return;
    }

    // Clear previous embeddings and re-index
    await vectorService.clearFileEmbeddings(fileId);
    const stored = await vectorService.indexFileContent(fileId, textForEmbedding);
    console.log(`‚úÖ Indexed ${stored} chunks for file ${fileId}`);
  }

  /**
   * Process message vectorization queue
   */
  private async processMessageQueue(priority: 'high' | 'normal' | 'low'): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    const jobs = this.messageQueue.filter(job => 
      job.priority === priority && 
      (!job.scheduledAt || job.scheduledAt <= new Date())
    );

    if (jobs.length === 0) {
      return;
    }

    console.log(`üîÑ Processing ${jobs.length} ${priority} priority message vectorization jobs`);

    for (const job of jobs) {
      try {
        await this.processMessageVectorization(job);
        
        // Remove completed job from queue
        this.messageQueue = this.messageQueue.filter(j => j.id !== job.id);
        
      } catch (error) {
        console.error(`‚ùå Message vectorization failed for job ${job.id}:`, error);
        
        // Handle retry logic
        if (job.retryCount < job.maxRetries) {
          job.retryCount++;
          job.scheduledAt = new Date(Date.now() + this.retryDelayMs * job.retryCount);
          console.log(`üîÑ Scheduled retry ${job.retryCount}/${job.maxRetries} for job ${job.id} at ${job.scheduledAt}`);
        } else {
          console.error(`‚ùå Max retries exceeded for message vectorization job ${job.id}, removing from queue`);
          this.messageQueue = this.messageQueue.filter(j => j.id !== job.id);
        }
      }

      // Small delay between jobs to avoid overwhelming the system
      await this.sleep(100);
    }
  }

  /**
   * Process conversation summary vectorization queue
   */
  private async processConversationQueue(priority: 'high' | 'normal' | 'low'): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    const jobs = this.conversationQueue.filter(job => job.priority === priority);

    if (jobs.length === 0) {
      return;
    }

    console.log(`üîÑ Processing ${jobs.length} ${priority} priority conversation summary jobs`);

    for (const job of jobs) {
      try {
        await this.processConversationSummaryVectorization(job);
        
        // Remove completed job from queue
        this.conversationQueue = this.conversationQueue.filter(j => j.id !== job.id);
        
      } catch (error) {
        console.error(`‚ùå Conversation summary vectorization failed for job ${job.id}:`, error);
        
        // Handle retry logic
        if (job.retryCount < job.maxRetries) {
          job.retryCount++;
          console.log(`üîÑ Retry ${job.retryCount}/${job.maxRetries} for conversation summary job ${job.id}`);
        } else {
          console.error(`‚ùå Max retries exceeded for conversation summary job ${job.id}, removing from queue`);
          this.conversationQueue = this.conversationQueue.filter(j => j.id !== job.id);
        }
      }

      // Small delay between jobs
      await this.sleep(200);
    }
  }

  /**
   * Process individual message vectorization
   */
  private async processMessageVectorization(job: VectorizationJob): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    console.log(`üî§ Processing message vectorization for message ${job.messageId}`);
    
    // Get the message
    const message = await conversationService.getMessage(job.messageId);
    if (!message) {
      throw new Error(`Message ${job.messageId} not found`);
    }

    // Generate embedding (service has internal fallback and will not throw)
    const embeddingResult = await vectorService.generateEmbedding(message.content).catch((e) => {
      console.warn('‚ö†Ô∏è Message embedding generation failed, skipping store:', e?.message || e);
      return null as any;
    });
    if (!embeddingResult || !embeddingResult.embedding) {
      return; // Skip storing if we have no embedding
    }
    
    // Store embedding
    await vectorService.storeMessageEmbedding(job.messageId, embeddingResult);
    
    console.log(`‚úÖ Completed vectorization for message ${job.messageId}`);
  }

  /**
   * Process conversation summary vectorization
   */
  private async processConversationSummaryVectorization(job: ConversationSummaryJob): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    console.log(`üìù Processing conversation summary vectorization for conversation ${job.conversationId}`);
    
    // Generate conversation summary
    const summary = await vectorService.generateConversationSummary(job.conversationId);
    
    // Generate embedding for summary (non-blocking)
    const embeddingResult = await vectorService.generateEmbedding(summary).catch((e) => {
      console.warn('‚ö†Ô∏è Summary embedding generation failed, skipping store:', e?.message || e);
      return null as any;
    });
    if (!embeddingResult || !embeddingResult.embedding) {
      return;
    }
    
    // Store conversation embedding
    await vectorService.storeConversationEmbedding(job.conversationId, summary, embeddingResult);
    
    console.log(`‚úÖ Completed conversation summary vectorization for conversation ${job.conversationId}`);
  }

  /**
   * Get queue status for monitoring
   */
  public getQueueStatus(): {
    messageQueue: number;
    conversationQueue: number;
    isProcessing: boolean;
    totalPending: number;
  } {
    return {
      messageQueue: isVectorizationEnabled() ? this.messageQueue.length : 0,
      conversationQueue: isVectorizationEnabled() ? this.conversationQueue.length : 0,
      isProcessing: isVectorizationEnabled() ? this.isProcessing : false,
      totalPending: isVectorizationEnabled() ? (this.messageQueue.length + this.conversationQueue.length) : 0
    };
  }

  /**
   * Clear all queues (for testing/maintenance)
   */
  public clearQueues(): void {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    this.messageQueue = [];
    this.conversationQueue = [];
    console.log('üßπ Cleared all vector processor queues');
  }

  /**
   * Process pending jobs immediately (manual trigger)
   */
  public async processPendingJobs(): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    if (this.isProcessing) {
      console.log('‚è≥ Vector processor is already processing, skipping manual trigger');
      return;
    }

    console.log('üöÄ Manually triggering vector processor');
    await this.processQueues();
  }

  /**
   * Utility function for delays
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Graceful shutdown
   */
  public async shutdown(): Promise<void> {
    console.log('üõë Shutting down vector processor...');
    
    this.stopProcessing();
    
    // Wait for current processing to complete
    while (this.isProcessing) {
      await this.sleep(100);
    }
    
    console.log(`üìä Vector processor shutdown complete. Remaining jobs: ${this.messageQueue.length + this.conversationQueue.length}`);
  }
}

// Export singleton instance
export const vectorProcessor = new VectorProcessor();

================
File: server/vector-service.ts
================
import { db } from "./db";
import { isVectorizationEnabled } from "./vector-flags";
import { messageEmbeddings, messages, conversations, conversationEmbeddings, fileEmbeddings, files } from "@shared/schema";
import { eq, desc, sql, and } from "drizzle-orm";

export interface SimilarMessage {
  id: number;
  content: string;
  role: string;
  conversationId: number;
  similarity: number;
  createdAt: Date;
}

export interface EmbeddingResult {
  embedding: number[];
  model: string;
  dimensions: number;
}

export interface SimilarConversation {
  id: number;
  title: string;
  summary: string;
  similarity: number;
  createdAt: Date;
}

/**
 * Vector service for generating embeddings and performing semantic search
 * Supports multiple embedding providers with LM Studio as primary choice
 */
export class VectorService {
  private defaultEmbeddingModel = 'text-embedding-ada-002';
  private defaultDimensions = 1536;

  /**
   * Generate embedding for text using available providers
   */
  async generateEmbedding(text: string): Promise<EmbeddingResult> {
    // Short-circuit when vectors are disabled
    if (!isVectorizationEnabled()) {
      return {
        embedding: [],
        model: 'vectors-disabled',
        dimensions: 0,
      };
    }
    // Clean and prepare text
    const cleanText = this.cleanTextForEmbedding(text);
    // Single local path: Transformers.js local embeddings with hash fallback
    try {
      return await this.generateTransformersEmbedding(cleanText);
    } catch (error) {
      console.warn('‚ö†Ô∏è Transformers.js embedding failed, falling back to local hash:', error);
      return this.generateLocalHashEmbedding(cleanText, 384);
    }
  }

  /**
   * Generate embedding using LM Studio
   */
  private async generateLMStudioEmbedding(text: string): Promise<EmbeddingResult> {
    const lmBase = this.getLMStudioBaseUrl();
    const targetUrl = `${lmBase}/v1/embeddings`;
    const proxyAuth = process.env.LMSTUDIO_API_KEY ? `Bearer ${process.env.LMSTUDIO_API_KEY}` : "Bearer lm-studio";

    console.log(`üî§ Generating LM Studio embedding for text: ${text.substring(0, 100)}...`);

    const response = await fetch(targetUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': proxyAuth
      },
      body: JSON.stringify({
        model: this.defaultEmbeddingModel,
        input: text,
        encoding_format: 'float'
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`LM Studio embedding failed (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    
    if (!data.data || !data.data[0] || !data.data[0].embedding) {
      throw new Error('Invalid embedding response from LM Studio');
    }

    const embedding = data.data[0].embedding;
    
    return {
      embedding,
      model: data.model || this.defaultEmbeddingModel,
      dimensions: embedding.length
    };
  }

  /**
   * Generate embedding using Transformers.js (in-process, no external API)
   */
  private transformersExtractorPromise: Promise<any> | null = null;
  private async getTransformersExtractor(): Promise<any> {
    if (!this.transformersExtractorPromise) {
      this.transformersExtractorPromise = (async () => {
        const { pipeline, env } = await import('@xenova/transformers');
        if (process.env.TRANSFORMERS_CACHE_DIR) {
          // @ts-ignore - env types may not include cacheDir
          env.cacheDir = process.env.TRANSFORMERS_CACHE_DIR;
        }
        // Allow using local models if provided
        // @ts-ignore
        env.allowLocalModels = true;
        if (process.env.TRANSFORMERS_LOCAL_DIR) {
          // @ts-ignore
          env.localModelPath = process.env.TRANSFORMERS_LOCAL_DIR;
        }
        const modelId = process.env.EMBEDDING_MODEL_ID || 'Xenova/all-MiniLM-L6-v2';
        return await pipeline('feature-extraction', modelId);
      })();
    }
    return this.transformersExtractorPromise;
  }

  private async generateTransformersEmbedding(text: string): Promise<EmbeddingResult> {
    console.log(`üî§ Generating Transformers.js embedding for text: ${text.substring(0, 100)}...`);
    const extractor = await this.getTransformersExtractor();
    const output = await extractor(text, { pooling: 'mean', normalize: true });
    // output can be a tensor with .data (Float32Array) or nested array
    const vec: number[] = Array.isArray(output)
      ? (output as number[])
      : Array.from((output?.data as Float32Array) || []);
    if (!vec || vec.length === 0) {
      throw new Error('Empty embedding from Transformers.js');
    }
    return {
      embedding: vec,
      model: 'transformers-js',
      dimensions: vec.length
    };
  }

  /**
   * Extract UTF-8 text from a file record for embedding.
   * Handles text/* directly, and decodes + extracts from common binaries like PDF/DOCX.
   */
  public async extractTextForFileRecord(file: any): Promise<string> {
    try {
      const mime = String(file.mimeType || '').toLowerCase();
      const encoding = String(file.encoding || 'utf-8').toLowerCase();
      const contentStr: string = String(file.content || '');

      // If it's already a text file stored as UTF-8, return directly
      if (!encoding || encoding === 'utf-8' || encoding === 'utf8') {
        // Some text files may be extremely large; clean before embedding
        return this.cleanTextForEmbedding(contentStr);
      }

      // Binary content expected to be base64-encoded
      const buffer = Buffer.from(contentStr, 'base64');

      // PDF
      if (mime === 'application/pdf') {
        try {
          const pdfModule = await import('pdf-parse');
          const pdfParse = (pdfModule as any).default || (pdfModule as any);
          const data = await pdfParse(buffer);
          return this.cleanTextForEmbedding(String(data.text || ''));
        } catch (e) {
          console.warn('‚ö†Ô∏è PDF text extraction failed:', e);
          return '';
        }
      }

      // DOCX (Word)
      if (
        mime === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
        mime.endsWith('+docx')
      ) {
        try {
          const mammothModule = await import('mammoth');
          const mammoth = (mammothModule as any).default || (mammothModule as any);
          const result = await mammoth.extractRawText({ buffer });
          return this.cleanTextForEmbedding(String(result.value || ''));
        } catch (e) {
          console.warn('‚ö†Ô∏è DOCX text extraction failed:', e);
          return '';
        }
      }

      // Legacy .doc is not supported by mammoth; skip gracefully
      if (mime === 'application/msword') {
        console.warn('‚ÑπÔ∏è Skipping legacy .doc extraction (unsupported).');
        return '';
      }

      // Fallback: unhandled binary type
      return '';
    } catch (error) {
      console.warn('‚ö†Ô∏è extractTextForFileRecord failed:', error);
      return '';
    }
  }

  /**
   * Generate a keyless local embedding using a hashing trick over tokens.
   * Deterministic, lightweight, and avoids external dependencies.
   */
  private generateLocalHashEmbedding(text: string, dimensions: number = 384): EmbeddingResult {
    const tokens = text
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(Boolean);

    const vector = new Array<number>(dimensions).fill(0);

    // FNV-1a hash for token hashing
    const fnv1a = (str: string): number => {
      let hash = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, 0x01000193) >>> 0; // 32-bit overflow
      }
      return hash >>> 0;
    };

    for (const token of tokens) {
      const h = fnv1a(token);
      const idx = h % dimensions;
      // Signed contribution via second bit to reduce collisions bias
      const sign = ((h >>> 1) & 1) === 1 ? 1 : -1;
      vector[idx] += sign;
    }

    // L2 normalize
    let norm = 0;
    for (let i = 0; i < dimensions; i++) norm += vector[i] * vector[i];
    norm = Math.sqrt(norm) || 1;
    for (let i = 0; i < dimensions; i++) vector[i] = vector[i] / norm;

    return {
      embedding: vector,
      model: 'local-hash-embedding-v1',
      dimensions,
    };
  }

  /**
   * Store message embedding in database
   */
  async storeMessageEmbedding(messageId: number, embeddingResult: EmbeddingResult): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    try {
      await db.insert(messageEmbeddings).values({
        messageId,
        embedding: JSON.stringify(embeddingResult.embedding),
        embeddingModel: embeddingResult.model,
        embeddingDimensions: embeddingResult.dimensions
      });

      console.log(`‚úÖ Stored embedding for message ${messageId} (${embeddingResult.dimensions}D, model: ${embeddingResult.model})`);
    } catch (error) {
      console.error(`‚ùå Failed to store embedding for message ${messageId}:`, error);
      throw error;
    }
  }

  /**
   * Store conversation summary embedding
   */
  async storeConversationEmbedding(conversationId: number, summary: string, embeddingResult: EmbeddingResult): Promise<void> {
    if (!isVectorizationEnabled()) {
      return; // no-op when disabled
    }
    try {
      // Check if embedding already exists
      const existing = await db
        .select()
        .from(conversationEmbeddings)
        .where(eq(conversationEmbeddings.conversationId, conversationId))
        .limit(1);

      if (existing.length > 0) {
        // Update existing
        await db
          .update(conversationEmbeddings)
          .set({
            summaryEmbedding: JSON.stringify(embeddingResult.embedding),
            embeddingModel: embeddingResult.model,
            embeddingDimensions: embeddingResult.dimensions,
            summary,
            updatedAt: new Date()
          })
          .where(eq(conversationEmbeddings.conversationId, conversationId));
      } else {
        // Insert new
        await db.insert(conversationEmbeddings).values({
          conversationId,
          summaryEmbedding: JSON.stringify(embeddingResult.embedding),
          embeddingModel: embeddingResult.model,
          embeddingDimensions: embeddingResult.dimensions,
          summary
        });
      }

      console.log(`‚úÖ Stored conversation embedding for conversation ${conversationId}`);
    } catch (error) {
      console.error(`‚ùå Failed to store conversation embedding for ${conversationId}:`, error);
      throw error;
    }
  }

  /**
   * Find similar messages using cosine similarity
   */
  async findSimilarMessages(
    queryEmbedding: number[], 
    userId: number, 
    limit: number = 5,
    threshold: number = 0.7
  ): Promise<SimilarMessage[]> {
    if (!isVectorizationEnabled()) {
      return [];
    }
    try {
      const queryEmbeddingStr = JSON.stringify(queryEmbedding);
      const dims = queryEmbedding.length;
      
      // Use raw SQL for vector similarity search
      const result = await db.execute(sql`
        SELECT 
          m.id,
          m.content,
          m.role,
          m.conversation_id,
          m.created_at,
          (1 - (me.embedding::vector <=> ${queryEmbeddingStr}::vector)) as similarity
        FROM message_embeddings me
        JOIN messages m ON me.message_id = m.id
        JOIN conversations c ON m.conversation_id = c.id
        WHERE c.user_id = ${userId}
          AND (1 - (me.embedding::vector <=> ${queryEmbeddingStr}::vector)) > ${threshold}
        ORDER BY similarity DESC
        LIMIT ${limit}
      `);

      return result.rows.map((row: any) => ({
        id: row.id,
        content: row.content,
        role: row.role,
        conversationId: row.conversation_id,
        similarity: parseFloat(row.similarity),
        createdAt: new Date(row.created_at)
      }));
    } catch (error) {
      console.error('‚ùå Error finding similar messages:', error);
      // Return empty array if similarity search fails
      return [];
    }
  }

  /**
   * Find similar conversations using summary embeddings
   */
  async findSimilarConversations(
    queryEmbedding: number[], 
    userId: number, 
    limit: number = 3,
    threshold: number = 0.7
  ): Promise<SimilarConversation[]> {
    if (!isVectorizationEnabled()) {
      return [];
    }
    try {
      const queryEmbeddingStr = JSON.stringify(queryEmbedding);
      const dims = queryEmbedding.length;
      
      const result = await db.execute(sql`
        SELECT 
          c.id,
          c.title,
          '' AS summary,
          c.created_at,
          (1 - (ce.summary_embedding::vector <=> ${queryEmbeddingStr}::vector)) as similarity
        FROM conversation_embeddings ce
        JOIN conversations c ON ce.conversation_id = c.id
        WHERE c.user_id = ${userId}
          AND c.archived_at IS NULL
          AND (1 - (ce.summary_embedding::vector <=> ${queryEmbeddingStr}::vector)) > ${threshold}
        ORDER BY similarity DESC
        LIMIT ${limit}
      `);

      return result.rows.map((row: any) => ({
        id: row.id,
        title: row.title,
        summary: row.summary,
        similarity: parseFloat(row.similarity),
        createdAt: new Date(row.created_at)
      }));
    } catch (error) {
      console.error('‚ùå Error finding similar conversations:', error);
      return [];
    }
  }

  /**
   * Generate conversation summary from messages
   */
  async generateConversationSummary(conversationId: number): Promise<string> {
    try {
      // Get all messages in conversation
      const conversationMessages = await db
        .select({
          content: messages.content,
          role: messages.role
        })
        .from(messages)
        .where(eq(messages.conversationId, conversationId))
        .orderBy(messages.messageIndex);

      if (conversationMessages.length === 0) {
        return "Empty conversation";
      }

      // Create a summary from the conversation
      const messageTexts = conversationMessages
        .map(msg => `${msg.role}: ${msg.content}`)
        .join('\n');

      // For now, create a simple summary. In the future, this could use AI summarization
      const summary = messageTexts.length > 500 
        ? messageTexts.substring(0, 500) + "..." 
        : messageTexts;

      return summary;
    } catch (error) {
      console.error(`‚ùå Error generating conversation summary for ${conversationId}:`, error);
      return "Failed to generate summary";
    }
  }

  /**
   * Clean text for embedding generation
   */
  private cleanTextForEmbedding(text: string): string {
    // Remove excessive whitespace and normalize
    return text
      .replace(/\s+/g, ' ')
      .trim()
      .substring(0, 8000); // Limit text length for embedding
  }

  /**
   * Get LM Studio base URL (copied from routes.ts)
   */
  private getLMStudioBaseUrl(): string {
    const lmBaseRaw = process.env.LMSTUDIO_BASE_URL;
    const isProduction = process.env.NODE_ENV === "production";

    if (!lmBaseRaw) {
      return isProduction ? "https://lmstudio.uterpi.com" : "http://localhost:1234";
    }

    // Sanitize the URL
    let sanitized = lmBaseRaw.trim();
    if (sanitized.endsWith('/')) {
      sanitized = sanitized.slice(0, -1);
    }
    if (!sanitized.startsWith('http://') && !sanitized.startsWith('https://')) {
      sanitized = isProduction ? `https://${sanitized}` : `http://${sanitized}`;
    }

    return sanitized;
  }

  /**
   * Split text into overlapping chunks for embedding
   */
  public splitTextIntoChunks(text: string, chunkSize: number = 1000, overlap: number = 200): { index: number; text: string }[] {
    const clean = (text || '').replace(/\s+/g, ' ').trim();
    if (!clean) return [];
    const chunks: { index: number; text: string }[] = [];
    let start = 0;
    let index = 0;
    while (start < clean.length) {
      const end = Math.min(start + chunkSize, clean.length);
      const chunk = clean.substring(start, end);
      chunks.push({ index, text: chunk });
      if (end === clean.length) break;
      start = Math.max(0, end - overlap);
      index++;
    }
    return chunks;
  }

  /**
   * Store embeddings for a file's textual content (chunked)
   */
  async indexFileContent(fileId: number, content: string): Promise<number> {
    if (!isVectorizationEnabled()) {
      return 0;
    }
    try {
      const chunks = this.splitTextIntoChunks(content);
      let stored = 0;
      for (const { index, text } of chunks) {
        const embeddingResult = await this.generateEmbedding(text).catch(() => null as any);
        if (!embeddingResult || !embeddingResult.embedding) continue;
        await db.insert(fileEmbeddings).values({
          fileId,
          chunkIndex: index,
          chunkText: text,
          embedding: JSON.stringify(embeddingResult.embedding),
          embeddingModel: embeddingResult.model,
          embeddingDimensions: embeddingResult.dimensions
        });
        stored++;
      }
      return stored;
    } catch (error) {
      console.error('‚ùå Failed to index file content:', error);
      return 0;
    }
  }

  /**
   * Remove existing embeddings for a file
   */
  async clearFileEmbeddings(fileId: number): Promise<void> {
    try {
      await db.execute(sql`DELETE FROM file_embeddings WHERE file_id = ${fileId}`);
    } catch (error) {
      console.error('‚ùå Failed to clear file embeddings:', error);
    }
  }

  /**
   * Find top-k relevant file chunks for a user by semantic similarity
   */
  async findRelevantFileChunks(queryEmbedding: number[], userId: number, limit: number = 8, threshold: number = 0.7): Promise<Array<{ fileId: number; chunkIndex: number; text: string; similarity: number; name: string; mimeType: string }>> {
    if (!isVectorizationEnabled()) {
      return [];
    }
    try {
      const queryEmbeddingStr = JSON.stringify(queryEmbedding);
      const result = await db.execute(sql`
        SELECT fe.file_id, fe.chunk_index, fe.chunk_text, (1 - (fe.embedding::vector <=> ${queryEmbeddingStr}::vector)) as similarity, f.name, f.mime_type
        FROM file_embeddings fe
        JOIN files f ON fe.file_id = f.id
        WHERE f.user_id = ${userId}
          AND f.status = 'active'
          AND (1 - (fe.embedding::vector <=> ${queryEmbeddingStr}::vector)) > ${threshold}
        ORDER BY similarity DESC
        LIMIT ${limit}
      `);
      return result.rows.map((row: any) => ({
        fileId: row.file_id,
        chunkIndex: row.chunk_index,
        text: row.chunk_text,
        similarity: parseFloat(row.similarity),
        name: row.name,
        mimeType: row.mime_type
      }));
    } catch (error) {
      console.error('‚ùå Error finding relevant file chunks:', error);
      return [];
    }
  }

  /**
   * Find relevant file chunks restricted to a set of fileIds
   */
  async findRelevantFileChunksForFiles(
    queryEmbedding: number[],
    userId: number,
    fileIds: number[],
    limit: number = 12,
    threshold: number = 0.0
  ): Promise<Array<{ fileId: number; chunkIndex: number; text: string; similarity: number; name: string; mimeType: string }>> {
    if (!isVectorizationEnabled()) {
      return [];
    }
    try {
      const cleanIds = (fileIds || []).filter((id) => Number.isFinite(id));
      if (cleanIds.length === 0) return [];
      const queryEmbeddingStr = JSON.stringify(queryEmbedding);
      const result = await db.execute(sql`
        SELECT fe.file_id, fe.chunk_index, fe.chunk_text,
               (1 - (fe.embedding::vector <=> ${queryEmbeddingStr}::vector)) as similarity,
               f.name, f.mime_type
        FROM file_embeddings fe
        JOIN files f ON fe.file_id = f.id
        WHERE f.user_id = ${userId}
          AND f.status = 'active'
          AND fe.file_id = ANY(${cleanIds}::int[])
          AND (1 - (fe.embedding::vector <=> ${queryEmbeddingStr}::vector)) >= ${threshold}
        ORDER BY similarity DESC
        LIMIT ${limit}
      `);
      return result.rows.map((row: any) => ({
        fileId: row.file_id,
        chunkIndex: row.chunk_index,
        text: row.chunk_text,
        similarity: parseFloat(row.similarity),
        name: row.name,
        mimeType: row.mime_type
      }));
    } catch (error) {
      console.error('‚ùå Error finding relevant chunks for files:', error);
      return [];
    }
  }
}

// Export singleton instance
export const vectorService = new VectorService();

================
File: server/vite.ts
================
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { createServer as createViteServer, createLogger, type ServerOptions } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";
import dotenv from "dotenv";
dotenv.config();

// Get __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions as ServerOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        __dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

================
File: server/webhooks.ts
================
import type { Request, Response } from 'express';
import Stripe from 'stripe';
import { verifyWebhookSignature, syncSubscriptionFromStripe } from './stripe';
import { handleSubscriptionCheckoutSuccess, handleCreditsCheckoutSuccess, grantMonthlyCreditsForTier } from './stripe-checkout';
import { db } from './db';
import { users } from '@shared/schema';
import { eq } from 'drizzle-orm';

/**
 * Handle Stripe webhooks for subscription events
 */
export async function handleStripeWebhook(req: Request, res: Response): Promise<void> {
  const sig = req.headers['stripe-signature'] as string;
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!webhookSecret) {
    console.error('Stripe webhook secret not configured');
    res.status(500).json({ error: 'Webhook configuration error' });
    return;
  }

  let event: Stripe.Event;

  try {
    // Verify webhook signature
    event = verifyWebhookSignature(req.body, sig, webhookSecret);
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    res.status(400).json({ error: 'Invalid signature' });
    return;
  }

  console.log(`Processing webhook event: ${event.type}`);

  try {
    switch (event.type) {
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'invoice.payment_succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;

      case 'customer.subscription.trial_will_end':
        await handleTrialWillEnd(event.data.object as Stripe.Subscription);
        break;

      case 'customer.updated':
        await handleCustomerUpdated(event.data.object as Stripe.Customer);
        break;

      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error(`Error processing webhook ${event.type}:`, error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
}

/**
 * Handle subscription created event
 */
async function handleSubscriptionCreated(subscription: Stripe.Subscription): Promise<void> {
  console.log(`Subscription created: ${subscription.id}`);
  
  try {
    const userId = await getUserIdFromCustomer(subscription.customer as string);
    if (userId) {
      await syncSubscriptionFromStripe(subscription.id, userId);
      console.log(`Synced new subscription for user ${userId}`);
    }
  } catch (error) {
    console.error('Error handling subscription created:', error);
  }
}

/**
 * Handle subscription updated event
 */
async function handleSubscriptionUpdated(subscription: Stripe.Subscription): Promise<void> {
  console.log(`Subscription updated: ${subscription.id}, status: ${subscription.status}`);
  
  try {
    const userId = await getUserIdFromCustomer(subscription.customer as string);
    if (userId) {
      await syncSubscriptionFromStripe(subscription.id, userId);
      console.log(`Synced updated subscription for user ${userId}`);
    }
  } catch (error) {
    console.error('Error handling subscription updated:', error);
  }
}

/**
 * Handle subscription deleted event
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription): Promise<void> {
  console.log(`Subscription deleted: ${subscription.id}`);
  
  try {
    const userId = await getUserIdFromCustomer(subscription.customer as string);
    if (userId) {
      // Update user status to free/canceled
      await db.update(users)
        .set({
          subscriptionStatus: 'canceled',
          subscriptionTier: 'freemium',
          subscriptionEndsAt: null,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));

      console.log(`Updated user ${userId} to freemium tier after subscription deletion`);
    }
  } catch (error) {
    console.error('Error handling subscription deleted:', error);
  }
}

/**
 * Handle successful payment event
 */
async function handlePaymentSucceeded(invoice: Stripe.Invoice): Promise<void> {
  console.log(`Payment succeeded for invoice: ${invoice.id}`);
  
  try {
    if ((invoice as any).subscription) {
      const userId = await getUserIdFromCustomer(invoice.customer as string);
      if (userId) {
        // Sync subscription to ensure status is current
        await syncSubscriptionFromStripe((invoice as any).subscription as string, userId);
        
        // If this was a recovery from past_due, update status
        await db.update(users)
          .set({
            subscriptionStatus: 'active',
            updatedAt: new Date()
          })
          .where(eq(users.id, userId));

        console.log(`Payment recovery completed for user ${userId}`);

        // Grant monthly credits on successful invoice for active paid tiers
        try {
          // We need the tier; fetch from users table after sync
          const [user] = await db.select().from(users).where(eq(users.id, userId));
          const tier = (user?.subscriptionTier || '').toLowerCase();
          if (tier && tier !== 'freemium' && tier !== 'free') {
            await grantMonthlyCreditsForTier({
              userId,
              tier,
              source: 'invoice',
              invoiceId: invoice.id,
              subscriptionId: (invoice as any).subscription as string,
              periodStart: (invoice?.period_start as any) || undefined,
            });
          }
        } catch (grantErr) {
          console.error('Error granting monthly credits on invoice:', grantErr);
        }
      }
    }
  } catch (error) {
    console.error('Error handling payment succeeded:', error);
  }
}

/**
 * Handle failed payment event
 */
async function handlePaymentFailed(invoice: Stripe.Invoice): Promise<void> {
  console.log(`Payment failed for invoice: ${invoice.id}`);
  
  try {
    if ((invoice as any).subscription) {
      const userId = await getUserIdFromCustomer(invoice.customer as string);
      if (userId) {
        // Update user status to past_due
        await db.update(users)
          .set({
            subscriptionStatus: 'past_due',
            updatedAt: new Date()
          })
          .where(eq(users.id, userId));

        console.log(`Updated user ${userId} to past_due status after payment failure`);
        
        // TODO: Send email notification to user about failed payment
        // TODO: Implement retry logic or grace period
      }
    }
  } catch (error) {
    console.error('Error handling payment failed:', error);
  }
}

/**
 * Handle trial will end event
 */
async function handleTrialWillEnd(subscription: Stripe.Subscription): Promise<void> {
  console.log(`Trial will end for subscription: ${subscription.id}`);
  
  try {
    const userId = await getUserIdFromCustomer(subscription.customer as string);
    if (userId) {
      // TODO: Send email notification about trial ending
      // TODO: Prompt user to add payment method if not already added
      console.log(`Trial ending notification needed for user ${userId}`);
    }
  } catch (error) {
    console.error('Error handling trial will end:', error);
  }
}

/**
 * Handle customer updated event
 */
async function handleCustomerUpdated(customer: Stripe.Customer): Promise<void> {
  console.log(`Customer updated: ${customer.id}`);
  
  try {
    // Update user information if email or other details changed
    const user = await db.select().from(users)
      .where(eq(users.stripeCustomerId, customer.id))
      .limit(1);

    if (user[0]) {
      const updates: any = {
        updatedAt: new Date()
      };

      // Update email if it changed in Stripe
      if (customer.email && customer.email !== user[0].email) {
        updates.email = customer.email;
      }

      await db.update(users)
        .set(updates)
        .where(eq(users.id, user[0].id));

      console.log(`Synced customer updates for user ${user[0].id}`);
    }
  } catch (error) {
    console.error('Error handling customer updated:', error);
  }
}

/**
 * Get user ID from Stripe customer ID
 */
async function getUserIdFromCustomer(customerId: string): Promise<number | null> {
  try {
    const user = await db.select().from(users)
      .where(eq(users.stripeCustomerId, customerId))
      .limit(1);

    return user[0]?.id || null;
  } catch (error) {
    console.error('Error getting user from customer ID:', error);
    return null;
  }
}

/**
 * Handle checkout session completed event (for Checkout Sessions)
 */
async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session): Promise<void> {
  console.log(`Checkout session completed: ${session.id}, mode: ${session.mode}`);
  
  try {
    // Check if this is a subscription or one-time payment
    if (session.mode === 'subscription') {
      // Handle subscription checkout completion
      await handleSubscriptionCheckoutSuccess(session);
      console.log(`Processed subscription checkout for session ${session.id}`);
    } else if (session.mode === 'payment') {
      // Handle AI credits checkout completion
      const isCreditsPayment = session.metadata?.type === 'ai_credits';
      if (isCreditsPayment) {
        await handleCreditsCheckoutSuccess(session);
        console.log(`Processed AI credits checkout for session ${session.id}`);
      } else {
        console.log(`One-time payment completed but not recognized: ${session.id}`);
      }
    } else {
      console.log(`Unknown checkout session mode: ${session.mode} for session ${session.id}`);
    }
  } catch (error) {
    console.error('Error handling checkout session completed:', error);
    throw error;
  }
}

/**
 * Raw body parser middleware for Stripe webhooks
 * This needs to be applied before any other body parsing
 */
export function rawBodyParser() {
  return (req: Request, res: Response, next: any) => {
    if (req.path === '/api/webhooks/stripe') {
      let data = '';
      req.on('data', (chunk) => {
        data += chunk;
      });
      req.on('end', () => {
        req.body = data;
        next();
      });
    } else {
      next();
    }
  };
}

================
File: shared/schema.ts
================
import { pgTable, text, serial, integer, boolean, timestamp, date, varchar, json, decimal } from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

// Session table for express-session with connect-pg-simple
// Matching the exact structure created by connect-pg-simple
export const sessions = pgTable("session", {
  sid: varchar("sid").primaryKey(),
  sess: json("sess").notNull(), // JSON session data
  expire: timestamp("expire", { precision: 6 }).notNull(),
});

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  username: text("username").unique(), // Make username optional for OAuth
  password: text("password"), // Optional for OAuth users
  firstName: text("first_name"),
  lastName: text("last_name"),
  googleId: text("google_id").unique(),
  avatar: text("avatar"),
  age: integer("age"),
  dateOfBirth: date("date_of_birth", { mode: "date" }),
  bio: text("bio"),
  emailVerified: boolean("email_verified").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  
  // Account deletion (soft-delete)
  deletedAt: timestamp("deleted_at"),
  
  // Subscription-related fields
  stripeCustomerId: text("stripe_customer_id").unique(),
  subscriptionStatus: text("subscription_status").default("freemium"), // freemium, active, past_due, canceled, etc.
  subscriptionTier: text("subscription_tier").default("freemium"), // freemium, pro, team, enterprise, etc.
  subscriptionEndsAt: timestamp("subscription_ends_at"),
  
  // AI Credits fields
  ai_credits_balance: integer("ai_credits_balance").default(0),
  ai_credits_used_this_month: integer("ai_credits_used_this_month").default(0),
  credits_reset_at: timestamp("credits_reset_at"),
  
  // Message allowance fields (for freemium)
  messages_used_this_month: integer("messages_used_this_month").default(0),
  messages_reset_at: timestamp("messages_reset_at"),
  
  // Team fields
  teamId: integer("team_id"), // Will add foreign key reference after teams table is defined
  teamRole: text("team_role"), // 'owner', 'admin', 'member'
  
  // Grandfathering fields
  is_grandfathered: boolean("is_grandfathered").default(false),
  grandfathered_from_tier: text("grandfathered_from_tier"),
  grandfathered_at: timestamp("grandfathered_at"),
  
  // Access override fields for admin control
  accessOverride: boolean("access_override").default(false),
  overrideReason: text("override_reason"),
  overrideGrantedBy: integer("override_granted_by"), // Admin user ID who granted override
  overrideGrantedAt: timestamp("override_granted_at"),
  overrideExpiresAt: timestamp("override_expires_at"), // Optional expiration for temporary overrides
  
  // Password reset fields
  resetToken: text("reset_token").unique(),
  resetTokenExpiry: timestamp("reset_token_expiry"),
});

// Subscription plans table
export const subscriptionPlans = pgTable("subscription_plans", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(), // e.g., "Basic", "Premium"
  description: text("description"),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(), // Monthly price in dollars
  interval: text("interval").notNull().default("month"), // month, year
  features: json("features").$type<string[]>(), // Array of feature descriptions
  stripePriceId: text("stripe_price_id").notNull().unique(),
  stripeProductId: text("stripe_product_id").notNull(),
  isActive: boolean("is_active").default(true),
  sortOrder: integer("sort_order").default(0), // For display ordering
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User subscriptions table
export const subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  teamId: integer("team_id").references(() => teams.id), // Team association for subscription
  planId: integer("plan_id").references(() => subscriptionPlans.id),
  stripeSubscriptionId: text("stripe_subscription_id").unique(),
  stripePriceId: text("stripe_price_id"),
  status: text("status").notNull(), // active, past_due, canceled, etc.
  currentPeriodStart: timestamp("current_period_start"),
  currentPeriodEnd: timestamp("current_period_end"),
  cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
  canceledAt: timestamp("canceled_at"),
  trialStart: timestamp("trial_start"),
  trialEnd: timestamp("trial_end"),
  metadata: json("metadata"), // For storing additional info like grandfathered status
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// File system tables for real file integration
export const files = pgTable("files", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  originalName: text("original_name").notNull(),
  mimeType: text("mime_type").notNull(),
  size: integer("size").notNull(), // File size in bytes
  content: text("content"), // Store file content as base64 encoded text
  encoding: text("encoding"), // File encoding (e.g., utf-8, base64)
  
  // File metadata
  description: text("description"),
  tags: json("tags").$type<string[]>().default([]), // Array of tags for categorization
  
  // File organization
  folder: text("folder").default("/"), // Virtual folder path
  isPublic: boolean("is_public").default(false),
  
  // AI Analysis results
  aiAnalysis: json("ai_analysis"), // Store Azure AI analysis results
  analysisStatus: text("analysis_status").default("pending"), // pending, analyzing, completed, failed
  
  // File status
  status: text("status").default("active"), // active, archived, deleted
  
  // Version control
  currentVersion: integer("current_version").default(1),
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  lastAccessedAt: timestamp("last_accessed_at").defaultNow(),
  analyzedAt: timestamp("analyzed_at"),
});

// File versions for version control
export const fileVersions = pgTable("file_versions", {
  id: serial("id").primaryKey(),
  fileId: integer("file_id").references(() => files.id).notNull(),
  versionNumber: integer("version_number").notNull(),
  content: text("content").notNull(), // Store as base64 encoded text
  size: integer("size").notNull(),
  
  // Version metadata
  changeDescription: text("change_description"),
  changeType: text("change_type").default("update"), // create, update, restore
  
  // AI analysis for this version
  aiAnalysis: json("ai_analysis"),
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: integer("created_by").references(() => users.id).notNull(),
});

// File permissions for sharing and collaboration
export const filePermissions = pgTable("file_permissions", {
  id: serial("id").primaryKey(),
  fileId: integer("file_id").references(() => files.id).notNull(),
  userId: integer("user_id").references(() => users.id), // null for public permissions
  
  // Permission levels
  permission: text("permission").notNull(), // read, write, admin, owner
  
  // Share settings
  sharedBy: integer("shared_by").references(() => users.id).notNull(),
  shareToken: text("share_token").unique(), // For public sharing
  shareExpiry: timestamp("share_expires_at"),
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// File interaction logs for analytics and AI insights
export const fileInteractions = pgTable("file_interactions", {
  id: serial("id").primaryKey(),
  fileId: integer("file_id").references(() => files.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Interaction details
  interactionType: text("interaction_type").notNull(), // view, edit, analyze, download, share
  details: json("details"), // Additional interaction metadata
  
  // AI context
  aiContext: json("ai_context"), // Context about AI analysis or suggestions
  
  // Performance metrics
  duration: integer("duration"), // Duration in milliseconds
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Vector embeddings for file chunks
export const fileEmbeddings = pgTable("file_embeddings", {
  id: serial("id").primaryKey(),
  fileId: integer("file_id").references(() => files.id).notNull(),
  chunkIndex: integer("chunk_index").notNull(),
  chunkText: text("chunk_text").notNull(),
  embedding: text("embedding").notNull(), // Stored as JSON array string
  embeddingModel: text("embedding_model").notNull(),
  embeddingDimensions: integer("embedding_dimensions").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Schema for creating a user with email/password
export const insertUserSchema = createInsertSchema(users, {
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters").optional(),
  username: z.string().min(3, "Username must be at least 3 characters").optional(),
  firstName: z.string().min(1, "First name is required").optional(),
  lastName: z.string().min(1, "Last name is required").optional(),
  age: z.number().int().min(13, "Must be at least 13 years old").max(120, "Invalid age").optional(),
  dateOfBirth: z.string().optional(), // Will be converted to Date
  bio: z.string().max(500, "Bio must be 500 characters or less").optional(),
}).pick({
  email: true,
  password: true,
  username: true,
  firstName: true,
  lastName: true,
  age: true,
  dateOfBirth: true,
  bio: true,
});

// Schema for user registration with email/password
export const registerUserSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  username: z.string().min(3, "Username must be at least 3 characters").optional(),
  firstName: z.string().min(1, "First name is required").optional(),
  lastName: z.string().min(1, "Last name is required").optional(),
});

// Schema for user login
export const loginUserSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(1, "Password is required"),
});

// Schema for forgot password request
export const forgotPasswordSchema = z.object({
  email: z.string().email("Invalid email address"),
});

// Schema for password reset
export const resetPasswordSchema = z.object({
  token: z.string().min(1, "Reset token is required"),
  password: z.string().min(8, "Password must be at least 8 characters"),
});

// Schema for user profile updates
export const updateProfileSchema = z.object({
  firstName: z.string().min(1, "First name is required").optional(),
  lastName: z.string().min(1, "Last name is required").optional(),
  username: z.string().min(3, "Username must be at least 3 characters").optional(),
  age: z.number().int().min(13, "Must be at least 13 years old").max(120, "Invalid age").optional(),
  dateOfBirth: z.string().optional().refine((date) => {
    if (!date) return true;
    const parsed = new Date(date);
    return !isNaN(parsed.getTime()) && parsed <= new Date();
  }, "Invalid date of birth"),
  bio: z.string().max(500, "Bio must be 500 characters or less").optional(),
});

// Schema for OAuth user creation
export const oauthUserSchema = z.object({
  email: z.string().email(),
  googleId: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  avatar: z.string().url().optional(),
  emailVerified: z.boolean().default(true), // OAuth emails are typically verified
});

// Public user schema (without sensitive data)
export const publicUserSchema = createSelectSchema(users).omit({
  password: true,
  googleId: true,
});

// Subscription plan schemas
export const insertSubscriptionPlanSchema = createInsertSchema(subscriptionPlans, {
  name: z.string().min(1, "Plan name is required"),
  price: z.string().refine((val) => !isNaN(Number(val)) && Number(val) >= 0, "Price must be a valid number"),
  interval: z.enum(["month", "year"]),
  features: z.array(z.string()).optional(),
  stripePriceId: z.string().min(1, "Stripe price ID is required"),
  stripeProductId: z.string().min(1, "Stripe product ID is required"),
});

export const subscriptionPlanSchema = createSelectSchema(subscriptionPlans);

// Subscription schemas
export const insertSubscriptionSchema = createInsertSchema(subscriptions, {
  userId: z.number().int().positive(),
  status: z.enum(["active", "past_due", "canceled", "incomplete", "incomplete_expired", "trialing", "unpaid"]),
});

export const subscriptionSchema = createSelectSchema(subscriptions);

// Registration with subscription schema
export const registerWithSubscriptionSchema = z.object({
  // User fields
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  username: z.string().min(3, "Username must be at least 3 characters").optional(),
  firstName: z.string().min(1, "First name is required").optional(),
  lastName: z.string().min(1, "Last name is required").optional(),
  
  // Subscription fields
  planId: z.number().int().positive().optional(), // Optional for free plan
  paymentMethodId: z.string().optional(), // Required for paid plans
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type RegisterUser = z.infer<typeof registerUserSchema>;
export type LoginUser = z.infer<typeof loginUserSchema>;
export type ForgotPassword = z.infer<typeof forgotPasswordSchema>;
export type ResetPassword = z.infer<typeof resetPasswordSchema>;
export type UpdateProfile = z.infer<typeof updateProfileSchema>;
export type OAuthUser = z.infer<typeof oauthUserSchema>;
export type User = typeof users.$inferSelect;
export type PublicUser = z.infer<typeof publicUserSchema>;

// New subscription types
export type SubscriptionPlan = typeof subscriptionPlans.$inferSelect;
export type InsertSubscriptionPlan = z.infer<typeof insertSubscriptionPlanSchema>;
export type Subscription = typeof subscriptions.$inferSelect;
export type InsertSubscription = z.infer<typeof insertSubscriptionSchema>;
export type RegisterWithSubscription = z.infer<typeof registerWithSubscriptionSchema>;

// File system schemas
export const insertFileSchema = createInsertSchema(files, {
  name: z.string().min(1, "File name is required").max(255, "File name too long"),
  originalName: z.string().min(1, "Original file name is required"),
  mimeType: z.string().min(1, "MIME type is required"),
  size: z.number().int().min(1, "File size must be positive"),
  folder: z.string().default("/"),
  description: z.string().max(1000, "Description too long").optional(),
  tags: z.array(z.string()).optional(),
}).pick({
  name: true,
  originalName: true,
  mimeType: true,
  size: true,
  folder: true,
  description: true,
  tags: true,
});

export const fileSchema = createSelectSchema(files);

export const updateFileSchema = z.object({
  name: z.string().min(1, "File name is required").max(255, "File name too long").optional(),
  description: z.string().max(1000, "Description too long").optional(),
  tags: z.array(z.string()).optional(),
  folder: z.string().optional(),
  isPublic: z.boolean().optional(),
});

export const filePermissionSchema = createInsertSchema(filePermissions, {
  permission: z.enum(["read", "write", "admin", "owner"]),
}).pick({
  permission: true,
});

export const shareFileSchema = z.object({
  userId: z.number().int().positive().optional(),
  permission: z.enum(["read", "write"]),
  shareExpiry: z.string().optional(), // ISO date string
});

// File interaction schema
export const fileInteractionSchema = createInsertSchema(fileInteractions, {
  interactionType: z.enum(["view", "edit", "analyze", "download", "share", "delete", "restore"]),
}).pick({
  interactionType: true,
  details: true,
});

// New file system types
export type File = typeof files.$inferSelect;
export type InsertFile = z.infer<typeof insertFileSchema>;
export type UpdateFile = z.infer<typeof updateFileSchema>;
export type FileVersion = typeof fileVersions.$inferSelect;
export type FilePermission = typeof filePermissions.$inferSelect;
export type ShareFile = z.infer<typeof shareFileSchema>;
export type FileInteraction = typeof fileInteractions.$inferSelect;
export type InsertFileInteraction = z.infer<typeof fileInteractionSchema>;

// Engagement system schemas
export const updateEmailPreferencesSchema = z.object({
  welcomeEmails: z.boolean().optional(),
  reengagementEmails: z.boolean().optional(),
  featureUpdates: z.boolean().optional(),
  productTips: z.boolean().optional(),
  usageInsights: z.boolean().optional(),
  communityHighlights: z.boolean().optional(),
  emailFrequency: z.enum(["daily", "weekly", "monthly"]).optional(),
  timezone: z.string().optional(),
  preferredContactTime: z.enum(["morning", "afternoon", "evening"]).optional(),
});

export const createCampaignSchema = z.object({
  name: z.string().min(1, "Campaign name is required"),
  description: z.string().optional(),
  campaignType: z.enum(["welcome", "reengagement", "feature_update", "product_tips", "usage_insights", "community"]),
  emailTemplate: z.string().min(1, "Email template is required"),
  targetSegment: z.enum(["all", "new", "active", "at_risk", "dormant"]).default("all"),
  sendAfterDays: z.number().int().min(0).optional(),
  triggerEvent: z.string().optional(),
});

export const unsubscribeSchema = z.object({
  token: z.string().min(1, "Unsubscribe token is required"),
  reason: z.string().optional(),
});

// Engagement system types
export type UserEngagement = typeof userEngagement.$inferSelect;
export type EmailPreferences = typeof emailPreferences.$inferSelect;
export type UpdateEmailPreferences = z.infer<typeof updateEmailPreferencesSchema>;
export type EmailCampaign = typeof emailCampaigns.$inferSelect;
export type CreateCampaign = z.infer<typeof createCampaignSchema>;
export type EmailSendLog = typeof emailSendLog.$inferSelect;
export type UserActivity = typeof userActivity.$inferSelect;
export type UnsubscribeRequest = z.infer<typeof unsubscribeSchema>;

// =============================================================================
// USER ENGAGEMENT SYSTEM
// =============================================================================

// User engagement tracking table
export const userEngagement = pgTable("user_engagement", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Login and session tracking
  lastLoginAt: timestamp("last_login_at"),
  totalLogins: integer("total_logins").default(0),
  totalSessions: integer("total_sessions").default(0),
  totalTimeSpent: integer("total_time_spent").default(0), // in minutes
  
  // Feature usage tracking
  filesUploaded: integer("files_uploaded").default(0),
  filesAnalyzed: integer("files_analyzed").default(0),
  chatMessagesCount: integer("chat_messages_count").default(0),
  aiInteractions: integer("ai_interactions").default(0),
  
  // Engagement scoring
  engagementScore: integer("engagement_score").default(0), // 0-100
  userSegment: text("user_segment").default("new"), // new, active, at_risk, dormant
  
  // Preferences and timezone
  timezone: text("timezone").default("UTC"),
  preferredContactTime: text("preferred_contact_time").default("morning"), // morning, afternoon, evening
  
  // Tracking metadata
  firstSessionAt: timestamp("first_session_at").defaultNow(),
  lastActivityAt: timestamp("last_activity_at").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Email preferences table
export const emailPreferences = pgTable("email_preferences", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Email subscription preferences
  welcomeEmails: boolean("welcome_emails").default(true),
  reengagementEmails: boolean("reengagement_emails").default(true),
  featureUpdates: boolean("feature_updates").default(true),
  productTips: boolean("product_tips").default(true),
  usageInsights: boolean("usage_insights").default(true),
  communityHighlights: boolean("community_highlights").default(false),
  
  // Frequency preferences
  emailFrequency: text("email_frequency").default("weekly"), // daily, weekly, monthly
  
  // Unsubscribe management
  isUnsubscribed: boolean("is_unsubscribed").default(false),
  unsubscribeToken: text("unsubscribe_token").unique(),
  unsubscribedAt: timestamp("unsubscribed_at"),
  unsubscribeReason: text("unsubscribe_reason"),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Email campaigns table
export const emailCampaigns = pgTable("email_campaigns", {
  id: serial("id").primaryKey(),
  
  // Campaign details
  name: text("name").notNull(),
  description: text("description"),
  campaignType: text("campaign_type").notNull(), // welcome, reengagement, feature_update, etc.
  emailTemplate: text("email_template").notNull(),
  
  // Targeting
  targetSegment: text("target_segment").default("all"), // all, new, active, at_risk, dormant
  targetConditions: json("target_conditions"), // JSON for complex targeting rules
  
  // Scheduling
  isActive: boolean("is_active").default(true),
  scheduledAt: timestamp("scheduled_at"),
  sendAfterDays: integer("send_after_days"), // Send X days after a trigger event
  triggerEvent: text("trigger_event"), // signup, last_login, feature_usage, etc.
  
  // Analytics
  totalSent: integer("total_sent").default(0),
  totalDelivered: integer("total_delivered").default(0),
  totalOpened: integer("total_opened").default(0),
  totalClicked: integer("total_clicked").default(0),
  totalUnsubscribed: integer("total_unsubscribed").default(0),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  createdBy: integer("created_by").references(() => users.id),
});

// Email send log table
export const emailSendLog = pgTable("email_send_log", {
  id: serial("id").primaryKey(),
  
  // References
  userId: integer("user_id").references(() => users.id).notNull(),
  campaignId: integer("campaign_id").references(() => emailCampaigns.id),
  
  // Email details
  emailType: text("email_type").notNull(), // welcome, reengagement, feature_update, etc.
  emailSubject: text("email_subject").notNull(),
  recipientEmail: text("recipient_email").notNull(),
  
  // Delivery tracking
  status: text("status").default("sent"), // sent, delivered, opened, clicked, bounced, failed
  resendMessageId: text("resend_message_id"), // Resend's message ID for tracking
  
  // Engagement tracking
  sentAt: timestamp("sent_at").defaultNow(),
  deliveredAt: timestamp("delivered_at"),
  openedAt: timestamp("opened_at"),
  clickedAt: timestamp("clicked_at"),
  bouncedAt: timestamp("bounced_at"),
  
  // Tracking tokens
  openTrackingToken: text("open_tracking_token").unique(),
  clickTrackingToken: text("click_tracking_token").unique(),
  
  // Error handling
  errorMessage: text("error_message"),
  retryCount: integer("retry_count").default(0),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
});

// User activity tracking for real-time engagement
export const userActivity = pgTable("user_activity", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Activity details
  activityType: text("activity_type").notNull(), // login, logout, file_upload, chat_message, etc.
  activityData: json("activity_data"), // Additional context data
  
  // Session tracking
  sessionId: text("session_id"),
  userAgent: text("user_agent"),
  ipAddress: text("ip_address"),
  
  // Timing
  duration: integer("duration"), // Duration in seconds for activities that have duration
  timestamp: timestamp("timestamp").defaultNow(),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
});

// =============================================================================
// AI COACH WORKFLOW TRACKING SYSTEM
// =============================================================================

// Workflow tracking table for AI Coach analysis
export const workflowTracking = pgTable("workflow_tracking", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  sessionId: text("session_id").notNull(),
  
  // Workflow identification
  workflowType: text("workflow_type"), // coding, debugging, analysis, writing, research, etc.
  workflowName: text("workflow_name"), // User-friendly name for the workflow
  
  // Workflow state
  status: text("status").default("active"), // active, completed, abandoned
  
  // Workflow metrics
  totalSteps: integer("total_steps").default(0),
  completedSteps: integer("completed_steps").default(0),
  
  // Command and model usage patterns
  commandSequence: json("command_sequence").$type<Array<{
    command: string;
    timestamp: string;
    modelUsed?: string;
    duration?: number;
    success?: boolean;
  }>>(),
  
  modelSwitchPatterns: json("model_switch_patterns").$type<Array<{
    fromModel: string;
    toModel: string;
    reason?: string;
    timestamp: string;
  }>>(),
  
  // Time tracking
  startedAt: timestamp("started_at").defaultNow(),
  completedAt: timestamp("completed_at"),
  totalDuration: integer("total_duration"), // in seconds
  activeTime: integer("active_time"), // actual working time in seconds
  
  // Efficiency metrics
  efficiencyScore: integer("efficiency_score"), // 0-100
  complexityLevel: text("complexity_level"), // simple, moderate, complex, expert
  
  // AI Coach analysis
  coachAnalysis: json("coach_analysis"), // Stored AI Coach insights
  lastAnalyzedAt: timestamp("last_analyzed_at"),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// AI Coach insights table
export const aiCoachInsights = pgTable("ai_coach_insights", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  workflowId: integer("workflow_id").references(() => workflowTracking.id),
  
  // Insight details
  insightType: text("insight_type").notNull(), // workflow_optimization, model_recommendation, efficiency_tip, etc.
  insightCategory: text("insight_category").notNull(), // strategic, tactical, operational
  
  title: text("title").notNull(),
  description: text("description").notNull(),
  
  // Actionable recommendations
  recommendations: json("recommendations").$type<Array<{
    action: string;
    expectedImprovement: string;
    difficulty: 'easy' | 'medium' | 'hard';
  }>>(),
  
  // Context and triggers
  triggerContext: json("trigger_context"), // What triggered this insight
  applicableScenarios: json("applicable_scenarios").$type<string[]>(),
  
  // User interaction
  wasShown: boolean("was_shown").default(false),
  wasActedUpon: boolean("was_acted_upon").default(false),
  userFeedback: text("user_feedback"), // positive, negative, neutral
  feedbackDetails: text("feedback_details"),
  
  // Impact tracking
  expectedImpact: text("expected_impact"), // high, medium, low
  actualImpact: text("actual_impact"),
  impactMetrics: json("impact_metrics"),
  
  // Timing
  generatedAt: timestamp("generated_at").defaultNow(),
  shownAt: timestamp("shown_at"),
  actedAt: timestamp("acted_at"),
  expiresAt: timestamp("expires_at"),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Workflow patterns table for learning user behaviors
export const workflowPatterns = pgTable("workflow_patterns", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Pattern identification
  patternName: text("pattern_name").notNull(),
  patternType: text("pattern_type").notNull(), // task_sequence, model_preference, time_of_day, etc.
  
  // Pattern data
  patternData: json("pattern_data").notNull(),
  frequency: integer("frequency").default(1),
  confidence: decimal("confidence", { precision: 3, scale: 2 }), // 0.00-1.00
  
  // Learning metrics
  firstObservedAt: timestamp("first_observed_at").defaultNow(),
  lastObservedAt: timestamp("last_observed_at").defaultNow(),
  observationCount: integer("observation_count").default(1),
  
  // Pattern effectiveness
  successRate: decimal("success_rate", { precision: 3, scale: 2 }), // 0.00-1.00
  averageTimeToComplete: integer("avg_time_to_complete"), // in seconds
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// AI Coach conversations table for contextual coaching
export const aiCoachConversations = pgTable("ai_coach_conversations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  // Conversation context
  conversationContext: text("conversation_context").notNull(), // workflow_help, optimization_advice, etc.
  
  // Messages
  messages: json("messages").$type<Array<{
    role: 'user' | 'coach';
    content: string;
    timestamp: string;
  }>>().notNull(),
  
  // Outcomes
  resolutionStatus: text("resolution_status"), // resolved, ongoing, abandoned
  userSatisfaction: integer("user_satisfaction"), // 1-5 rating
  
  // Metadata
  startedAt: timestamp("started_at").defaultNow(),
  endedAt: timestamp("ended_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// =============================================================================
// CHAT VECTORIZATION SYSTEM
// =============================================================================

// Chat conversations storage
export const conversations = pgTable("conversations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  sessionId: text("session_id").notNull(),
  title: text("title"),
  provider: text("provider").notNull(), // 'uterpi', 'openai', 'gemini', 'azure', 'lmstudio'
  model: text("model").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  archivedAt: timestamp("archived_at"),
});

// Individual messages within conversations
export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  conversationId: integer("conversation_id").references(() => conversations.id).notNull(),
  content: text("content").notNull(),
  role: text("role").notNull(), // 'user', 'assistant', 'system'
  messageIndex: integer("message_index").notNull(), // Order within conversation
  attachments: json("attachments").$type<string[]>(), // File attachments
  metadata: json("metadata").$type<{
    code?: string;
    currentBalance?: number;
    messagesUsed?: number;
    monthlyAllowance?: number;
    isFreemium?: boolean;
    creditsRequired?: number;
    isTeamPooled?: boolean;
    purchaseUrl?: string;
    upgradeUrl?: string;
    message?: string;
    model?: string;
    provider?: string;
    tokensUsed?: number;
  }>(), // Additional message metadata
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Vector embeddings for semantic search
export const messageEmbeddings = pgTable("message_embeddings", {
  id: serial("id").primaryKey(),
  messageId: integer("message_id").references(() => messages.id).notNull(),
  embedding: text("embedding").notNull(), // Stored as JSON array string
  embeddingModel: text("embedding_model").notNull(), // Model used for embedding
  embeddingDimensions: integer("embedding_dimensions").notNull(), // Vector dimensions
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Conversation context vectors (aggregated summaries)
export const conversationEmbeddings = pgTable("conversation_embeddings", {
  id: serial("id").primaryKey(),
  conversationId: integer("conversation_id").references(() => conversations.id).notNull(),
  summaryEmbedding: text("summary_embedding").notNull(), // Stored as JSON array string
  embeddingModel: text("embedding_model").notNull(),
  embeddingDimensions: integer("embedding_dimensions").notNull(),
  summary: text("summary"), // Text summary of conversation
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// =============================================================================
// NEW MULTI-TIER SUBSCRIPTION TABLES
// =============================================================================

// Teams table for Team and Enterprise plans
export const teams = pgTable("teams", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  ownerId: integer("owner_id").references(() => users.id).notNull(),
  subscriptionTier: text("subscription_tier").notNull(), // 'team', 'enterprise'
  
  // Team limits and usage
  maxMembers: integer("max_members").notNull().default(3),
  currentMembers: integer("current_members").default(1),
  pooledAiCredits: integer("pooled_ai_credits").default(0),
  pooledCreditsUsedThisMonth: integer("pooled_credits_used_this_month").default(0),
  
  // Team features
  sharedWorkspacesCount: integer("shared_workspaces_count").default(0),
  maxWorkspaces: integer("max_workspaces").default(10),
  customPersonasCount: integer("custom_personas_count").default(0),
  
  // Enterprise features
  ssoEnabled: boolean("sso_enabled").default(false),
  auditLogsEnabled: boolean("audit_logs_enabled").default(false),
  dataResidencyRegion: text("data_residency_region"),
  dedicatedAccountManager: text("dedicated_account_manager"),
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// AI credits transactions table for tracking usage
export const aiCreditsTransactions = pgTable("ai_credits_transactions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  teamId: integer("team_id").references(() => teams.id),
  
  // Transaction details
  transactionType: text("transaction_type").notNull(), // 'usage', 'purchase', 'monthly_reset', 'bonus', 'refund'
  amount: integer("amount").notNull(), // Positive for credits added, negative for credits used
  balanceAfter: integer("balance_after").notNull(),
  
  // Usage details (for 'usage' type)
  operationType: text("operation_type"), // 'chat', 'codebase_analysis', 'app_generation', 'code_review', 'advanced_model'
  modelUsed: text("model_used"),
  tokensConsumed: integer("tokens_consumed"),
  
  // Purchase details (for 'purchase' type)
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  purchaseAmountCents: integer("purchase_amount_cents"),
  
  // Metadata
  description: text("description"),
  metadata: json("metadata"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Feature flags table for tier-based feature access
export const subscriptionFeatures = pgTable("subscription_features", {
  id: serial("id").primaryKey(),
  tierName: text("tier_name").notNull().unique(), // 'free', 'pro', 'team', 'enterprise'
  
  // Core features
  unlimitedChat: boolean("unlimited_chat").default(false),
  monthlyMessageAllowance: integer("monthly_message_allowance").default(0), // For freemium tier
  aiProvidersAccess: json("ai_providers_access").$type<string[]>(), // Array of allowed AI provider names
  
  // AI Credits
  monthlyAiCredits: integer("monthly_ai_credits").default(0),
  creditsRollover: boolean("credits_rollover").default(false),
  creditsPurchaseEnabled: boolean("credits_purchase_enabled").default(true),
  
  // Project limits
  maxProjects: integer("max_projects").default(1),
  fullCodebaseContext: boolean("full_codebase_context").default(false),
  
  // Integrations
  gitIntegration: boolean("git_integration").default(false),
  
  // AI Features
  aiCodeReviewsPerMonth: integer("ai_code_reviews_per_month").default(0),
  
  // Team features
  teamFeaturesEnabled: boolean("team_features_enabled").default(false),
  sharedWorkspaces: boolean("shared_workspaces").default(false),
  teamPersonas: boolean("team_personas").default(false),
  
  // Security & Compliance
  ssoEnabled: boolean("sso_enabled").default(false),
  auditLogs: boolean("audit_logs").default(false),
  dataResidency: boolean("data_residency").default(false),
  
  // Support
  supportLevel: text("support_level").default("email"), // 'email', 'priority_email', 'dedicated'
  
  // Metadata
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// =============================================================================
// DISTRIBUTED RATE LIMITING TABLE
// =============================================================================

// Stores per-key, per-route request counts within a fixed window
// A unique index on (key, route, window_start) is created via migration
export const rateLimits = pgTable("rate_limits", {
  id: serial("id").primaryKey(),
  key: text("key").notNull(),
  route: text("route").notNull(),
  windowStart: timestamp("window_start", { precision: 6 }).notNull(),
  windowEnd: timestamp("window_end", { precision: 6 }).notNull(),
  windowMs: integer("window_ms").notNull(),
  count: integer("count").notNull().default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

================
File: src/components/LLMModelSelector.tsx
================
"use client";

import * as React from "react";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { 
  Search, 
  Filter, 
  Star, 
  StarOff, 
  Zap, 
  DollarSign, 
  Clock, 
  TrendingUp, 
  Brain, 
  Sparkles,
  ChevronDown,
  ArrowUpDown,
  Heart,
  HeartOff,
  X
} from "lucide-react";
import { LLMModel } from "@/types";
import { AzureAIService } from "@/lib/azureAI";

// Get Azure AI models from the service
const getAzureModels = (): LLMModel[] => {
  return AzureAIService.getAvailableModels();
};

const categoryIcons = {
  text: Brain,
  code: Zap,
  multimodal: Sparkles,
  reasoning: TrendingUp
};

const tierColors = {
  free: "bg-emerald-500/20 text-emerald-400 border-emerald-500/30",
  pro: "bg-violet-500/20 text-violet-400 border-violet-500/30",
  enterprise: "bg-amber-500/20 text-amber-400 border-amber-500/30"
};

interface ModelCardProps {
  model: LLMModel;
  onFavorite: (id: string) => void;
  onSelect: (model: LLMModel) => void;
  isSelected: boolean;
}

const ModelCard: React.FC<ModelCardProps> = ({ model, onFavorite, onSelect, isSelected }) => {
  const CategoryIcon = categoryIcons[model.category];
  
  return (
    <motion.div
      layout
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      whileHover={{ y: -2, scale: 1.02 }}
      transition={{ duration: 0.2 }}
    >
      <Card 
        className={cn(
          "relative overflow-hidden border transition-all duration-300 cursor-pointer group",
          "bg-slate-900/50 backdrop-blur-xl border-slate-700/50",
          "hover:bg-slate-800/50 hover:border-violet-500/50 hover:shadow-lg hover:shadow-violet-500/10",
          "rounded-2xl p-6",
          isSelected 
            ? "border-violet-500 bg-violet-500/10 shadow-lg shadow-violet-500/20" 
            : ""
        )}
        onClick={() => onSelect(model)}
      >
        {/* Favorite Button */}
        <motion.button
          whileHover={{ scale: 1.1 }}
          whileTap={{ scale: 0.9 }}
          onClick={(e) => {
            e.stopPropagation();
            onFavorite(model.id);
          }}
          className="absolute top-4 right-4 p-2 rounded-full bg-slate-800/80 backdrop-blur-sm border border-slate-600/50 hover:bg-slate-700/80 transition-colors"
        >
          {model.isFavorite ? (
            <Heart className="w-4 h-4 text-red-400 fill-current" />
          ) : (
            <HeartOff className="w-4 h-4 text-slate-400" />
          )}
        </motion.button>

        {/* Header */}
        <div className="flex items-start gap-3 mb-4">
          <div className="p-3 rounded-xl bg-violet-500/20 border border-violet-500/30">
            <CategoryIcon className="w-6 h-6 text-violet-400" />
          </div>
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-lg text-white truncate">{model.name}</h3>
            <p className="text-sm text-slate-400">{model.provider}</p>
          </div>
        </div>

        {/* Description */}
        <p className="text-sm text-slate-300 mb-4 line-clamp-2">{model.description}</p>

        {/* Metrics */}
        <div className="grid grid-cols-3 gap-3 mb-4">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <TrendingUp className="w-4 h-4 text-emerald-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">{model.performance}%</div>
                  <div className="text-xs text-slate-400">Performance</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Model performance score</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <DollarSign className="w-4 h-4 text-blue-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">${model.cost}</div>
                  <div className="text-xs text-slate-400">Per 1K tokens</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Cost per 1000 tokens</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="text-center p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                  <Clock className="w-4 h-4 text-orange-400 mx-auto mb-1" />
                  <div className="text-sm font-semibold text-white">{model.latency}ms</div>
                  <div className="text-xs text-slate-400">Latency</div>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-slate-800 border-slate-700">
                <p>Average response time</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>

        {/* Tags */}
        <div className="flex items-center justify-between">
          <Badge variant="outline" className="capitalize border-slate-600 text-slate-300 bg-slate-800/50">
            {model.category}
          </Badge>
          <Badge className={cn("capitalize border", tierColors[model.tier])}>
            {model.tier}
          </Badge>
        </div>

        {/* Selection Indicator */}
        <AnimatePresence>
          {isSelected && (
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0 }}
              className="absolute top-4 left-4 w-6 h-6 bg-violet-500 rounded-full flex items-center justify-center"
            >
              <Star className="w-4 h-4 text-white fill-current" />
            </motion.div>
          )}
        </AnimatePresence>
      </Card>
    </motion.div>
  );
};

interface FilterControlsProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
  selectedCategory: string;
  onCategoryChange: (value: string) => void;
  selectedTier: string;
  onTierChange: (value: string) => void;
  sortBy: string;
  onSortChange: (value: string) => void;
  showFavoritesOnly: boolean;
  onToggleFavorites: () => void;
}

const FilterControls: React.FC<FilterControlsProps> = ({
  searchTerm,
  onSearchChange,
  selectedCategory,
  onCategoryChange,
  selectedTier,
  onTierChange,
  sortBy,
  onSortChange,
  showFavoritesOnly,
  onToggleFavorites
}) => {
  return (
    <div className="flex flex-wrap gap-4 items-center justify-between p-4 rounded-2xl bg-slate-800/30 border border-slate-700/50 backdrop-blur-sm">
      {/* Search */}
      <div className="relative flex-1 min-w-[250px]">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400 w-4 h-4" />
        <Input
          placeholder="Search models..."
          value={searchTerm}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10 h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white placeholder:text-slate-400 text-sm focus:border-violet-500"
        />
      </div>

      {/* Filters */}
      <div className="flex gap-2 items-center flex-wrap">
        <Select value={selectedCategory} onValueChange={onCategoryChange}>
          <SelectTrigger className="w-[120px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <SelectValue placeholder="Category" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="all">All</SelectItem>
            <SelectItem value="text">Text</SelectItem>
            <SelectItem value="code">Code</SelectItem>
            <SelectItem value="multimodal">Multimodal</SelectItem>
            <SelectItem value="reasoning">Reasoning</SelectItem>
          </SelectContent>
        </Select>

        <Select value={selectedTier} onValueChange={onTierChange}>
          <SelectTrigger className="w-[100px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <SelectValue placeholder="Tier" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="all">All</SelectItem>
            <SelectItem value="free">Free</SelectItem>
            <SelectItem value="pro">Pro</SelectItem>
            <SelectItem value="enterprise">Enterprise</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={onSortChange}>
          <SelectTrigger className="w-[120px] h-10 rounded-xl border-slate-600 bg-slate-800/50 text-white text-sm">
            <ArrowUpDown className="w-3 h-3 mr-1" />
            <SelectValue placeholder="Sort" />
          </SelectTrigger>
          <SelectContent className="bg-slate-800 border-slate-700">
            <SelectItem value="performance">Performance</SelectItem>
            <SelectItem value="cost">Cost</SelectItem>
            <SelectItem value="latency">Latency</SelectItem>
            <SelectItem value="name">Name</SelectItem>
          </SelectContent>
        </Select>

        <Button
          variant={showFavoritesOnly ? "default" : "outline"}
          onClick={onToggleFavorites}
          size="sm"
          className={cn(
            "h-10 px-4 rounded-xl transition-colors",
            showFavoritesOnly 
              ? "bg-violet-600 hover:bg-violet-700 text-white" 
              : "border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50"
          )}
        >
          <Star className={cn("w-3 h-3 mr-1", showFavoritesOnly && "fill-current")} />
          Favorites
        </Button>
      </div>
    </div>
  );
};

interface LLMModalSelectorProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (model: LLMModel) => void;
  selectedModel?: LLMModel | null;
}

const LLMModalSelector: React.FC<LLMModalSelectorProps> = ({
  isOpen,
  onClose,
  onSelect,
  selectedModel: externalSelectedModel
}) => {
  const [models, setModels] = React.useState<LLMModel[]>(getAzureModels());
  const [selectedModel, setSelectedModel] = React.useState<LLMModel | null>(externalSelectedModel || null);
  const [searchTerm, setSearchTerm] = React.useState("");
  const [selectedCategory, setSelectedCategory] = React.useState("all");
  const [selectedTier, setSelectedTier] = React.useState("all");
  const [sortBy, setSortBy] = React.useState("performance");
  const [showFavoritesOnly, setShowFavoritesOnly] = React.useState(false);

  const handleFavorite = (id: string) => {
    setModels(prev => prev.map(model => 
      model.id === id ? { ...model, isFavorite: !model.isFavorite } : model
    ));
  };

  const handleSelect = (model: LLMModel) => {
    setSelectedModel(model);
  };

  const handleConfirmSelection = () => {
    if (selectedModel) {
      onSelect(selectedModel);
      onClose();
    }
  };

  const filteredAndSortedModels = React.useMemo(() => {
    let filtered = models.filter(model => {
      const matchesSearch = model.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           model.provider.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           model.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesCategory = selectedCategory === "all" || model.category === selectedCategory;
      const matchesTier = selectedTier === "all" || model.tier === selectedTier;
      const matchesFavorites = !showFavoritesOnly || model.isFavorite;

      return matchesSearch && matchesCategory && matchesTier && matchesFavorites;
    });

    return filtered.sort((a, b) => {
      switch (sortBy) {
        case "performance":
          return b.performance - a.performance;
        case "cost":
          return a.cost - b.cost;
        case "latency":
          return a.latency - b.latency;
        case "name":
          return a.name.localeCompare(b.name);
        default:
          return 0;
      }
    });
  }, [models, searchTerm, selectedCategory, selectedTier, sortBy, showFavoritesOnly]);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto bg-slate-950/95 backdrop-blur-xl border-slate-700/50 text-white p-0">
        <div className="flex flex-col h-full">
          {/* Header */}
          <div className="p-6 pb-4 border-b border-slate-700/50">
            <DialogHeader>
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                className="space-y-2"
              >
                <DialogTitle className="text-3xl font-bold bg-gradient-to-r from-violet-400 via-purple-400 to-violet-600 bg-clip-text text-transparent">
                  Select AI Model
                </DialogTitle>
                <DialogDescription className="text-base text-slate-300">
                  Choose from Azure's premium collection of AI models
                </DialogDescription>
              </motion.div>
            </DialogHeader>
            <motion.button
              onClick={onClose}
              className="absolute right-4 top-4 p-2 rounded-xl bg-slate-800/50 hover:bg-slate-700/50 transition-colors"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              <X className="w-5 h-5 text-slate-400" />
            </motion.button>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-6 space-y-6">
            {/* Filter Controls */}
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.1 }}
            >
              <FilterControls
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                selectedCategory={selectedCategory}
                onCategoryChange={setSelectedCategory}
                selectedTier={selectedTier}
                onTierChange={setSelectedTier}
                sortBy={sortBy}
                onSortChange={setSortBy}
                showFavoritesOnly={showFavoritesOnly}
                onToggleFavorites={() => setShowFavoritesOnly(!showFavoritesOnly)}
              />
            </motion.div>

            {/* Results Count */}
            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.2 }}
              className="flex items-center justify-between"
            >
              <p className="text-sm text-slate-400">
                Showing {filteredAndSortedModels.length} of {models.length} models
              </p>
              {selectedModel && (
                <Badge variant="outline" className="text-sm px-3 py-1 border-violet-500/50 text-violet-400 bg-violet-500/10">
                  Selected: {selectedModel.name}
                </Badge>
              )}
            </motion.div>

            {/* Model Grid */}
            <motion.div 
              layout
              className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            >
              <AnimatePresence>
                {filteredAndSortedModels.map((model) => (
                  <ModelCard
                    key={model.id}
                    model={model}
                    onFavorite={handleFavorite}
                    onSelect={handleSelect}
                    isSelected={selectedModel?.id === model.id}
                  />
                ))}
              </AnimatePresence>
            </motion.div>

            {/* Empty State */}
            {filteredAndSortedModels.length === 0 && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="text-center py-12"
              >
                <div className="w-20 h-20 mx-auto mb-4 rounded-full bg-slate-800/50 flex items-center justify-center">
                  <Search className="w-10 h-10 text-slate-400" />
                </div>
                <h3 className="text-lg font-semibold mb-2 text-white">No models found</h3>
                <p className="text-slate-400">Try adjusting your search criteria or filters.</p>
              </motion.div>
            )}
          </div>

          {/* Footer */}
          <div className="p-6 pt-4 border-t border-slate-700/50 bg-slate-900/30">
            <div className="flex items-center justify-between">
              <Button
                variant="outline"
                onClick={onClose}
                className="border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50 px-6"
              >
                Cancel
              </Button>
              <div className="flex gap-3">
                {selectedModel && (
                  <Dialog>
                    <DialogTrigger asChild>
                      <Button variant="outline" className="border-slate-600 bg-slate-800/50 text-slate-300 hover:bg-slate-700/50 px-6">
                        View Details
                      </Button>
                    </DialogTrigger>
                    <DialogContent className="max-w-2xl bg-slate-950/95 backdrop-blur-xl border-slate-700/50 text-white">
                      <DialogHeader>
                        <DialogTitle className="text-2xl text-white">{selectedModel.name}</DialogTitle>
                        <DialogDescription className="text-base text-slate-300">
                          {selectedModel.description}
                        </DialogDescription>
                      </DialogHeader>
                      <div className="grid grid-cols-2 gap-6 mt-6">
                        <div className="space-y-4">
                          <div>
                            <label className="text-sm font-medium text-slate-400">Provider</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.provider}</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Performance</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.performance}%</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Context Length</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.contextLength.toLocaleString()} tokens</p>
                          </div>
                        </div>
                        <div className="space-y-4">
                          <div>
                            <label className="text-sm font-medium text-slate-400">Cost per 1K tokens</label>
                            <p className="text-lg font-semibold text-white">${selectedModel.cost}</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Latency</label>
                            <p className="text-lg font-semibold text-white">{selectedModel.latency}ms</p>
                          </div>
                          <div>
                            <label className="text-sm font-medium text-slate-400">Tier</label>
                            <Badge className={cn("capitalize border", tierColors[selectedModel.tier])}>
                              {selectedModel.tier}
                            </Badge>
                          </div>
                        </div>
                      </div>
                    </DialogContent>
                  </Dialog>
                )}
                <Button
                  onClick={handleConfirmSelection}
                  disabled={!selectedModel}
                  className="bg-violet-600 hover:bg-violet-700 text-white px-8 disabled:opacity-50"
                >
                  Select Model
                </Button>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default LLMModalSelector;

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;

================
File: tsconfig.json
================
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}

================
File: vite.config.ts
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import { fileURLToPath } from "url";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

// Get __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets"),
    },
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true,
  },
});
